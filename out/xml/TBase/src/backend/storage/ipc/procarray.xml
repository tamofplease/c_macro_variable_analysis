<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/storage/ipc/procarray.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * procarray.c
 *      POSTGRES process array code.
 *
 *
 * This module maintains arrays of the PGPROC and PGXACT structures for all
 * active backends.  Although there are several uses for this, the principal
 * one is as a means of determining the set of currently running transactions.
 *
 * Because of various subtle race conditions it is critical that a backend
 * hold the correct locks while setting or clearing its MyPgXact-&gt;xid field.
 * See notes in src/backend/access/transam/README.
 *
 * The process arrays now also include structures representing prepared
 * transactions.  The xid and subxids fields of these are valid, as are the
 * myProcLocks lists.  They can be distinguished from regular backend PGPROCs
 * at need by checking for pid == 0.
 *
#ifdef PGXC
 * For Postgres-XC, there is some special handling for ANALYZE.
 * An XID for a local ANALYZE command will never involve other nodes.
 * Also, ANALYZE may run for a long time, affecting snapshot xmin values
 * on other nodes unnecessarily.  We want to exclude the XID
 * in global snapshots, but include it in local ones. As a result,
 * these are tracked in shared memory separately.
#endif
 *
 * During hot standby, we also keep a list of XIDs representing transactions
 * that are known to be running in the master (or more precisely, were running
 * as of the current point in the WAL stream).  This list is kept in the
 * KnownAssignedXids array, and is updated by watching the sequence of
 * arriving XIDs.  This is necessary because if we leave those XIDs out of
 * snapshots taken for standby queries, then they will appear to be already
 * complete, leading to MVCC failures.  Note that in hot standby, the PGPROC
 * array represents standby processes, which by definition are not running
 * transactions that have XIDs.
 *
 * It is perhaps possible for a backend on the master to terminate without
 * writing an abort record for its transaction.  While that shouldn't really
 * happen, it would tie up KnownAssignedXids indefinitely, so we protect
 * ourselves by pruning the array when a valid list of running XIDs arrives.
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *
 * IDENTIFICATION
 *      src/backend/storage/ipc/procarray.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/clog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/subtrans.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/clustermon.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<comment type="block">/* PGXC_DATANODE */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/shardmap.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMESTAMP_SHIFT</name></cpp:macro> <cpp:value>(1000*1000L)</cpp:value></cpp:define>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* Our shared memory area */</comment>
<typedef>typedef <type><struct>struct <name>ProcArrayStruct</name>
<block>{
    <decl_stmt><decl><type><name>int</name></type>            <name>numProcs</name></decl>;</decl_stmt>        <comment type="block">/* number of valid procs entries */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>maxProcs</name></decl>;</decl_stmt>        <comment type="block">/* allocated size of procs array */</comment>

    <comment type="block">/*
     * Known assigned XIDs handling
     */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>maxKnownAssignedXids</name></decl>;</decl_stmt>    <comment type="block">/* allocated size of array */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>numKnownAssignedXids</name></decl>;</decl_stmt>    <comment type="block">/* current # of valid entries */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>tailKnownAssignedXids</name></decl>;</decl_stmt>    <comment type="block">/* index of oldest valid element */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>headKnownAssignedXids</name></decl>;</decl_stmt>    <comment type="block">/* index of newest element, + 1 */</comment>
    <decl_stmt><decl><type><name>slock_t</name></type>        <name>known_assigned_xids_lck</name></decl>;</decl_stmt>    <comment type="block">/* protects head/tail pointers */</comment>

    <comment type="block">/*
     * Highest subxid that has been removed from KnownAssignedXids array to
     * prevent overflow; or InvalidTransactionId if none.  We track this for
     * similar reasons to tracking overflowing cached subxids in PGXACT
     * entries.  Must hold exclusive ProcArrayLock to change this, and shared
     * lock to read it.
     */</comment>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>lastOverflowedXid</name></decl>;</decl_stmt>

    <comment type="block">/* oldest xmin of any replication slot */</comment>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>replication_slot_xmin</name></decl>;</decl_stmt>
    <comment type="block">/* oldest catalog xmin of any replication slot */</comment>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>replication_slot_catalog_xmin</name></decl>;</decl_stmt>

    <comment type="block">/* indexes into allPgXact[], has PROCARRAY_MAXPROCS entries */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name><name>pgprocnos</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>ProcArrayStruct</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>ProcArrayStruct</name> <modifier>*</modifier></type><name>procArray</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>allProcs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>allPgXact</name></decl>;</decl_stmt>

<comment type="block">/*
 * Bookkeeping for tracking emulated transactions in recovery
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name> <modifier>*</modifier></type><name>KnownAssignedXids</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name> <modifier>*</modifier></type><name>KnownAssignedXidsValid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>latestObservedXid</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * If we're in STANDBY_SNAPSHOT_PENDING state, standbySnapshotPendingXmin is
 * the highest xid that might still be running that we don't have in
 * KnownAssignedXids.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>standbySnapshotPendingXmin</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XIDCACHE_DEBUG</name></cpp:ifdef>

<comment type="block">/* counters for XidCache measurement */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>xc_by_recent_xmin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>xc_by_known_xact</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>xc_by_my_xact</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>xc_by_latest_xid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>xc_by_main_xid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>xc_by_child_xid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>xc_by_known_assigned</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>xc_no_overflow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>xc_slow_answer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xc_by_recent_xmin_inc</name><parameter_list>()</parameter_list></cpp:macro>        <cpp:value>(xc_by_recent_xmin++)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xc_by_known_xact_inc</name><parameter_list>()</parameter_list></cpp:macro>        <cpp:value>(xc_by_known_xact++)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xc_by_my_xact_inc</name><parameter_list>()</parameter_list></cpp:macro>            <cpp:value>(xc_by_my_xact++)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xc_by_latest_xid_inc</name><parameter_list>()</parameter_list></cpp:macro>        <cpp:value>(xc_by_latest_xid++)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xc_by_main_xid_inc</name><parameter_list>()</parameter_list></cpp:macro>        <cpp:value>(xc_by_main_xid++)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xc_by_child_xid_inc</name><parameter_list>()</parameter_list></cpp:macro>        <cpp:value>(xc_by_child_xid++)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xc_by_known_assigned_inc</name><parameter_list>()</parameter_list></cpp:macro>    <cpp:value>(xc_by_known_assigned++)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xc_no_overflow_inc</name><parameter_list>()</parameter_list></cpp:macro>        <cpp:value>(xc_no_overflow++)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xc_slow_answer_inc</name><parameter_list>()</parameter_list></cpp:macro>        <cpp:value>(xc_slow_answer++)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DisplayXidCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>                            <comment type="block">/* !XIDCACHE_DEBUG */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xc_by_recent_xmin_inc</name><parameter_list>()</parameter_list></cpp:macro>        <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xc_by_known_xact_inc</name><parameter_list>()</parameter_list></cpp:macro>        <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xc_by_my_xact_inc</name><parameter_list>()</parameter_list></cpp:macro>            <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xc_by_latest_xid_inc</name><parameter_list>()</parameter_list></cpp:macro>        <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xc_by_main_xid_inc</name><parameter_list>()</parameter_list></cpp:macro>        <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xc_by_child_xid_inc</name><parameter_list>()</parameter_list></cpp:macro>        <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xc_by_known_assigned_inc</name><parameter_list>()</parameter_list></cpp:macro>    <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xc_no_overflow_inc</name><parameter_list>()</parameter_list></cpp:macro>        <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xc_slow_answer_inc</name><parameter_list>()</parameter_list></cpp:macro>        <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* XIDCACHE_DEBUG */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>  <comment type="block">/* PGXC_DATANODE */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GetPGXCSnapshotData</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>latest</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><struct>struct
<block>{
    <comment type="block">/* Global snapshot data */</comment>
    <decl_stmt><decl><type><name>SnapshotSource</name></type> <name>snapshot_source</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>gxmin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>gxmax</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTimestamp</name></type> <name>gts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>gxcnt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max_gxcnt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>gxip</name></decl>;</decl_stmt>
}</block></struct></type> <name>GlobalSnapshotData</name>;</typedef>

<decl_stmt><decl><type><name>GlobalSnapshotData</name></type> <name>globalSnapshot</name> <init>= <expr><block>{
    <expr><name>SNAPSHOT_UNDEFINED</name></expr>,
    <expr><name>InvalidTransactionId</name></expr>,
    <expr><name>InvalidTransactionId</name></expr>,
    <expr><name>InvalidGlobalTimestamp</name></expr>,
    <expr><literal type="number">0</literal></expr>,
    <expr><literal type="number">0</literal></expr>,
    <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GetGlobalTimestampFromGTM</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>GetGlobalTimestampFromGlobalSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static void GetSnapshotFromGlobalSnapshot(Snapshot snapshot);
static void GetSnapshotDataFromGTM(Snapshot snapshot);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Primitives for KnownAssignedXids array handling for standby */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>KnownAssignedXidsCompress</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>KnownAssignedXidsAdd</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>from_xid</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>to_xid</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>exclusive_lock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>KnownAssignedXidsSearch</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>remove</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>KnownAssignedXidExists</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>KnownAssignedXidsRemove</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>KnownAssignedXidsRemoveTree</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nsubxids</name></decl></parameter>,
                            <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>subxids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>KnownAssignedXidsRemovePreceding</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>KnownAssignedXidsGet</name><parameter_list>(<parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xarray</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xmax</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>KnownAssignedXidsGetAndSetXmin</name><parameter_list>(<parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xarray</name></decl></parameter>,
                               <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xmin</name></decl></parameter>,
                               <parameter><decl><type><name>TransactionId</name></type> <name>xmax</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>KnownAssignedXidsGetOldestXmin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>KnownAssignedXidsDisplay</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>trace_level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>KnownAssignedXidsReset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>ProcArrayEndTransactionInternal</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>,
                                <parameter><decl><type><name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>latestXid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcArrayGroupClearXid</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>latestXid</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type>    <name>GlobalSnapshotSource</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Report shared-memory space needed by CreateSharedProcArray.
 */</comment>
<function><type><name>Size</name></type>
<name>ProcArrayShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>

    <comment type="block">/* Size of the ProcArray structure itself */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROCARRAY_MAXPROCS</name></cpp:macro>    <cpp:value>(MaxBackends + max_prepared_xacts)</cpp:value></cpp:define>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>ProcArrayStruct</name></expr></argument>, <argument><expr><name>pgprocnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>PROCARRAY_MAXPROCS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * During Hot Standby processing we have a data structure called
     * KnownAssignedXids, created in shared memory. Local data structures are
     * also created in various backends during GetSnapshotData(),
     * TransactionIdIsInProgress() and GetRunningTransactionData(). All of the
     * main structures created in those functions must be identically sized,
     * since we may at times copy the whole of the data structures around. We
     * refer to this size as TOTAL_MAX_CACHED_SUBXIDS.
     *
     * Ideally we'd only create this structure if we were actually doing hot
     * standby in the current run, but we don't know that yet at the time
     * shared memory is being set up.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOTAL_MAX_CACHED_SUBXIDS</name></cpp:macro> \
    <cpp:value>((PGPROC_MAX_CACHED_SUBXIDS + 1) * PROCARRAY_MAXPROCS)</cpp:value></cpp:define>

    <if_stmt><if>if <condition>(<expr><name>EnableHotStandby</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>,
                        <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                 <argument><expr><name>TOTAL_MAX_CACHED_SUBXIDS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>,
                        <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>TOTAL_MAX_CACHED_SUBXIDS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the shared PGPROC array during postmaster startup.
 */</comment>
<function><type><name>void</name></type>
<name>CreateSharedProcArray</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

    <comment type="block">/* Create or attach to the ProcArray shared structure */</comment>
    <expr_stmt><expr><name>procArray</name> <operator>=</operator> <operator>(</operator><name>ProcArrayStruct</name> <operator>*</operator><operator>)</operator>
        <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Proc Array"</literal></expr></argument>,
                        <argument><expr><call><name>add_size</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ProcArrayStruct</name></expr></argument>, <argument><expr><name>pgprocnos</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                          <argument><expr><name>PROCARRAY_MAXPROCS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We're the first - initialize.
         */</comment>
        <expr_stmt><expr><name><name>procArray</name><operator>-&gt;</operator><name>numProcs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>procArray</name><operator>-&gt;</operator><name>maxProcs</name></name> <operator>=</operator> <name>PROCARRAY_MAXPROCS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>procArray</name><operator>-&gt;</operator><name>replication_slot_xmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>procArray</name><operator>-&gt;</operator><name>maxKnownAssignedXids</name></name> <operator>=</operator> <name>TOTAL_MAX_CACHED_SUBXIDS</name> <operator>+</operator>
            <name>CONTROL_INTERVAL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>procArray</name><operator>-&gt;</operator><name>numKnownAssignedXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>procArray</name><operator>-&gt;</operator><name>tailKnownAssignedXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>procArray</name><operator>-&gt;</operator><name>headKnownAssignedXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>procArray</name><operator>-&gt;</operator><name>known_assigned_xids_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>procArray</name><operator>-&gt;</operator><name>lastOverflowedXid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>allProcs</name> <operator>=</operator> <name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>allPgXact</name> <operator>=</operator> <name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name></name></expr>;</expr_stmt>

    <comment type="block">/* Create or attach to the KnownAssignedXids arrays too, if needed */</comment>
    <if_stmt><if>if <condition>(<expr><name>EnableHotStandby</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>KnownAssignedXids</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator>
            <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"KnownAssignedXids"</literal></expr></argument>,
                            <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                     <argument><expr><name><name>procArray</name><operator>-&gt;</operator><name>maxKnownAssignedXids</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>KnownAssignedXidsValid</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
            <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"KnownAssignedXidsValid"</literal></expr></argument>,
                            <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                <argument><expr><name><name>procArray</name><operator>-&gt;</operator><name>maxKnownAssignedXids</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Register and initialize fields of ProcLWLockTranche */</comment>
    <expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_PROC</name></expr></argument>, <argument><expr><literal type="string">"proc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_PROC_DATA</name></expr></argument>, <argument><expr><literal type="string">"proc_data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Add the specified PGPROC to the shared array.
 */</comment>
<function><type><name>void</name></type>
<name>ProcArrayAdd</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name> <operator>&gt;=</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>maxProcs</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Oops, no room.  (This really shouldn't happen, since there is a
         * fixed supply of PGPROC structs too, and so we should have failed
         * earlier.)
         */</comment>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_CONNECTIONS</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sorry, too many clients already"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Keep the procs array sorted by (PGPROC *) so that we can utilize
     * locality of references much better. This is useful while traversing the
     * ProcArray because there is an increased likelihood of finding the next
     * PGPROC structure in the cache.
     *
     * Since the occurrence of adding/removing a proc is much lower than the
     * access to the ProcArray itself, the overhead should be marginal
     */</comment>
    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * If we are the first PGPROC or if we have found our right position
         * in the array, break
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name> <operator>&gt;</operator> <name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>,
            <argument><expr><operator>(</operator><name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name> <operator>-</operator> <name>index</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name><operator>++</operator></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* 
         * As procarrary lock is held and only the local proc is accessed, 
         * per-proc lock is not necessary.
         */</comment>
        <if_stmt><if>if<condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>hasGlobalXid</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>globalXid</name></name></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>globalXid</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>hasGlobalXid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>hasGlobalXid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"myproc no %d transfer global xid %s procno %d"</literal></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>globalXid</name></name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove the specified PGPROC from the shared array.
 *
 * When latestXid is a valid XID, we are removing a live 2PC gxact from the
 * array, and thus causing it to appear as "not running" anymore.  In this
 * case we must advance latestCompletedXid.  (This is essentially the same
 * as ProcArrayEndTransaction followed by removal of the PGPROC, but we take
 * the ProcArrayLock only once, and don't damage the content of the PGPROC;
 * twophase.c depends on the latter.)
 */</comment>
<function><type><name>void</name></type>
<name>ProcArrayRemove</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>latestXid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XIDCACHE_DEBUG</name></cpp:ifdef>
    <comment type="block">/* dump stats at backend shutdown, but not prepared-xact end */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DisplayXidCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <comment type="block">/* 
     * As procarrary lock is held and only the local proc is accessed, 
     * per-proc lock is not necessary.
     */</comment>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"remove global xid %s %d"</literal></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>globalXid</name></name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>hasGlobalXid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>latestXid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>allPgXact</name><index>[<expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Advance global latestCompletedXid while holding the lock */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr></argument>,
                                  <argument><expr><name>latestXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name> <operator>=</operator> <name>latestXid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>CommitTsLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>commitTs</name></name> <operator>&gt;</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCommitTs</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCommitTs</name></name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>commitTs</name></name></expr>;</expr_stmt>
            
            <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"latest committs xid %d ts "</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>latestXid</name></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>commitTs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>commitTs</name></name> <operator>=</operator> <name>InvalidGlobalTimestamp</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>commitTs</name></name> <operator>&gt;</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestGTS</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestGTS</name></name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>commitTs</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>        
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>CommitTsLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>||</operator> <operator>!</operator><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Shouldn't be trying to remove a live transaction here */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>allPgXact</name><index>[<expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name> <operator>==</operator> <name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Keep the PGPROC array sorted. See notes above */</comment>
            <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><operator>(</operator><name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name> <operator>-</operator> <name>index</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* for debugging */</comment>
            <expr_stmt><expr><name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Oops */</comment>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"failed to find proc %p in ProcArray"</literal></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ProcArrayEndTransaction -- mark a transaction as no longer running
 *
 * This is used interchangeably for commit and abort cases.  The transaction
 * commit/abort must already be reported to WAL and pg_xact.
 *
 * proc is currently always MyProc, but we pass it explicitly for flexibility.
 * latestXid is the latest Xid among the transaction's main XID and
 * subtransactions, or InvalidTransactionId if it has no XID.  (We must ask
 * the caller to pass latestXid, instead of computing it from the PGPROC's
 * contents, because the subxid information in the PGPROC might be
 * incomplete.)
 */</comment>
<function><type><name>void</name></type>
<name>ProcArrayEndTransaction</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>latestXid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGXACT</name>       <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>latestXid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We must lock ProcArrayLock while clearing our advertised XID, so
         * that we do not exit the set of "running" transactions while someone
         * else is taking a snapshot.  See discussion in
         * src/backend/access/transam/README.
         */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <comment type="block">/*
         * Remove this assertion. We have seen this failing because a ROLLBACK
         * statement may get canceled by a Coordinator, leading to recursive
         * abort of a transaction. This must be a PostgreSQL issue, highlighted
         * by XC. See thread on hackers with subject "Canceling ROLLBACK
         * statement"
         */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>allPgXact</name><index>[<expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * If we can immediately acquire ProcArrayLock, we clear our own XID
         * and release the lock.  If not, use group XID clearing to improve
         * efficiency.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>LWLockConditionalAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ProcArrayEndTransactionInternal</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>pgxact</name></expr></argument>, <argument><expr><name>latestXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ProcArrayGroupClearXid</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>latestXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * If we have no XID, we don't need to lock, since we won't affect
         * anyone else's calculation of a snapshot.  We might change their
         * estimate of global xmin, but that's OK.
         */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><call><name>IsConnFromDatanode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>allPgXact</name><index>[<expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name><operator>.</operator><name>xid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>allPgXact</name><index>[<expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>lxid</name></name> <operator>=</operator> <name>InvalidLocalTransactionId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
        <comment type="block">/* must be cleared with xid/xmin: */</comment>
        <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PROC_VACUUM_STATE_MASK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* be sure this is cleared in abort */</comment>
        <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>recoveryConflictPending</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>    <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* Clear the subtransaction-XID cache too while holding the lock */</comment>
        <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>nxids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>overflowed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"invalid pgxact tmin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>tmin</name></name></expr></argument>, <argument><expr><name>InvalidGlobalTimestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>prepare_timestamp</name></name></expr></argument>, <argument><expr><name>InvalidGlobalTimestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pgxact</name><operator>-&gt;</operator><name>nxids</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pgxact</name><operator>-&gt;</operator><name>overflowed</name></name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Mark a write transaction as no longer running.
 *
 * We don't do any locking here; caller must handle that.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>ProcArrayEndTransactionInternal</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name></decl></parameter>,
                                <parameter><decl><type><name>TransactionId</name></type> <name>latestXid</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>lxid</name></name> <operator>=</operator> <name>InvalidLocalTransactionId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
    <comment type="block">/* must be cleared with xid/xmin: */</comment>
    <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PROC_VACUUM_STATE_MASK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* be sure this is cleared in abort */</comment>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>recoveryConflictPending</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* Clear the subtransaction-XID cache too while holding the lock */</comment>
    <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>nxids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>overflowed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* Also advance global latestCompletedXid while holding the lock */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr></argument>,
                              <argument><expr><name>latestXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name> <operator>=</operator> <name>latestXid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <comment type="block">/* avoid concurrency conflicts with the checkpoint */</comment>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>CommitTsLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>commitTs</name></name> <operator>&gt;</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCommitTs</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCommitTs</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>commitTs</name></name></expr>;</expr_stmt>
        
        <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"latest committs xid %d ts "</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>latestXid</name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>commitTs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>commitTs</name></name> <operator>=</operator> <name>InvalidGlobalTimestamp</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>commitTs</name></name> <operator>&gt;</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestGTS</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestGTS</name></name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>commitTs</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>CommitTsLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"invalid pgxact tmin xid %d"</literal></expr></argument>, <argument><expr><name>latestXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>tmin</name></name></expr></argument>, <argument><expr><name>InvalidGlobalTimestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>prepare_timestamp</name></name></expr></argument>, <argument><expr><name>InvalidGlobalTimestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <comment type="block">/* 
     * As procarrary lock is held and only the local proc is accessed, 
     * per-proc lock is not necessary.
     * On the condition of group clearing, as other back-ends are hung on the queue,
     * there is no concurrency.
     */</comment>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"remove my proc global xid %s procno %d"</literal></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>globalXid</name></name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>hasGlobalXid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<comment type="block">/*
 * ProcArrayGroupClearXid -- group XID clearing
 *
 * When we cannot immediately acquire ProcArrayLock in exclusive mode at
 * commit time, add ourselves to a list of processes that need their XIDs
 * cleared.  The first process to add itself to the list will acquire
 * ProcArrayLock in exclusive mode and perform ProcArrayEndTransactionInternal
 * on behalf of all group members.  This avoids a great deal of contention
 * around ProcArrayLock when many processes are trying to commit at once,
 * since the lock need not be repeatedly handed off from one committing
 * process to the next.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcArrayGroupClearXid</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>latestXid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>PROC_HDR</name> <modifier>*</modifier></type><name>procglobal</name> <init>= <expr><name>ProcGlobal</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>nextidx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>wakeidx</name></decl>;</decl_stmt>

    <comment type="block">/* We should definitely have an XID to clear. */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>allPgXact</name><index>[<expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Add ourselves to the list of processes needing a group XID clear. */</comment>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>procArrayGroupMember</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>procArrayGroupMemberXid</name></name> <operator>=</operator> <name>latestXid</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>true</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>nextidx</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>procglobal</name><operator>-&gt;</operator><name>procArrayGroupFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>procArrayGroupNext</name></name></expr></argument>, <argument><expr><name>nextidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>pg_atomic_compare_exchange_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>procglobal</name><operator>-&gt;</operator><name>procArrayGroupFirst</name></name></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name>nextidx</name></expr></argument>,
                                           <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * If the list was not empty, the leader will clear our XID.  It is
     * impossible to have followers without a leader because the first process
     * that has added itself to the list will always have nextidx as
     * INVALID_PGPROCNO.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>nextidx</name> <operator>!=</operator> <name>INVALID_PGPROCNO</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>extraWaits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Sleep until the leader clears our XID. */</comment>
        <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_PROCARRAY_GROUP_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <comment type="block">/* acts as a read barrier */</comment>
            <expr_stmt><expr><call><name>PGSemaphoreLock</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>proc</name><operator>-&gt;</operator><name>procArrayGroupMember</name></name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>extraWaits</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>procArrayGroupNext</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>INVALID_PGPROCNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Fix semaphore count for any absorbed wakeups */</comment>
        <while>while <condition>(<expr><name>extraWaits</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PGSemaphoreUnlock</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We are the leader.  Acquire the lock on behalf of everyone. */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now that we've got the lock, clear the list of processes waiting for
     * group XID clearing, saving a pointer to the head of the list.  Trying
     * to pop elements one at a time could lead to an ABA problem.
     */</comment>
    <while>while <condition>(<expr><name>true</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>nextidx</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>procglobal</name><operator>-&gt;</operator><name>procArrayGroupFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>pg_atomic_compare_exchange_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>procglobal</name><operator>-&gt;</operator><name>procArrayGroupFirst</name></name></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name>nextidx</name></expr></argument>,
                                           <argument><expr><name>INVALID_PGPROCNO</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Remember head of list so we can perform wakeups after dropping lock. */</comment>
    <expr_stmt><expr><name>wakeidx</name> <operator>=</operator> <name>nextidx</name></expr>;</expr_stmt>

    <comment type="block">/* Walk the list and clear all XIDs. */</comment>
    <while>while <condition>(<expr><name>nextidx</name> <operator>!=</operator> <name>INVALID_PGPROCNO</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGPROC</name>       <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>nextidx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PGXACT</name>       <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>nextidx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ProcArrayEndTransactionInternal</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>pgxact</name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>procArrayGroupMemberXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Move to next proc in list. */</comment>
        <expr_stmt><expr><name>nextidx</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>procArrayGroupNext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* We're done with the lock now. */</comment>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now that we've released the lock, go back and wake everybody up.  We
     * don't do this under the lock so as to keep lock hold times to a
     * minimum.  The system calls we need to perform to wake other processes
     * up are probably much slower than the simple memory writes we did while
     * holding the lock.
     */</comment>
    <while>while <condition>(<expr><name>wakeidx</name> <operator>!=</operator> <name>INVALID_PGPROCNO</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGPROC</name>       <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>wakeidx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>wakeidx</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>procArrayGroupNext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>procArrayGroupNext</name></name></expr></argument>, <argument><expr><name>INVALID_PGPROCNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* ensure all previous writes are visible before follower continues. */</comment>
        <expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>procArrayGroupMember</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>proc</name> <operator>!=</operator> <name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PGSemaphoreUnlock</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * ProcArrayClearTransaction -- clear the transaction fields
 *
 * This is used after successfully preparing a 2-phase transaction.  We are
 * not actually reporting the transaction's XID as no longer running --- it
 * will still appear as running because the 2PC's gxact is in the ProcArray
 * too.  We just have to clear out our own PGXACT.
 */</comment>
<function><type><name>void</name></type>
<name>ProcArrayClearTransaction</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGXACT</name>       <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * We can skip locking ProcArrayLock here, because this action does not
     * actually change anyone's view of the set of running XIDs: our entry is
     * duplicate with the gxact that has already been inserted into the
     * ProcArray.
     */</comment>
    <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>lxid</name></name> <operator>=</operator> <name>InvalidLocalTransactionId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>recoveryConflictPending</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* redundant, but just in case */</comment>
    <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PROC_VACUUM_STATE_MASK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* Clear the subtransaction-XID cache too */</comment>
    <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>nxids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>overflowed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>tmin</name></name></expr></argument>, <argument><expr><name>InvalidGlobalTimestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>prepare_timestamp</name></name></expr></argument>, <argument><expr><name>InvalidGlobalTimestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * ProcArrayInitRecovery -- initialize recovery xid mgmt environment
 *
 * Remember up to where the startup process initialized the CLOG and subtrans
 * so we can ensure it's initialized gaplessly up to the point where necessary
 * while in recovery.
 */</comment>
<function><type><name>void</name></type>
<name>ProcArrayInitRecovery</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>initializedUptoXID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>standbyState</name> <operator>==</operator> <name>STANDBY_INITIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>initializedUptoXID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * we set latestObservedXid to the xid SUBTRANS has been initialized up
     * to, so we can extend it from that point onwards in
     * RecordKnownAssignedTransactionIds, and when we get consistent in
     * ProcArrayApplyRecoveryInfo().
     */</comment>
    <expr_stmt><expr><name>latestObservedXid</name> <operator>=</operator> <name>initializedUptoXID</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TransactionIdRetreat</name><argument_list>(<argument><expr><name>latestObservedXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcArrayApplyRecoveryInfo -- apply recovery info about xids
 *
 * Takes us through 3 states: Initialized, Pending and Ready.
 * Normal case is to go all the way to Ready straight away, though there
 * are atypical cases where we need to take it in steps.
 *
 * Use the data about running transactions on master to create the initial
 * state of KnownAssignedXids. We also use these records to regularly prune
 * KnownAssignedXids because we know it is possible that some transactions
 * with FATAL errors fail to write abort records, which could cause eventual
 * overflow.
 *
 * See comments for LogStandbySnapshot().
 */</comment>
<function><type><name>void</name></type>
<name>ProcArrayApplyRecoveryInfo</name><parameter_list>(<parameter><decl><type><name>RunningTransactions</name></type> <name>running</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nxids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>nextXid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>standbyState</name> <operator>&gt;=</operator> <name>STANDBY_INITIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>running</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>running</name><operator>-&gt;</operator><name>oldestRunningXid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>running</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Remove stale transactions, if any.
     */</comment>
    <expr_stmt><expr><call><name>ExpireOldKnownAssignedTransactionIds</name><argument_list>(<argument><expr><name><name>running</name><operator>-&gt;</operator><name>oldestRunningXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Remove stale locks, if any.
     *
     * Locks are always assigned to the toplevel xid so we don't need to care
     * about subxcnt/subxids (and by extension not about -&gt;suboverflowed).
     */</comment>
    <expr_stmt><expr><call><name>StandbyReleaseOldLocks</name><argument_list>(<argument><expr><name><name>running</name><operator>-&gt;</operator><name>xcnt</name></name></expr></argument>, <argument><expr><name><name>running</name><operator>-&gt;</operator><name>xids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If our snapshot is already valid, nothing else to do...
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>standbyState</name> <operator>==</operator> <name>STANDBY_SNAPSHOT_READY</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If our initial RunningTransactionsData had an overflowed snapshot then
     * we knew we were missing some subxids from our snapshot. If we continue
     * to see overflowed snapshots then we might never be able to start up, so
     * we make another test to see if our snapshot is now valid. We know that
     * the missing subxids are equal to or earlier than nextXid. After we
     * initialise we continue to apply changes during recovery, so once the
     * oldestRunningXid is later than the nextXid from the initial snapshot we
     * know that we no longer have missing information and can mark the
     * snapshot as valid.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>standbyState</name> <operator>==</operator> <name>STANDBY_SNAPSHOT_PENDING</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If the snapshot isn't overflowed or if its empty we can reset our
         * pending state and use this snapshot instead.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>running</name><operator>-&gt;</operator><name>subxid_overflow</name></name> <operator>||</operator> <name><name>running</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If we have already collected known assigned xids, we need to
             * throw them away before we apply the recovery snapshot.
             */</comment>
            <expr_stmt><expr><call><name>KnownAssignedXidsReset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>standbyState</name> <operator>=</operator> <name>STANDBY_INITIALIZED</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>standbySnapshotPendingXmin</name></expr></argument>,
                                      <argument><expr><name><name>running</name><operator>-&gt;</operator><name>oldestRunningXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>standbyState</name> <operator>=</operator> <name>STANDBY_SNAPSHOT_READY</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><call><name>trace_recovery</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><literal type="string">"recovery snapshots are now enabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><call><name>trace_recovery</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><literal type="string">"recovery snapshot waiting for non-overflowed snapshot or "</literal>
                     <literal type="string">"until oldest active xid on standby is at least %u (now %u)"</literal></expr></argument>,
                     <argument><expr><name>standbySnapshotPendingXmin</name></expr></argument>,
                     <argument><expr><name><name>running</name><operator>-&gt;</operator><name>oldestRunningXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>standbyState</name> <operator>==</operator> <name>STANDBY_INITIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * OK, we need to initialise from the RunningTransactionsData record.
     *
     * NB: this can be reached at least twice, so make sure new code can deal
     * with that.
     */</comment>

    <comment type="block">/*
     * Nobody else is running yet, but take locks anyhow
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * KnownAssignedXids is sorted so we cannot just add the xids, we have to
     * sort them first.
     *
     * Some of the new xids are top-level xids and some are subtransactions.
     * We don't call SubtransSetParent because it doesn't matter yet. If we
     * aren't overflowed then all xids will fit in snapshot and so we don't
     * need subtrans. If we later overflow, an xid assignment record will add
     * xids to subtrans. If RunningXacts is overflowed then we don't have
     * enough information to correctly update subtrans anyway.
     */</comment>

    <comment type="block">/*
     * Allocate a temporary array to avoid modifying the array passed as
     * argument.
     */</comment>
    <expr_stmt><expr><name>xids</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>running</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>+</operator> <name><name>running</name><operator>-&gt;</operator><name>subxcnt</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Add to the temp array any xids which have not already completed.
     */</comment>
    <expr_stmt><expr><name>nxids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>running</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>+</operator> <name><name>running</name><operator>-&gt;</operator><name>subxcnt</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><name><name>running</name><operator>-&gt;</operator><name>xids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * The running-xacts snapshot can contain xids that were still visible
         * in the procarray when the snapshot was taken, but were already
         * WAL-logged as completed. They're not running anymore, so ignore
         * them.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>TransactionIdDidAbort</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>xids</name><index>[<expr><name>nxids</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>nxids</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>procArray</name><operator>-&gt;</operator><name>numKnownAssignedXids</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"KnownAssignedXids is not empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Sort the array so that we can add them safely into
         * KnownAssignedXids.
         */</comment>
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>xids</name></expr></argument>, <argument><expr><name>nxids</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>xidComparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
		 * Add the sorted snapshot into KnownAssignedXids.  The running-xacts
		 * snapshot may include duplicated xids because of prepared
		 * transactions, so ignore them.
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nxids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>xids</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>xids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					 <argument><expr><literal type="string">"found duplicated transaction %u for KnownAssignedXids insertion"</literal></expr></argument>,
					 <argument><expr><name><name>xids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>KnownAssignedXidsAdd</name><argument_list>(<argument><expr><name><name>xids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>xids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

        <expr_stmt><expr><call><name>KnownAssignedXidsDisplay</name><argument_list>(<argument><expr><call><name>trace_recovery</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>xids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * latestObservedXid is at least set to the point where SUBTRANS was
     * started up to (c.f. ProcArrayInitRecovery()) or to the biggest xid
     * RecordKnownAssignedTransactionIds() was called for.  Initialize
     * subtrans from thereon, up to nextXid - 1.
     *
     * We need to duplicate parts of RecordKnownAssignedTransactionId() here,
     * because we've just added xids to the known assigned xids machinery that
     * haven't gone through RecordKnownAssignedTransactionId().
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>latestObservedXid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name>latestObservedXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>latestObservedXid</name></expr></argument>, <argument><expr><name><name>running</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ExtendSUBTRANS</name><argument_list>(<argument><expr><name>latestObservedXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name>latestObservedXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>TransactionIdRetreat</name><argument_list>(<argument><expr><name>latestObservedXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* = running-&gt;nextXid - 1 */</comment>

    <comment type="block">/* ----------
     * Now we've got the running xids we need to set the global values that
     * are used to track snapshots as they evolve further.
     *
     * - latestCompletedXid which will be the xmax for snapshots
     * - lastOverflowedXid which shows whether snapshots overflow
     * - nextXid
     *
     * If the snapshot overflowed, then we still initialise with what we know,
     * but the recovery snapshot isn't fully valid yet because we know there
     * are some subxids missing. We don't know the specific subxids that are
     * missing, so conservatively assume the last one is latestObservedXid.
     * ----------
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>running</name><operator>-&gt;</operator><name>subxid_overflow</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>standbyState</name> <operator>=</operator> <name>STANDBY_SNAPSHOT_PENDING</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>standbySnapshotPendingXmin</name> <operator>=</operator> <name>latestObservedXid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>procArray</name><operator>-&gt;</operator><name>lastOverflowedXid</name></name> <operator>=</operator> <name>latestObservedXid</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>standbyState</name> <operator>=</operator> <name>STANDBY_SNAPSHOT_READY</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>standbySnapshotPendingXmin</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * If a transaction wrote a commit record in the gap between taking and
     * logging the snapshot then latestCompletedXid may already be higher than
     * the value from the snapshot, so check before we use the incoming value.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr></argument>,
                              <argument><expr><name><name>running</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name> <operator>=</operator> <name><name>running</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * ShmemVariableCache-&gt;nextXid must be beyond any observed xid.
     *
     * We don't expect anyone else to modify nextXid, hence we don't need to
     * hold a lock while examining it.  We still acquire the lock to modify
     * it, though.
     */</comment>
    <expr_stmt><expr><name>nextXid</name> <operator>=</operator> <name>latestObservedXid</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name>nextXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>nextXid</name></expr></argument>, <argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name> <operator>=</operator> <name>nextXid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>KnownAssignedXidsDisplay</name><argument_list>(<argument><expr><call><name>trace_recovery</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>standbyState</name> <operator>==</operator> <name>STANDBY_SNAPSHOT_READY</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><call><name>trace_recovery</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"recovery snapshots are now enabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><call><name>trace_recovery</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><literal type="string">"recovery snapshot waiting for non-overflowed snapshot or "</literal>
             <literal type="string">"until oldest active xid on standby is at least %u (now %u)"</literal></expr></argument>,
             <argument><expr><name>standbySnapshotPendingXmin</name></expr></argument>,
             <argument><expr><name><name>running</name><operator>-&gt;</operator><name>oldestRunningXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcArrayApplyXidAssignment
 *        Process an XLOG_XACT_ASSIGNMENT WAL record
 */</comment>
<function><type><name>void</name></type>
<name>ProcArrayApplyXidAssignment</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>topxid</name></decl></parameter>,
                            <parameter><decl><type><name>int</name></type> <name>nsubxids</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>subxids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>max_xid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>standbyState</name> <operator>&gt;=</operator> <name>STANDBY_INITIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>max_xid</name> <operator>=</operator> <call><name>TransactionIdLatest</name><argument_list>(<argument><expr><name>topxid</name></expr></argument>, <argument><expr><name>nsubxids</name></expr></argument>, <argument><expr><name>subxids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Mark all the subtransactions as observed.
     *
     * NOTE: This will fail if the subxid contains too many previously
     * unobserved xids to fit into known-assigned-xids. That shouldn't happen
     * as the code stands, because xid-assignment records should never contain
     * more than PGPROC_MAX_CACHED_SUBXIDS entries.
     */</comment>
    <expr_stmt><expr><call><name>RecordKnownAssignedTransactionIds</name><argument_list>(<argument><expr><name>max_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Notice that we update pg_subtrans with the top-level xid, rather than
     * the parent xid. This is a difference between normal processing and
     * recovery, yet is still correct in all cases. The reason is that
     * subtransaction commit is not marked in clog until commit processing, so
     * all aborted subtransactions have already been clearly marked in clog.
     * As a result we are able to refer directly to the top-level
     * transaction's state rather than skipping through all the intermediate
     * states in the subtransaction tree. This should be the first time we
     * have attempted to SubTransSetParent().
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsubxids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SubTransSetParent</name><argument_list>(<argument><expr><name><name>subxids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>topxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* KnownAssignedXids isn't maintained yet, so we're done for now */</comment>
    <if_stmt><if>if <condition>(<expr><name>standbyState</name> <operator>==</operator> <name>STANDBY_INITIALIZED</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Uses same locking as transaction commit
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Remove subxids from known-assigned-xacts.
     */</comment>
    <expr_stmt><expr><call><name>KnownAssignedXidsRemoveTree</name><argument_list>(<argument><expr><name>InvalidTransactionId</name></expr></argument>, <argument><expr><name>nsubxids</name></expr></argument>, <argument><expr><name>subxids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Advance lastOverflowedXid to be at least the last of these subxids.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>procArray</name><operator>-&gt;</operator><name>lastOverflowedXid</name></name></expr></argument>, <argument><expr><name>max_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>procArray</name><operator>-&gt;</operator><name>lastOverflowedXid</name></name> <operator>=</operator> <name>max_xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
<comment type="block">/*
 * In our distributed transaction concurrency protocol, 
 * we should wait for the transaction to complete if it has been prepared.
 * Return true if the xid has been prepared, committed or aborted.
 * Otherwise, return false.
 */</comment>

<function><type><name>bool</name></type>
<name>TransactionIdIsPrepared</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>GlobalTimestamp</name> <modifier>*</modifier></type><name>prepare_ts</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name> <modifier>*</modifier></type><name>xids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>GlobalTimestamp</name> <modifier>*</modifier></type><name>prepare_timestamp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nxids</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>topxid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><operator>*</operator><name>prepare_ts</name> <operator>=</operator> <name>InvalidGlobalTimestamp</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Don't bother checking a transaction older than RecentXmin; it could not
     * possibly still be running.  (Note: in particular, this guarantees that
     * we reject InvalidTransactionId, FrozenTransactionId, etc as not
     * running.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>RecentXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>xc_by_recent_xmin_inc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>


    <comment type="block">/*
     * Also, we can handle our own transaction (and subtransactions) without
     * any access to shared memory.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>xc_by_my_xact_inc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transaction %d should not wait for itsef to complete. autovacuum %d"</literal></expr></argument>, 
                         <argument><expr><name>xid</name></expr></argument>, <argument><expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If first time through, get workspace to remember main XIDs in. We
     * malloc it permanently to avoid repeated palloc/pfree overhead.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>xids</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * In hot standby mode, reserve enough space to hold all xids in the
         * known-assigned list. If we later finish recovery, we no longer need
         * the bigger array, but we don't bother to shrink it.
         */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>maxxids</name> <init>= <expr><ternary><condition><expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>TOTAL_MAX_CACHED_SUBXIDS</name></expr> </then><else>: <expr><name><name>arrayP</name><operator>-&gt;</operator><name>maxProcs</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>xids</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>maxxids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>xids</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>prepare_timestamp</name> <operator>=</operator> <operator>(</operator><name>GlobalTimestamp</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>maxxids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>prepare_timestamp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/* No shortcuts, gotta grovel through the array */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>pxid</name></decl>;</decl_stmt>

        <comment type="block">/* Ignore my own proc --- dealt with it above */</comment>
        <if_stmt><if>if <condition>(<expr><name>proc</name> <operator>==</operator> <name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Fetch xid just once - see GetNewTransactionId */</comment>
        <expr_stmt><expr><name>pxid</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>pxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Step 1: check the main Xid
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>pxid</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>res</name></decl>;</decl_stmt>
                
            <expr_stmt><expr><operator>*</operator><name>prepare_ts</name>  <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>prepare_timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><call><name>GlobalTimestampIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>prepare_ts</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>true</name></expr></then><else>:<expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>xc_by_main_xid_inc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>res</name></expr>;</return>
            
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * We can ignore main Xids that are younger than the target Xid, since
         * the target could not possibly be their child.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>pxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Step 2: check the cached child-Xids arrays
         */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>nxids</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* Fetch xid just once - see GetNewTransactionId */</comment>
            <decl_stmt><decl><type><name>TransactionId</name></type> <name>cxid</name> <init>= <expr><name><name>proc</name><operator>-&gt;</operator><name>subxids</name><operator>.</operator><name>xids</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>cxid</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>bool</name></type> <name>res</name></decl>;</decl_stmt>
                
                <expr_stmt><expr><operator>*</operator><name>prepare_ts</name>  <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>prepare_timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><call><name>GlobalTimestampIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>prepare_ts</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>true</name></expr></then><else>:<expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>xc_by_child_xid_inc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>res</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * Save the main Xid for step 4.  We only need to remember main Xids
         * that have uncached children.  (Note: there is no race condition
         * here because the overflowed flag cannot be cleared, only set, while
         * we hold ProcArrayLock.  So we can't miss an Xid that we need to
         * worry about.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pgxact</name><operator>-&gt;</operator><name>overflowed</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>xids</name><index>[<expr><name>nxids</name></expr>]</index></name> <operator>=</operator> <name>pxid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>prepare_timestamp</name><index>[<expr><name>nxids</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>prepare_timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>


    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/*
     * Step 4: have to check pg_subtrans.
     *
     * At this point, we know it's either a subtransaction of one of the Xids
     * in xids[], or it's not running.  If it's an already-failed
     * subtransaction, we want to say "not running" even though its parent may
     * still be running.  So first, check pg_xact to see if it's been aborted.
     */</comment>
    <expr_stmt><expr><call><name>xc_slow_answer_inc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdDidAbort</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * It isn't aborted, so check whether the transaction tree it belongs to
     * is still running (or, more precisely, whether it was running when we
     * held ProcArrayLock).
     */</comment>
    <expr_stmt><expr><name>topxid</name> <operator>=</operator> <call><name>SubTransGetTopmostTransaction</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>topxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>topxid</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nxids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>xids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>topxid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><call><name>GlobalTimestampIsValid</name><argument_list>(<argument><expr><name><name>prepare_timestamp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>prepare_ts</name> <operator>=</operator> <name><name>prepare_timestamp</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                    <return>return <expr><name>true</name></expr>;</return>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * TransactionIdIsInProgress -- is given transaction running in some backend
 *
 * Aside from some shortcuts such as checking RecentXmin and our own Xid,
 * there are four possibilities for finding a running transaction:
 *
 * 1. The given Xid is a main transaction Id.  We will find this out cheaply
 * by looking at the PGXACT struct for each backend.
 *
 * 2. The given Xid is one of the cached subxact Xids in the PGPROC array.
 * We can find this out cheaply too.
 *
 * 3. In Hot Standby mode, we must search the KnownAssignedXids list to see
 * if the Xid is running on the master.
 *
 * 4. Search the SubTrans tree to find the Xid's topmost parent, and then see
 * if that is running according to PGXACT or KnownAssignedXids.  This is the
 * slowest way, but sadly it has to be done always if the others failed,
 * unless we see that the cached subxact sets are complete (none have
 * overflowed).
 *
 * ProcArrayLock has to be held while we do 1, 2, 3.  If we save the top Xids
 * while doing 1 and 3, we can release the ProcArrayLock while we do 4.
 * This buys back some concurrency (and we can't retrieve the main Xids from
 * PGXACT again anyway; see GetNewTransactionId).
 */</comment>
<function><type><name>bool</name></type>
<name>TransactionIdIsInProgress</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name> <modifier>*</modifier></type><name>xids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nxids</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>topxid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Don't bother checking a transaction older than RecentXmin; it could not
     * possibly still be running.  (Note: in particular, this guarantees that
     * we reject InvalidTransactionId, FrozenTransactionId, etc as not
     * running.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>RecentXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>xc_by_recent_xmin_inc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We may have just checked the status of this transaction, so if it is
     * already known to be completed, we can fall out without any access to
     * shared memory.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsKnownCompleted</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>xc_by_known_xact_inc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/*
     * We should check clog status here as now one tuple becomes visible immediately
     * after its commit timestamps is written to committs log.
     * If TransactionIdIsInProgress performs just before tuple's transaction 
     * proc entry is removed from procarray, then the tuple may be regarded as invisible by mistaken.
     * Since the clog status is updated before writting committs log upon commits 
     * (See RecordTransactionCommit, RecordTransactionCommitPrepared),
     * the clog rechecking could avoid the above situation.
     */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Also, we can handle our own transaction (and subtransactions) without
     * any access to shared memory.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>xc_by_my_xact_inc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If first time through, get workspace to remember main XIDs in. We
     * malloc it permanently to avoid repeated palloc/pfree overhead.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>xids</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * In hot standby mode, reserve enough space to hold all xids in the
         * known-assigned list. If we later finish recovery, we no longer need
         * the bigger array, but we don't bother to shrink it.
         */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>maxxids</name> <init>= <expr><ternary><condition><expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>TOTAL_MAX_CACHED_SUBXIDS</name></expr> </then><else>: <expr><name><name>arrayP</name><operator>-&gt;</operator><name>maxProcs</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>xids</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>maxxids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>xids</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now that we have the lock, we can check latestCompletedXid; if the
     * target Xid is after that, it's surely still running.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>xc_by_latest_xid_inc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* No shortcuts, gotta grovel through the array */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>pxid</name></decl>;</decl_stmt>

        <comment type="block">/* Ignore my own proc --- dealt with it above */</comment>
        <if_stmt><if>if <condition>(<expr><name>proc</name> <operator>==</operator> <name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Fetch xid just once - see GetNewTransactionId */</comment>
        <expr_stmt><expr><name>pxid</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>pxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Step 1: check the main Xid
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>pxid</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>xc_by_main_xid_inc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * We can ignore main Xids that are younger than the target Xid, since
         * the target could not possibly be their child.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>pxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Step 2: check the cached child-Xids arrays
         */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>nxids</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* Fetch xid just once - see GetNewTransactionId */</comment>
            <decl_stmt><decl><type><name>TransactionId</name></type> <name>cxid</name> <init>= <expr><name><name>proc</name><operator>-&gt;</operator><name>subxids</name><operator>.</operator><name>xids</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>cxid</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>xc_by_child_xid_inc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * Save the main Xid for step 4.  We only need to remember main Xids
         * that have uncached children.  (Note: there is no race condition
         * here because the overflowed flag cannot be cleared, only set, while
         * we hold ProcArrayLock.  So we can't miss an Xid that we need to
         * worry about.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pgxact</name><operator>-&gt;</operator><name>overflowed</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>xids</name><index>[<expr><name>nxids</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pxid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Step 3: in hot standby mode, check the known-assigned-xids list.  XIDs
     * in the list must be treated as running.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* none of the PGXACT entries should have XIDs in hot standby mode */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nxids</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>KnownAssignedXidExists</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>xc_by_known_assigned_inc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If the KnownAssignedXids overflowed, we have to check pg_subtrans
         * too.  Fetch all xids from KnownAssignedXids that are lower than
         * xid, since if xid is a subtransaction its parent will always have a
         * lower value.  Note we will collect both main and subXIDs here, but
         * there's no help for it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedesOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>procArray</name><operator>-&gt;</operator><name>lastOverflowedXid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nxids</name> <operator>=</operator> <call><name>KnownAssignedXidsGet</name><argument_list>(<argument><expr><name>xids</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If none of the relevant caches overflowed, we know the Xid is not
     * running without even looking at pg_subtrans.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>nxids</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>xc_no_overflow_inc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Step 4: have to check pg_subtrans.
     *
     * At this point, we know it's either a subtransaction of one of the Xids
     * in xids[], or it's not running.  If it's an already-failed
     * subtransaction, we want to say "not running" even though its parent may
     * still be running.  So first, check pg_xact to see if it's been aborted.
     */</comment>
    <expr_stmt><expr><call><name>xc_slow_answer_inc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdDidAbort</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * It isn't aborted, so check whether the transaction tree it belongs to
     * is still running (or, more precisely, whether it was running when we
     * held ProcArrayLock).
     */</comment>
    <expr_stmt><expr><name>topxid</name> <operator>=</operator> <call><name>SubTransGetTopmostTransaction</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>topxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>topxid</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nxids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>xids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>topxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TransactionIdIsActive -- is xid the top-level XID of an active backend?
 *
 * This differs from TransactionIdIsInProgress in that it ignores prepared
 * transactions, as well as transactions running on the master if we're in
 * hot standby.  Also, we ignore subtransactions since that's not needed
 * for current uses.
 */</comment>
<function><type><name>bool</name></type>
<name>TransactionIdIsActive</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Don't bother checking a transaction older than RecentXmin; it could not
     * possibly still be running.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>RecentXmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>pxid</name></decl>;</decl_stmt>

        <comment type="block">/* Fetch xid just once - see GetNewTransactionId */</comment>
        <expr_stmt><expr><name>pxid</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>pxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* ignore prepared transactions */</comment>

        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>pxid</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetOldestXmin -- returns oldest transaction that was running
 *                    when any current transaction was started.
 *
 * If rel is NULL or a shared relation, all backends are considered, otherwise
 * only backends running in this database are considered.
 *
 * The flags are used to ignore the backends in calculation when any of the
 * corresponding flags is set. Typically, if you want to ignore ones with
 * PROC_IN_VACUUM flag, you can use PROCARRAY_FLAGS_VACUUM.
 *
 * PROCARRAY_SLOTS_XMIN causes GetOldestXmin to ignore the xmin and
 * catalog_xmin of any replication slots that exist in the system when
 * calculating the oldest xmin.
 *
 * This is used by VACUUM to decide which deleted tuples must be preserved in
 * the passed in table. For shared relations backends in all databases must be
 * considered, but for non-shared relations that's not required, since only
 * backends in my own database could ever see the tuples in them. Also, we can
 * ignore concurrently running lazy VACUUMs because (a) they must be working
 * on other tables, and (b) they don't need to do snapshot-based lookups.
 *
 * This is also used to determine where to truncate pg_subtrans.  For that
 * backends in all databases have to be considered, so rel = NULL has to be
 * passed in.
 *
 * Note: we include all currently running xids in the set of considered xids.
 * This ensures that if a just-started xact has not yet set its snapshot,
 * when it does set the snapshot it cannot set xmin less than what we compute.
 * See notes in src/backend/access/transam/README.
 *
 * Note: despite the above, it's possible for the calculated value to move
 * backwards on repeated calls. The calculated value is conservative, so that
 * anything older is definitely not considered as running by anyone anymore,
 * but the exact value calculated depends on a number of things. For example,
 * if rel = NULL and there are no transactions running in the current
 * database, GetOldestXmin() returns latestCompletedXid. If a transaction
 * begins after that, its xmin will include in-progress transactions in other
 * databases that started earlier, so another call will return a lower value.
 * Nonetheless it is safe to vacuum a table in the current database with the
 * first result.  There are also replication-related effects: a walsender
 * process can set its xmin based on transactions that are no longer running
 * in the master but are still being replayed on the standby, thus possibly
 * making the GetOldestXmin reading go backwards.  In this case there is a
 * possibility that we lose data that the standby would like to have, but
 * unless the standby uses a replication slot to make its xmin persistent
 * there is little we can do about that --- data is only protected if the
 * walsender runs continuously while queries are executed on the standby.
 * (The Hot Standby code deals with such cases by failing standby queries
 * that needed to access already-removed data, so there's no integrity bug.)
 * The return value is also adjusted with vacuum_defer_cleanup_age, so
 * increasing that setting on the fly is another easy way to make
 * GetOldestXmin() move backwards, with no consequences for data integrity.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>GetOldestXmin</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>GetOldestXminInternal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
            <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This implements most of the logic that GetOldestXmin needs. In XL, we don't
 * actually compute OldestXmin unless specifically told to do by computeLocal
 * argument set to true which GetOldestXmin never done. So we just return the
 * value from the shared memory. The OldestXmin itself is always computed by
 * the Cluster Monitor process by sending local state information to the GTM,
 * which then aggregates information from all the nodes and gives out final
 * OldestXmin or GlobalXmin which is consistent across the entire cluster.
 *
 * In addition, Cluster Monitor also passes the last reported xmin (or the one
 * sent back by GTM in case we were idle) and the last received GlobalXmin. We
 * must ensure that we don't see an XID or xmin which is beyond these horizons.
 * Otherwise it signals problems with the GlobalXmin calculation. This can
 * happen because of network disconnects or extreme load on the machine
 * (unlikely). In any case, we must restart ourselves to avoid any data
 * consistency problem. A more careful approach could involve killing only
 * those backends which are running with old xid or xmin. We can consider
 * implementing it that way in future
 */</comment>
<function><type><name>TransactionId</name></type>
<name>GetOldestXminInternal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>computeLocal</name></decl></parameter>,
        <parameter><decl><type><name>TransactionId</name></type> <name>lastGlobalXmin</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>allDbs</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xmin</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>TransactionId</name></type> <name>replication_slot_xmin</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>TransactionId</name></type> <name>replication_slot_catalog_xmin</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If we're not computing a relation specific limit, or if a shared
     * relation has been passed in, backends in all databases have to be
     * considered.
     */</comment>
    <expr_stmt><expr><name>allDbs</name> <operator>=</operator> <name>rel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>computeLocal</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>xmin</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator> <call><name>ClusterMonitorGetGlobalXmin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>xmin</name> <operator>=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>xmin</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Cannot look for individual databases during recovery */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>allDbs</name> <operator>||</operator> <operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We initialize the MIN() calculation with latestCompletedXid + 1. This
     * is a lower bound for the XIDs that might appear in the ProcArray later,
     * and so protects us against overestimating the result due to future
     * additions.
     */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"GetOldestXminInternal - Starting computation with"</literal>
            <literal type="string">"latestCompletedXid %d + 1"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pgxact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>PROCARRAY_PROC_FLAGS_MASK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>allDbs</name> <operator>||</operator>
            <name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>==</operator> <name>MyDatabaseId</name> <operator>||</operator>
            <name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>    <comment type="block">/* always include WalSender */</comment>
        <block>{<block_content>
            <comment type="block">/* Fetch xid just once - see GetNewTransactionId */</comment>
            <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
            <decl_stmt><decl><type><name>TransactionId</name></type> <name>xmin</name> <init>= <expr><name><name>pgxact</name><operator>-&gt;</operator><name>xmin</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Fetch just once */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/* First consider the transaction's own Xid, if any */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Also consider the transaction's Xmin, if set.
             *
             * We must check both Xid and Xmin because a transaction might
             * have an Xmin but not (yet) an Xid; conversely, if it has an
             * Xid, that could determine some not-yet-set Xmin.
             */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>

            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"proc: pid:%d, xmin: %d, xid: %d"</literal></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>,
                    <argument><expr><name>xmin</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                 <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * If we see an xid or an xmin which precedes the GlobalXmin calculated by the
             * Cluster Monitor process then it signals bad things and we must
             * abort and restart the database server
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>lastGlobalXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>, <argument><expr><name>lastGlobalXmin</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
                    <operator>(</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>,
                                                                        <argument><expr><name>lastGlobalXmin</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Found xid (%d) or xmin (%d) precedes "</literal>
                            <literal type="string">"global xmin (%d)"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>, <argument><expr><name>lastGlobalXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt> <comment type="block">/* Fetch just once */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* fetch into volatile var while ProcArrayLock is held */</comment>
    <expr_stmt><expr><name>replication_slot_xmin</name> <operator>=</operator> <name><name>procArray</name><operator>-&gt;</operator><name>replication_slot_xmin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>replication_slot_catalog_xmin</name> <operator>=</operator> <name><name>procArray</name><operator>-&gt;</operator><name>replication_slot_catalog_xmin</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Check to see whether KnownAssignedXids contains an xid value older
         * than the main procarray.
         */</comment>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>kaxmin</name> <init>= <expr><call><name>KnownAssignedXidsGetOldestXmin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>kaxmin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>kaxmin</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>kaxmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * No other information needed, so release the lock immediately.
         */</comment>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Compute the cutoff XID by subtracting vacuum_defer_cleanup_age,
         * being careful not to generate a "permanent" XID.
         *
         * vacuum_defer_cleanup_age provides some additional "slop" for the
         * benefit of hot standby queries on standby servers.  This is quick
         * and dirty, and perhaps not all that useful unless the master has a
         * predictable transaction rate, but it offers some protection when
         * there's no walsender connection.  Note that we are assuming
         * vacuum_defer_cleanup_age isn't large enough to cause wraparound ---
         * so guc.c should limit it to no more than the xidStopLimit threshold
         * in varsup.c.  Also note that we intentionally don't apply
         * vacuum_defer_cleanup_age on standby servers.
         */</comment>
        <expr_stmt><expr><name>result</name> <operator>-=</operator> <name>vacuum_defer_cleanup_age</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Check whether there are replication slots requiring an older xmin.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>PROCARRAY_SLOTS_XMIN</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>replication_slot_xmin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>NormalTransactionIdPrecedes</name><argument_list>(<argument><expr><name>replication_slot_xmin</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>replication_slot_xmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * After locks have been released and defer_cleanup_age has been applied,
     * check whether we need to back up further to make logical decoding
     * possible. We need to do so if we're computing the global limit (rel =
     * NULL) or if the passed relation is a catalog relation of some kind.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>PROCARRAY_SLOTS_XMIN</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>rel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
         <call><name>RelationIsAccessibleInLogicalDecoding</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
        <call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>replication_slot_catalog_xmin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>NormalTransactionIdPrecedes</name><argument_list>(<argument><expr><name>replication_slot_catalog_xmin</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>replication_slot_catalog_xmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetMaxSnapshotXidCount -- get max size for snapshot XID array
 *
 * We have to export this for use by snapmgr.c.
 */</comment>
<function><type><name>int</name></type>
<name>GetMaxSnapshotXidCount</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>procArray</name><operator>-&gt;</operator><name>maxProcs</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetMaxSnapshotSubxidCount -- get max size for snapshot sub-XID array
 *
 * We have to export this for use by snapmgr.c.
 */</comment>
<function><type><name>int</name></type>
<name>GetMaxSnapshotSubxidCount</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>TOTAL_MAX_CACHED_SUBXIDS</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>TransactionId</name></type> <name>GetLocalTransactionId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>globalXid</name></decl></parameter>,
				<parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>subxids</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nsub</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>overflowed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>pgprocnos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numProcs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>index</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>numProcs</name> <operator>=</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pgprocnos</name> <operator>=</operator>  <name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>numProcs</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>         <name>pgprocno</name> <init>= <expr><name><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type>    <name>result</name> <init>=  <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>nxid</name></decl>;</decl_stmt>
        
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>globalxidLock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>proc</name><operator>-&gt;</operator><name>hasGlobalXid</name></name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>globalXid</name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>globalXid</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>proc</name><operator>-&gt;</operator><name>hasGlobalXid</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"proc no %d null"</literal></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"proc no %d global xid %s target %s"</literal></expr></argument>, 
                <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>globalXid</name></name></expr></argument>, <argument><expr><name>globalXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>globalxidLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>
		
		<expr_stmt><expr><operator>*</operator><name>overflowed</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>overflowed</name></name></expr>;</expr_stmt>
		
		<comment type="block">/* look for max xid in subtrans */</comment>
		<expr_stmt><expr><operator>*</operator><name>nsub</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>nxids</name></name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>nxid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nxid</name> <operator>&lt;</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>nxids</name></name></expr>;</condition> <incr><expr><name>nxid</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>subxid</name> <init>= <expr><name><name>proc</name><operator>-&gt;</operator><name>subxids</name><operator>.</operator><name>xids</name><index>[<expr><name>nxid</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>subxids</name><index>[<expr><name>nxid</name></expr>]</index></name> <operator>=</operator> <name>subxid</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>globalxidLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"found xid %d for global xid %s"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>globalXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>InvalidTransactionId</name></expr>;</return>

</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>char</name> <modifier>*</modifier></type><name>GetGlobalTransactionId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TransactionId</name></type> <name>pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>pgprocnos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numProcs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>index</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>numProcs</name> <operator>=</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pgprocnos</name> <operator>=</operator>  <name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>numProcs</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>         <name>pgprocno</name> <init>= <expr><name><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>globalxidLock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>proc</name><operator>-&gt;</operator><name>hasGlobalXid</name></name> <operator>||</operator> <name>pid</name> <operator>!=</operator> <name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>proc</name><operator>-&gt;</operator><name>hasGlobalXid</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"proc no %d null"</literal></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"proc no %d pid %d target global xid %s"</literal></expr></argument>, 
                <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>globalXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>globalxidLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>globalxidLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"found global xid %s for xid %d"</literal></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>globalXid</name></name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>proc</name><operator>-&gt;</operator><name>globalXid</name></name></expr>;</return>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<comment type="block">/*
 * GetSnapshotData -- returns information about running transactions.
 *
 * The returned snapshot includes xmin (lowest still-running xact ID),
 * xmax (highest completed xact ID + 1), and a list of running xact IDs
 * in the range xmin &lt;= xid &lt; xmax.  It is used as follows:
 *        All xact IDs &lt; xmin are considered finished.
 *        All xact IDs &gt;= xmax are considered still running.
 *        For an xact ID xmin &lt;= xid &lt; xmax, consult list to see whether
 *        it is considered running or not.
 * This ensures that the set of transactions seen as "running" by the
 * current xact will not change after it takes the snapshot.
 *
 * All running top-level XIDs are included in the snapshot, except for lazy
 * VACUUM processes.  We also try to include running subtransaction XIDs,
 * but since PGPROC has only a limited cache area for subxact XIDs, full
 * information may not be available.  If we find any overflowed subxid arrays,
 * we have to mark the snapshot's subxid data as overflowed, and extra work
 * *may* need to be done to determine what's running (see XidInMVCCSnapshot()
 * in tqual.c).
 *
 * We also update the following backend-global variables:
 *        TransactionXmin: the oldest xmin of any snapshot in use in the
 *            current transaction (this is the same as MyPgXact-&gt;xmin).
 *        RecentXmin: the xmin computed for the most recent snapshot.  XIDs
 *            older than this are known not running any more.
 *        RecentGlobalXmin: the global xmin (oldest TransactionXmin across all
 *            running transactions, except those running LAZY VACUUM).  This is
 *            the same computation done by
 *            GetOldestXmin(NULL, PROCARRAY_FLAGS_VACUUM).
 *        RecentGlobalDataXmin: the global xmin for non-catalog tables
 *            &gt;= RecentGlobalXmin
 *
 * Note: this function should probably not be called with an argument that's
 * not statically allocated (see xip allocation below).
 */</comment>
<function><type><name>Snapshot</name></type>
<name>GetSnapshotData_shard</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>latest</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_shardmap</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xmin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xmax</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>globalxmin</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>prepare_xmin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTimestamp</name></type> <name>tmin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>precount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>subprecount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>subcount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>suboverflowed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>TransactionId</name></type> <name>replication_slot_xmin</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>TransactionId</name></type> <name>replication_slot_catalog_xmin</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>TransactionId</name> <name>clustermon_xmin</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>IsNormalProcessingMode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>need_shardmap</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>groupsize</name></name> <operator>=</operator> <call><name>GetGroupSize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>SnapshotGetShardTable</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>SnapshotGetShardTable</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>Bitmapset</name> <operator>*</operator><operator>)</operator><name><name>snapshot</name><operator>-&gt;</operator><name>sg_filler</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>CopyShardGroups_DN</name><argument_list>(<argument><expr><call><name>SnapshotGetShardTable</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>groupsize</name></name><operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SnapshotGetShardTable</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef> <comment type="block">/* PGXC_DATANODE */</comment>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>local</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <comment type="block">/*
     * If the user has chosen to work with a coordinator-local snapshot, just
     * compute snapshot locally. This can have adverse effects on the global
     * consistency, in a multi-coordinator environment, but also in a
     * single-coordinator setup because our recent changes to transaction
     * management now allows datanodes to start global snapshots or more
     * precisely attach current transaction to a global transaction. But users
     * may still want to use this model for performance of their XL cluster, at
     * the cost of reduced global consistency
     */</comment> 

    <if_stmt><if>if <condition>(<expr><name>GlobalSnapshotSource</name> <operator>==</operator> <name>GLOBAL_SNAPSHOT_SOURCE_GTM</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Obtain a global snapshot for a Postgres-XC session
         * if possible.
         */</comment>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>GetPGXCSnapshotData</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>latest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Fallback to standard routine, calculate snapshot from local proc arrey
     * if no master connection
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>snapshot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Allocating space for maxProcs xids is usually overkill; numProcs would
     * be sufficient.  But it seems better to do the malloc while not holding
     * the lock, so we can't look at numProcs.  Likewise, we allocate much
     * more subxip storage than is probably needed.
     *
     * This does open a possibility for avoiding repeated malloc/free: since
     * maxProcs does not change at runtime, we can simply reuse the previous
     * xip arrays if any.  (This relies on the fact that all callers pass
     * static SnapshotData structs.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>xip</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * First call for this snapshot. Snapshot is same size whether or not
         * we are in recovery, see later comments.
         */</comment>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xip</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator>
            <call><name>malloc</name><argument_list>(<argument><expr><call><name>GetMaxSnapshotXidCount</name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>xip</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxip</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxip</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator>
            <call><name>malloc</name><argument_list>(<argument><expr><call><name>GetMaxSnapshotSubxidCount</name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxip</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xip</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator>
            <call><name>malloc</name><argument_list>(<argument><expr><call><name>GetMaxSnapshotXidCount</name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xip</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxip</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator>
            <call><name>malloc</name><argument_list>(<argument><expr><call><name>GetMaxSnapshotSubxidCount</name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxip</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xip_ts</name></name> <operator>=</operator> <operator>(</operator><name>GlobalTimestamp</name> <operator>*</operator><operator>)</operator>
            <call><name>malloc</name><argument_list>(<argument><expr><call><name>GetMaxSnapshotXidCount</name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xip_ts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxip_ts</name></name> <operator>=</operator> <operator>(</operator><name>GlobalTimestamp</name> <operator>*</operator><operator>)</operator>
            <call><name>malloc</name><argument_list>(<argument><expr><call><name>GetMaxSnapshotSubxidCount</name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxip_ts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * It is sufficient to get shared lock on ProcArrayLock, even if we are
     * going to set MyPgXact-&gt;xmin.
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* xmax is always latestCompletedXid + 1 */</comment>
    <expr_stmt><expr><name>xmax</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* initialize xmin calculation with xmax */</comment>
    <expr_stmt><expr><name>globalxmin</name> <operator>=</operator> <name>xmin</name> <operator>=</operator> <name>xmax</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><name>prepare_xmin</name>   <operator>=</operator> <name>xmin</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>RecentCommitTs</name> <operator>=</operator> <name>tmin</name> <operator>=</operator> <ternary><condition><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestGTS</name></name> <operator>&gt;</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCommitTs</name></name></expr> ?</condition><then> 
                                <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestGTS</name></name></expr> </then><else>: <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCommitTs</name></name></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>takenDuringRecovery</name></name> <operator>=</operator> <call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>snapshot</name><operator>-&gt;</operator><name>takenDuringRecovery</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>pgprocnos</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>numProcs</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Spin over procArray checking xid, xmin, and subxids.  The goal is
         * to gather all active xids, find the lowest xmin, and try to record
         * subxids.
         */</comment>
        <expr_stmt><expr><name>numProcs</name> <operator>=</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>numProcs</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>GlobalTimestamp</name></type> <name>saved_tmin</name></decl>;</decl_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>

            <expr_stmt><expr><name>saved_tmin</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>tmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>GlobalTimestampIsValid</name><argument_list>(<argument><expr><name>saved_tmin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>saved_tmin</name> <operator>&lt;</operator> <name>tmin</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>tmin</name> <operator>=</operator> <name>saved_tmin</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* Fetch xid just once - see GetNewTransactionId */</comment>
            <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>                    
                <if_stmt><if>if<condition>(<expr><call><name>NormalTransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>prepare_xmin</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>prepare_xmin</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if<condition>(<expr><name>pgxact</name> <operator>!=</operator> <name>MyPgXact</name></expr>)</condition>
                <block>{<block_content>

                    <decl_stmt><decl><type><name>GlobalTimestamp</name></type> <name>prepare_ts</name> <init>= <expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>prepare_timestamp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>TransactionId</name></type> <name>latest_xid</name> <init>= <expr><name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr></init></decl>;</decl_stmt>
                    <comment type="block">/*
                     * Fetching the xid and checking whether it has been changed 
                     * to ensure that the prepare_timestamp indeed belongs to this xid and is valid.
                     */</comment>
                    <if_stmt><if>if<condition>(<expr><name>latest_xid</name> <operator>!=</operator> <name>xid</name></expr>)</condition>
                    <block>{<block_content>
                        <goto>goto <name>prepare_finished</name>;</goto>
                    </block_content>}</block></if></if_stmt>
                    
                    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xip</name><index>[<expr><name>precount</name></expr>]</index></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xip_ts</name><index>[<expr><name>precount</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>prepare_ts</name></expr>;</expr_stmt>
                    
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>suboverflowed</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>pgxact</name><operator>-&gt;</operator><name>overflowed</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>suboverflowed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>int</name></type>         <name>nxids</name> <init>= <expr><name><name>pgxact</name><operator>-&gt;</operator><name>nxids</name></name></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>int</name></type>         <name>j</name></decl>;</decl_stmt>

                            <if_stmt><if>if<condition>(<expr><name>nxids</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                                <for>for<control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nxids</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
                                <block>{<block_content>
                                    <comment type="block">/* Fetch xid just once - see GetNewTransactionId */</comment>
                                    <decl_stmt><decl><type><name>TransactionId</name></type> <name>cxid</name> <init>= <expr><name><name>proc</name><operator>-&gt;</operator><name>subxids</name><operator>.</operator><name>xids</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                                    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxip</name><index>[<expr><name>subprecount</name></expr>]</index></name> <operator>=</operator> <name>cxid</name></expr>;</expr_stmt>
                                    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxip_ts</name><index>[<expr><name>subprecount</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>prepare_ts</name></expr>;</expr_stmt>
                                </block_content>}</block></for>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                
            </block_content>}</block></if></if_stmt>
<label><name>prepare_finished</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>        


            <comment type="block">/*
             * Backend is doing logical decoding which manages xmin
             * separately, check below.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>pgxact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>&amp;</operator> <name>PROC_IN_LOGICAL_DECODING</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/* Ignore procs running LAZY VACUUM */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>pgxact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>&amp;</operator> <name>PROC_IN_VACUUM</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/* Update globalxmin to be the smallest valid xmin */</comment>
            <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt> <comment type="block">/* fetch just once */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <call><name>NormalTransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>globalxmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>globalxmin</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Fetch xid just once - see GetNewTransactionId */</comment>
            <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

            <comment type="block">/*
             * If the transaction has no XID assigned, we can skip it; it
             * won't have sub-XIDs either.  If the XID is &gt;= xmax, we can also
             * skip it; such transactions will be treated as running anyway
             * (and any sub-XIDs will also be &gt;= xmax).
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call>
                <operator>||</operator> <operator>!</operator><call><name>NormalTransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/*
             * We don't include our own XIDs (if any) in the snapshot, but we
             * must include them in xmin.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>NormalTransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>xmin</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>pgxact</name> <operator>==</operator> <name>MyPgXact</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/* Add XID to snapshot. */</comment>
            <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name>count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Save subtransaction XIDs if possible (if we've already
             * overflowed, there's no point).  Note that the subxact XIDs must
             * be later than their parent, so no need to check them against
             * xmin.  We could filter against xmax, but it seems better not to
             * do that much work while holding the ProcArrayLock.
             *
             * The other backend can add more subxids concurrently, but cannot
             * remove any.  Hence it's important to fetch nxids just once.
             * Should be safe to use memcpy, though.  (We needn't worry about
             * missing any xids added concurrently, because they must postdate
             * xmax.)
             *
             * Again, our own XIDs are not included in the snapshot.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>suboverflowed</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>pgxact</name><operator>-&gt;</operator><name>overflowed</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>suboverflowed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type>            <name>nxids</name> <init>= <expr><name><name>pgxact</name><operator>-&gt;</operator><name>nxids</name></name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>nxids</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxip</name></name> <operator>+</operator> <name>subcount</name></expr></argument>,
                               <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>proc</name><operator>-&gt;</operator><name>subxids</name><operator>.</operator><name>xids</name></name></expr></argument>,
                               <argument><expr><name>nxids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>subcount</name> <operator>+=</operator> <name>nxids</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * We're in hot standby, so get XIDs from KnownAssignedXids.
         *
         * We store all xids directly into subxip[]. Here's why:
         *
         * In recovery we don't know which xids are top-level and which are
         * subxacts, a design choice that greatly simplifies xid processing.
         *
         * It seems like we would want to try to put xids into xip[] only, but
         * that is fairly small. We would either need to make that bigger or
         * to increase the rate at which we WAL-log xid assignment; neither is
         * an appealing choice.
         *
         * We could try to store xids into xip[] first and then into subxip[]
         * if there are too many xids. That only works if the snapshot doesn't
         * overflow because we do not search subxip[] in that case. A simpler
         * way is to just store all xids in the subxact array because this is
         * by far the bigger array. We just leave the xip array empty.
         *
         * Either way we need to change the way XidInMVCCSnapshot() works
         * depending upon when the snapshot was taken, or change normal
         * snapshot processing so it matches.
         *
         * Note: It is possible for recovery to end before we finish taking
         * the snapshot, and for newly assigned transaction ids to be added to
         * the ProcArray.  xmax cannot change while we hold ProcArrayLock, so
         * those newly added transaction ids would be filtered away, so we
         * need not be concerned about them.
         */</comment>
        <expr_stmt><expr><name>subcount</name> <operator>=</operator> <call><name>KnownAssignedXidsGetAndSetXmin</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxip</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xmin</name></expr></argument>,
                                                  <argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedesOrEquals</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>, <argument><expr><name><name>procArray</name><operator>-&gt;</operator><name>lastOverflowedXid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>suboverflowed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>


    <comment type="block">/* fetch into volatile var while ProcArrayLock is held */</comment>
    <expr_stmt><expr><name>replication_slot_xmin</name> <operator>=</operator> <name><name>procArray</name><operator>-&gt;</operator><name>replication_slot_xmin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>replication_slot_catalog_xmin</name> <operator>=</operator> <name><name>procArray</name><operator>-&gt;</operator><name>replication_slot_catalog_xmin</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>TransactionXmin</name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>snapshot</name><operator>-&gt;</operator><name>local</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyPgXact</name><operator>-&gt;</operator><name>tmin</name></name></expr></argument>,<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"MyPgXact xid %d tmin "</literal><name>INT64_FORMAT</name> <literal type="string">" start ts "</literal> <name>INT64_FORMAT</name></expr></argument>, 
                        <argument><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyPgXact</name><operator>-&gt;</operator><name>tmin</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Update globalxmin to include actual process xids.  This is a slightly
     * different way of computing it than GetOldestXmin uses, but should give
     * the same result.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>, <argument><expr><name>globalxmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>globalxmin</name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
    <expr_stmt><expr><name>clustermon_xmin</name> <operator>=</operator> <call><name>ClusterMonitorGetGlobalXmin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>clustermon_xmin</name></expr></argument>, <argument><expr><name>globalxmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>globalxmin</name> <operator>=</operator> <name>clustermon_xmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Update global variables too */</comment>
    <expr_stmt><expr><name>RecentGlobalXmin</name> <operator>=</operator> <name>globalxmin</name> <operator>-</operator> <name>vacuum_defer_cleanup_age</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>RecentGlobalXmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>RecentGlobalXmin</name> <operator>=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check whether there's a replication slot requiring an older xmin. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>replication_slot_xmin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>NormalTransactionIdPrecedes</name><argument_list>(<argument><expr><name>replication_slot_xmin</name></expr></argument>, <argument><expr><name>RecentGlobalXmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>RecentGlobalXmin</name> <operator>=</operator> <name>replication_slot_xmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Non-catalog tables can be vacuumed if older than this xid */</comment>
    <expr_stmt><expr><name>RecentGlobalDataXmin</name> <operator>=</operator> <name>RecentGlobalXmin</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Check whether there's a replication slot requiring an older catalog
     * xmin.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>replication_slot_catalog_xmin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>NormalTransactionIdPrecedes</name><argument_list>(<argument><expr><name>replication_slot_catalog_xmin</name></expr></argument>, <argument><expr><name>RecentGlobalXmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>RecentGlobalXmin</name> <operator>=</operator> <name>replication_slot_catalog_xmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>RecentXmin</name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name>xmax</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>=</operator> <name>subcount</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>suboverflowed</name></name> <operator>=</operator> <name>suboverflowed</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>curcid</name></name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xcnt</name></name> <operator>=</operator> <name>precount</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name> <operator>=</operator> <name>subprecount</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>, <argument><expr><name>prepare_xmin</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>prepare_xmin</name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xmin</name></name> <operator>=</operator> <name>prepare_xmin</name></expr>;</expr_stmt>


    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>RecentCommitTs</name> <operator>&lt;</operator> <operator>(</operator><name>vacuum_delta</name> <operator>*</operator> <name>TIMESTAMP_SHIFT</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>RecentCommitTs</name> <operator>=</operator> <name>InvalidGlobalTimestamp</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>RecentCommitTs</name> <operator>=</operator> <name>RecentCommitTs</name> <operator>-</operator> <operator>(</operator><name>vacuum_delta</name> <operator>*</operator> <name>TIMESTAMP_SHIFT</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        
        <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>snapshot</name><operator>-&gt;</operator><name>local</name></name> 
            <operator>&amp;&amp;</operator> <call><name>TestForOldTimestamp</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>, <argument><expr><name>RecentCommitTs</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"start timestamp "</literal> <name>INT64_FORMAT</name> <literal type="string">" is too old to execute, recentCommitTs "</literal> <name>INT64_FORMAT</name></expr></argument> , 
                    <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>, <argument><expr><name>RecentCommitTs</name> <operator>+</operator> <operator>(</operator><name>vacuum_delta</name> <operator>*</operator> <name>TIMESTAMP_SHIFT</name><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    
    <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>snapshot</name><operator>-&gt;</operator><name>local</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>snapshot</name><operator>-&gt;</operator><name>start_ts</name></name> <operator>&lt;</operator> <name>tmin</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>tmin</name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>tmin</name> <operator>&lt;</operator>  <operator>(</operator><name>vacuum_delta</name> <operator>*</operator> <name>TIMESTAMP_SHIFT</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>RecentDataTs</name> <operator>=</operator> <name>InvalidGlobalTimestamp</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>RecentDataTs</name> <operator>=</operator> <name>tmin</name> <operator>-</operator>  <operator>(</operator><name>vacuum_delta</name> <operator>*</operator> <name>TIMESTAMP_SHIFT</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Local snapshot is built, xmin: %d, xmax: %d, xcnt: %d, RecentGlobalXmin: %d"</literal></expr></argument>,
             <argument><expr><name>xmin</name></expr></argument>, <argument><expr><name>xmax</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>globalxmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * This is a new snapshot, so set both refcounts are zero, and mark it as
     * not copied in persistent memory.
     */</comment>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>active_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>regd_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>copied</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>old_snapshot_threshold</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If not using "snapshot too old" feature, fill related fields with
         * dummy values that don't require any locking.
         */</comment>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>whenTaken</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Capture the current time and WAL stream location in case this
         * snapshot becomes old enough to need to fall back on the special
         * "old snapshot" logic.
         */</comment>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>lsn</name></name> <operator>=</operator> <call><name>GetXLogInsertRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>whenTaken</name></name> <operator>=</operator> <call><name>GetSnapshotCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MaintainOldSnapshotTimeMapping</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>whenTaken</name></name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>snapshot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ProcArrayInstallImportedXmin -- install imported xmin into MyPgXact-&gt;xmin
 *
 * This is called when installing a snapshot imported from another
 * transaction.  To ensure that OldestXmin doesn't go backwards, we must
 * check that the source transaction is still running, and we'd better do
 * that atomically with installing the new xmin.
 *
 * Returns TRUE if successful, FALSE if source xact is no longer running.
 */</comment>
<function><type><name>bool</name></type>
<name>ProcArrayInstallImportedXmin</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xmin</name></decl></parameter>,
                             <parameter><decl><type><name>VirtualTransactionId</name> <modifier>*</modifier></type><name>sourcevxid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sourcevxid</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Get lock so source xact can't end while we're doing this */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

        <comment type="block">/* Ignore procs running LAZY VACUUM */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pgxact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>&amp;</operator> <name>PROC_IN_VACUUM</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* We are only interested in the specific virtual transaction. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>backendId</name></name> <operator>!=</operator> <name><name>sourcevxid</name><operator>-&gt;</operator><name>backendId</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>lxid</name></name> <operator>!=</operator> <name><name>sourcevxid</name><operator>-&gt;</operator><name>localTransactionId</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * We check the transaction's database ID for paranoia's sake: if it's
         * in another DB then its xmin does not cover us.  Caller should have
         * detected this already, so we just treat any funny cases as
         * "transaction not found".
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>!=</operator> <name>MyDatabaseId</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Likewise, let's just make real sure its xmin does cover us.
         */</comment>
        <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt>        <comment type="block">/* fetch just once */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <operator>!</operator><call><name>TransactionIdPrecedesOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * We're good.  Install the new xmin.  As in GetSnapshotData, set
         * TransactionXmin too.  (Note that because snapmgr.c called
         * GetSnapshotData first, we'll be overwriting a valid xmin here, so
         * we don't check that.)
         */</comment>
        <expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>TransactionXmin</name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ProcArrayInstallRestoredXmin -- install restored xmin into MyPgXact-&gt;xmin
 *
 * This is like ProcArrayInstallImportedXmin, but we have a pointer to the
 * PGPROC of the transaction from which we imported the snapshot, rather than
 * an XID.
 *
 * Returns TRUE if successful, FALSE if source xact is no longer running.
 */</comment>
<function><type><name>bool</name></type>
<name>ProcArrayInstallRestoredXmin</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xmin</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>proc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get lock so source xact can't end while we're doing this */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pgxact</name> <operator>=</operator> <operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Be certain that the referenced PGPROC has an advertised xmin which is
     * no later than the one we're installing, so that the system-wide xmin
     * can't go backwards.  Also, make sure it's running in the same database,
     * so that the per-database xmin cannot go backwards.
     */</comment>
    <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt>            <comment type="block">/* fetch just once */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>==</operator> <name>MyDatabaseId</name> <operator>&amp;&amp;</operator>
        <call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>TransactionIdPrecedesOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>TransactionXmin</name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetRunningTransactionData -- returns information about running transactions.
 *
 * Similar to GetSnapshotData but returns more information. We include
 * all PGXACTs with an assigned TransactionId, even VACUUM processes and
 * prepared transactions.
 *
 * We acquire XidGenLock and ProcArrayLock, but the caller is responsible for
 * releasing them. Acquiring XidGenLock ensures that no new XIDs enter the proc
 * array until the caller has WAL-logged this snapshot, and releases the
 * lock. Acquiring ProcArrayLock ensures that no transactions commit until the
 * lock is released.
 *
 * The returned data structure is statically allocated; caller should not
 * modify it, and must not assume it is valid past the next call.
 *
 * This is never executed during recovery so there is no need to look at
 * KnownAssignedXids.
 *
 * Dummy PGXACTs from prepared transaction are included, meaning that this
 * may return entries with duplicated TransactionId values coming from
 * transaction finishing to prepare.  Nothing is done about duplicated
 * entries here to not hold on ProcArrayLock more than necessary.
 *
 * We don't worry about updating other counters, we want to keep this as
 * simple as possible and leave GetSnapshotData() as the primary code for
 * that bookkeeping.
 *
 * Note that if any transaction has overflowed its cached subtransactions
 * then there is no real need include any subtransactions. That isn't a
 * common enough case to worry about optimising the size of the WAL record,
 * and we may wish to see that data for diagnostic purposes anyway.
 */</comment>
<function><type><name>RunningTransactions</name></type>
<name>GetRunningTransactionData</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* result workspace */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>RunningTransactionsData</name></type> <name>CurrentRunningXactsData</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RunningTransactions</name></type> <name>CurrentRunningXacts</name> <init>= <expr><operator>&amp;</operator><name>CurrentRunningXactsData</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>latestCompletedXid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>oldestRunningXid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>subcount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>suboverflowed</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Allocating space for maxProcs xids is usually overkill; numProcs would
     * be sufficient.  But it seems better to do the malloc while not holding
     * the lock, so we can't look at numProcs.  Likewise, we allocate much
     * more subxip storage than is probably needed.
     *
     * Should only be allocated in bgwriter, since only ever executed during
     * checkpoints.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>xids</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * First call
         */</comment>
        <expr_stmt><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>xids</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator>
            <call><name>malloc</name><argument_list>(<argument><expr><name>TOTAL_MAX_CACHED_SUBXIDS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>xids</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>xids</name> <operator>=</operator> <name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>xids</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>count</name> <operator>=</operator> <name>subcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>suboverflowed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Ensure that no xids enter or leave the procarray while we obtain
     * snapshot.
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>latestCompletedXid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>oldestRunningXid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Spin over procArray collecting all xids
     */</comment>
    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

        <comment type="block">/* Fetch xid just once - see GetNewTransactionId */</comment>
        <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * We don't need to store transactions that don't have a TransactionId
         * yet because they will not show as running on a standby server.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>xids</name><index>[<expr><name>count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>oldestRunningXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>oldestRunningXid</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pgxact</name><operator>-&gt;</operator><name>overflowed</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>suboverflowed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Spin over procArray collecting all subxids, but only if there hasn't
     * been a suboverflow.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>suboverflowed</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>nxids</name></decl>;</decl_stmt>

            <comment type="block">/*
             * Save subtransaction XIDs. Other backends can't add or remove
             * entries while we're holding XidGenLock.
             */</comment>
            <expr_stmt><expr><name>nxids</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>nxids</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>nxids</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xids</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>proc</name><operator>-&gt;</operator><name>subxids</name><operator>.</operator><name>xids</name></name></expr></argument>,
                       <argument><expr><name>nxids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>count</name> <operator>+=</operator> <name>nxids</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>subcount</name> <operator>+=</operator> <name>nxids</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Top-level XID of a transaction is always less than any of
                 * its subxids, so we don't need to check if any of the
                 * subxids are smaller than oldestRunningXid
                 */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * It's important *not* to include the limits set by slots here because
     * snapbuild.c uses oldestRunningXid to manage its xmin horizon. If those
     * were to be included here the initial value could never increase because
     * of a circular dependency where slots only increase their limits when
     * running xacts increases oldestRunningXid and running xacts only
     * increases if slots do.
     */</comment>

    <expr_stmt><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>=</operator> <name>count</name> <operator>-</operator> <name>subcount</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>=</operator> <name>subcount</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>subxid_overflow</name></name> <operator>=</operator> <name>suboverflowed</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>nextXid</name></name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>oldestRunningXid</name></name> <operator>=</operator> <name>oldestRunningXid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>latestCompletedXid</name></name> <operator>=</operator> <name>latestCompletedXid</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>oldestRunningXid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We don't release the locks here, the caller is responsible for that */</comment>

    <return>return <expr><name>CurrentRunningXacts</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetOldestActiveTransactionId()
 *
 * Similar to GetSnapshotData but returns just oldestActiveXid. We include
 * all PGXACTs with an assigned TransactionId, even VACUUM processes.
 * We look at all databases, though there is no need to include WALSender
 * since this has no effect on hot standby conflicts.
 *
 * This is never executed during recovery so there is no need to look at
 * KnownAssignedXids.
 *
 * We don't worry about updating other counters, we want to keep this as
 * simple as possible and leave GetSnapshotData() as the primary code for
 * that bookkeeping.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>GetOldestActiveTransactionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>oldestRunningXid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Read nextXid, as the upper bound of what's still active.
     *
     * Reading a TransactionId is atomic, but we must grab the lock to make
     * sure that all XIDs &lt; nextXid are already present in the proc array (or
     * have already completed), when we spin over it.
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldestRunningXid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Spin over procArray collecting all xids and subxids.
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

        <comment type="block">/* Fetch xid just once - see GetNewTransactionId */</comment>
        <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>oldestRunningXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>oldestRunningXid</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Top-level XID of a transaction is always less than any of its
         * subxids, so we don't need to check if any of the subxids are
         * smaller than oldestRunningXid
         */</comment>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>oldestRunningXid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetOldestSafeDecodingTransactionId -- lowest xid not affected by vacuum
 *
 * Returns the oldest xid that we can guarantee not to have been affected by
 * vacuum, i.e. no rows &gt;= that xid have been vacuumed away unless the
 * transaction aborted. Note that the value can (and most of the time will) be
 * much more conservative than what really has been affected by vacuum, but we
 * currently don't have better data available.
 *
 * This is useful to initialize the cutoff xid after which a new changeset
 * extraction replication slot can start decoding changes.
 *
 * Must be called with ProcArrayLock held either shared or exclusively,
 * although most callers will want to use exclusive mode since it is expected
 * that the caller will immediately use the xid to peg the xmin horizon.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>GetOldestSafeDecodingTransactionId</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>catalogOnly</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>oldestSafeXid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>recovery_in_progress</name> <init>= <expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Acquire XidGenLock, so no transactions can acquire an xid while we're
     * running. If no transaction with xid were running concurrently a new xid
     * could influence the RecentXmin et al.
     *
     * We initialize the computation to nextXid since that's guaranteed to be
     * a safe, albeit pessimal, value.
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldestSafeXid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * If there's already a slot pegging the xmin horizon, we can start with
     * that value, it's guaranteed to be safe since it's computed by this
     * routine initially and has been enforced since.  We can always use the
     * slot's general xmin horizon, but the catalog horizon is only usable
     * when we only catalog data is going to be looked at.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>procArray</name><operator>-&gt;</operator><name>replication_slot_xmin</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>procArray</name><operator>-&gt;</operator><name>replication_slot_xmin</name></name></expr></argument>,
                              <argument><expr><name>oldestSafeXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>oldestSafeXid</name> <operator>=</operator> <name><name>procArray</name><operator>-&gt;</operator><name>replication_slot_xmin</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>catalogOnly</name> <operator>&amp;&amp;</operator>
        <call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>procArray</name><operator>-&gt;</operator><name>replication_slot_catalog_xmin</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>procArray</name><operator>-&gt;</operator><name>replication_slot_catalog_xmin</name></name></expr></argument>,
                              <argument><expr><name>oldestSafeXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>oldestSafeXid</name> <operator>=</operator> <name><name>procArray</name><operator>-&gt;</operator><name>replication_slot_catalog_xmin</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If we're not in recovery, we walk over the procarray and collect the
     * lowest xid. Since we're called with ProcArrayLock held and have
     * acquired XidGenLock, no entries can vanish concurrently, since
     * PGXACT-&gt;xid is only set with XidGenLock held and only cleared with
     * ProcArrayLock held.
     *
     * In recovery we can't lower the safe value besides what we've computed
     * above, so we'll have to wait a bit longer there. We unfortunately can
     * *not* use KnownAssignedXidsGetOldestXmin() since the KnownAssignedXids
     * machinery can miss values and return an older value than is safe.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>recovery_in_progress</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Spin over procArray collecting all min(PGXACT-&gt;xid)
         */</comment>
        <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

            <comment type="block">/* Fetch xid just once - see GetNewTransactionId */</comment>
            <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>oldestSafeXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oldestSafeXid</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>oldestSafeXid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetVirtualXIDsDelayingChkpt -- Get the VXIDs of transactions that are
 * delaying checkpoint because they have critical actions in progress.
 *
 * Constructs an array of VXIDs of transactions that are currently in commit
 * critical sections, as shown by having delayChkpt set in their PGXACT.
 *
 * Returns a palloc'd array that should be freed by the caller.
 * *nvxids is the number of valid entries.
 *
 * Note that because backends set or clear delayChkpt without holding any lock,
 * the result is somewhat indeterminate, but we don't really care.  Even in
 * a multiprocessor with delayed writes to shared memory, it should be certain
 * that setting of delayChkpt will propagate to shared memory when the backend
 * takes a lock, so we cannot fail to see a virtual xact as delayChkpt if
 * it's already inserted its commit record.  Whether it takes a little while
 * for clearing of delayChkpt to propagate is unimportant for correctness.
 */</comment>
<function><type><name>VirtualTransactionId</name> <modifier>*</modifier></type>
<name>GetVirtualXIDsDelayingChkpt</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nvxids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VirtualTransactionId</name> <modifier>*</modifier></type><name>vxids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>

    <comment type="block">/* allocate what's certainly enough result space */</comment>
    <expr_stmt><expr><name>vxids</name> <operator>=</operator> <operator>(</operator><name>VirtualTransactionId</name> <operator>*</operator><operator>)</operator>
        <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VirtualTransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>maxProcs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pgxact</name><operator>-&gt;</operator><name>delayChkpt</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>GET_VXID_FROM_PGPROC</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>, <argument><expr><operator>*</operator><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>VirtualTransactionIdIsValid</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>vxids</name><index>[<expr><name>count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>vxid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>nvxids</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
    <return>return <expr><name>vxids</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * HaveVirtualXIDsDelayingChkpt -- Are any of the specified VXIDs delaying?
 *
 * This is used with the results of GetVirtualXIDsDelayingChkpt to see if any
 * of the specified VXIDs are still in critical sections of code.
 *
 * Note: this is O(N^2) in the number of vxacts that are/were delaying, but
 * those numbers should be small enough for it not to be a problem.
 */</comment>
<function><type><name>bool</name></type>
<name>HaveVirtualXIDsDelayingChkpt</name><parameter_list>(<parameter><decl><type><name>VirtualTransactionId</name> <modifier>*</modifier></type><name>vxids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvxids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>GET_VXID_FROM_PGPROC</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>, <argument><expr><operator>*</operator><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pgxact</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>&amp;&amp;</operator> <call><name>VirtualTransactionIdIsValid</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nvxids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>VirtualTransactionIdEquals</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>, <argument><expr><name><name>vxids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * BackendPidGetProc -- get a backend's PGPROC given its PID
 *
 * Returns NULL if not found.  Note that it is up to the caller to be
 * sure that the question remains meaningful for long enough for the
 * answer to be used ...
 */</comment>
<function><type><name>PGPROC</name> <modifier>*</modifier></type>
<name>BackendPidGetProc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGPROC</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>                <comment type="block">/* never match dummy PGPROCs */</comment>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BackendPidGetProcWithLock</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * BackendPidGetProcWithLock -- get a backend's PGPROC given its PID
 *
 * Same as above, except caller must be holding ProcArrayLock.  The found
 * entry, if any, can be assumed to be valid as long as the lock remains held.
 */</comment>
<function><type><name>PGPROC</name> <modifier>*</modifier></type>
<name>BackendPidGetProcWithLock</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGPROC</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>                <comment type="block">/* never match dummy PGPROCs */</comment>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGPROC</name>       <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name>pid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * BackendXidGetPid -- get a backend's pid given its XID
 *
 * Returns 0 if not found or it's a prepared transaction.  Note that
 * it is up to the caller to be sure that the question remains
 * meaningful for long enough for the answer to be used ...
 *
 * Only main transaction Ids are considered.  This function is mainly
 * useful for determining what backend owns a lock.
 *
 * Beware that not every xact has an XID assigned.  However, as long as you
 * only call this using an XID found on disk, you're safe.
 */</comment>
<function><type><name>int</name></type>
<name>BackendXidGetPid</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>xid</name> <operator>==</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* never match invalid xid */</comment>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name> <operator>==</operator> <name>xid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsBackendPid -- is a given pid a running backend
 *
 * This is not called by the backend, but is called by external modules.
 */</comment>
<function><type><name>bool</name></type>
<name>IsBackendPid</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>BackendPidGetProc</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetCurrentVirtualXIDs -- returns an array of currently active VXIDs.
 *
 * The array is palloc'd. The number of valid entries is returned into *nvxids.
 *
 * The arguments allow filtering the set of VXIDs returned.  Our own process
 * is always skipped.  In addition:
 *    If limitXmin is not InvalidTransactionId, skip processes with
 *        xmin &gt; limitXmin.
 *    If excludeXmin0 is true, skip processes with xmin = 0.
 *    If allDbs is false, skip processes attached to other databases.
 *    If excludeVacuum isn't zero, skip processes for which
 *        (vacuumFlags &amp; excludeVacuum) is not zero.
 *
 * Note: the purpose of the limitXmin and excludeXmin0 parameters is to
 * allow skipping backends whose oldest live snapshot is no older than
 * some snapshot we have.  Since we examine the procarray with only shared
 * lock, there are race conditions: a backend could set its xmin just after
 * we look.  Indeed, on multiprocessors with weak memory ordering, the
 * other backend could have set its xmin *before* we look.  We know however
 * that such a backend must have held shared ProcArrayLock overlapping our
 * own hold of ProcArrayLock, else we would see its xmin update.  Therefore,
 * any snapshot the other backend is taking concurrently with our scan cannot
 * consider any transactions as still running that we think are committed
 * (since backends must hold ProcArrayLock exclusive to commit).
 */</comment>
<function><type><name>VirtualTransactionId</name> <modifier>*</modifier></type>
<name>GetCurrentVirtualXIDs</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>limitXmin</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>excludeXmin0</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>allDbs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>excludeVacuum</name></decl></parameter>,
                      <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nvxids</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>VirtualTransactionId</name> <modifier>*</modifier></type><name>vxids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>

    <comment type="block">/* allocate what's certainly enough result space */</comment>
    <expr_stmt><expr><name>vxids</name> <operator>=</operator> <operator>(</operator><name>VirtualTransactionId</name> <operator>*</operator><operator>)</operator>
        <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VirtualTransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>maxProcs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>proc</name> <operator>==</operator> <name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>excludeVacuum</name> <operator>&amp;</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>vacuumFlags</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>allDbs</name> <operator>||</operator> <name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>==</operator> <name>MyDatabaseId</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Fetch xmin just once - might change on us */</comment>
            <decl_stmt><decl><type><name>TransactionId</name></type> <name>pxmin</name> <init>= <expr><name><name>pgxact</name><operator>-&gt;</operator><name>xmin</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>excludeXmin0</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>pxmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/*
             * InvalidTransactionId precedes all other XIDs, so a proc that
             * hasn't set xmin yet will not be rejected by this test.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>limitXmin</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <call><name>TransactionIdPrecedesOrEquals</name><argument_list>(<argument><expr><name>pxmin</name></expr></argument>, <argument><expr><name>limitXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>GET_VXID_FROM_PGPROC</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>, <argument><expr><operator>*</operator><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>VirtualTransactionIdIsValid</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>vxids</name><index>[<expr><name>count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>vxid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>nvxids</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
    <return>return <expr><name>vxids</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetConflictingVirtualXIDs -- returns an array of currently active VXIDs.
 *
 * Usage is limited to conflict resolution during recovery on standby servers.
 * limitXmin is supplied as either latestRemovedXid, or InvalidTransactionId
 * in cases where we cannot accurately determine a value for latestRemovedXid.
 *
 * If limitXmin is InvalidTransactionId then we want to kill everybody,
 * so we're not worried if they have a snapshot or not, nor does it really
 * matter what type of lock we hold.
 *
 * All callers that are checking xmins always now supply a valid and useful
 * value for limitXmin. The limitXmin is always lower than the lowest
 * numbered KnownAssignedXid that is not already a FATAL error. This is
 * because we only care about cleanup records that are cleaning up tuple
 * versions from committed transactions. In that case they will only occur
 * at the point where the record is less than the lowest running xid. That
 * allows us to say that if any backend takes a snapshot concurrently with
 * us then the conflict assessment made here would never include the snapshot
 * that is being derived. So we take LW_SHARED on the ProcArray and allow
 * concurrent snapshots when limitXmin is valid. We might think about adding
 *     Assert(limitXmin &lt; lowest(KnownAssignedXids))
 * but that would not be true in the case of FATAL errors lagging in array,
 * but we already know those are bogus anyway, so we skip that test.
 *
 * If dbOid is valid we skip backends attached to other databases.
 *
 * Be careful to *not* pfree the result from this function. We reuse
 * this array sufficiently often that we use malloc for the result.
 */</comment>
<function><type><name>VirtualTransactionId</name> <modifier>*</modifier></type>
<name>GetConflictingVirtualXIDs</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>limitXmin</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>dbOid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>VirtualTransactionId</name> <modifier>*</modifier></type><name>vxids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If first time through, get workspace to remember main XIDs in. We
     * malloc it permanently to avoid repeated palloc/pfree overhead. Allow
     * result space, remembering room for a terminator.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>vxids</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>vxids</name> <operator>=</operator> <operator>(</operator><name>VirtualTransactionId</name> <operator>*</operator><operator>)</operator>
            <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VirtualTransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>arrayP</name><operator>-&gt;</operator><name>maxProcs</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>vxids</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Exclude prepared transactions */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>dbOid</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>==</operator> <name>dbOid</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Fetch xmin just once - can't change on us, but good coding */</comment>
            <decl_stmt><decl><type><name>TransactionId</name></type> <name>pxmin</name> <init>= <expr><name><name>pgxact</name><operator>-&gt;</operator><name>xmin</name></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * We ignore an invalid pxmin because this means that backend has
             * no snapshot currently. We hold a Share lock to avoid contention
             * with users taking snapshots.  That is not a problem because the
             * current xmin is always at least one higher than the latest
             * removed xid, so any new snapshot would never conflict with the
             * test here.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>limitXmin</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <operator>(</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>pxmin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>pxmin</name></expr></argument>, <argument><expr><name>limitXmin</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>GET_VXID_FROM_PGPROC</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>, <argument><expr><operator>*</operator><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>VirtualTransactionIdIsValid</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>vxids</name><index>[<expr><name>count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>vxid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* add the terminator */</comment>
    <expr_stmt><expr><name><name>vxids</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>backendId</name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vxids</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>localTransactionId</name> <operator>=</operator> <name>InvalidLocalTransactionId</name></expr>;</expr_stmt>

    <return>return <expr><name>vxids</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CancelVirtualTransaction - used in recovery conflict processing
 *
 * Returns pid of the process signaled, or 0 if not found.
 */</comment>
<function><type><name>pid_t</name></type>
<name>CancelVirtualTransaction</name><parameter_list>(<parameter><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl></parameter>, <parameter><decl><type><name>ProcSignalReason</name></type> <name>sigmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pid_t</name></type>        <name>pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>VirtualTransactionId</name></type> <name>procvxid</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>GET_VXID_FROM_PGPROC</name><argument_list>(<argument><expr><name>procvxid</name></expr></argument>, <argument><expr><operator>*</operator><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>procvxid</name><operator>.</operator><name>backendId</name></name> <operator>==</operator> <name><name>vxid</name><operator>.</operator><name>backendId</name></name> <operator>&amp;&amp;</operator>
            <name><name>procvxid</name><operator>.</operator><name>localTransactionId</name></name> <operator>==</operator> <name><name>vxid</name><operator>.</operator><name>localTransactionId</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>recoveryConflictPending</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pid</name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>pid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Kill the pid if it's still here. If not, that's what we
                 * wanted so ignore any errors.
                 */</comment>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>SendProcSignal</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>sigmode</name></expr></argument>, <argument><expr><name><name>vxid</name><operator>.</operator><name>backendId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MinimumActiveBackends --- count backends (other than myself) that are
 *        in active transactions.  Return true if the count exceeds the
 *        minimum threshold passed.  This is used as a heuristic to decide if
 *        a pre-XLOG-flush delay is worthwhile during commit.
 *
 * Do not count backends that are blocked waiting for locks, since they are
 * not going to get to run until someone else commits.
 */</comment>
<function><type><name>bool</name></type>
<name>MinimumActiveBackends</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>min</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>

    <comment type="block">/* Quick short-circuit if no minimum is specified */</comment>
    <if_stmt><if>if <condition>(<expr><name>min</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Note: for speed, we don't acquire ProcArrayLock.  This is a little bit
     * bogus, but since we are only testing fields for zero or nonzero, it
     * should be OK.  The result is only used for heuristic purposes anyway...
     */</comment>
    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Since we're not holding a lock, need to be prepared to deal with
         * garbage, as someone could have incremented numProcs but not yet
         * filled the structure.
         *
         * If someone just decremented numProcs, 'proc' could also point to a
         * PGPROC entry that's no longer in the array. It still points to a
         * PGPROC struct, though, because freed PGPROC entries just go to the
         * free list and are recycled. Its contents are nonsense in that case,
         * but that's acceptable for this function.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>pgprocno</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* do not count deleted entries */</comment>
        <if_stmt><if>if <condition>(<expr><name>proc</name> <operator>==</operator> <name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* do not count myself */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name> <operator>==</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* do not count if no XID assigned */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* do not count prepared xacts */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>waitLock</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* do not count if blocked on a lock */</comment>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;=</operator> <name>min</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>count</name> <operator>&gt;=</operator> <name>min</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CountDBBackends --- count backends that are using specified database
 */</comment>
<function><type><name>int</name></type>
<name>CountDBBackends</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* do not count prepared xacts */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>databaseid</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>==</operator> <name>databaseid</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CountDBConnections --- counts database backends ignoring any background
 *        worker processes
 */</comment>
<function><type><name>int</name></type>
<name>CountDBConnections</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* do not count prepared xacts */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>isBackgroundWorker</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* do not count background workers */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>databaseid</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>==</operator> <name>databaseid</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CancelDBBackends --- cancel backends that are using specified database
 */</comment>
<function><type><name>void</name></type>
<name>CancelDBBackends</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>, <parameter><decl><type><name>ProcSignalReason</name></type> <name>sigmode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>conflictPending</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pid_t</name></type>        <name>pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* tell all backends to die */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>databaseid</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator> <name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>==</operator> <name>databaseid</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>VirtualTransactionId</name></type> <name>procvxid</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>GET_VXID_FROM_PGPROC</name><argument_list>(<argument><expr><name>procvxid</name></expr></argument>, <argument><expr><operator>*</operator><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>recoveryConflictPending</name></name> <operator>=</operator> <name>conflictPending</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pid</name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>pid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Kill the pid if it's still here. If not, that's what we
                 * wanted so ignore any errors.
                 */</comment>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>SendProcSignal</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>sigmode</name></expr></argument>, <argument><expr><name><name>procvxid</name><operator>.</operator><name>backendId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CountUserBackends --- count backends that are used by specified user
 */</comment>
<function><type><name>int</name></type>
<name>CountUserBackends</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* do not count prepared xacts */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>isBackgroundWorker</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* do not count background workers */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>roleId</name></name> <operator>==</operator> <name>roleid</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CountOtherDBBackends -- check for other backends running in the given DB
 *
 * If there are other backends in the DB, we will wait a maximum of 5 seconds
 * for them to exit.  Autovacuum backends are encouraged to exit early by
 * sending them SIGTERM, but normal user backends are just waited for.
 *
 * The current backend is always ignored; it is caller's responsibility to
 * check whether the current backend uses the given DB, if it's important.
 *
 * Returns TRUE if there are (still) other backends in the DB, FALSE if not.
 * Also, *nbackends and *nprepared are set to the number of other backends
 * and prepared transactions in the DB, respectively.
 *
 * This function is used to interlock DROP DATABASE and related commands
 * against there being any active backends in the target DB --- dropping the
 * DB while active backends remain would be a Bad Thing.  Note that we cannot
 * detect here the possibility of a newly-started backend that is trying to
 * connect to the doomed database, so additional interlocking is needed during
 * backend startup.  The caller should normally hold an exclusive lock on the
 * target DB before calling this, which is one reason we mustn't wait
 * indefinitely.
 */</comment>
<function><type><name>bool</name></type>
<name>CountOtherDBBackends</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseId</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nbackends</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nprepared</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXAUTOVACPIDS</name></cpp:macro>    <cpp:value>10</cpp:value></cpp:define>        <comment type="block">/* max autovacs to SIGTERM per iteration */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name><name>autovac_pids</name><index>[<expr><name>MAXAUTOVACPIDS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>tries</name></decl>;</decl_stmt>

    <comment type="block">/* 50 tries with 100ms sleep between tries makes 5 sec total wait */</comment>
    <for>for <control>(<init><expr><name>tries</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>tries</name> <operator>&lt;</operator> <literal type="number">50</literal></expr>;</condition> <incr><expr><name>tries</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>nautovacs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>nbackends</name> <operator>=</operator> <operator>*</operator><name>nprepared</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>!=</operator> <name>databaseId</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>proc</name> <operator>==</operator> <name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
            <comment type="block">/*
             * PGXC pooler just refers to XC-specific catalogs,
             * it does not create any consistency issues.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>isPooler</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>(</operator><operator>*</operator><name>nprepared</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><operator>(</operator><operator>*</operator><name>nbackends</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pgxact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>&amp;</operator> <name>PROC_IS_AUTOVACUUM</name><operator>)</operator> <operator>&amp;&amp;</operator>
                    <name>nautovacs</name> <operator>&lt;</operator> <name>MAXAUTOVACPIDS</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>autovac_pids</name><index>[<expr><name>nautovacs</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* no conflicting backends, so done */</comment>

        <comment type="block">/*
         * Send SIGTERM to any conflicting autovacuums before sleeping. We
         * postpone this step until after the loop because we don't want to
         * hold ProcArrayLock while issuing kill(). We have no idea what might
         * block kill() inside the kernel...
         */</comment>
        <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>nautovacs</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>kill</name><argument_list>(<argument><expr><name><name>autovac_pids</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>    <comment type="block">/* ignore any error */</comment>

        <comment type="block">/* sleep, then try again */</comment>
        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">100</literal> <operator>*</operator> <literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 100ms */</comment>
    </block_content>}</block></for>

    <return>return <expr><name>true</name></expr>;</return>                <comment type="block">/* timed out, still conflicts */</comment>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/*
 * ReloadConnInfoOnBackends -- reload/refresh connection information
 * for all the backends
 *
 * "refresh" is less destructive than "reload"
 */</comment>
<function><type><name>void</name></type>
<name>ReloadConnInfoOnBackends</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>refresh_only</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pid_t</name></type>        <name>pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* tell all backends to reload except this one who already reloaded */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>GET_VXID_FROM_PGPROC</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>, <argument><expr><operator>*</operator><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>proc</name> <operator>==</operator> <name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* do not do that on myself */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>isPooler</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* Pooler cannot do that */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* useless on prepared xacts */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* ignore backends not connected to a database */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pgxact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>&amp;</operator> <name>PROC_IN_VACUUM</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* ignore vacuum processes */</comment>

        <expr_stmt><expr><name>pid</name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
        <comment type="block">/*
         * Send the reload signal if backend still exists
         */</comment>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>SendProcSignal</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><ternary><condition><expr><name>refresh_only</name></expr>?</condition><then>
                      <expr><name>PROCSIG_PGXCPOOL_REFRESH</name></expr></then><else>:<expr><name>PROCSIG_PGXCPOOL_RELOAD</name></expr></else></ternary></expr></argument>,
                      <argument><expr><name><name>vxid</name><operator>.</operator><name>backendId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * ProcArraySetReplicationSlotXmin
 *
 * Install limits to future computations of the xmin horizon to prevent vacuum
 * and HOT pruning from removing affected rows still needed by clients with
 * replicaton slots.
 */</comment>
<function><type><name>void</name></type>
<name>ProcArraySetReplicationSlotXmin</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xmin</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>catalog_xmin</name></decl></parameter>,
                                <parameter><decl><type><name>bool</name></type> <name>already_locked</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>already_locked</name> <operator>||</operator> <call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>already_locked</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>procArray</name><operator>-&gt;</operator><name>replication_slot_xmin</name></name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>procArray</name><operator>-&gt;</operator><name>replication_slot_catalog_xmin</name></name> <operator>=</operator> <name>catalog_xmin</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>already_locked</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcArrayGetReplicationSlotXmin
 *
 * Return the current slot xmin limits. That's useful to be able to remove
 * data that's older than those limits.
 */</comment>
<function><type><name>void</name></type>
<name>ProcArrayGetReplicationSlotXmin</name><parameter_list>(<parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xmin</name></decl></parameter>,
                                <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>catalog_xmin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>xmin</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>xmin</name> <operator>=</operator> <name><name>procArray</name><operator>-&gt;</operator><name>replication_slot_xmin</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>catalog_xmin</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>catalog_xmin</name> <operator>=</operator> <name><name>procArray</name><operator>-&gt;</operator><name>replication_slot_catalog_xmin</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XidCacheRemove</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        MyProc-&gt;subxids.xids[i] = MyProc-&gt;subxids.xids[MyPgXact-&gt;nxids - 1]; \
        MyPgXact-&gt;nxids--; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/*
 * XidCacheRemoveRunningXids
 *
 * Remove a bunch of TransactionIds from the list of known-running
 * subtransactions for my backend.  Both the specified xid and those in
 * the xids[] array (of length nxids) are removed from the subxids cache.
 * latestXid must be the latest XID among the group.
 */</comment>
<function><type><name>void</name></type>
<name>XidCacheRemoveRunningXids</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
                          <parameter><decl><type><name>int</name></type> <name>nxids</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TransactionId</name> <modifier>*</modifier></type><name>xids</name></decl></parameter>,
                          <parameter><decl><type><name>TransactionId</name></type> <name>latestXid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We must hold ProcArrayLock exclusively in order to remove transactions
     * from the PGPROC array.  (See src/backend/access/transam/README.)  It's
     * possible this could be relaxed since we know this routine is only used
     * to abort subtransactions, but pending closer analysis we'd best be
     * conservative.
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Under normal circumstances xid and xids[] will be in increasing order,
     * as will be the entries in subxids.  Scan backwards to avoid O(N^2)
     * behavior when removing a lot of xids.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>nxids</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>anxid</name> <init>= <expr><name><name>xids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>MyPgXact</name><operator>-&gt;</operator><name>nxids</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>subxids</name><operator>.</operator><name>xids</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>anxid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>XidCacheRemove</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * Ordinarily we should have found it, unless the cache has
         * overflowed. However it's also possible for this routine to be
         * invoked multiple times for the same subtransaction, in case of an
         * error during AbortSubTransaction.  So instead of Assert, emit a
         * debug warning.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>MyPgXact</name><operator>-&gt;</operator><name>overflowed</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"did not find subXID %u in MyProc"</literal></expr></argument>, <argument><expr><name>anxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>MyPgXact</name><operator>-&gt;</operator><name>nxids</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>subxids</name><operator>.</operator><name>xids</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>XidCacheRemove</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <comment type="block">/* Ordinarily we should have found it, unless the cache has overflowed */</comment>
    <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>MyPgXact</name><operator>-&gt;</operator><name>overflowed</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"did not find subXID %u in MyProc"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Also advance global latestCompletedXid while holding the lock */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr></argument>,
                              <argument><expr><name>latestXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name> <operator>=</operator> <name>latestXid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XIDCACHE_DEBUG</name></cpp:ifdef>

<comment type="block">/*
 * Print stats about effectiveness of XID cache
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DisplayXidCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
            <argument><expr><literal type="string">"XidCache: xmin: %ld, known: %ld, myxact: %ld, latest: %ld, mainxid: %ld, childxid: %ld, knownassigned: %ld, nooflo: %ld, slow: %ld\n"</literal></expr></argument>,
            <argument><expr><name>xc_by_recent_xmin</name></expr></argument>,
            <argument><expr><name>xc_by_known_xact</name></expr></argument>,
            <argument><expr><name>xc_by_my_xact</name></expr></argument>,
            <argument><expr><name>xc_by_latest_xid</name></expr></argument>,
            <argument><expr><name>xc_by_main_xid</name></expr></argument>,
            <argument><expr><name>xc_by_child_xid</name></expr></argument>,
            <argument><expr><name>xc_by_known_assigned</name></expr></argument>,
            <argument><expr><name>xc_no_overflow</name></expr></argument>,
            <argument><expr><name>xc_slow_answer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* XIDCACHE_DEBUG */</comment>

<function><type><name>void</name></type>
<name>SetGlobalTimestamp</name><parameter_list>(<parameter><decl><type><name>GlobalTimestamp</name></type> <name>gts</name></decl></parameter>, <parameter><decl><type><name>SnapshotSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>globalSnapshot</name><operator>.</operator><name>snapshot_source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>globalSnapshot</name><operator>.</operator><name>gts</name></name> <operator>=</operator> <name>gts</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name> <argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"set start ts "</literal> <name>INT64_FORMAT</name> <literal type="string">" xid %d"</literal></expr></argument>, <argument><expr><name>gts</name></expr></argument>, <argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
 * Store snapshot data received from the Coordinator
 */</comment>
void
SetGlobalSnapshotData(TransactionId xmin, TransactionId xmax,
        int xcnt, TransactionId *xip, SnapshotSource source)
{
    if (globalSnapshot.max_gxcnt &lt; xcnt)
    {
        globalSnapshot.gxip = (TransactionId *) realloc(globalSnapshot.gxip,
                sizeof (TransactionId) * xcnt);
        if (globalSnapshot.gxip == NULL)
            elog(ERROR, "Out of memory");
        globalSnapshot.max_gxcnt = xcnt;
    }

    globalSnapshot.snapshot_source = source;
    globalSnapshot.gxmin = xmin;
    globalSnapshot.gxmax = xmax;
    globalSnapshot.gxcnt = xcnt;
    memcpy(globalSnapshot.gxip, xip, sizeof (TransactionId) * xcnt);
    elog (DEBUG1, "global snapshot info: gxmin: %d, gxmax: %d, gxcnt: %d", xmin, xmax, xcnt);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * Force Datanode to use local snapshot data
 */</comment>
<function><type><name>void</name></type>
<name>UnsetGlobalSnapshotData</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>globalSnapshot</name><operator>.</operator><name>snapshot_source</name></name> <operator>=</operator> <name>SNAPSHOT_UNDEFINED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>globalSnapshot</name><operator>.</operator><name>gxmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>globalSnapshot</name><operator>.</operator><name>gxmax</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>globalSnapshot</name><operator>.</operator><name>gxcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>globalSnapshot</name><operator>.</operator><name>gts</name></name> <operator>=</operator> <name>InvalidGlobalTimestamp</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name> <argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"unset snapshot info"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>

<comment type="block">/*
 * Entry of snapshot obtention for Postgres-XC node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GetPGXCSnapshotData</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>latest</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
     * If this node is in recovery phase,
     * snapshot has to be taken directly from WAL information.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsInitProcessingMode</name><argument_list>()</argument_list></call> <operator>||</operator> <name>latest</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IsStandbyPostgres</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>latest</name> <operator>&amp;&amp;</operator> <name>query_delay</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* need global snapshot now */</comment>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"local snapshot latest %d IsinitprocessingMode %d xid %u."</literal></expr></argument>, <argument><expr><name>latest</name></expr></argument>, 
                                        <argument><expr><call><name>IsInitProcessingMode</name><argument_list>()</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/*
     * The typical case is that the local Coordinator passes down the snapshot to the
     * remote nodes to use, while it itself obtains it from GTM. Autovacuum processes
     * need however to connect directly to GTM themselves to obtain XID and snapshot
     * information for autovacuum worker threads.
     * A vacuum analyze uses a special function to get a transaction ID and signal
     * GTM not to include this transaction ID in snapshot.
     * A vacuum worker starts as a normal transaction would.
     */</comment>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>IsPostmasterEnvironment</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"local snapshot postmaster %d %d."</literal></expr></argument>, <argument><expr><name>IsPostmasterEnvironment</name></expr></argument>,<argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        </block_content>}</block></if></if_stmt>
        <return>return;</return>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsConnFromDatanode</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>

        <if_stmt><if>if <condition>(<expr><name>SNAPSHOT_COORDINATOR</name> <operator>==</operator> <name><name>globalSnapshot</name><operator>.</operator><name>snapshot_source</name></name></expr>)</condition>
        <block>{<block_content>
            
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"obtain timestamp from coord for snapshot postmaster %d."</literal></expr></argument>, <argument><expr><name>IsPostmasterEnvironment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
            <expr_stmt><expr><call><name>GetGlobalTimestampFromGlobalSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>GetGlobalTimestampFromGTM</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return;</return>
    </block_content>}</block></if>
    <else>else 
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"postmaster gets timestamp from GTM for snapshot latest %d GetForceXidFromGTM() %d IsInitProcessingMode %d"</literal>
                    <literal type="string">" from coord %d."</literal></expr></argument>,
                    <argument><expr><name>latest</name></expr></argument>, <argument><expr><call><name>GetForceXidFromGTM</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>IsInitProcessingMode</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        </block_content>}</block></if></if_stmt>
                    
        <expr_stmt><expr><call><name>GetGlobalTimestampFromGTM</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return;</return>
    </block_content>}</block></else></if_stmt> 

    <return>return;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>GetGlobalTimestampFromGTM</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GlobalTimestamp</name></type> <name>start_ts</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>start_ts</name> <operator>=</operator> <operator>(</operator><name>GlobalTimestamp</name><operator>)</operator> <call><name>GetGlobalTimestampGTM</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>start_ts</name></name> <operator>=</operator> <name>start_ts</name></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GlobalTimestampIsValid</name><argument_list>(<argument><expr><name>start_ts</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GTM error, could not obtain global timestamp. Current XID = %d, Autovac = %d"</literal></expr></argument>, 
                             <argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Get GTM global timestamp "</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>


</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type>
<name>GetGlobalTimestampFromGlobalSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>SNAPSHOT_COORDINATOR</name> <operator>==</operator> <name><name>globalSnapshot</name><operator>.</operator><name>snapshot_source</name></name>  
                <operator>&amp;&amp;</operator> <call><name>GlobalTimestampIsValid</name><argument_list>(<argument><expr><name><name>globalSnapshot</name><operator>.</operator><name>gts</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>start_ts</name></name> <operator>=</operator> <name><name>globalSnapshot</name><operator>.</operator><name>gts</name></name></expr>;</expr_stmt>

        <comment type="block">/* if gts is local, use local snapshot */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>CommitTimestampIsLocal</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Get global timestamp from global "</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not obtain global timestamp for snapshot. Current XID = %d, Autovac = %d"</literal></expr></argument>, 
                             <argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static void
GetSnapshotDataFromGTM(Snapshot snapshot)
{<comment type="line">// #lizard forgives</comment>
    GTM_Snapshot gtm_snapshot;
    GlobalTransactionId reporting_xmin;
    bool canbe_grouped = (!FirstSnapshotSet) || (!IsolationUsesXactSnapshot());
    bool xmin_changed = false;

    <comment type="block">/*
     * We never want to use a snapshot whose xmin is older than the
     * RecentGlobalXmin computed by the GTM. While it does not look likely that
     * that this will ever happen because both these computations happen on the
     * GTM, we are still worried about a race condition where a backend sends a
     * snapshot request, and before snapshot is received, the cluster monitor
     * reports our Xmin (which obviously does not include this snapshot's
     * xmin). Now if GTM processes the snapshot request first, computes
     * snapshot's xmin and then receives our Xmin-report, it may actually moves
     * RecentGlobalXmin beyond snapshot's xmin assuming some transactions
     * finished in between.
     *
     * We try to introduce some interlock between the Xmin reporting and
     * snapshot request. Since we don't want to wait on a lock while Xmin is
     * being reported by the cluster monitor process, we just make sure that
     * the snapshot's xmin is not older than the Xmin we are currently
     * reporting. Given that this is a very rare possibility, we just get a
     * fresh snapshot from the GTM.
     *
     */</comment>
    
    LWLockAcquire(ClusterMonitorLock, LW_SHARED);

retry:
    reporting_xmin = ClusterMonitorGetReportingGlobalXmin();
    
    xmin_changed = false;
    if (TransactionIdIsValid(reporting_xmin) &amp;&amp;
        !TransactionIdIsValid(MyPgXact-&gt;xmin))
    {
        MyPgXact-&gt;xmin = reporting_xmin;
        xmin_changed = true;
    }

    gtm_snapshot = GetSnapshotGTM(GetCurrentTransactionIdIfAny(), canbe_grouped);

    if (!gtm_snapshot)
        ereport(ERROR,
                (errcode(ERRCODE_CONNECTION_FAILURE),
                 errmsg("GTM error, could not obtain snapshot. Current XID = %d, Autovac = %d", GetCurrentTransactionId(), IsAutoVacuumWorkerProcess())));
    else
    {
        if (xmin_changed)
            MyPgXact-&gt;xmin = InvalidTransactionId;
        if (TransactionIdPrecedes(gtm_snapshot-&gt;sn_xmin, reporting_xmin))
            goto retry;

        <comment type="block">/* 
         * Set RecentGlobalXmin by copying from the shared memory state
         * maintained by the Clutser Monitor
         */</comment>
        RecentGlobalXmin = ClusterMonitorGetGlobalXmin();
        if (!TransactionIdIsValid(RecentGlobalXmin))
            RecentGlobalXmin = FirstNormalTransactionId;
        <comment type="block">/*
         * XXX Is it ok to set RecentGlobalDataXmin same as RecentGlobalXmin ?
         */</comment>
        RecentGlobalDataXmin = RecentGlobalXmin;
        SetGlobalSnapshotData(gtm_snapshot-&gt;sn_xmin, gtm_snapshot-&gt;sn_xmax,
                gtm_snapshot-&gt;sn_xcnt, gtm_snapshot-&gt;sn_xip, SNAPSHOT_DIRECT);
        GetSnapshotFromGlobalSnapshot(snapshot);
    }
    LWLockRelease(ClusterMonitorLock);
}

static void
GetSnapshotFromGlobalSnapshot(Snapshot snapshot)
{<comment type="line">// #lizard forgives</comment>
    if ((globalSnapshot.snapshot_source == SNAPSHOT_COORDINATOR ||
                globalSnapshot.snapshot_source == SNAPSHOT_DIRECT)
                &amp;&amp; TransactionIdIsValid(globalSnapshot.gxmin))
    {
        TransactionId global_xmin;

        snapshot-&gt;xmin = globalSnapshot.gxmin;
        snapshot-&gt;xmax = globalSnapshot.gxmax;
        snapshot-&gt;xcnt = globalSnapshot.gxcnt;
        <comment type="block">/*
         * Allocating space for maxProcs xids is usually overkill; numProcs would
         * be sufficient.  But it seems better to do the malloc while not holding
         * the lock, so we can't look at numProcs.  Likewise, we allocate much
         * more subxip storage than is probably needed.
         *
         * This does open a possibility for avoiding repeated malloc/free: since
         * maxProcs does not change at runtime, we can simply reuse the previous
         * xip arrays if any.  (This relies on the fact that all callers pass
         * static SnapshotData structs.) */</comment>
        if (snapshot-&gt;xip == NULL)
        {
            ProcArrayStruct *arrayP = procArray;
            <comment type="block">/*
             * First call for this snapshot
             */</comment>
            snapshot-&gt;xip = (TransactionId *)
                malloc(Max(arrayP-&gt;maxProcs, globalSnapshot.gxcnt) * sizeof(TransactionId));
            if (snapshot-&gt;xip == NULL)
                ereport(ERROR,
                        (errcode(ERRCODE_OUT_OF_MEMORY),
                         errmsg("out of memory")));
            snapshot-&gt;max_xcnt = Max(arrayP-&gt;maxProcs, globalSnapshot.gxcnt);

            Assert(snapshot-&gt;subxip == NULL);
            snapshot-&gt;subxip = (TransactionId *)
                malloc(arrayP-&gt;maxProcs * PGPROC_MAX_CACHED_SUBXIDS * sizeof(TransactionId));
            if (snapshot-&gt;subxip == NULL)
                ereport(ERROR,
                        (errcode(ERRCODE_OUT_OF_MEMORY),
                         errmsg("out of memory")));
        }
        else if (snapshot-&gt;max_xcnt &lt; globalSnapshot.gxcnt)
        {
            snapshot-&gt;xip = (TransactionId *)
                realloc(snapshot-&gt;xip, globalSnapshot.gxcnt * sizeof(TransactionId));
            if (snapshot-&gt;xip == NULL)
                ereport(ERROR,
                        (errcode(ERRCODE_OUT_OF_MEMORY),
                         errmsg("out of memory")));
            snapshot-&gt;max_xcnt = globalSnapshot.gxcnt;
        }

        <comment type="block">/* PGXCTODO - set this until we handle subtransactions. */</comment>
        snapshot-&gt;subxcnt = 0;

        <comment type="block">/*
         * This is a new snapshot, so set both refcounts are zero, and mark it
         * as not copied in persistent memory.
         */</comment>
        snapshot-&gt;active_count = 0;
        snapshot-&gt;regd_count = 0;
        snapshot-&gt;copied = false;

        <comment type="block">/*
         * Start of handling for local ANALYZE
         * Make adjustments for any running auto ANALYZE commands
         */</comment>
        LWLockAcquire(ProcArrayLock, LW_SHARED);

        <comment type="block">/*
         * Once we have a SHARED lock on the ProcArrayLock, fetch the
         * GlobalXmin and ensure that the snapshot we are dealing with isn't
         * too old. Since such a snapshot may need to see rows that have
         * already been removed by the server
         *
         * These scenarios are not very likely to happen because the
         * ClusterMonitor will ensure that GlobalXmins are reported to GTM in
         * time and the GlobalXmin on the GTM can't advance past the reported
         * xmins. But in some cases where a node fails to report its GlobalXmin
         * and gets excluded from the list of nodes on GTM, the GlobalXmin will
         * be advanced. Usually such node will shoot itself in the head
         * and rejoin the cluster, but if at all it sends a snapshot to us, we
         * should protect ourselves from using it
         */</comment>
        global_xmin = ClusterMonitorGetGlobalXmin();
        if (!TransactionIdIsValid(global_xmin))
            global_xmin = FirstNormalTransactionId;

        if (TransactionIdPrecedes(globalSnapshot.gxmin, global_xmin))
            elog(ERROR, "Snapshot too old - RecentGlobalXmin (%d) has already "
                    "advanced past the snapshot xmin (%d)",
                    global_xmin, globalSnapshot.gxmin);

        memcpy(snapshot-&gt;xip, globalSnapshot.gxip,
                globalSnapshot.gxcnt * sizeof(TransactionId));
        snapshot-&gt;curcid = GetCurrentCommandId(false);

        if (!TransactionIdIsValid(MyPgXact-&gt;xmin))
            MyPgXact-&gt;xmin = TransactionXmin = globalSnapshot.gxmin;

        RecentXmin = globalSnapshot.gxmin;
        RecentGlobalXmin = global_xmin;

        <comment type="block">/*
         * XXX Is it ok to set RecentGlobalDataXmin same as RecentGlobalXmin ?
         */</comment>
        RecentGlobalDataXmin = RecentGlobalXmin;

        if (!TransactionIdIsValid(MyPgXact-&gt;xmin))
            MyPgXact-&gt;xmin = snapshot-&gt;xmin;

        LWLockRelease(ProcArrayLock);
        <comment type="block">/* End handling of local analyze XID in snapshots */</comment>
    }
    else
        elog(ERROR, "Cannot set snapshot from global snapshot");
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>

<comment type="block">/* ----------------------------------------------
 *        KnownAssignedTransactions sub-module
 * ----------------------------------------------
 */</comment>

<comment type="block">/*
 * In Hot Standby mode, we maintain a list of transactions that are (or were)
 * running in the master at the current point in WAL.  These XIDs must be
 * treated as running by standby transactions, even though they are not in
 * the standby server's PGXACT array.
 *
 * We record all XIDs that we know have been assigned.  That includes all the
 * XIDs seen in WAL records, plus all unobserved XIDs that we can deduce have
 * been assigned.  We can deduce the existence of unobserved XIDs because we
 * know XIDs are assigned in sequence, with no gaps.  The KnownAssignedXids
 * list expands as new XIDs are observed or inferred, and contracts when
 * transaction completion records arrive.
 *
 * During hot standby we do not fret too much about the distinction between
 * top-level XIDs and subtransaction XIDs. We store both together in the
 * KnownAssignedXids list.  In backends, this is copied into snapshots in
 * GetSnapshotData(), taking advantage of the fact that XidInMVCCSnapshot()
 * doesn't care about the distinction either.  Subtransaction XIDs are
 * effectively treated as top-level XIDs and in the typical case pg_subtrans
 * links are *not* maintained (which does not affect visibility).
 *
 * We have room in KnownAssignedXids and in snapshots to hold maxProcs *
 * (1 + PGPROC_MAX_CACHED_SUBXIDS) XIDs, so every master transaction must
 * report its subtransaction XIDs in a WAL XLOG_XACT_ASSIGNMENT record at
 * least every PGPROC_MAX_CACHED_SUBXIDS.  When we receive one of these
 * records, we mark the subXIDs as children of the top XID in pg_subtrans,
 * and then remove them from KnownAssignedXids.  This prevents overflow of
 * KnownAssignedXids and snapshots, at the cost that status checks for these
 * subXIDs will take a slower path through TransactionIdIsInProgress().
 * This means that KnownAssignedXids is not necessarily complete for subXIDs,
 * though it should be complete for top-level XIDs; this is the same situation
 * that holds with respect to the PGPROC entries in normal running.
 *
 * When we throw away subXIDs from KnownAssignedXids, we need to keep track of
 * that, similarly to tracking overflow of a PGPROC's subxids array.  We do
 * that by remembering the lastOverflowedXID, ie the last thrown-away subXID.
 * As long as that is within the range of interesting XIDs, we have to assume
 * that subXIDs are missing from snapshots.  (Note that subXID overflow occurs
 * on primary when 65th subXID arrives, whereas on standby it occurs when 64th
 * subXID arrives - that is not an error.)
 *
 * Should a backend on primary somehow disappear before it can write an abort
 * record, then we just leave those XIDs in KnownAssignedXids. They actually
 * aborted but we think they were running; the distinction is irrelevant
 * because either way any changes done by the transaction are not visible to
 * backends in the standby.  We prune KnownAssignedXids when
 * XLOG_RUNNING_XACTS arrives, to forestall possible overflow of the
 * array due to such dead XIDs.
 */</comment>

<comment type="block">/*
 * RecordKnownAssignedTransactionIds
 *        Record the given XID in KnownAssignedXids, as well as any preceding
 *        unobserved XIDs.
 *
 * RecordKnownAssignedTransactionIds() should be run for *every* WAL record
 * associated with a transaction. Must be called for each record after we
 * have executed StartupCLOG() et al, since we must ExtendCLOG() etc..
 *
 * Called during recovery in analogy with and in place of GetNewTransactionId()
 */</comment>
<function><type><name>void</name></type>
<name>RecordKnownAssignedTransactionIds</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>standbyState</name> <operator>&gt;=</operator> <name>STANDBY_INITIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>latestObservedXid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><call><name>trace_recovery</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"record known xact %u latestObservedXid %u"</literal></expr></argument>,
         <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>latestObservedXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * When a newly observed xid arrives, it is frequently the case that it is
     * *not* the next xid in sequence. When this occurs, we must treat the
     * intervening xids as running also.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>latestObservedXid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>next_expected_xid</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Extend subtrans like we do in GetNewTransactionId() during normal
         * operation using individual extend steps. Note that we do not need
         * to extend clog since its extensions are WAL logged.
         *
         * This part has to be done regardless of standbyState since we
         * immediately start assigning subtransactions to their toplevel
         * transactions.
         */</comment>
        <expr_stmt><expr><name>next_expected_xid</name> <operator>=</operator> <name>latestObservedXid</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>next_expected_xid</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name>next_expected_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtendSUBTRANS</name><argument_list>(<argument><expr><name>next_expected_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>next_expected_xid</name> <operator>==</operator> <name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If the KnownAssignedXids machinery isn't up yet, there's nothing
         * more to do since we don't track assigned xids yet.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>standbyState</name> <operator>&lt;=</operator> <name>STANDBY_INITIALIZED</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>latestObservedXid</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Add (latestObservedXid, xid] onto the KnownAssignedXids array.
         */</comment>
        <expr_stmt><expr><name>next_expected_xid</name> <operator>=</operator> <name>latestObservedXid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name>next_expected_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>KnownAssignedXidsAdd</name><argument_list>(<argument><expr><name>next_expected_xid</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Now we can advance latestObservedXid
         */</comment>
        <expr_stmt><expr><name>latestObservedXid</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>

        <comment type="block">/* ShmemVariableCache-&gt;nextXid must be beyond any observed xid */</comment>
        <expr_stmt><expr><name>next_expected_xid</name> <operator>=</operator> <name>latestObservedXid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name>next_expected_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name> <operator>=</operator> <name>next_expected_xid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExpireTreeKnownAssignedTransactionIds
 *        Remove the given XIDs from KnownAssignedXids.
 *
 * Called during recovery in analogy with and in place of ProcArrayEndTransaction()
 */</comment>
<function><type><name>void</name></type>
<name>ExpireTreeKnownAssignedTransactionIds</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nsubxids</name></decl></parameter>,
                                      <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>subxids</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>max_xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>standbyState</name> <operator>&gt;=</operator> <name>STANDBY_INITIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Uses same locking as transaction commit
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>KnownAssignedXidsRemoveTree</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>nsubxids</name></expr></argument>, <argument><expr><name>subxids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* As in ProcArrayEndTransaction, advance latestCompletedXid */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr></argument>,
                              <argument><expr><name>max_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name> <operator>=</operator> <name>max_xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExpireAllKnownAssignedTransactionIds
 *        Remove all entries in KnownAssignedXids
 */</comment>
<function><type><name>void</name></type>
<name>ExpireAllKnownAssignedTransactionIds</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>KnownAssignedXidsRemovePreceding</name><argument_list>(<argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExpireOldKnownAssignedTransactionIds
 *        Remove KnownAssignedXids entries preceding the given XID
 */</comment>
<function><type><name>void</name></type>
<name>ExpireOldKnownAssignedTransactionIds</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>KnownAssignedXidsRemovePreceding</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Private module functions to manipulate KnownAssignedXids
 *
 * There are 5 main uses of the KnownAssignedXids data structure:
 *
 *    * backends taking snapshots - all valid XIDs need to be copied out
 *    * backends seeking to determine presence of a specific XID
 *    * startup process adding new known-assigned XIDs
 *    * startup process removing specific XIDs as transactions end
 *    * startup process pruning array when special WAL records arrive
 *
 * This data structure is known to be a hot spot during Hot Standby, so we
 * go to some lengths to make these operations as efficient and as concurrent
 * as possible.
 *
 * The XIDs are stored in an array in sorted order --- TransactionIdPrecedes
 * order, to be exact --- to allow binary search for specific XIDs.  Note:
 * in general TransactionIdPrecedes would not provide a total order, but
 * we know that the entries present at any instant should not extend across
 * a large enough fraction of XID space to wrap around (the master would
 * shut down for fear of XID wrap long before that happens).  So it's OK to
 * use TransactionIdPrecedes as a binary-search comparator.
 *
 * It's cheap to maintain the sortedness during insertions, since new known
 * XIDs are always reported in XID order; we just append them at the right.
 *
 * To keep individual deletions cheap, we need to allow gaps in the array.
 * This is implemented by marking array elements as valid or invalid using
 * the parallel boolean array KnownAssignedXidsValid[].  A deletion is done
 * by setting KnownAssignedXidsValid[i] to false, *without* clearing the
 * XID entry itself.  This preserves the property that the XID entries are
 * sorted, so we can do binary searches easily.  Periodically we compress
 * out the unused entries; that's much cheaper than having to compress the
 * array immediately on every deletion.
 *
 * The actually valid items in KnownAssignedXids[] and KnownAssignedXidsValid[]
 * are those with indexes tail &lt;= i &lt; head; items outside this subscript range
 * have unspecified contents.  When head reaches the end of the array, we
 * force compression of unused entries rather than wrapping around, since
 * allowing wraparound would greatly complicate the search logic.  We maintain
 * an explicit tail pointer so that pruning of old XIDs can be done without
 * immediately moving the array contents.  In most cases only a small fraction
 * of the array contains valid entries at any instant.
 *
 * Although only the startup process can ever change the KnownAssignedXids
 * data structure, we still need interlocking so that standby backends will
 * not observe invalid intermediate states.  The convention is that backends
 * must hold shared ProcArrayLock to examine the array.  To remove XIDs from
 * the array, the startup process must hold ProcArrayLock exclusively, for
 * the usual transactional reasons (compare commit/abort of a transaction
 * during normal running).  Compressing unused entries out of the array
 * likewise requires exclusive lock.  To add XIDs to the array, we just insert
 * them into slots to the right of the head pointer and then advance the head
 * pointer.  This wouldn't require any lock at all, except that on machines
 * with weak memory ordering we need to be careful that other processors
 * see the array element changes before they see the head pointer change.
 * We handle this by using a spinlock to protect reads and writes of the
 * head/tail pointers.  (We could dispense with the spinlock if we were to
 * create suitable memory access barrier primitives and use those instead.)
 * The spinlock must be taken to read or write the head/tail pointers unless
 * the caller holds ProcArrayLock exclusively.
 *
 * Algorithmic analysis:
 *
 * If we have a maximum of M slots, with N XIDs currently spread across
 * S elements then we have N &lt;= S &lt;= M always.
 *
 *    * Adding a new XID is O(1) and needs little locking (unless compression
 *        must happen)
 *    * Compressing the array is O(S) and requires exclusive lock
 *    * Removing an XID is O(logS) and requires exclusive lock
 *    * Taking a snapshot is O(S) and requires shared lock
 *    * Checking for an XID is O(logS) and requires shared lock
 *
 * In comparison, using a hash table for KnownAssignedXids would mean that
 * taking snapshots would be O(M). If we can maintain S &lt;&lt; M then the
 * sorted array technique will deliver significantly faster snapshots.
 * If we try to keep S too small then we will spend too much time compressing,
 * so there is an optimal point for any workload mix. We use a heuristic to
 * decide when to compress the array, though trimming also helps reduce
 * frequency of compressing. The heuristic requires us to track the number of
 * currently valid XIDs in the array.
 */</comment>


<comment type="block">/*
 * Compress KnownAssignedXids by shifting valid data down to the start of the
 * array, removing any gaps.
 *
 * A compression step is forced if "force" is true, otherwise we do it
 * only if a heuristic indicates it's a good time to do it.
 *
 * Caller must hold ProcArrayLock in exclusive mode.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>KnownAssignedXidsCompress</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* use volatile pointer to prevent code rearrangement */</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>ProcArrayStruct</name> <modifier>*</modifier></type><name>pArray</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>head</name></decl>,
                <decl><type ref="prev"/><name>tail</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>compress_index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* no spinlock required since we hold ProcArrayLock exclusively */</comment>
    <expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>pArray</name><operator>-&gt;</operator><name>headKnownAssignedXids</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tail</name> <operator>=</operator> <name><name>pArray</name><operator>-&gt;</operator><name>tailKnownAssignedXids</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If we can choose how much to compress, use a heuristic to avoid
         * compressing too often or not often enough.
         *
         * Heuristic is if we have a large enough current spread and less than
         * 50% of the elements are currently in use, then compress. This
         * should ensure we compress fairly infrequently. We could compress
         * less often though the virtual array would spread out more and
         * snapshots would become more expensive.
         */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>nelements</name> <init>= <expr><name>head</name> <operator>-</operator> <name>tail</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>nelements</name> <operator>&lt;</operator> <literal type="number">4</literal> <operator>*</operator> <name>PROCARRAY_MAXPROCS</name> <operator>||</operator>
            <name>nelements</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>pArray</name><operator>-&gt;</operator><name>numKnownAssignedXids</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We compress the array by reading the valid values from tail to head,
     * re-aligning data to 0th element.
     */</comment>
    <expr_stmt><expr><name>compress_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>tail</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>head</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>KnownAssignedXidsValid</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>KnownAssignedXids</name><index>[<expr><name>compress_index</name></expr>]</index></name> <operator>=</operator> <name><name>KnownAssignedXids</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>KnownAssignedXidsValid</name><index>[<expr><name>compress_index</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>compress_index</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>pArray</name><operator>-&gt;</operator><name>tailKnownAssignedXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pArray</name><operator>-&gt;</operator><name>headKnownAssignedXids</name></name> <operator>=</operator> <name>compress_index</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add xids into KnownAssignedXids at the head of the array.
 *
 * xids from from_xid to to_xid, inclusive, are added to the array.
 *
 * If exclusive_lock is true then caller already holds ProcArrayLock in
 * exclusive mode, so we need no extra locking here.  Else caller holds no
 * lock, so we need to be sure we maintain sufficient interlocks against
 * concurrent readers.  (Only the startup process ever calls this, so no need
 * to worry about concurrent writers.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>KnownAssignedXidsAdd</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>from_xid</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>to_xid</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>exclusive_lock</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* use volatile pointer to prevent code rearrangement */</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>ProcArrayStruct</name> <modifier>*</modifier></type><name>pArray</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>next_xid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>head</name></decl>,
                <decl><type ref="prev"/><name>tail</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nxids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdPrecedesOrEquals</name><argument_list>(<argument><expr><name>from_xid</name></expr></argument>, <argument><expr><name>to_xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Calculate how many array slots we'll need.  Normally this is cheap; in
     * the unusual case where the XIDs cross the wrap point, we do it the hard
     * way.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>to_xid</name> <operator>&gt;=</operator> <name>from_xid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nxids</name> <operator>=</operator> <name>to_xid</name> <operator>-</operator> <name>from_xid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>nxids</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>next_xid</name> <operator>=</operator> <name>from_xid</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>next_xid</name></expr></argument>, <argument><expr><name>to_xid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>nxids</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name>next_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Since only the startup process modifies the head/tail pointers, we
     * don't need a lock to read them here.
     */</comment>
    <expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>pArray</name><operator>-&gt;</operator><name>headKnownAssignedXids</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tail</name> <operator>=</operator> <name><name>pArray</name><operator>-&gt;</operator><name>tailKnownAssignedXids</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>head</name> <operator>&lt;=</operator> <name><name>pArray</name><operator>-&gt;</operator><name>maxKnownAssignedXids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tail</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tail</name> <operator>&lt;</operator> <name><name>pArray</name><operator>-&gt;</operator><name>maxKnownAssignedXids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Verify that insertions occur in TransactionId sequence.  Note that even
     * if the last existing element is marked invalid, it must still have a
     * correctly sequenced XID value.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>head</name> <operator>&gt;</operator> <name>tail</name> <operator>&amp;&amp;</operator>
        <call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name><name>KnownAssignedXids</name><index>[<expr><name>head</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>from_xid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>KnownAssignedXidsDisplay</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"out-of-order XID insertion in KnownAssignedXids"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If our xids won't fit in the remaining space, compress out free space
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>head</name> <operator>+</operator> <name>nxids</name> <operator>&gt;</operator> <name><name>pArray</name><operator>-&gt;</operator><name>maxKnownAssignedXids</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* must hold lock to compress */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>exclusive_lock</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>KnownAssignedXidsCompress</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>pArray</name><operator>-&gt;</operator><name>headKnownAssignedXids</name></name></expr>;</expr_stmt>
        <comment type="block">/* note: we no longer care about the tail pointer */</comment>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>exclusive_lock</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * If it still won't fit then we're out of memory
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>head</name> <operator>+</operator> <name>nxids</name> <operator>&gt;</operator> <name><name>pArray</name><operator>-&gt;</operator><name>maxKnownAssignedXids</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many KnownAssignedXids"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Now we can insert the xids into the space starting at head */</comment>
    <expr_stmt><expr><name>next_xid</name> <operator>=</operator> <name>from_xid</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nxids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>KnownAssignedXids</name><index>[<expr><name>head</name></expr>]</index></name> <operator>=</operator> <name>next_xid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>KnownAssignedXidsValid</name><index>[<expr><name>head</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name>next_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>head</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Adjust count of number of valid entries */</comment>
    <expr_stmt><expr><name><name>pArray</name><operator>-&gt;</operator><name>numKnownAssignedXids</name></name> <operator>+=</operator> <name>nxids</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Now update the head pointer.  We use a spinlock to protect this
     * pointer, not because the update is likely to be non-atomic, but to
     * ensure that other processors see the above array updates before they
     * see the head pointer change.
     *
     * If we're holding ProcArrayLock exclusively, there's no need to take the
     * spinlock.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>exclusive_lock</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pArray</name><operator>-&gt;</operator><name>headKnownAssignedXids</name></name> <operator>=</operator> <name>head</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pArray</name><operator>-&gt;</operator><name>known_assigned_xids_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pArray</name><operator>-&gt;</operator><name>headKnownAssignedXids</name></name> <operator>=</operator> <name>head</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pArray</name><operator>-&gt;</operator><name>known_assigned_xids_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * KnownAssignedXidsSearch
 *
 * Searches KnownAssignedXids for a specific xid and optionally removes it.
 * Returns true if it was found, false if not.
 *
 * Caller must hold ProcArrayLock in shared or exclusive mode.
 * Exclusive lock must be held for remove = true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>KnownAssignedXidsSearch</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>remove</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* use volatile pointer to prevent code rearrangement */</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>ProcArrayStruct</name> <modifier>*</modifier></type><name>pArray</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>first</name></decl>,
                <decl><type ref="prev"/><name>last</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>head</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>tail</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>result_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>remove</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* we hold ProcArrayLock exclusively, so no need for spinlock */</comment>
        <expr_stmt><expr><name>tail</name> <operator>=</operator> <name><name>pArray</name><operator>-&gt;</operator><name>tailKnownAssignedXids</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>pArray</name><operator>-&gt;</operator><name>headKnownAssignedXids</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* take spinlock to ensure we see up-to-date array contents */</comment>
        <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pArray</name><operator>-&gt;</operator><name>known_assigned_xids_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tail</name> <operator>=</operator> <name><name>pArray</name><operator>-&gt;</operator><name>tailKnownAssignedXids</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>pArray</name><operator>-&gt;</operator><name>headKnownAssignedXids</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pArray</name><operator>-&gt;</operator><name>known_assigned_xids_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Standard binary search.  Note we can ignore the KnownAssignedXidsValid
     * array here, since even invalid entries will contain sorted XIDs.
     */</comment>
    <expr_stmt><expr><name>first</name> <operator>=</operator> <name>tail</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>last</name> <operator>=</operator> <name>head</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>first</name> <operator>&lt;=</operator> <name>last</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>mid_index</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>mid_xid</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>mid_index</name> <operator>=</operator> <operator>(</operator><name>first</name> <operator>+</operator> <name>last</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>mid_xid</name> <operator>=</operator> <name><name>KnownAssignedXids</name><index>[<expr><name>mid_index</name></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>xid</name> <operator>==</operator> <name>mid_xid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result_index</name> <operator>=</operator> <name>mid_index</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>mid_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>last</name> <operator>=</operator> <name>mid_index</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>first</name> <operator>=</operator> <name>mid_index</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>result_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* not in array */</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>KnownAssignedXidsValid</name><index>[<expr><name>result_index</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* in array, but invalid */</comment>

    <if_stmt><if>if <condition>(<expr><name>remove</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>KnownAssignedXidsValid</name><index>[<expr><name>result_index</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>pArray</name><operator>-&gt;</operator><name>numKnownAssignedXids</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pArray</name><operator>-&gt;</operator><name>numKnownAssignedXids</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If we're removing the tail element then advance tail pointer over
         * any invalid elements.  This will speed future searches.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>result_index</name> <operator>==</operator> <name>tail</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>tail</name><operator>++</operator></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>tail</name> <operator>&lt;</operator> <name>head</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>KnownAssignedXidsValid</name><index>[<expr><name>tail</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>tail</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
            <if_stmt><if>if <condition>(<expr><name>tail</name> <operator>&gt;=</operator> <name>head</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Array is empty, so we can reset both pointers */</comment>
                <expr_stmt><expr><name><name>pArray</name><operator>-&gt;</operator><name>headKnownAssignedXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pArray</name><operator>-&gt;</operator><name>tailKnownAssignedXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>pArray</name><operator>-&gt;</operator><name>tailKnownAssignedXids</name></name> <operator>=</operator> <name>tail</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Is the specified XID present in KnownAssignedXids[]?
 *
 * Caller must hold ProcArrayLock in shared or exclusive mode.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>KnownAssignedXidExists</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>KnownAssignedXidsSearch</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove the specified XID from KnownAssignedXids[].
 *
 * Caller must hold ProcArrayLock in exclusive mode.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>KnownAssignedXidsRemove</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><call><name>trace_recovery</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"remove KnownAssignedXid %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Note: we cannot consider it an error to remove an XID that's not
     * present.  We intentionally remove subxact IDs while processing
     * XLOG_XACT_ASSIGNMENT, to avoid array overflow.  Then those XIDs will be
     * removed again when the top-level xact commits or aborts.
     *
     * It might be possible to track such XIDs to distinguish this case from
     * actual errors, but it would be complicated and probably not worth it.
     * So, just ignore the search result.
     */</comment>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>KnownAssignedXidsSearch</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * KnownAssignedXidsRemoveTree
 *        Remove xid (if it's not InvalidTransactionId) and all the subxids.
 *
 * Caller must hold ProcArrayLock in exclusive mode.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>KnownAssignedXidsRemoveTree</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nsubxids</name></decl></parameter>,
                            <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>subxids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>KnownAssignedXidsRemove</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsubxids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>KnownAssignedXidsRemove</name><argument_list>(<argument><expr><name><name>subxids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* Opportunistically compress the array */</comment>
    <expr_stmt><expr><call><name>KnownAssignedXidsCompress</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prune KnownAssignedXids up to, but *not* including xid. If xid is invalid
 * then clear the whole table.
 *
 * Caller must hold ProcArrayLock in exclusive mode.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>KnownAssignedXidsRemovePreceding</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>removeXid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* use volatile pointer to prevent code rearrangement */</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>ProcArrayStruct</name> <modifier>*</modifier></type><name>pArray</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>head</name></decl>,
                <decl><type ref="prev"/><name>tail</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>removeXid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><call><name>trace_recovery</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"removing all KnownAssignedXids"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pArray</name><operator>-&gt;</operator><name>numKnownAssignedXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pArray</name><operator>-&gt;</operator><name>headKnownAssignedXids</name></name> <operator>=</operator> <name><name>pArray</name><operator>-&gt;</operator><name>tailKnownAssignedXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><call><name>trace_recovery</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"prune KnownAssignedXids to %u"</literal></expr></argument>, <argument><expr><name>removeXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Mark entries invalid starting at the tail.  Since array is sorted, we
     * can stop as soon as we reach an entry &gt;= removeXid.
     */</comment>
    <expr_stmt><expr><name>tail</name> <operator>=</operator> <name><name>pArray</name><operator>-&gt;</operator><name>tailKnownAssignedXids</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>pArray</name><operator>-&gt;</operator><name>headKnownAssignedXids</name></name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>tail</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>head</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>KnownAssignedXidsValid</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TransactionId</name></type> <name>knownXid</name> <init>= <expr><name><name>KnownAssignedXids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>knownXid</name></expr></argument>, <argument><expr><name>removeXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>StandbyTransactionIdIsPrepared</name><argument_list>(<argument><expr><name>knownXid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>KnownAssignedXidsValid</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>pArray</name><operator>-&gt;</operator><name>numKnownAssignedXids</name></name> <operator>-=</operator> <name>count</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pArray</name><operator>-&gt;</operator><name>numKnownAssignedXids</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Advance the tail pointer if we've marked the tail item invalid.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>tail</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>head</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>KnownAssignedXidsValid</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>head</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Array is empty, so we can reset both pointers */</comment>
        <expr_stmt><expr><name><name>pArray</name><operator>-&gt;</operator><name>headKnownAssignedXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pArray</name><operator>-&gt;</operator><name>tailKnownAssignedXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>pArray</name><operator>-&gt;</operator><name>tailKnownAssignedXids</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Opportunistically compress the array */</comment>
    <expr_stmt><expr><call><name>KnownAssignedXidsCompress</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * KnownAssignedXidsGet - Get an array of xids by scanning KnownAssignedXids.
 * We filter out anything &gt;= xmax.
 *
 * Returns the number of XIDs stored into xarray[].  Caller is responsible
 * that array is large enough.
 *
 * Caller must hold ProcArrayLock in (at least) shared mode.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>KnownAssignedXidsGet</name><parameter_list>(<parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xarray</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xmax</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xtmp</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>KnownAssignedXidsGetAndSetXmin</name><argument_list>(<argument><expr><name>xarray</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xtmp</name></expr></argument>, <argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * KnownAssignedXidsGetAndSetXmin - as KnownAssignedXidsGet, plus
 * we reduce *xmin to the lowest xid value seen if not already lower.
 *
 * Caller must hold ProcArrayLock in (at least) shared mode.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>KnownAssignedXidsGetAndSetXmin</name><parameter_list>(<parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xarray</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xmin</name></decl></parameter>,
                               <parameter><decl><type><name>TransactionId</name></type> <name>xmax</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>head</name></decl>,
                <decl><type ref="prev"/><name>tail</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Fetch head just once, since it may change while we loop. We can stop
     * once we reach the initially seen head, since we are certain that an xid
     * cannot enter and then leave the array while we hold ProcArrayLock.  We
     * might miss newly-added xids, but they should be &gt;= xmax so irrelevant
     * anyway.
     *
     * Must take spinlock to ensure we see up-to-date array contents.
     */</comment>
    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>procArray</name><operator>-&gt;</operator><name>known_assigned_xids_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tail</name> <operator>=</operator> <name><name>procArray</name><operator>-&gt;</operator><name>tailKnownAssignedXids</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>procArray</name><operator>-&gt;</operator><name>headKnownAssignedXids</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>procArray</name><operator>-&gt;</operator><name>known_assigned_xids_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>tail</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>head</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* Skip any gaps in the array */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>KnownAssignedXidsValid</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TransactionId</name></type> <name>knownXid</name> <init>= <expr><name><name>KnownAssignedXids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * Update xmin if required.  Only the first XID need be checked,
             * since the array is sorted.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>knownXid</name></expr></argument>, <argument><expr><operator>*</operator><name>xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>xmin</name> <operator>=</operator> <name>knownXid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Filter out anything &gt;= xmax, again relying on sorted property
             * of array.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>knownXid</name></expr></argument>, <argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <comment type="block">/* Add knownXid into output array */</comment>
            <expr_stmt><expr><name><name>xarray</name><index>[<expr><name>count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>knownXid</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get oldest XID in the KnownAssignedXids array, or InvalidTransactionId
 * if nothing there.
 */</comment>
<function><type><specifier>static</specifier> <name>TransactionId</name></type>
<name>KnownAssignedXidsGetOldestXmin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>head</name></decl>,
                <decl><type ref="prev"/><name>tail</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Fetch head just once, since it may change while we loop.
     */</comment>
    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>procArray</name><operator>-&gt;</operator><name>known_assigned_xids_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tail</name> <operator>=</operator> <name><name>procArray</name><operator>-&gt;</operator><name>tailKnownAssignedXids</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>procArray</name><operator>-&gt;</operator><name>headKnownAssignedXids</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>procArray</name><operator>-&gt;</operator><name>known_assigned_xids_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>tail</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>head</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* Skip any gaps in the array */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>KnownAssignedXidsValid</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name><name>KnownAssignedXids</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>InvalidTransactionId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Display KnownAssignedXids to provide debug trail
 *
 * Currently this is only called within startup process, so we need no
 * special locking.
 *
 * Note this is pretty expensive, and much of the expense will be incurred
 * even if the elog message will get discarded.  It's not currently called
 * in any performance-critical places, however, so no need to be tenser.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>KnownAssignedXidsDisplay</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>trace_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* use volatile pointer to prevent code rearrangement */</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>ProcArrayStruct</name> <modifier>*</modifier></type><name>pArray</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>head</name></decl>,
                <decl><type ref="prev"/><name>tail</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nxids</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>tail</name> <operator>=</operator> <name><name>pArray</name><operator>-&gt;</operator><name>tailKnownAssignedXids</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>pArray</name><operator>-&gt;</operator><name>headKnownAssignedXids</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>tail</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>head</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>KnownAssignedXidsValid</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>nxids</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"[%d]=%u "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>KnownAssignedXids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>trace_level</name></expr></argument>, <argument><expr><literal type="string">"%d KnownAssignedXids (num=%d tail=%d head=%d) %s"</literal></expr></argument>,
         <argument><expr><name>nxids</name></expr></argument>,
         <argument><expr><name><name>pArray</name><operator>-&gt;</operator><name>numKnownAssignedXids</name></name></expr></argument>,
         <argument><expr><name><name>pArray</name><operator>-&gt;</operator><name>tailKnownAssignedXids</name></name></expr></argument>,
         <argument><expr><name><name>pArray</name><operator>-&gt;</operator><name>headKnownAssignedXids</name></name></expr></argument>,
         <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<comment type="block">/*
 * GetGlobalSessionInfo
 *
 * Determine the global session id of the specified backend process
 * Returns coordinator node_id and pid of the initiating coordinator session.
 * If no such backend or global session id is not defined for the backend
 * return zero values.
 */</comment>
<function><type><name>void</name></type>
<name>GetGlobalSessionInfo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>coordId</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>coordPid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>coordId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>coordPid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Scan processes and get from it info about the parent session
     */</comment>
    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name>pid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>coordId</name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>coordId</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>coordPid</name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>coordPid</name></name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetFirstBackendId
 *
 * Determine BackendId of the current process.
 * The caller must hold the ProcArrayLock and the global session id should
 * be defined.
 */</comment>
<function><type><name>int</name></type>
<name>GetFirstBackendId</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numBackends</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>backends</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>                <name>coordId</name> <init>= <expr><name><name>MyProc</name><operator>-&gt;</operator><name>coordId</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>coordPid</name> <init>= <expr><name><name>MyProc</name><operator>-&gt;</operator><name>coordPid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>bCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name><name>bPids</name><index>[<expr><name>MaxBackends</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>index</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>coordId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Scan processes */</comment>
    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Skip MyProc */</comment>
        <if_stmt><if>if <condition>(<expr><name>proc</name> <operator>==</operator> <name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>coordId</name></name> <operator>==</operator> <name>coordId</name> <operator>&amp;&amp;</operator> <name><name>proc</name><operator>-&gt;</operator><name>coordPid</name></name> <operator>==</operator> <name>coordPid</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* BackendId is the same for all backends of the session */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>firstBackendId</name></name> <operator>!=</operator> <name>InvalidBackendId</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name><name>proc</name><operator>-&gt;</operator><name>firstBackendId</name></name></expr>;</return></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>bPids</name><index>[<expr><name>bCount</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>numBackends</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
        <comment type="block">/*
         * This is not the first invocation, to prevent endless loop in case
         * if first backend failed to complete initialization check if all the
         * processes which were intially found are still here, throw error if
         * not.
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>numBackends</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>bCount</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>bPids</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name><name>backends</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to determine BackendId for distributed session"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>numBackends</name> <operator>=</operator> <name>bCount</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>bCount</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>backends</name></expr></argument>, <argument><expr><name>bPids</name></expr></argument>, <argument><expr><name>bCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>InvalidBackendId</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * KnownAssignedXidsReset
 *        Resets KnownAssignedXids to be empty
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>KnownAssignedXidsReset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* use volatile pointer to prevent code rearrangement */</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>ProcArrayStruct</name> <modifier>*</modifier></type><name>pArray</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pArray</name><operator>-&gt;</operator><name>numKnownAssignedXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pArray</name><operator>-&gt;</operator><name>tailKnownAssignedXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pArray</name><operator>-&gt;</operator><name>headKnownAssignedXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Do a consistency check on the running processes. Cluster Monitor uses this
 * API to check if some transaction has started with an xid or xmin lower than
 * the GlobalXmin reported by the GTM. This can only happen under extreme
 * conditions and we must take necessary steps to safe-guard against such
 * anomalies.
 */</comment>
<function><type><name>void</name></type>
<name>ProcArrayCheckXminConsistency</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>global_xmin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>        <comment type="block">/* fetch just once */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>global_xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"xmin consistency check failed - found %d xid in "</literal>
                    <literal type="string">"PGPROC %d ahead of GlobalXmin %d"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>pgprocno</name></expr></argument>,
                    <argument><expr><name>global_xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt>        <comment type="block">/* fetch just once */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>global_xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"xmin consistency check failed - found %d xmin in "</literal>
                    <literal type="string">"PGPROC %d ahead of GlobalXmin %d"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>pgprocno</name></expr></argument>,
                    <argument><expr><name>global_xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SetLatestCompletedXid</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>latestCompletedXid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>latestCompletedXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <comment type="block">/*
     * First extend the commit logs. Even though we may not have actually
     * started any transactions in the new range, we must still extend the logs
     * so that later operations which may try to query them based on the new
     * value of latestCompletedXid do not throw errors
     */</comment>
    <expr_stmt><expr><call><name>ExtendLogs</name><argument_list>(<argument><expr><name>latestCompletedXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>latestCompletedXid</name></expr></argument>,
                <argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name> <operator>=</operator> <name>latestCompletedXid</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/* 
  * get current running transactions 
  * do not include lazy vacuum and itself
  */</comment>
<function><type><name>RunningTransactions</name></type>
<name>GetCurrentRunningTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* result workspace */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>RunningTransactionsData</name></type> <name>CurrentRunningXactsData</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ProcArrayStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>procArray</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RunningTransactions</name></type> <name>CurrentRunningXacts</name> <init>= <expr><operator>&amp;</operator><name>CurrentRunningXactsData</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>latestCompletedXid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>oldestRunningXid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>subcount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>suboverflowed</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Allocating space for maxProcs xids is usually overkill; numProcs would
     * be sufficient.  But it seems better to do the malloc while not holding
     * the lock, so we can't look at numProcs.  Likewise, we allocate much
     * more subxip storage than is probably needed.
     *
     * Should only be allocated in bgwriter, since only ever executed during
     * checkpoints.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>xids</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * First call
         */</comment>
        <expr_stmt><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>xids</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator>
            <call><name>malloc</name><argument_list>(<argument><expr><name>TOTAL_MAX_CACHED_SUBXIDS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>xids</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>xids</name> <operator>=</operator> <name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>xids</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>count</name> <operator>=</operator> <name>subcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>suboverflowed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Ensure that no xids enter or leave the procarray while we obtain
     * snapshot.
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>latestCompletedXid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>oldestRunningXid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Spin over procArray collecting all xids and subxids.
     */</comment>
    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>numProcs</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name> <init>= <expr><name><name>arrayP</name><operator>-&gt;</operator><name>pgprocnos</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>allProcs</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>allPgXact</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>nxids</name></decl>;</decl_stmt>

        <comment type="block">/* Fetch xid just once - see GetNewTransactionId */</comment>
        <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * We don't need to store transactions that don't have a TransactionId
         * yet because they will not show as running on a standby server.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        
        <comment type="block">/* Ignore procs running LAZY VACUUM */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pgxact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>&amp;</operator> <name>PROC_IN_VACUUM</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>    
        
        <if_stmt><if>if <condition>(<expr><name>pgxact</name> <operator>==</operator> <name>MyPgXact</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>


        <expr_stmt><expr><name><name>xids</name><index>[<expr><name>count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>oldestRunningXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>oldestRunningXid</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Save subtransaction XIDs. Other backends can't add or remove
         * entries while we're holding XidGenLock.
         */</comment>
        <expr_stmt><expr><name>nxids</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>nxids</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nxids</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xids</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>proc</name><operator>-&gt;</operator><name>subxids</name><operator>.</operator><name>xids</name></name></expr></argument>,
                   <argument><expr><name>nxids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name> <operator>+=</operator> <name>nxids</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>subcount</name> <operator>+=</operator> <name>nxids</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>pgxact</name><operator>-&gt;</operator><name>overflowed</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>suboverflowed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Top-level XID of a transaction is always less than any of its
             * subxids, so we don't need to check if any of the subxids are
             * smaller than oldestRunningXid
             */</comment>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>subxid_overflow</name></name> <operator>=</operator> <name>suboverflowed</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>nextXid</name></name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>oldestRunningXid</name></name> <operator>=</operator> <name>oldestRunningXid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>latestCompletedXid</name></name> <operator>=</operator> <name>latestCompletedXid</name></expr>;</expr_stmt>

    <comment type="block">/* We don't release XidGenLock here, the caller is responsible for that */</comment>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>oldestRunningXid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>CurrentRunningXacts</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>CurrentRunningXacts</name></expr>;</return>

</block_content>}</block></function>

<comment type="block">/* Get global gts, here we don't take lock, just ensure the 64 bits assign is atomic. */</comment>
<function><type><name>GlobalTimestamp</name></type> <name>GetLatestCommitTS</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GlobalTimestamp</name></type> <name>gts</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>gts</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestGTS</name></name></expr>;</expr_stmt>
    <return>return <expr><name>gts</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
