<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/partitioning/partprune.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * partprune.c
 *		Parses clauses attempting to match them up to partition keys of a
 *		given relation and generates a set of "pruning steps", which can be
 *		later "executed" either from the planner or the executor to determine
 *		the minimum set of partitions which match the given clauses.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *		  src/backend/partitioning/partprune.c
 *
 *-------------------------------------------------------------------------
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opfamily.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/predtest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partprune.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partbounds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Information about a clause matched with a partition key.
 */</comment>
<typedef>typedef <type><struct>struct <name>PartClauseInfo</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>			<comment type="block">/* Partition key number (0 to partnatts - 1)  */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opno</name></decl>;</decl_stmt>			<comment type="block">/* operator used to compare partkey to 'expr' */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>op_is_ne</name></decl>;</decl_stmt>		<comment type="block">/* is clause's original operator &lt;&gt; ? */</comment>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>			<comment type="block">/* expr the partition key is compared to */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>cmpfn</name></decl>;</decl_stmt>			<comment type="block">/* Oid of function to compare 'expr' to the
								 * partition key */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>op_strategy</name></decl>;</decl_stmt>	<comment type="block">/* cached info. */</comment>
}</block></struct></type> <name>PartClauseInfo</name>;</typedef>

<comment type="block">/*
 * PartClauseMatchStatus
 *		Describes the result match_clause_to_partition_key produces for a
 *		given clause and the partition key to match with that are passed to it
 */</comment>
<typedef>typedef <type><enum>enum <name>PartClauseMatchStatus</name>
<block>{
	<decl><name>PARTCLAUSE_NOMATCH</name></decl>,
	<decl><name>PARTCLAUSE_MATCH_CLAUSE</name></decl>,
	<decl><name>PARTCLAUSE_MATCH_NULLNESS</name></decl>,
	<decl><name>PARTCLAUSE_MATCH_STEPS</name></decl>,
	<decl><name>PARTCLAUSE_MATCH_CONTRADICT</name></decl>,
	<decl><name>PARTCLAUSE_UNSUPPORTED</name></decl>
}</block></enum></type> <name>PartClauseMatchStatus</name>;</typedef>

<comment type="block">/*
 * GeneratePruningStepsContext
 *		Information about the current state of generation of "pruning steps"
 *		for a given set of clauses
 *
 * gen_partprune_steps() initializes an instance of this struct, which is used
 * throughout the step generation process.
 */</comment>
<typedef>typedef <type><struct>struct <name>GeneratePruningStepsContext</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>next_step_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>steps</name></decl>;</decl_stmt>
}</block></struct></type> <name>GeneratePruningStepsContext</name>;</typedef>

<comment type="block">/* The result of performing one PartitionPruneStep */</comment>
<typedef>typedef <type><struct>struct <name>PruneStepResult</name>
<block>{
	<comment type="block">/*
	 * The offsets of bounds (in a table's boundinfo) whose partition is
	 * selected by the pruning step.
	 */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>bound_offsets</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>scan_default</name></decl>;</decl_stmt>	<comment type="block">/* Scan the default partition? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>scan_null</name></decl>;</decl_stmt>		<comment type="block">/* Scan the partition for NULL values? */</comment>
}</block></struct></type> <name>PruneStepResult</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>gen_partprune_steps_internal</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>contradictory</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitionPruneStep</name> <modifier>*</modifier></type><name>gen_prune_step_op</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				  <parameter><decl><type><name>StrategyNumber</name></type> <name>opstrategy</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>op_is_ne</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmpfns</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitionPruneStep</name> <modifier>*</modifier></type><name>gen_prune_step_combine</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>source_stepids</name></decl></parameter>,
					   <parameter><decl><type><name>PartitionPruneCombineOp</name></type> <name>combineOp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitionPruneStep</name> <modifier>*</modifier></type><name>gen_prune_steps_from_opexps</name><parameter_list>(<parameter><decl><type><name>PartitionScheme</name></type> <name>part_scheme</name></decl></parameter>,
							<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>keyclauses</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartClauseMatchStatus</name></type> <name>match_clause_to_partition_key</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
							  <parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>partkey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>partkeyidx</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>clause_is_not_null</name></decl></parameter>,
							  <parameter><decl><type><name>PartClauseInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>pc</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>clause_steps</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_steps_using_prefix</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>StrategyNumber</name></type> <name>step_opstrategy</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>step_op_is_ne</name></decl></parameter>,
					   <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>step_lastexpr</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name></type> <name>step_lastcmpfn</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>step_lastkeyno</name></decl></parameter>,
					   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>step_nullkeys</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_steps_using_prefix_recurse</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							   <parameter><decl><type><name>StrategyNumber</name></type> <name>step_opstrategy</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>step_op_is_ne</name></decl></parameter>,
							   <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>step_lastexpr</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>step_lastcmpfn</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>step_lastkeyno</name></decl></parameter>,
							   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>step_nullkeys</name></decl></parameter>,
							   <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>start</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>step_exprs</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>step_cmpfns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type><name>get_matching_hash_bounds</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						 <parameter><decl><type><name>StrategyNumber</name></type> <name>opstrategy</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvalues</name></decl></parameter>,
						 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type><name>get_matching_list_bounds</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						 <parameter><decl><type><name>StrategyNumber</name></type> <name>opstrategy</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvalues</name></decl></parameter>,
						 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type><name>get_matching_range_bounds</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						  <parameter><decl><type><name>StrategyNumber</name></type> <name>opstrategy</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvalues</name></decl></parameter>,
						  <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type><name>perform_pruning_base_step</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						  <parameter><decl><type><name>PartitionPruneStepOp</name> <modifier>*</modifier></type><name>opstep</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type><name>perform_pruning_combine_step</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							 <parameter><decl><type><name>PartitionPruneStepCombine</name> <modifier>*</modifier></type><name>cstep</name></decl></parameter>,
							 <parameter><decl><type><name>PruneStepResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>step_results</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartClauseMatchStatus</name></type> <name>match_boolean_partition_clause</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>partopfamily</name></decl></parameter>,
                                                           <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
                                                           <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>partkey</name></decl></parameter>,
                                                           <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>outconst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>partkey_datum_from_expr</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * gen_partprune_steps
 *		Process 'clauses' (a rel's baserestrictinfo list of clauses) and return
 *		a list of "partition pruning steps"
 *
 * If the clauses in the input list are contradictory or there is a
 * pseudo-constant "false", *contradictory is set to true upon return.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>gen_partprune_steps</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>contradictory</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GeneratePruningStepsContext</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>next_step_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>steps</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* The clauses list may be modified below, so better make a copy. */</comment>
	<expr_stmt><expr><name>clauses</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For sub-partitioned tables there's a corner case where if the
	 * sub-partitioned table shares any partition keys with its parent, then
	 * it's possible that the partitioning hierarchy allows the parent
	 * partition to only contain a narrower range of values than the
	 * sub-partitioned table does.  In this case it is possible that we'd
	 * include partitions that could not possibly have any tuples matching
	 * 'clauses'.  The possibility of such a partition arrangement is perhaps
	 * unlikely for non-default partitions, but it may be more likely in the
	 * case of default partitions, so we'll add the parent partition table's
	 * partition qual to the clause list in this case only.  This may result
	 * in the default partition being eliminated.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>partition_qual</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partqual</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>partition_qual</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>partqual</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>partqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fix Vars to have the desired varno */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>partqual</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>clauses</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>partqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Down into the rabbit-hole. */</comment>
	<expr_stmt><expr><call><name>gen_partprune_steps_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>contradictory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>context</name><operator>.</operator><name>steps</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * prune_append_rel_partitions
 *		Returns RT indexes of the minimum set of child partitions which must
 *		be scanned to satisfy rel's baserestrictinfo quals.
 *
 * Callers must ensure that 'rel' is a partitioned table.
 */</comment>
<function><type><name>Relids</name></type>
<name>prune_append_rel_partitions</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>clauses</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pruning_steps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>contradictory</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionPruneContext</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>partindexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>clauses</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If there are no partitions, return the empty set */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>nparts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Process clauses.  If the clauses are found to be contradictory, we can
	 * return the empty set.
	 */</comment>
	<expr_stmt><expr><name>pruning_steps</name> <operator>=</operator> <call><name>gen_partprune_steps</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>clauses</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>contradictory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>contradictory</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>strategy</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>partnatts</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>partopfamily</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>partopfamily</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>partopcintype</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>partopcintype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>partcollation</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>partcollation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>partsupfunc</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>nparts</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>boundinfo</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>boundinfo</name></name></expr>;</expr_stmt>

	<comment type="block">/* Actual pruning happens here. */</comment>
	<expr_stmt><expr><name>partindexes</name> <operator>=</operator> <call><name>get_matching_partitions</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>pruning_steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add selected partitions' RT indexes to result. */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>partindexes</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>part_rels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_matching_partitions
 *		Determine partitions that survive partition pruning
 *
 * Returns a Bitmapset of indexes of surviving partitions.
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>get_matching_partitions</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pruning_steps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_steps</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>pruning_steps</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PruneStepResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>results</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>final_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>scan_default</name></decl>;</decl_stmt>

	<comment type="block">/* If there are no pruning steps then all partitions match. */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_steps</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>nparts</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Allocate space for individual pruning steps to store its result.  Each
	 * slot will hold a PruneStepResult after performing a given pruning step.
	 * Later steps may use the result of one or more earlier steps.  The
	 * result of applying all pruning steps is the value contained in the slot
	 * of the last pruning step.
	 */</comment>
	<expr_stmt><expr><name>results</name> <operator>=</operator> <operator>(</operator><name>PruneStepResult</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><name>num_steps</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PruneStepResult</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pruning_steps</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_PartitionPruneStepOp</name></expr>:</case>
				<expr_stmt><expr><name><name>results</name><index>[<expr><name><name>step</name><operator>-&gt;</operator><name>step_id</name></name></expr>]</index></name> <operator>=</operator>
					<call><name>perform_pruning_base_step</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>PartitionPruneStepOp</name> <operator>*</operator><operator>)</operator> <name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_PartitionPruneStepCombine</name></expr>:</case>
				<expr_stmt><expr><name><name>results</name><index>[<expr><name><name>step</name><operator>-&gt;</operator><name>step_id</name></name></expr>]</index></name> <operator>=</operator>
					<call><name>perform_pruning_combine_step</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>PartitionPruneStepCombine</name> <operator>*</operator><operator>)</operator> <name>step</name></expr></argument>,
												 <argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid pruning step type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block>

	<comment type="block">/*
	 * At this point we know the offsets of all the datums whose corresponding
	 * partitions need to be in the result, including special null-accepting
	 * and default partitions.  Collect the actual partition indexes now.
	 */</comment>
	<expr_stmt><expr><name>final_result</name> <operator>=</operator> <name><name>results</name><index>[<expr><name>num_steps</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>final_result</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan_default</name> <operator>=</operator> <name><name>final_result</name><operator>-&gt;</operator><name>scan_default</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>final_result</name><operator>-&gt;</operator><name>bound_offsets</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>partindex</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>partindex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In range partitioning cases, if a partition index is -1 it
			 * means that the bound at the offset is the upper bound for a
			 * range not covered by any partition (other than a possible
			 * default partition).  In hash partitioning, the same means no
			 * partition has been defined for the corresponding remainder
			 * value.
			 *
			 * In either case, the value is still part of the queried range of
			 * values, so mark to scan the default partition if one exists.
			 */</comment>
			<expr_stmt><expr><name>scan_default</name> <operator>|=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>partindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Add the null and/or default partition if needed and present. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>final_result</name><operator>-&gt;</operator><name>scan_null</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>null_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>scan_default</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name> <operator>||</operator>
			   <name><name>context</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * gen_partprune_steps_internal
 *		Processes 'clauses' to generate partition pruning steps.
 *
 * From OpExpr clauses that are mutually AND'd, we find combinations of those
 * that match to the partition key columns and for every such combination,
 * we emit a PartitionPruneStepOp containing a vector of expressions whose
 * values are used as a look up key to search partitions by comparing the
 * values with partition bounds.  Relevant details of the operator and a
 * vector of (possibly cross-type) comparison functions is also included with
 * each step.
 *
 * For BoolExpr clauses, we recursively generate steps for each argument, and
 * return a PartitionPruneStepCombine of their results.
 *
 * The return value is a list of the steps generated, which are also added to
 * the context's steps list.  Each step is assigned a step identifier, unique
 * even across recursive calls.
 *
 * If we find clauses that are mutually contradictory, or a pseudoconstant
 * clause that contains false, we set *contradictory to true and return NIL
 * (that is, no pruning steps).  Caller should consider all partitions as
 * pruned in that case.  Otherwise, *contradictory is set to false.
 *
 * Note: the 'clauses' List may be modified inside this function. Callers may
 * like to make a copy of it before passing them to this function.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>gen_partprune_steps_internal</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>contradictory</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionScheme</name></type> <name>part_scheme</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name><name>keyclauses</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>nullkeys</name> <init>= <expr><name>NULL</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>notnullkeys</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>generate_opsteps</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>contradictory</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>keyclauses</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>keyclauses</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>clause</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name> <operator>&amp;&amp;</operator>
				<call><name>IsA</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>contradictory</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<return>return <expr><name>NIL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Get the BoolExpr's out of the way. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Generate steps for arguments.
			 *
			 * While steps generated for the arguments themselves will be
			 * added to context-&gt;steps during recursion and will be evaluated
			 * independently, collect their step IDs to be stored in the
			 * combine step we'll be creating.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>or_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>arg_stepids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>all_args_contradictory</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Get pruning step for each arg.  If we get contradictory for
				 * all args, it means the OR expression is false as a whole.
				 */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>((BoolExpr *) clause)-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>arg_contradictory</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>argsteps</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>argsteps</name> <operator>=</operator>
						<call><name>gen_partprune_steps_internal</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
													 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>arg_contradictory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg_contradictory</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>all_args_contradictory</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>argsteps</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>argsteps</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>step</name> <operator>=</operator> <operator>(</operator><name>PartitionPruneStep</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>argsteps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>arg_stepids</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>arg_stepids</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>step_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * No steps either means that arg_contradictory is
						 * true or the arg didn't contain a clause matching
						 * this partition key.
						 *
						 * In case of the latter, we cannot prune using such
						 * an arg.  To indicate that to the pruning code, we
						 * must construct a dummy PartitionPruneStepCombine
						 * whose source_stepids is set to an empty List.
						 * However, if we can prove using constraint exclusion
						 * that the clause refutes the table's partition
						 * constraint (if it's sub-partitioned), we need not
						 * bother with that.  That is, we effectively ignore
						 * this OR arm.
						 */</comment>
						<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partconstr</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>partition_qual</name></name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>orstep</name></decl>;</decl_stmt>

						<comment type="block">/* Just ignore this argument. */</comment>
						<if_stmt><if>if <condition>(<expr><name>arg_contradictory</name></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><name>partconstr</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>partconstr</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
								<call><name>expression_planner</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>partconstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>partconstr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
											   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<if_stmt><if>if <condition>(<expr><call><name>predicate_refuted_by</name><argument_list>(<argument><expr><name>partconstr</name></expr></argument>,
													 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<continue>continue;</continue></block_content></block></if></if_stmt>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><name>orstep</name> <operator>=</operator> <call><name>gen_prune_step_combine</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
														<argument><expr><name>PARTPRUNE_COMBINE_UNION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>arg_stepids</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>arg_stepids</name></expr></argument>, <argument><expr><name><name>orstep</name><operator>-&gt;</operator><name>step_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block>

				<expr_stmt><expr><operator>*</operator><name>contradictory</name> <operator>=</operator> <name>all_args_contradictory</name></expr>;</expr_stmt>

				<comment type="block">/* Check if any contradicting clauses were found */</comment>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>contradictory</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>arg_stepids</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>gen_prune_step_combine</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>arg_stepids</name></expr></argument>,
												  <argument><expr><name>PARTPRUNE_COMBINE_UNION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>and_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>argsteps</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>arg_stepids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * args may itself contain clauses of arbitrary type, so just
				 * recurse and later combine the component partitions sets
				 * using a combine step.
				 */</comment>
				<expr_stmt><expr><name>argsteps</name> <operator>=</operator> <call><name>gen_partprune_steps_internal</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>args</name></expr></argument>,
														<argument><expr><name>contradictory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>contradictory</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>argsteps</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>arg_stepids</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>arg_stepids</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>step_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<if_stmt><if>if <condition>(<expr><name>arg_stepids</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>gen_prune_step_combine</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>arg_stepids</name></expr></argument>,
												  <argument><expr><name>PARTPRUNE_COMBINE_INTERSECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Fall-through for a NOT clause, which if it's a Boolean clause,
			 * will be handled in match_clause_to_partition_key(). We
			 * currently don't perform any pruning for more complex NOT
			 * clauses.
			 */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Must be a clause for which we can check if one of its args matches
		 * the partition key.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>partkey</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>partexprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>clause_is_not_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>clause_steps</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><call><name>match_clause_to_partition_key</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
												  <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>clause_is_not_null</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>pc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clause_steps</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>PARTCLAUSE_MATCH_CLAUSE</name></expr>:</case>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Since we only allow strict operators, check for any
					 * contradicting IS NULL.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><operator>*</operator><name>contradictory</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<return>return <expr><name>NIL</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>generate_opsteps</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>keyclauses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>keyclauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>PARTCLAUSE_MATCH_NULLNESS</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>clause_is_not_null</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* check for conflicting IS NOT NULL */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>notnullkeys</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><operator>*</operator><name>contradictory</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<return>return <expr><name>NIL</name></expr>;</return>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>nullkeys</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>nullkeys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* check for conflicting IS NULL */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><operator>*</operator><name>contradictory</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<return>return <expr><name>NIL</name></expr>;</return>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>notnullkeys</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>notnullkeys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>

				<case>case <expr><name>PARTCLAUSE_MATCH_STEPS</name></expr>:</case>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>clause_steps</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>clause_steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>PARTCLAUSE_MATCH_CONTRADICT</name></expr>:</case>
					<comment type="block">/* We've nothing more to do if a contradiction was found. */</comment>
					<expr_stmt><expr><operator>*</operator><name>contradictory</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<return>return <expr><name>NIL</name></expr>;</return>

				<case>case <expr><name>PARTCLAUSE_NOMATCH</name></expr>:</case>

					<comment type="block">/*
					 * Clause didn't match this key, but it might match the
					 * next one.
					 */</comment>
					<continue>continue;</continue>

				<case>case <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>:</case>
					<comment type="block">/* This clause cannot be used for pruning. */</comment>
					<break>break;</break>

				<default>default:</default>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>

			<comment type="block">/* done; go check the next clause. */</comment>
			<break>break;</break>
		</block_content>}</block></for>
	</block_content>}</block>

	<comment type="block">/*-----------
	 * Now generate some (more) pruning steps.  We have three strategies:
	 *
	 * 1) Generate pruning steps based on IS NULL clauses:
	 *   a) For list partitioning, null partition keys can only be found in
	 *      the designated null-accepting partition, so if there are IS NULL
	 *      clauses containing partition keys we should generate a pruning
	 *      step that gets rid of all partitions but that one.  We can
	 *      disregard any OpExpr we may have found.
	 *   b) For range partitioning, only the default partition can contain
	 *      NULL values, so the same rationale applies.
	 *   c) For hash partitioning, we only apply this strategy if we have
	 *      IS NULL clauses for all the keys.  Strategy 2 below will take
	 *      care of the case where some keys have OpExprs and others have
	 *      IS NULL clauses.
	 *
	 * 2) If not, generate steps based on OpExprs we have (if any).
	 *
	 * 3) If this doesn't work either, we may be able to generate steps to
	 *    prune just the null-accepting partition (if one exists), if we have
	 *    IS NOT NULL clauses for all partition keys.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name> <operator>||</operator>
		 <name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name> <operator>||</operator>
		 <operator>(</operator><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name> <operator>&amp;&amp;</operator>
		  <call><name>bms_num_members</name><argument_list>(<argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>

		<comment type="block">/* Strategy 1 */</comment>
		<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>gen_prune_step_op</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>InvalidStrategy</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>generate_opsteps</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>

		<comment type="block">/* Strategy 2 */</comment>
		<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>gen_prune_steps_from_opexps</name><argument_list>(<argument><expr><name>part_scheme</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
										   <argument><expr><name>keyclauses</name></expr></argument>, <argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>step</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>notnullkeys</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>

		<comment type="block">/* Strategy 3 */</comment>
		<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>gen_prune_step_op</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>InvalidStrategy</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Finally, results from all entries appearing in result should be
	 * combined using an INTERSECT combine step, if more than one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>step_ids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>result</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>step_ids</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>step_ids</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>step_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>step_ids</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>gen_prune_step_combine</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>step_ids</name></expr></argument>,
										  <argument><expr><name>PARTPRUNE_COMBINE_INTERSECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * gen_prune_step_op
 *		Generate a pruning step for a specific operator
 *
 * The step is assigned a unique step identifier and added to context's 'steps'
 * list.
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionPruneStep</name> <modifier>*</modifier></type>
<name>gen_prune_step_op</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				  <parameter><decl><type><name>StrategyNumber</name></type> <name>opstrategy</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>op_is_ne</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmpfns</name></decl></parameter>,
				  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionPruneStepOp</name> <modifier>*</modifier></type><name>opstep</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionPruneStepOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>opstep</name><operator>-&gt;</operator><name>step</name><operator>.</operator><name>step_id</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>next_step_id</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * For clauses that contain an &lt;&gt; operator, set opstrategy to
	 * InvalidStrategy to signal get_matching_list_bounds to do the right
	 * thing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>op_is_ne</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>opstrategy</name> <operator>==</operator> <name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opstep</name><operator>-&gt;</operator><name>opstrategy</name></name> <operator>=</operator> <name>InvalidStrategy</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>opstep</name><operator>-&gt;</operator><name>opstrategy</name></name> <operator>=</operator> <name>opstrategy</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>cmpfns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opstep</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <name>exprs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opstep</name><operator>-&gt;</operator><name>cmpfns</name></name> <operator>=</operator> <name>cmpfns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opstep</name><operator>-&gt;</operator><name>nullkeys</name></name> <operator>=</operator> <name>nullkeys</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>steps</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>steps</name></name></expr></argument>, <argument><expr><name>opstep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>PartitionPruneStep</name> <operator>*</operator><operator>)</operator> <name>opstep</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * gen_prune_step_combine
 *		Generate a pruning step for a combination of several other steps
 *
 * The step is assigned a unique step identifier and added to context's
 * 'steps' list.
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionPruneStep</name> <modifier>*</modifier></type>
<name>gen_prune_step_combine</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>source_stepids</name></decl></parameter>,
					   <parameter><decl><type><name>PartitionPruneCombineOp</name></type> <name>combineOp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionPruneStepCombine</name> <modifier>*</modifier></type><name>cstep</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionPruneStepCombine</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>cstep</name><operator>-&gt;</operator><name>step</name><operator>.</operator><name>step_id</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>next_step_id</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstep</name><operator>-&gt;</operator><name>combineOp</name></name> <operator>=</operator> <name>combineOp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstep</name><operator>-&gt;</operator><name>source_stepids</name></name> <operator>=</operator> <name>source_stepids</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>steps</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>steps</name></name></expr></argument>, <argument><expr><name>cstep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>PartitionPruneStep</name> <operator>*</operator><operator>)</operator> <name>cstep</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * gen_prune_steps_from_opexps
 *		Generate pruning steps based on clauses for partition keys
 *
 * 'keyclauses' contains one list of clauses per partition key.  We check here
 * if we have found clauses for a valid subset of the partition key. In some
 * cases, (depending on the type of partitioning being used) if we didn't
 * find clauses for a given key, we discard clauses that may have been
 * found for any subsequent keys; see specific notes below.
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionPruneStep</name> <modifier>*</modifier></type>
<name>gen_prune_steps_from_opexps</name><parameter_list>(<parameter><decl><type><name>PartitionScheme</name></type> <name>part_scheme</name></decl></parameter>,
							<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>keyclauses</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opsteps</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name><name>btree_clauses</name><index>[<expr><name>BTMaxStrategyNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name><name>hash_clauses</name><index>[<expr><name>HTMaxStrategyNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>btree_clauses</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>btree_clauses</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>hash_clauses</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_clauses</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>clauselist</name> <init>= <expr><name><name>keyclauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>consider_next_key</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * For range partitioning, if we have no clauses for the current key,
		 * we can't consider any later keys either, so we can stop here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name> <operator>&amp;&amp;</operator>
			<name>clauselist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * For hash partitioning, if a column doesn't have the necessary
		 * equality clause, there should be an IS NULL clause, otherwise
		 * pruning is not possible.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name> <operator>&amp;&amp;</operator>
			<name>clauselist</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>clauselist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><operator>(</operator><name>PartClauseInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>lefttype</name></decl>,
						<decl><type ref="prev"/><name>righttype</name></decl>;</decl_stmt>

			<comment type="block">/* Look up the operator's btree/hash strategy number. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>==</operator> <name>InvalidStrategy</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>get_op_opfamily_properties</name><argument_list>(<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>,
										   <argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopfamily</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>lefttype</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<switch>switch <condition>(<expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
				<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
					<block>{<block_content>
						<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

						<comment type="block">/*
						 * Add this clause to the list of clauses to be used
						 * for pruning if this is the first such key for this
						 * operator strategy or if it is consecutively next to
						 * the last column for which a clause with this
						 * operator strategy was matched.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>btree_clauses</name><index>[<expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name></expr>]</index></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>last</name> <operator>=</operator> <call><name>llast</name><argument_list>(<argument><expr><name><name>btree_clauses</name><index>[<expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><name>last</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
							<name>i</name> <operator>==</operator> <name><name>last</name><operator>-&gt;</operator><name>keyno</name></name> <operator>||</operator> <name>i</name> <operator>==</operator> <name><name>last</name><operator>-&gt;</operator><name>keyno</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>btree_clauses</name><index>[<expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name></expr>]</index></name> <operator>=</operator>
								<call><name>lappend</name><argument_list>(<argument><expr><name><name>btree_clauses</name><index>[<expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<comment type="block">/*
						 * We can't consider subsequent partition keys if the
						 * clause for the current key contains a non-inclusive
						 * operator.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>==</operator> <name>BTLessStrategyNumber</name> <operator>||</operator>
							<name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>==</operator> <name>BTGreaterStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>consider_next_key</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<break>break;</break>
					</block_content>}</block>

				<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>!=</operator> <name>HTEqualStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid clause for hash partitioning"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>hash_clauses</name><index>[<expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name></expr>]</index></name> <operator>=</operator>
						<call><name>lappend</name><argument_list>(<argument><expr><name><name>hash_clauses</name><index>[<expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid partition strategy: %c"</literal></expr></argument>,
						 <argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block>

		<comment type="block">/*
		 * If we've decided that clauses for subsequent partition keys
		 * wouldn't be useful for pruning, don't search any further.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>consider_next_key</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now, we have divided clauses according to their operator strategies.
	 * Check for each strategy if we can generate pruning step(s) by
	 * collecting a list of expressions whose values will constitute a vector
	 * that can be used as a lookup key by a partition bound searching
	 * function.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>eq_clauses</name> <init>= <expr><name><name>btree_clauses</name><index>[<expr><name>BTEqualStrategyNumber</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>le_clauses</name> <init>= <expr><name><name>btree_clauses</name><index>[<expr><name>BTLessEqualStrategyNumber</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ge_clauses</name> <init>= <expr><name><name>btree_clauses</name><index>[<expr><name>BTGreaterEqualStrategyNumber</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>strat</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * For each clause under consideration for a given strategy,
				 * we collect expressions from clauses for earlier keys, whose
				 * operator strategy is inclusive, into a list called
				 * 'prefix'. By appending the clause's own expression to the
				 * 'prefix', we'll generate one step using the so generated
				 * vector and assign the current strategy to it.  Actually,
				 * 'prefix' might contain multiple clauses for the same key,
				 * in which case, we must generate steps for various
				 * combinations of expressions of different keys, which
				 * get_steps_using_prefix takes care of for us.
				 */</comment>
				<for>for <control>(<init><expr><name>strat</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>strat</name> <operator>&lt;=</operator> <name>BTMaxStrategyNumber</name></expr>;</condition> <incr><expr><name>strat</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>btree_clauses[strat]</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>prefix</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pc_steps</name></decl>;</decl_stmt>

						<comment type="block">/*
						 * Expressions from = clauses can always be in the
						 * prefix, provided they're from an earlier key.
						 */</comment>
						<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>eq_clauses</argument>)</argument_list></macro>
						<block>{<block_content>
							<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>eqpc</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><name><name>eqpc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>==</operator> <name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name></expr>)</condition><block type="pseudo"><block_content>
								<break>break;</break></block_content></block></if></if_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>eqpc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>&lt;</operator> <name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>eqpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block>

						<comment type="block">/*
						 * If we're generating steps for &lt;/&lt;= strategy, we can
						 * add other &lt;= clauses to the prefix, provided
						 * they're from an earlier key.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>strat</name> <operator>==</operator> <name>BTLessStrategyNumber</name> <operator>||</operator>
							<name>strat</name> <operator>==</operator> <name>BTLessEqualStrategyNumber</name></expr>)</condition>
						<block>{<block_content>
							<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>le_clauses</argument>)</argument_list></macro>
							<block>{<block_content>
								<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>lepc</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

								<if_stmt><if>if <condition>(<expr><name><name>lepc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>==</operator> <name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name></expr>)</condition><block type="pseudo"><block_content>
									<break>break;</break></block_content></block></if></if_stmt>
								<if_stmt><if>if <condition>(<expr><name><name>lepc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>&lt;</operator> <name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>lepc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							</block_content>}</block>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/*
						 * If we're generating steps for &gt;/&gt;= strategy, we can
						 * add other &gt;= clauses to the prefix, provided
						 * they're from an earlier key.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>strat</name> <operator>==</operator> <name>BTGreaterStrategyNumber</name> <operator>||</operator>
							<name>strat</name> <operator>==</operator> <name>BTGreaterEqualStrategyNumber</name></expr>)</condition>
						<block>{<block_content>
							<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>ge_clauses</argument>)</argument_list></macro>
							<block>{<block_content>
								<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>gepc</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

								<if_stmt><if>if <condition>(<expr><name><name>gepc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>==</operator> <name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name></expr>)</condition><block type="pseudo"><block_content>
									<break>break;</break></block_content></block></if></if_stmt>
								<if_stmt><if>if <condition>(<expr><name><name>gepc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>&lt;</operator> <name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>gepc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							</block_content>}</block>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/*
						 * As mentioned above, if 'prefix' contains multiple
						 * expressions for the same key, the following will
						 * generate multiple steps, one for each combination
						 * of the expressions for different keys.
						 *
						 * Note that we pass NULL for step_nullkeys, because
						 * we don't search list/range partition bounds where
						 * some keys are NULL.
						 */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>==</operator> <name>strat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>pc_steps</name> <operator>=</operator> <call><name>get_steps_using_prefix</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>strat</name></expr></argument>,
														  <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>op_is_ne</name></name></expr></argument>,
														  <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
														  <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>cmpfn</name></name></expr></argument>,
														  <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name></expr></argument>,
														  <argument><expr><name>NULL</name></expr></argument>,
														  <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>opsteps</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>opsteps</name></expr></argument>, <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>pc_steps</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
				</block_content>}</block></for>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>eq_clauses</name> <init>= <expr><name><name>hash_clauses</name><index>[<expr><name>HTEqualStrategyNumber</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* For hash partitioning, we have just the = strategy. */</comment>
				<if_stmt><if>if <condition>(<expr><name>eq_clauses</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>pc</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pc_steps</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>prefix</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>last_keyno</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * Locate the clause for the greatest column.  This may
					 * not belong to the last partition key, but it is the
					 * clause belonging to the last partition key we found a
					 * clause for above.
					 */</comment>
					<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>llast</name><argument_list>(<argument><expr><name>eq_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * There might be multiple clauses which matched to that
					 * partition key; find the first such clause.  While at
					 * it, add all the clauses before that one to 'prefix'.
					 */</comment>
					<expr_stmt><expr><name>last_keyno</name> <operator>=</operator> <name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name></expr>;</expr_stmt>
					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>eq_clauses</argument>)</argument_list></macro>
					<block>{<block_content>
						<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>==</operator> <name>last_keyno</name></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>

					<comment type="block">/*
					 * For each clause for the "last" column, after appending
					 * the clause's own expression to the 'prefix', we'll
					 * generate one step using the so generated vector and and
					 * assign = as its strategy.  Actually, 'prefix' might
					 * contain multiple clauses for the same key, in which
					 * case, we must generate steps for various combinations
					 * of expressions of different keys, which
					 * get_steps_using_prefix will take care of for us.
					 */</comment>
					<macro><name>for_each_cell</name><argument_list>(<argument>lc1</argument>, <argument>lc</argument>)</argument_list></macro>
					<block>{<block_content>
						<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * Note that we pass nullkeys for step_nullkeys,
						 * because we need to tell hash partition bound search
						 * function which of the keys we found IS NULL clauses
						 * for.
						 */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>==</operator> <name>HTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>pc_steps</name> <operator>=</operator>
							<call><name>get_steps_using_prefix</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
												   <argument><expr><name>HTEqualStrategyNumber</name></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>,
												   <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
												   <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>cmpfn</name></name></expr></argument>,
												   <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name></expr></argument>,
												   <argument><expr><name>nullkeys</name></expr></argument>,
												   <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>opsteps</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>opsteps</name></expr></argument>, <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>pc_steps</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid partition strategy: %c"</literal></expr></argument>,
				 <argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Lastly, add a combine step to mutually AND these op steps, if needed */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>opsteps</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opstep_ids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>opsteps</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>opstep_ids</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>opstep_ids</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>step_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>opstep_ids</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>gen_prune_step_combine</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>opstep_ids</name></expr></argument>,
										  <argument><expr><name>PARTPRUNE_COMBINE_INTERSECT</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>opsteps</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>linitial</name><argument_list>(<argument><expr><name>opsteps</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If the partition key has a collation, then the clause must have the same
 * input collation.  If the partition key is non-collatable, we assume the
 * collation doesn't matter, because while collation wasn't considered when
 * performing partitioning, the clause still may have a collation assigned
 * due to the other input being of a collatable type.
 *
 * See also IndexCollMatchesExprColl.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PartCollMatchesExprColl</name><parameter_list>(<parameter><type><name>partcoll</name></type></parameter>, <parameter><type><name>exprcoll</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((partcoll) == InvalidOid || (partcoll) == (exprcoll))</cpp:value></cpp:define>

<comment type="block">/*
 * match_clause_to_partition_key
 *		Attempt to match the given 'clause' with the specified partition key.
 *
 * Return value is:
 * * PARTCLAUSE_NOMATCH if the clause doesn't match this partition key (but
 *   caller should keep trying, because it might match a subsequent key).
 *   Output arguments: none set.
 *
 * * PARTCLAUSE_MATCH_CLAUSE if there is a match.
 *   Output arguments: *pc is set to a PartClauseInfo constructed for the
 *   matched clause.
 *
 * * PARTCLAUSE_MATCH_NULLNESS if there is a match, and the matched clause was
 *   either a "a IS NULL" or "a IS NOT NULL" clause.
 *   Output arguments: *clause_is_not_null is set to false in the former case
 *   true otherwise.
 *
 * * PARTCLAUSE_MATCH_STEPS if there is a match.
 *   Output arguments: *clause_steps is set to a list of PartitionPruneStep
 *   generated for the clause.
 *
 * * PARTCLAUSE_MATCH_CONTRADICT if the clause is self-contradictory.  This can
 *   only happen if it's a BoolExpr whose arguments are self-contradictory.
 *   Output arguments: none set.
 *
 * * PARTCLAUSE_UNSUPPORTED if the clause cannot be used for pruning at all
 *   due to one of its properties, such as argument volatility, even if it may
 *   have been matched with a key.
 *   Output arguments: none set.
 */</comment>
<function><type><specifier>static</specifier> <name>PartClauseMatchStatus</name></type>
<name>match_clause_to_partition_key</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
							  <parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>partkey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>partkeyidx</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>clause_is_not_null</name></decl></parameter>, <parameter><decl><type><name>PartClauseInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>pc</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>clause_steps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartClauseMatchStatus</name></type> <name>boolmatchstatus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionScheme</name></type> <name>part_scheme</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>partopfamily</name> <init>= <expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopfamily</name><index>[<expr><name>partkeyidx</name></expr>]</index></name></expr></init></decl>,
				<decl><type ref="prev"/><name>partcoll</name> <init>= <expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>partkeyidx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Recognize specially shaped clauses that match with the Boolean
	 * partition key.
	 */</comment>
	<expr_stmt><expr><name>boolmatchstatus</name> <operator>=</operator> <call><name>match_boolean_partition_clause</name><argument_list>(<argument><expr><name>partopfamily</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>,
                                                     <argument><expr><name>partkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>boolmatchstatus</name> <operator>==</operator> <name>PARTCLAUSE_MATCH_CLAUSE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>partclause</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>partclause</name> <operator>=</operator> <operator>(</operator><name>PartClauseInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartClauseInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>keyno</name></name> <operator>=</operator> <name>partkeyidx</name></expr>;</expr_stmt>
		<comment type="block">/* Do pruning with the Boolean equality operator. */</comment>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name>BooleanEqualOperator</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>op_is_ne</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
		<comment type="block">/* We know that expr is of Boolean type. */</comment>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>cmpfn</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>partkeyidx</name></expr>]</index></name><operator>.</operator><name>fn_oid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>=</operator> <name>InvalidStrategy</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>pc</name> <operator>=</operator> <name>partclause</name></expr>;</expr_stmt>

		<return>return <expr><name>PARTCLAUSE_MATCH_CLAUSE</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>opclause</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>leftop</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>rightop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>commutator</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>,
					<decl><type ref="prev"/><name>negator</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>cmpfn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>exprtype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_opne_listp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>partclause</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>get_leftop</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>rightop</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>get_rightop</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rightop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* check if the clause matches this partition key */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <name>rightop</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <name>leftop</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>commutator</name> <operator>=</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name><name>opclause</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* nothing we can do unless we can swap the operands */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>commutator</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<comment type="block">/* clause does not match this partition key, but perhaps next. */</comment>
			<return>return <expr><name>PARTCLAUSE_NOMATCH</name></expr>;</return></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Partition key also consists of a collation that's specified for it,
		 * so try to match it too.  There may be multiple keys with the same
		 * expression but different collations.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PartCollMatchesExprColl</name><argument_list>(<argument><expr><name>partcoll</name></expr></argument>, <argument><expr><name><name>opclause</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_NOMATCH</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Matched with this key.  Now check various properties of the clause
		 * to see if it's sane to use it for pruning.  If any of the
		 * properties makes it unsuitable for pruning, then the clause is
		 * useless no matter which key it's matched to.
		 */</comment>

		<comment type="block">/*
		 * Only allow strict operators.  This will guarantee nulls are
		 * filtered.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_strict</name><argument_list>(<argument><expr><name><name>opclause</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* We can't use any volatile expressions to prune partitions. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Normally we only bother with operators that are listed as being
		 * part of the partitioning operator family.  But we make an exception
		 * in one case -- operators named '&lt;&gt;' are not listed in any operator
		 * family whatsoever, in which case, we try to perform partition
		 * pruning with it only if list partitioning is in use.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_in_opfamily</name><argument_list>(<argument><expr><name><name>opclause</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><name>partopfamily</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_LIST</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * To confirm if the operator is really '&lt;&gt;', check if its negator
			 * is a btree equality operator.
			 */</comment>
			<expr_stmt><expr><name>negator</name> <operator>=</operator> <call><name>get_negator</name><argument_list>(<argument><expr><name><name>opclause</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>negator</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>op_in_opfamily</name><argument_list>(<argument><expr><name>negator</name></expr></argument>, <argument><expr><name>partopfamily</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>lefttype</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>righttype</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>strategy</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>get_op_opfamily_properties</name><argument_list>(<argument><expr><name>negator</name></expr></argument>, <argument><expr><name>partopfamily</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefttype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>BTEqualStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>is_opne_listp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Operator isn't really what we were hoping it'd be. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_opne_listp</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check if we're going to need a cross-type comparison function. */</comment>
		<expr_stmt><expr><name>exprtype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>exprtype</name> <operator>!=</operator> <name><name>part_scheme</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>partkeyidx</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
				<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
					<expr_stmt><expr><name>cmpfn</name> <operator>=</operator>
						<call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopfamily</name><index>[<expr><name>partkeyidx</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>partkeyidx</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name>exprtype</name></expr></argument>, <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
					<expr_stmt><expr><name>cmpfn</name> <operator>=</operator>
						<call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopfamily</name><index>[<expr><name>partkeyidx</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name>exprtype</name></expr></argument>, <argument><expr><name>exprtype</name></expr></argument>, <argument><expr><name>HASHEXTENDED_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid partition strategy: %c"</literal></expr></argument>,
						 <argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>

			<comment type="block">/* If we couldn't find one, we cannot use this expression. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cmpfn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmpfn</name> <operator>=</operator> <name><name>part_scheme</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>partkeyidx</name></expr>]</index></name><operator>.</operator><name>fn_oid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>partclause</name> <operator>=</operator> <operator>(</operator><name>PartClauseInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartClauseInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>keyno</name></name> <operator>=</operator> <name>partkeyidx</name></expr>;</expr_stmt>

		<comment type="block">/* For &lt;&gt; operator clauses, pass on the negator. */</comment>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>op_is_ne</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>=</operator> <name>InvalidStrategy</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>is_opne_listp</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>negator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name>negator</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>op_is_ne</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * We already know the strategy in this case, so may as well set
			 * it rather than having to look it up later.
			 */</comment>
			<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/* And if commuted before matching, pass on the commutator */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>commutator</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name>commutator</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name><name>opclause</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>cmpfn</name></name> <operator>=</operator> <name>cmpfn</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>pc</name> <operator>=</operator> <name>partclause</name></expr>;</expr_stmt>

		<return>return <expr><name>PARTCLAUSE_MATCH_CLAUSE</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saop</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>saop_op</name> <init>= <expr><name><name>saop</name><operator>-&gt;</operator><name>opno</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>saop_coll</name> <init>= <expr><name><name>saop</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>leftop</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>rightop</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elem_exprs</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>elem_clauses</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>contradictory</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Check it matches this partition key */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>PartCollMatchesExprColl</name><argument_list>(<argument><expr><name>partcoll</name></expr></argument>, <argument><expr><name><name>saop</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_NOMATCH</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Matched with this key.  Check various properties of the clause to
		 * see if it can sanely be used for partition pruning.
		 */</comment>

		<comment type="block">/*
		 * Only allow strict operators.  This will guarantee nulls are
		 * filtered.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_strict</name><argument_list>(<argument><expr><name>saop_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Useless if the array has any volatile functions. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rightop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * In case of NOT IN (..), we get a '&lt;&gt;', which we handle if list
		 * partitioning is in use and we're able to confirm that it's negator
		 * is a btree equality operator belonging to the partitioning operator
		 * family.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_in_opfamily</name><argument_list>(<argument><expr><name>saop_op</name></expr></argument>, <argument><expr><name>partopfamily</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>negator</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_LIST</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>negator</name> <operator>=</operator> <call><name>get_negator</name><argument_list>(<argument><expr><name>saop_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>negator</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>op_in_opfamily</name><argument_list>(<argument><expr><name>negator</name></expr></argument>, <argument><expr><name>partopfamily</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>strategy</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>lefttype</name></decl>,
							<decl><type ref="prev"/><name>righttype</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>get_op_opfamily_properties</name><argument_list>(<argument><expr><name>negator</name></expr></argument>, <argument><expr><name>partopfamily</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>lefttype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>!=</operator> <name>BTEqualStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></else></if_stmt> <comment type="block">/* no useful negator */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * First generate a list of Const nodes, one for each array element
		 * (excepting nulls).
		 */</comment>
		<expr_stmt><expr><name>elem_exprs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>rightop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arrval</name> <init>= <expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name><name>arr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int16</name></type>		<name>elemlen</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>elembyval</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name>elemalign</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elem_values</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>elem_nulls</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>num_elems</name></decl>,
						<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrval</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>elemlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elembyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>arrval</name></expr></argument>,
							  <argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrval</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>elemlen</name></expr></argument>, <argument><expr><name>elembyval</name></expr></argument>, <argument><expr><name>elemalign</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>elem_values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem_nulls</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>num_elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_elems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>elem_expr</name></decl>;</decl_stmt>

				<comment type="block">/* Only consider non-null values. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>elem_nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>elem_expr</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name><name>arr</name><operator>-&gt;</operator><name>constcollid</name></name></expr></argument>, <argument><expr><name>elemlen</name></expr></argument>,
									  <argument><expr><name><name>elem_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>elembyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>elem_exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>elem_exprs</name></expr></argument>, <argument><expr><name>elem_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>arrexpr</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>, <argument><expr><name>rightop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * For a nested ArrayExpr, we don't know how to get the actual
			 * scalar values out into a flat list, so we give up doing
			 * anything with this ScalarArrayOpExpr.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>arrexpr</name><operator>-&gt;</operator><name>multidims</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>elem_exprs</name> <operator>=</operator> <name><name>arrexpr</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Give up on any other clause types. */</comment>
			<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Now generate a list of clauses, one for each array element, of the
		 * form saop_leftop saop_op elem_expr
		 */</comment>
		<expr_stmt><expr><name>elem_clauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>elem_exprs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>rightop</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>elem_clause</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>elem_clause</name> <operator>=</operator> <call><name>make_opclause</name><argument_list>(<argument><expr><name>saop_op</name></expr></argument>, <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>rightop</name></expr></argument>,
										<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>saop_coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>elem_clauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>elem_clauses</name></expr></argument>, <argument><expr><name>elem_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If we have an ANY clause and multiple elements, first turn the list
		 * of clauses into an OR expression.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>saop</name><operator>-&gt;</operator><name>useOr</name></name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>elem_clauses</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>elem_clauses</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>elem_clauses</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Finally, generate steps */</comment>
		<expr_stmt><expr><operator>*</operator><name>clause_steps</name> <operator>=</operator>
			<call><name>gen_partprune_steps_internal</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>elem_clauses</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>contradictory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>contradictory</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_MATCH_CONTRADICT</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>clause_steps</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* step generation failed */</comment>
		<return>return <expr><name>PARTCLAUSE_MATCH_STEPS</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>nulltest</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>nulltest</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Does arg match with this partition key column? */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_NOMATCH</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>clause_is_not_null</name> <operator>=</operator> <name><name>nulltest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NOT_NULL</name></expr>;</expr_stmt>

		<return>return <expr><name>PARTCLAUSE_MATCH_NULLNESS</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we get here then the return value depends on the result of the
	 * match_boolean_partition_clause call above.  If the call returned
	 * PARTCLAUSE_UNSUPPORTED then we're either not dealing with a bool qual
	 * or the bool qual is not suitable for pruning.  Since the qual didn't
	 * match up to any of the other qual types supported here, then trying to
	 * match it against any other partition key is a waste of time, so just
	 * return PARTCLAUSE_UNSUPPORTED.  If the qual just couldn't be matched to
	 * this partition key, then it may match another, so return
	 * PARTCLAUSE_NOMATCH.  The only other value that
	 * match_boolean_partition_clause can return is PARTCLAUSE_MATCH_CLAUSE,
	 * and since that value was already dealt with above, then we can just
	 * return boolmatchstatus.
	 */</comment>
	<return>return <expr><name>boolmatchstatus</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_steps_using_prefix
 *		Generate list of PartitionPruneStepOp steps each consisting of given
 *		opstrategy
 *
 * To generate steps, step_lastexpr and step_lastcmpfn are appended to
 * expressions and cmpfns, respectively, extracted from the clauses in
 * 'prefix'.  Actually, since 'prefix' may contain multiple clauses for the
 * same partition key column, we must generate steps for various combinations
 * of the clauses of different keys.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_steps_using_prefix</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>StrategyNumber</name></type> <name>step_opstrategy</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>step_op_is_ne</name></decl></parameter>,
					   <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>step_lastexpr</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name></type> <name>step_lastcmpfn</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>step_lastkeyno</name></decl></parameter>,
					   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>step_nullkeys</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Quick exit if there are no values to prefix with. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>gen_prune_step_op</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
								 <argument><expr><name>step_opstrategy</name></expr></argument>,
								 <argument><expr><name>step_op_is_ne</name></expr></argument>,
								 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>step_lastexpr</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>list_make1_oid</name><argument_list>(<argument><expr><name>step_lastcmpfn</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>step_nullkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Recurse to generate steps for various combinations. */</comment>
	<return>return <expr><call><name>get_steps_using_prefix_recurse</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
										  <argument><expr><name>step_opstrategy</name></expr></argument>,
										  <argument><expr><name>step_op_is_ne</name></expr></argument>,
										  <argument><expr><name>step_lastexpr</name></expr></argument>,
										  <argument><expr><name>step_lastcmpfn</name></expr></argument>,
										  <argument><expr><name>step_lastkeyno</name></expr></argument>,
										  <argument><expr><name>step_nullkeys</name></expr></argument>,
										  <argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_steps_using_prefix_recurse
 *		Recursively generate combinations of clauses for different partition
 *		keys and start generating steps upon reaching clauses for the greatest
 *		column that is less than the one for which we're currently generating
 *		steps (that is, step_lastkeyno)
 *
 * 'start' is where we should start iterating for the current invocation.
 * 'step_exprs' and 'step_cmpfns' each contains the expressions and cmpfns
 * we've generated so far from the clauses for the previous part keys.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_steps_using_prefix_recurse</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							   <parameter><decl><type><name>StrategyNumber</name></type> <name>step_opstrategy</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>step_op_is_ne</name></decl></parameter>,
							   <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>step_lastexpr</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>step_lastcmpfn</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>step_lastkeyno</name></decl></parameter>,
							   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>step_nullkeys</name></decl></parameter>,
							   <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>start</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>step_exprs</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>step_cmpfns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cur_keyno</name></decl>;</decl_stmt>

	<comment type="block">/* Actually, recursion would be limited by PARTITION_MAX_KEYS. */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check if we need to recurse. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>start</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur_keyno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>PartClauseInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>keyno</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cur_keyno</name> <operator>&lt;</operator> <name>step_lastkeyno</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>pc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>next_start</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * For each clause with cur_keyno, adds its expr and cmpfn to
		 * step_exprs and step_cmpfns, respectively, and recurse after setting
		 * next_start to the ListCell of the first clause for the next
		 * partition key.
		 */</comment>
		<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>start</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>&gt;</operator> <name>cur_keyno</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>next_start</name> <operator>=</operator> <name>lc</name></expr>;</expr_stmt>

		<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>start</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>moresteps</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>==</operator> <name>cur_keyno</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* clean up before starting a new recursion cycle. */</comment>
				<if_stmt><if>if <condition>(<expr><name>cur_keyno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>step_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>step_cmpfns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>step_exprs</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>step_cmpfns</name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>cmpfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>step_exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>step_exprs</name></expr></argument>, <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>step_cmpfns</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>step_cmpfns</name></expr></argument>, <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>cmpfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>&gt;</operator> <name>cur_keyno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>moresteps</name> <operator>=</operator> <call><name>get_steps_using_prefix_recurse</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
													   <argument><expr><name>step_opstrategy</name></expr></argument>,
													   <argument><expr><name>step_op_is_ne</name></expr></argument>,
													   <argument><expr><name>step_lastexpr</name></expr></argument>,
													   <argument><expr><name>step_lastcmpfn</name></expr></argument>,
													   <argument><expr><name>step_lastkeyno</name></expr></argument>,
													   <argument><expr><name>step_nullkeys</name></expr></argument>,
													   <argument><expr><name>next_start</name></expr></argument>,
													   <argument><expr><name>step_exprs</name></expr></argument>,
													   <argument><expr><name>step_cmpfns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>moresteps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * End the current recursion cycle and start generating steps, one for
		 * each clause with cur_keyno, which is all clauses from here onward
		 * till the end of the list.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>step_exprs</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>cur_keyno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>start</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>step_exprs1</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>step_cmpfns1</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>==</operator> <name>cur_keyno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Leave the original step_exprs unmodified. */</comment>
			<expr_stmt><expr><name>step_exprs1</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>step_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>step_exprs1</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>step_exprs1</name></expr></argument>, <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>step_exprs1</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>step_exprs1</name></expr></argument>, <argument><expr><name>step_lastexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Leave the original step_cmpfns unmodified. */</comment>
			<expr_stmt><expr><name>step_cmpfns1</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>step_cmpfns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>step_cmpfns1</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>step_cmpfns1</name></expr></argument>, <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>cmpfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>step_cmpfns1</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>step_cmpfns1</name></expr></argument>, <argument><expr><name>step_lastcmpfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>gen_prune_step_op</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
									 <argument><expr><name>step_opstrategy</name></expr></argument>, <argument><expr><name>step_op_is_ne</name></expr></argument>,
									 <argument><expr><name>step_exprs1</name></expr></argument>, <argument><expr><name>step_cmpfns1</name></expr></argument>,
									 <argument><expr><name>step_nullkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_matching_hash_bounds
 *		Determine offset of the hash bound matching the specified values,
 *		considering that all the non-null values come from clauses containing
 *		a compatible hash equality operator and any keys that are null come
 *		from an IS NULL clause.
 *
 * Generally this function will return a single matching bound offset,
 * although if a partition has not been setup for a given modulus then we may
 * return no matches.  If the number of clauses found don't cover the entire
 * partition key, then we'll need to return all offsets.
 *
 * 'opstrategy' if non-zero must be HTEqualStrategyNumber.
 *
 * 'values' contains Datums indexed by the partition key to use for pruning.
 *
 * 'nvalues', the number of Datums in the 'values' array.
 *
 * 'partsupfunc' contains partition hashing functions that can produce correct
 * hash for the type of the values contained in 'values'.
 *
 * 'nullkeys' is the set of partition keys that are null.
 */</comment>
<function><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type>
<name>get_matching_hash_bounds</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						 <parameter><decl><type><name>StrategyNumber</name></type> <name>opstrategy</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvalues</name></decl></parameter>,
						 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PruneStepResult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>PruneStepResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PruneStepResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>partindices</name> <init>= <expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>partnatts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>rowHash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>greatest_modulus</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For hash partitioning we can only perform pruning based on equality
	 * clauses to the partition key or IS NULL clauses.  We also can only
	 * prune if we got values for all keys.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nvalues</name> <operator>+</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>partnatts</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If there are any values, they must have come from clauses
		 * containing an equality operator compatible with hash partitioning.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>opstrategy</name> <operator>==</operator> <name>HTEqualStrategyNumber</name> <operator>||</operator> <name>nvalues</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><name>greatest_modulus</name> <operator>=</operator> <call><name>get_hash_partition_greatest_modulus</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rowHash</name> <operator>=</operator> <call><name>compute_hash_value</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partsupfunc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>partindices</name><index>[<expr><name>rowHash</name> <operator>%</operator> <name>greatest_modulus</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator>
				<call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>rowHash</name> <operator>%</operator> <name>greatest_modulus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
											  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * There is neither a special hash null partition or the default hash
	 * partition.
	 */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_matching_list_bounds
 *		Determine the offsets of list bounds matching the specified value,
 *		according to the semantics of the given operator strategy
 *
 * scan_default will be set in the returned struct, if the default partition
 * needs to be scanned, provided one exists at all.  scan_null will be set if
 * the special null-accepting partition needs to be scanned.
 *
 * 'opstrategy' if non-zero must be a btree strategy number.
 *
 * 'value' contains the value to use for pruning.
 *
 * 'nvalues', if non-zero, should be exactly 1, because of list partitioning.
 *
 * 'partsupfunc' contains the list partitioning comparison function to be used
 * to perform partition_list_bsearch
 *
 * 'nullkeys' is the set of partition keys that are null.
 */</comment>
<function><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type>
<name>get_matching_list_bounds</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						 <parameter><decl><type><name>StrategyNumber</name></type> <name>opstrategy</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvalues</name></decl></parameter>,
						 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PruneStepResult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>PruneStepResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PruneStepResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>,
				<decl><type ref="prev"/><name>minoff</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_equal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inclusive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>partcollation</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>partcollation</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Nulls may exist in only one partition - the partition whose
		 * accepted set of values includes null or the default partition if
		 * the former doesn't exist.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there are no datums to compare keys with, but there are partitions,
	 * just return the default partition if one exists.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>minoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are no values to compare with the datums in boundinfo, it
	 * means the caller asked for partitions for all non-null datums.  Add
	 * indexes of *all* partitions, including the default if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nvalues</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
											  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Special case handling of values coming from a &lt;&gt; operator clause. */</comment>
	<if_stmt><if>if <condition>(<expr><name>opstrategy</name> <operator>==</operator> <name>InvalidStrategy</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * First match to all bounds.  We'll remove any matching datums below.
		 */</comment>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
											  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>partition_list_bsearch</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>, <argument><expr><name>partcollation</name></expr></argument>, <argument><expr><name>boundinfo</name></expr></argument>,
									 <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>is_equal</name></expr>)</condition>
		<block>{<block_content>

			<comment type="block">/* We have a match. Remove from the result. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>off</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name></expr></argument>,
												   <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Always include the default partition if any. */</comment>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * With range queries, always include the default list partition, because
	 * list partitions divide the key space in a discontinuous manner, not all
	 * values in the given range will have a partition assigned.  This may not
	 * technically be true for some data types (e.g. integer types), however,
	 * we currently lack any sort of infrastructure to provide us with proofs
	 * that would allow us to do anything smarter here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>opstrategy</name> <operator>!=</operator> <name>BTEqualStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>opstrategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>partition_list_bsearch</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
										 <argument><expr><name>partcollation</name></expr></argument>,
										 <argument><expr><name>boundinfo</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>is_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>is_equal</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>off</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<return>return <expr><name>result</name></expr>;</return>

		<case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>inclusive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* fall through */</comment>
		<case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>partition_list_bsearch</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
										 <argument><expr><name>partcollation</name></expr></argument>,
										 <argument><expr><name>boundinfo</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>is_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* We don't want the matched datum to be in the result. */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_equal</name> <operator>||</operator> <operator>!</operator><name>inclusive</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * This case means all partition bounds are greater, which in
				 * turn means that all partitions satisfy this key.
				 */</comment>
				<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * off is greater than the numbers of datums we have partitions
			 * for.  The only possible partition that could contain a match is
			 * the default partition, but we must've set context-&gt;scan_default
			 * above anyway if one exists.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>minoff</name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>inclusive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* fall through */</comment>
		<case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>partition_list_bsearch</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
										 <argument><expr><name>partcollation</name></expr></argument>,
										 <argument><expr><name>boundinfo</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>is_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>is_equal</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>inclusive</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>off</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * off is smaller than the datums of all non-default partitions.
			 * The only possible partition that could contain a match is the
			 * default partition, but we must've set context-&gt;scan_default
			 * above anyway if one exists.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid strategy number %d"</literal></expr></argument>, <argument><expr><name>opstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>minoff</name></expr></argument>, <argument><expr><name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_matching_range_datums
 *		Determine the offsets of range bounds matching the specified values,
 *		according to the semantics of the given operator strategy
 *
 * Each datum whose offset is in result is to be treated as the upper bound of
 * the partition that will contain the desired values.
 *
 * scan_default is set in the returned struct if a default partition exists
 * and we're absolutely certain that it needs to be scanned.  We do *not* set
 * it just because values match portions of the key space uncovered by
 * partitions other than default (space which we normally assume to belong to
 * the default partition): the final set of bounds obtained after combining
 * multiple pruning steps might exclude it, so we infer its inclusion
 * elsewhere.
 *
 * 'opstrategy' if non-zero must be a btree strategy number.
 *
 * 'values' contains Datums indexed by the partition key to use for pruning.
 *
 * 'nvalues', number of Datums in 'values' array. Must be &lt;= context-&gt;partnatts.
 *
 * 'partsupfunc' contains the range partitioning comparison functions to be
 * used to perform partition_range_datum_bsearch or partition_rbound_datum_cmp
 * using.
 *
 * 'nullkeys' is the set of partition keys that are null.
 */</comment>
<function><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type>
<name>get_matching_range_bounds</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						  <parameter><decl><type><name>StrategyNumber</name></type> <name>opstrategy</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvalues</name></decl></parameter>,
						  <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PruneStepResult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>PruneStepResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PruneStepResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>partcollation</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>partcollation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>partnatts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>partindices</name> <init>= <expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>,
				<decl><type ref="prev"/><name>minoff</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_equal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inclusive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nvalues</name> <operator>&lt;=</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are no datums to compare keys with, or if we got an IS NULL
	 * clause just return the default partition, if it exists.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>minoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are no values to compare with the datums in boundinfo, it
	 * means the caller asked for partitions for all non-null datums.  Add
	 * indexes of *all* partitions, including the default partition if one
	 * exists.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nvalues</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ignore key space not covered by any partitions */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>partindices</name><index>[<expr><name>minoff</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>minoff</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>partindices</name><index>[<expr><name>maxoff</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>maxoff</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>partindices</name><index>[<expr><name>minoff</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
               <name><name>partindices</name><index>[<expr><name>maxoff</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>minoff</name></expr></argument>, <argument><expr><name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the query does not constrain all key columns, we'll need to scan the
	 * the default partition, if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nvalues</name> <operator>&lt;</operator> <name>partnatts</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>opstrategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>
			<comment type="block">/* Look for the smallest bound that is = lookup value. */</comment>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>partition_range_datum_bsearch</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
												<argument><expr><name>partcollation</name></expr></argument>,
												<argument><expr><name>boundinfo</name></expr></argument>,
												<argument><expr><name>nvalues</name></expr></argument>, <argument><expr><name>values</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>is_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>is_equal</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>nvalues</name> <operator>==</operator> <name>partnatts</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* There can only be zero or one matching partition. */</comment>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>saved_off</name> <init>= <expr><name>off</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * Since the lookup value contains only a prefix of keys,
					 * we must find other bounds that may also match the
					 * prefix.  partition_range_datum_bsearch() returns the
					 * offset of one of them, find others by checking adjacent
					 * bounds.
					 */</comment>

					<comment type="block">/*
					 * First find greatest bound that's smaller than the
					 * lookup value.
					 */</comment>
					<while>while <condition>(<expr><name>off</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>cmpval</name> <operator>=</operator>
							<call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
													   <argument><expr><name>partcollation</name></expr></argument>,
													   <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
													   <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
													   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>off</name><operator>--</operator></expr>;</expr_stmt>
					</block_content>}</block></while>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>==</operator>
						   <call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
													  <argument><expr><name>partcollation</name></expr></argument>,
													  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
													  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
													  <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * We can treat 'off' as the offset of the smallest bound
					 * to be included in the result, if we know it is the
					 * upper bound of the partition in which the lookup value
					 * could possibly exist.  One case it couldn't is if the
					 * bound, or precisely the matched portion of its prefix,
					 * is not inclusive.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>off</name></expr>]</index><index>[<expr><name>nvalues</name></expr>]</index></name> <operator>==</operator>
						<name>PARTITION_RANGE_DATUM_MINVALUE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>minoff</name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Now find smallest bound that's greater than the lookup
					 * value.
					 */</comment>
					<expr_stmt><expr><name>off</name> <operator>=</operator> <name>saved_off</name></expr>;</expr_stmt>
					<while>while <condition>(<expr><name>off</name> <operator>&lt;</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
															<argument><expr><name>partcollation</name></expr></argument>,
															<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
															<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
															<argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></while>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>==</operator>
						   <call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
													  <argument><expr><name>partcollation</name></expr></argument>,
													  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
													  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
													  <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * off + 1, then would be the offset of the greatest bound
					 * to be included in the result.
					 */</comment>
					<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name>off</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>minoff</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>maxoff</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>minoff</name></expr></argument>, <argument><expr><name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * The lookup value falls in the range between some bounds in
				 * boundinfo.  'off' would be the offset of the greatest bound
				 * that is &lt;= lookup value, so add off + 1 to the result
				 * instead as the offset of the upper bound of the only
				 * partition that may contain the lookup value.  If 'off' is
				 * -1 indicating that all bounds are greater, then we simply
				 * end up adding the first bound's offset, that is, 0.
				 */</comment>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<return>return <expr><name>result</name></expr>;</return>

		<case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>inclusive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* fall through */</comment>
		<case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>

			<comment type="block">/*
			 * Look for the smallest bound that is &gt; or &gt;= lookup value and
			 * set minoff to its offset.
			 */</comment>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>partition_range_datum_bsearch</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
												<argument><expr><name>partcollation</name></expr></argument>,
												<argument><expr><name>boundinfo</name></expr></argument>,
												<argument><expr><name>nvalues</name></expr></argument>, <argument><expr><name>values</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>is_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * All bounds are greater than the lookup value, so include
				 * all of them in the result.
				 */</comment>
				<expr_stmt><expr><name>minoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>is_equal</name> <operator>&amp;&amp;</operator> <name>nvalues</name> <operator>&lt;</operator> <name>partnatts</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Since the lookup value contains only a prefix of keys,
					 * we must find other bounds that may also match the
					 * prefix.  partition_range_datum_bsearch() returns the
					 * offset of one of them, find others by checking adjacent
					 * bounds.
					 *
					 * Based on whether the lookup values are inclusive or
					 * not, we must either include the indexes of all such
					 * bounds in the result (that is, set minoff to the index
					 * of smallest such bound) or find the smallest one that's
					 * greater than the lookup values and set minoff to that.
					 */</comment>
					<while>while <condition>(<expr><name>off</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>off</name> <operator>&lt;</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>			<name>nextoff</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>nextoff</name> <operator>=</operator> <ternary><condition><expr><name>inclusive</name></expr> ?</condition><then> <expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
						<expr_stmt><expr><name>cmpval</name> <operator>=</operator>
							<call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
													   <argument><expr><name>partcollation</name></expr></argument>,
													   <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>nextoff</name></expr>]</index></name></expr></argument>,
													   <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>nextoff</name></expr>]</index></name></expr></argument>,
													   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>

						<expr_stmt><expr><name>off</name> <operator>=</operator> <name>nextoff</name></expr>;</expr_stmt>
					</block_content>}</block></while>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>==</operator>
						   <call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
													  <argument><expr><name>partcollation</name></expr></argument>,
													  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
													  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
													  <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>minoff</name> <operator>=</operator> <ternary><condition><expr><name>inclusive</name></expr> ?</condition><then> <expr><name>off</name></expr> </then><else>: <expr><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>

					<comment type="block">/*
					 * lookup value falls in the range between some bounds in
					 * boundinfo.  off would be the offset of the greatest
					 * bound that is &lt;= lookup value, so add off + 1 to the
					 * result instead as the offset of the upper bound of the
					 * smallest partition that may contain the lookup value.
					 */</comment>
					<expr_stmt><expr><name>minoff</name> <operator>=</operator> <name>off</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>inclusive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* fall through */</comment>
		<case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>

			<comment type="block">/*
			 * Look for the greatest bound that is &lt; or &lt;= lookup value and
			 * set maxoff to its offset.
			 */</comment>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>partition_range_datum_bsearch</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
												<argument><expr><name>partcollation</name></expr></argument>,
												<argument><expr><name>boundinfo</name></expr></argument>,
												<argument><expr><name>nvalues</name></expr></argument>, <argument><expr><name>values</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>is_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * See the comment above.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>is_equal</name> <operator>&amp;&amp;</operator> <name>nvalues</name> <operator>&lt;</operator> <name>partnatts</name></expr>)</condition>
				<block>{<block_content>
					<while>while <condition>(<expr><name>off</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>off</name> <operator>&lt;</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>			<name>nextoff</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>nextoff</name> <operator>=</operator> <ternary><condition><expr><name>inclusive</name></expr> ?</condition><then> <expr><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
						<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
															<argument><expr><name>partcollation</name></expr></argument>,
															<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>nextoff</name></expr>]</index></name></expr></argument>,
															<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>nextoff</name></expr>]</index></name></expr></argument>,
															<argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>

						<expr_stmt><expr><name>off</name> <operator>=</operator> <name>nextoff</name></expr>;</expr_stmt>
					</block_content>}</block></while>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>==</operator>
						   <call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
													  <argument><expr><name>partcollation</name></expr></argument>,
													  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
													  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
													  <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <ternary><condition><expr><name>inclusive</name></expr> ?</condition><then> <expr><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>off</name></expr></else></ternary></expr>;</expr_stmt>
				</block_content>}</block></if>

				<comment type="block">/*
				 * The lookup value falls in the range between some bounds in
				 * boundinfo.  'off' would be the offset of the greatest bound
				 * that is &lt;= lookup value, so add off + 1 to the result
				 * instead as the offset of the upper bound of the greatest
				 * partition that may contain lookup value.  If the lookup
				 * value had exactly matched the bound, but it isn't
				 * inclusive, no need add the adjacent partition.
				 */</comment>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><name>is_equal</name> <operator>||</operator> <name>inclusive</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name>off</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * 'off' is -1 indicating that all bounds are greater, so just
				 * set the first bound's offset as maxoff.
				 */</comment>
				<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name>off</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid strategy number %d"</literal></expr></argument>, <argument><expr><name>opstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	 <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>minoff</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>minoff</name> <operator>&lt;=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxoff</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>maxoff</name> <operator>&lt;=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the smallest partition to return has MINVALUE (negative infinity) as
     * its lower bound, increment it to point to the next finite bound
     * (supposedly its upper bound), so that we don't advertently end up
     * scanning the default partition.
	 */</comment>
    <if_stmt><if>if <condition>(<expr><name>minoff</name> <operator>&lt;</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>&amp;&amp;</operator> <name><name>partindices</name><index>[<expr><name>minoff</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>lastkey</name> <init>= <expr><name>nvalues</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>minoff</name></expr>]</index><index>[<expr><name>lastkey</name></expr>]</index></name> <operator>==</operator>
		   <name>PARTITION_RANGE_DATUM_MINVALUE</name></expr>)</condition>
		<block>{<block_content>
		   <expr_stmt><expr><name>minoff</name><operator>++</operator></expr>;</expr_stmt>
		   <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>minoff</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the previous greatest partition has MAXVALUE (positive infinity) as
     * its upper bound (something only possible to do with multi-column range
     * partitioning), we scan switch to it as the greatest partition to
     * return.  Again, so that we don't advertently end up scanning the
     * default partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>maxoff</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>partindices</name><index>[<expr><name>maxoff</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>lastkey</name> <init>= <expr><name>nvalues</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>maxoff</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>lastkey</name></expr>]</index></name> <operator>==</operator>
            <name>PARTITION_RANGE_DATUM_MAXVALUE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>maxoff</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>maxoff</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>minoff</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>maxoff</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>minoff</name> <operator>&lt;=</operator> <name>maxoff</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>minoff</name></expr></argument>, <argument><expr><name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * perform_pruning_base_step
 *		Determines the indexes of datums that satisfy conditions specified in
 *		'opstep'.
 *
 * Result also contains whether special null-accepting and/or default
 * partition need to be scanned.
 */</comment>
<function><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type>
<name>perform_pruning_base_step</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						  <parameter><decl><type><name>PartitionPruneStepOp</name> <modifier>*</modifier></type><name>opstep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>,
				<decl><type ref="prev"/><name>nvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name><name>partsupfunc</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * There better be the same number of expressions and compare functions.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>cmpfns</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nvalues</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>lc1</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lc2</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>cmpfns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate the partition lookup key that will be used by one of the
	 * get_matching_*_bounds functions called below.
	 */</comment>
	<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>context</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * For hash partitioning, it is possible that values of some keys are
		 * not provided in operator clauses, but instead the planner found
		 * that they appeared in a IS NULL clause.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>keyno</name></expr></argument>, <argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>nullkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * For range partitioning, we must only perform pruning with values
		 * for either all partition keys or a prefix thereof.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>keyno</name> <operator>&gt;</operator> <name>nvalues</name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>lc1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>partkey_datum_from_expr</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datum</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>cmpfn</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * If we're going to need a different comparison function than
				 * the one cached in the PartitionKey, we'll need to look up
				 * the FmgrInfo.
				 */</comment>
				<expr_stmt><expr><name>cmpfn</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cmpfn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>cmpfn</name> <operator>!=</operator> <name><name>context</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>keyno</name></expr>]</index></name><operator>.</operator><name>fn_oid</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>cmpfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nvalues</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>lc1</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lc2</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<switch>switch <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
			<return>return <expr><call><name>get_matching_hash_bounds</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
											<argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>opstrategy</name></name></expr></argument>,
											<argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>,
											<argument><expr><name>partsupfunc</name></expr></argument>,
											<argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>nullkeys</name></name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
			<return>return <expr><call><name>get_matching_list_bounds</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
											<argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>opstrategy</name></name></expr></argument>,
											<argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
											<argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>nullkeys</name></name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<return>return <expr><call><name>get_matching_range_bounds</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
											 <argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>opstrategy</name></name></expr></argument>,
											 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>,
											 <argument><expr><name>partsupfunc</name></expr></argument>,
											 <argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>nullkeys</name></name></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>context</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * perform_pruning_combine_step
 *		Determines the indexes of datums obtained by combining those given
 *		by the steps identified by cstep-&gt;source_stepids using the specified
 *		combination method
 *
 * Since cstep may refer to the result of earlier steps, we also receive
 * step_results here.
 */</comment>
<function><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type>
<name>perform_pruning_combine_step</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							 <parameter><decl><type><name>PartitionPruneStepCombine</name> <modifier>*</modifier></type><name>cstep</name></decl></parameter>,
							 <parameter><decl><type><name>PruneStepResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>step_results</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PruneStepResult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>firststep</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * A combine step without any source steps is an indication to not perform
	 * any partition pruning.  Return all datum indexes in that case.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PruneStepResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PruneStepResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cstep</name><operator>-&gt;</operator><name>source_stepids</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rangemax</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Add all valid offsets into the boundinfo-&gt;indexes array.  For range
		 * partitioning, boundinfo-&gt;indexes contains (boundinfo-&gt;ndatums + 1)
		 * valid entries; otherwise there are boundinfo-&gt;ndatums.
		 */</comment>
		<expr_stmt><expr><name>rangemax</name> <operator>=</operator> <ternary><condition><expr><name><name>context</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr> ?</condition><then>
			<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name></expr> </then><else>: <expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator>
			<call><name>bms_add_range</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rangemax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name> <operator>=</operator> <call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>cstep</name><operator>-&gt;</operator><name>combineOp</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTPRUNE_COMBINE_UNION</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>cstep-&gt;source_stepids</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>step_id</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PruneStepResult</name> <modifier>*</modifier></type><name>step_result</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * step_results[step_id] must contain a valid result, which is
				 * confirmed by the fact that cstep's step_id is greater than
				 * step_id and the fact that results of the individual steps
				 * are evaluated in sequence of their step_ids.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>step_id</name> <operator>&gt;=</operator> <name><name>cstep</name><operator>-&gt;</operator><name>step</name><operator>.</operator><name>step_id</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid pruning combine step argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>step_result</name> <operator>=</operator> <name><name>step_results</name><index>[<expr><name>step_id</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>step_result</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Record any additional datum indexes from this step */</comment>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name></expr></argument>,
														<argument><expr><name><name>step_result</name><operator>-&gt;</operator><name>bound_offsets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Update whether to scan null and default partitions. */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name> <operator>=</operator> <name><name>step_result</name><operator>-&gt;</operator><name>scan_null</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <name><name>step_result</name><operator>-&gt;</operator><name>scan_default</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PARTPRUNE_COMBINE_INTERSECT</name></expr>:</case>
			<expr_stmt><expr><name>firststep</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>cstep-&gt;source_stepids</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>step_id</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PruneStepResult</name> <modifier>*</modifier></type><name>step_result</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>step_id</name> <operator>&gt;=</operator> <name><name>cstep</name><operator>-&gt;</operator><name>step</name><operator>.</operator><name>step_id</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid pruning combine step argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>step_result</name> <operator>=</operator> <name><name>step_results</name><index>[<expr><name>step_id</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>step_result</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>firststep</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Copy step's result the first time. */</comment>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <name><name>step_result</name><operator>-&gt;</operator><name>bound_offsets</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name> <operator>=</operator> <name><name>step_result</name><operator>-&gt;</operator><name>scan_null</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <name><name>step_result</name><operator>-&gt;</operator><name>scan_default</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>firststep</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Record datum indexes common to both steps */</comment>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator>
						<call><name>bms_int_members</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name></expr></argument>,
										<argument><expr><name><name>step_result</name><operator>-&gt;</operator><name>bound_offsets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Update whether to scan null and default partitions. */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name> <operator>=</operator> <name><name>step_result</name><operator>-&gt;</operator><name>scan_null</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <name><name>step_result</name><operator>-&gt;</operator><name>scan_default</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid pruning combine op: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>cstep</name><operator>-&gt;</operator><name>combineOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * match_boolean_partition_clause
 *
 * If we're able to match the clause to the partition key as specially-shaped
 * boolean clause, set *outconst to a Const containing a true or false value
 * and return PARTCLAUSE_MATCH_CLAUSE.  Returns PARTCLAUSE_UNSUPPORTED if the
 * clause is not a boolean clause or if the boolean clause is unsuitable for
 * partition pruning.  Returns PARTCLAUSE_NOMATCH if it's a bool quals but
 * just does not match this partition key.  *outconst is set to NULL in the
 * latter two cases.
 */</comment>
<function><type><specifier>static</specifier> <name>PartClauseMatchStatus</name></type>
<name>match_boolean_partition_clause</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>partopfamily</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>partkey</name></decl></parameter>,
							   <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>outconst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>leftop</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>outconst</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBooleanOpfamily</name><argument_list>(<argument><expr><name>partopfamily</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>btest</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Only IS [NOT] TRUE/FALSE are any good to us */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_UNKNOWN</name> <operator>||</operator>
			<name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_NOT_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>leftop</name> <operator>=</operator> <name><name>btest</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>outconst</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_TRUE</name> <operator>||</operator>
						 <name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_NOT_FALSE</name><operator>)</operator></expr>
				?</condition><then> <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>
				</then><else>: <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>outconst</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_MATCH_CLAUSE</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_not_clause</name> <init>= <expr><call><name>not_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>leftop</name> <operator>=</operator> <ternary><condition><expr><name>is_not_clause</name></expr> ?</condition><then> <expr><call><name>get_notclausearg</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>clause</name></expr></else></ternary></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Compare to the partition key, and make up a clause ... */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>outconst</name> <operator>=</operator> <ternary><condition><expr><name>is_not_clause</name></expr> ?</condition><then>
				<expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr> </then><else>:
				<expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><call><name>negate_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>leftop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>partkey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>outconst</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>outconst</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_MATCH_CLAUSE</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>PARTCLAUSE_NOMATCH</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partkey_datum_from_expr
 *		Evaluate 'expr', set *value to the resulting Datum. Return true if
 *		evaluation was possible, otherwise false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>partkey_datum_from_expr</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Const</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
</unit>
