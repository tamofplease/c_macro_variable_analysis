<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/regex/regc_color.c"><comment type="block">/*
 * colorings of characters
 * This file is #included by regcomp.c.
 *
 * Copyright (c) 1998, 1999 Henry Spencer.  All rights reserved.
 *
 * Development of this software was funded, in part, by Cray Research Inc.,
 * UUNET Communications Services Inc., Sun Microsystems Inc., and Scriptics
 * Corporation, none of whom are responsible for the results.  The author
 * thanks all of them.
 *
 * Redistribution and use in source and binary forms -- with or without
 * modification -- are permitted for any purpose, provided that
 * redistributions in source form retain this entire copyright notice and
 * indicate the origin and nature of any modifications.
 *
 * I'd appreciate being given credit for this package in the documentation
 * of software which uses it, but that is not a requirement.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * HENRY SPENCER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * src/backend/regex/regc_color.c
 *
 *
 * Note that there are some incestuous relationships between this code and
 * NFA arc maintenance, which perhaps ought to be cleaned up sometime.
 */</comment>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CISERR</name><parameter_list>()</parameter_list></cpp:macro>    <cpp:value>VISERR(cm-&gt;v)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CERR</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>        <cpp:value>VERR(cm-&gt;v, (e))</cpp:value></cpp:define>



<comment type="block">/*
 * initcm - set up new colormap
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initcm</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
       <parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>colordesc</name></name> <modifier>*</modifier></type><name>cd</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>CMMAGIC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>v</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>ncds</name></name> <operator>=</operator> <name>NINLINECDS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>cd</name></name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>cdspace</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>cd</name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>cd</name></name></expr>;</expr_stmt>                <comment type="block">/* cm-&gt;cd[WHITE] */</comment>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>nschrs</name></name> <operator>=</operator> <name>MAX_SIMPLE_CHR</name> <operator>-</operator> <name>CHR_MIN</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>nuchrs</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>sub</name></name> <operator>=</operator> <name>NOSUB</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>arcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>firstchr</name></name> <operator>=</operator> <name>CHR_MIN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>locolormap</name></name> <operator>=</operator> <operator>(</operator><name>color</name> <operator>*</operator><operator>)</operator>
        <call><name>MALLOC</name><argument_list>(<argument><expr><operator>(</operator><name>MAX_SIMPLE_CHR</name> <operator>-</operator> <name>CHR_MIN</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>locolormap</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>cmranges</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    <comment type="block">/* prevent failure during freecm */</comment>
        <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>hicolormap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* this memset relies on WHITE being zero: */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>locolormap</name></name></expr></argument>, <argument><expr><name>WHITE</name></expr></argument>,
           <argument><expr><operator>(</operator><name>MAX_SIMPLE_CHR</name> <operator>-</operator> <name>CHR_MIN</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>classbits</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>classbits</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>numcmranges</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>cmranges</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>maxarrayrows</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>        <comment type="block">/* arbitrary initial allocation */</comment>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>hiarrayrows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>        <comment type="block">/* but we have only one row/col initially */</comment>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>hicolormap</name></name> <operator>=</operator> <operator>(</operator><name>color</name> <operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>maxarrayrows</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>hicolormap</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* initialize the "all other characters" row to WHITE */</comment>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>hicolormap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>WHITE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * freecm - free dynamically-allocated things in a colormap
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>freecm</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>cd</name></name> <operator>!=</operator> <name><name>cm</name><operator>-&gt;</operator><name>cdspace</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>cd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>locolormap</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>locolormap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>cmranges</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>cmranges</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>hicolormap</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>hicolormap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_reg_getcolor - slow case of GETCOLOR()
 */</comment>
<function><type><name>color</name></type>
<name>pg_reg_getcolor</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>, <parameter><decl><type><name>chr</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>rownum</name></decl>,
                <decl><type ref="prev"/><name>colnum</name></decl>,
                <decl><type ref="prev"/><name>low</name></decl>,
                <decl><type ref="prev"/><name>high</name></decl>;</decl_stmt>

    <comment type="block">/* Should not be used for chrs in the locolormap */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>c</name> <operator>&gt;</operator> <name>MAX_SIMPLE_CHR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Find which row it's in.  The colormapranges are in order, so we can use
     * binary search.
     */</comment>
    <expr_stmt><expr><name>rownum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                    <comment type="block">/* if no match, use array row zero */</comment>
    <expr_stmt><expr><name>low</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>high</name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>numcmranges</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>low</name> <operator>&lt;</operator> <name>high</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>middle</name> <init>= <expr><name>low</name> <operator>+</operator> <operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>colormaprange</name> <modifier>*</modifier></type><name>cmr</name> <init>= <expr><operator>&amp;</operator><name><name>cm</name><operator>-&gt;</operator><name>cmranges</name><index>[<expr><name>middle</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <name><name>cmr</name><operator>-&gt;</operator><name>cmin</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>high</name> <operator>=</operator> <name>middle</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>c</name> <operator>&gt;</operator> <name><name>cmr</name><operator>-&gt;</operator><name>cmax</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>low</name> <operator>=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>rownum</name> <operator>=</operator> <name><name>cmr</name><operator>-&gt;</operator><name>rownum</name></name></expr>;</expr_stmt>    <comment type="block">/* found a match */</comment>
            <break>break;</break>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Find which column it's in --- this is all locale-dependent.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>colnum</name> <operator>=</operator> <call><name>cclass_column_index</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>cm</name><operator>-&gt;</operator><name>hicolormap</name><index>[<expr><name>rownum</name> <operator>*</operator> <name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name> <operator>+</operator> <name>colnum</name></expr>]</index></name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* fast path if no relevant cclasses */</comment>
        <return>return <expr><name><name>cm</name><operator>-&gt;</operator><name>hicolormap</name><index>[<expr><name>rownum</name></expr>]</index></name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * maxcolor - report largest color number in use
 */</comment>
<function><type><specifier>static</specifier> <name>color</name></type>
<name>maxcolor</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>CISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>COLORLESS</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><operator>(</operator><name>color</name><operator>)</operator> <name><name>cm</name><operator>-&gt;</operator><name>max</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * newcolor - find a new color (must be assigned at once)
 * Beware:    may relocate the colordescs.
 */</comment>
<function><type><specifier>static</specifier> <name>color</name></type>                    <comment type="block">/* COLORLESS for error */</comment>
<name>newcolor</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>colordesc</name></name> <modifier>*</modifier></type><name>cd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>n</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>CISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>COLORLESS</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>free</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>free</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name><name>cm</name><operator>-&gt;</operator><name>free</name></name> <operator>&lt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>ncds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cd</name> <operator>=</operator> <operator>&amp;</operator><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name><name>cm</name><operator>-&gt;</operator><name>free</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>UNUSEDCOLOR</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>arcs</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name><name>cd</name><operator>-&gt;</operator><name>sub</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>max</name></name> <operator>&lt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>ncds</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>max</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>cd</name> <operator>=</operator> <operator>&amp;</operator><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name><name>cm</name><operator>-&gt;</operator><name>max</name></name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* oops, must allocate more */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>colordesc</name></name> <modifier>*</modifier></type><name>newCd</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>max</name></name> <operator>==</operator> <name>MAX_COLOR</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>CERR</name><argument_list>(<argument><expr><name>REG_ECOLORS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COLORLESS</name></expr>;</return>    <comment type="block">/* too many colors */</comment>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>ncds</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>MAX_COLOR</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>n</name> <operator>=</operator> <name>MAX_COLOR</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>cd</name></name> <operator>==</operator> <name><name>cm</name><operator>-&gt;</operator><name>cdspace</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>newCd</name> <operator>=</operator> <operator>(</operator>struct <name>colordesc</name> <operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>colordesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>newCd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VS</name><argument_list>(<argument><expr><name>newCd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VS</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>cdspace</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cm</name><operator>-&gt;</operator><name>ncds</name></name> <operator>*</operator>
                       <sizeof>sizeof<argument_list>(<argument><expr>struct <name>colordesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>newCd</name> <operator>=</operator> <operator>(</operator>struct <name>colordesc</name> <operator>*</operator><operator>)</operator>
                <call><name>REALLOC</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>cd</name></name></expr></argument>, <argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>colordesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>newCd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>CERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COLORLESS</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>cd</name></name> <operator>=</operator> <name>newCd</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>ncds</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>max</name></name> <operator>&lt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>ncds</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>max</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>cd</name> <operator>=</operator> <operator>&amp;</operator><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name><name>cm</name><operator>-&gt;</operator><name>max</name></name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>nschrs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>nuchrs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>sub</name></name> <operator>=</operator> <name>NOSUB</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>arcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>firstchr</name></name> <operator>=</operator> <name>CHR_MIN</name></expr>;</expr_stmt>        <comment type="block">/* in case never set otherwise */</comment>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>color</name><operator>)</operator> <operator>(</operator><name>cd</name> <operator>-</operator> <name><name>cm</name><operator>-&gt;</operator><name>cd</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * freecolor - free a color (must have no arcs or subcolor)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>freecolor</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>,
          <parameter><decl><type><name>color</name></type> <name>co</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>colordesc</name></name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><operator>&amp;</operator><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>co</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>color</name></type>        <name>pco</name></decl>,
                <decl><type ref="prev"/><name>nco</name></decl>;</decl_stmt>            <comment type="block">/* for freelist scan */</comment>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>co</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>co</name> <operator>==</operator> <name>WHITE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>arcs</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>sub</name></name> <operator>==</operator> <name>NOSUB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>nschrs</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>nuchrs</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>FREECOL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>co</name> <operator>==</operator> <name><name>cm</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition>
    <block>{<block_content>
        <while>while <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>max</name></name> <operator>&gt;</operator> <name>WHITE</name> <operator>&amp;&amp;</operator> <call><name>UNUSEDCOLOR</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name><name>cm</name><operator>-&gt;</operator><name>max</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>max</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>free</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator> <name><name>cm</name><operator>-&gt;</operator><name>free</name></name> <operator>&gt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name><name>cm</name><operator>-&gt;</operator><name>free</name></name></expr>]</index></name><operator>.</operator><name>sub</name></expr>;</expr_stmt></block_content></block></while>
        <if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>free</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>free</name></name> <operator>&lt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pco</name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>free</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>nco</name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>pco</name></expr>]</index></name><operator>.</operator><name>sub</name></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>nco</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>nco</name> <operator>&gt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* take this one out of freelist */</comment>
                    <expr_stmt><expr><name>nco</name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>nco</name></expr>]</index></name><operator>.</operator><name>sub</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>pco</name></expr>]</index></name><operator>.</operator><name>sub</name> <operator>=</operator> <name>nco</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nco</name> <operator>&lt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pco</name> <operator>=</operator> <name>nco</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>nco</name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>pco</name></expr>]</index></name><operator>.</operator><name>sub</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt></block_content></block></while>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>sub</name></name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>free</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <operator>(</operator><name>color</name><operator>)</operator> <operator>(</operator><name>cd</name> <operator>-</operator> <name><name>cm</name><operator>-&gt;</operator><name>cd</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pseudocolor - allocate a false color, to be managed by other means
 */</comment>
<function><type><specifier>static</specifier> <name>color</name></type>
<name>pseudocolor</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>color</name></type>        <name>co</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>colordesc</name></name> <modifier>*</modifier></type><name>cd</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>co</name> <operator>=</operator> <call><name>newcolor</name><argument_list>(<argument><expr><name>cm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>CISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>COLORLESS</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cd</name> <operator>=</operator> <operator>&amp;</operator><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>co</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>nschrs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>nuchrs</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>                <comment type="block">/* pretend it is in the upper map */</comment>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>sub</name></name> <operator>=</operator> <name>NOSUB</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>arcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>firstchr</name></name> <operator>=</operator> <name>CHR_MIN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>PSEUDO</name></expr>;</expr_stmt>
    <return>return <expr><name>co</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * subcolor - allocate a new subcolor (if necessary) to this chr
 *
 * This works only for chrs that map into the low color map.
 */</comment>
<function><type><specifier>static</specifier> <name>color</name></type>
<name>subcolor</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>, <parameter><decl><type><name>chr</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>color</name></type>        <name>co</name></decl>;</decl_stmt>                <comment type="block">/* current color of c */</comment>
    <decl_stmt><decl><type><name>color</name></type>        <name>sco</name></decl>;</decl_stmt>            <comment type="block">/* new subcolor */</comment>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>c</name> <operator>&lt;=</operator> <name>MAX_SIMPLE_CHR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>co</name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>locolormap</name><index>[<expr><name>c</name> <operator>-</operator> <name>CHR_MIN</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sco</name> <operator>=</operator> <call><name>newsub</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>CISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>COLORLESS</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sco</name> <operator>!=</operator> <name>COLORLESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>co</name> <operator>==</operator> <name>sco</name></expr>)</condition><block type="pseudo"><block_content>                <comment type="block">/* already in an open subcolor */</comment>
        <return>return <expr><name>co</name></expr>;</return></block_content></block></if></if_stmt>                <comment type="block">/* rest is redundant */</comment>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>co</name></expr>]</index></name><operator>.</operator><name>nschrs</name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>sco</name></expr>]</index></name><operator>.</operator><name>nschrs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>sco</name></expr>]</index></name><operator>.</operator><name>firstchr</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>sco</name></expr>]</index></name><operator>.</operator><name>nschrs</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>locolormap</name><index>[<expr><name>c</name> <operator>-</operator> <name>CHR_MIN</name></expr>]</index></name> <operator>=</operator> <name>sco</name></expr>;</expr_stmt>
    <return>return <expr><name>sco</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * subcolorhi - allocate a new subcolor (if necessary) to this colormap entry
 *
 * This is the same processing as subcolor(), but for entries in the high
 * colormap, which do not necessarily correspond to exactly one chr code.
 */</comment>
<function><type><specifier>static</specifier> <name>color</name></type>
<name>subcolorhi</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>, <parameter><decl><type><name>color</name> <modifier>*</modifier></type><name>pco</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>color</name></type>        <name>co</name></decl>;</decl_stmt>                <comment type="block">/* current color of entry */</comment>
    <decl_stmt><decl><type><name>color</name></type>        <name>sco</name></decl>;</decl_stmt>            <comment type="block">/* new subcolor */</comment>

    <expr_stmt><expr><name>co</name> <operator>=</operator> <operator>*</operator><name>pco</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sco</name> <operator>=</operator> <call><name>newsub</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>CISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>COLORLESS</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sco</name> <operator>!=</operator> <name>COLORLESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>co</name> <operator>==</operator> <name>sco</name></expr>)</condition><block type="pseudo"><block_content>                <comment type="block">/* already in an open subcolor */</comment>
        <return>return <expr><name>co</name></expr>;</return></block_content></block></if></if_stmt>                <comment type="block">/* rest is redundant */</comment>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>co</name></expr>]</index></name><operator>.</operator><name>nuchrs</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>sco</name></expr>]</index></name><operator>.</operator><name>nuchrs</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pco</name> <operator>=</operator> <name>sco</name></expr>;</expr_stmt>
    <return>return <expr><name>sco</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * newsub - allocate a new subcolor (if necessary) for a color
 */</comment>
<function><type><specifier>static</specifier> <name>color</name></type>
<name>newsub</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>,
       <parameter><decl><type><name>color</name></type> <name>co</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>color</name></type>        <name>sco</name></decl>;</decl_stmt>            <comment type="block">/* new subcolor */</comment>

    <expr_stmt><expr><name>sco</name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>co</name></expr>]</index></name><operator>.</operator><name>sub</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>sco</name> <operator>==</operator> <name>NOSUB</name></expr>)</condition>
    <block>{<block_content>                            <comment type="block">/* color has no open subcolor */</comment>
        <comment type="block">/* optimization: singly-referenced color need not be subcolored */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>co</name></expr>]</index></name><operator>.</operator><name>nschrs</name> <operator>+</operator> <name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>co</name></expr>]</index></name><operator>.</operator><name>nuchrs</name><operator>)</operator> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>co</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>sco</name> <operator>=</operator> <call><name>newcolor</name><argument_list>(<argument><expr><name>cm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* must create subcolor */</comment>
        <if_stmt><if>if <condition>(<expr><name>sco</name> <operator>==</operator> <name>COLORLESS</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>CISERR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COLORLESS</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>co</name></expr>]</index></name><operator>.</operator><name>sub</name> <operator>=</operator> <name>sco</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>sco</name></expr>]</index></name><operator>.</operator><name>sub</name> <operator>=</operator> <name>sco</name></expr>;</expr_stmt>    <comment type="block">/* open subcolor points to self */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sco</name> <operator>!=</operator> <name>NOSUB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>sco</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * newhicolorrow - get a new row in the hicolormap, cloning it from oldrow
 *
 * Returns array index of new row.  Note the array might move.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>newhicolorrow</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>,
              <parameter><decl><type><name>int</name></type> <name>oldrow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>newrow</name> <init>= <expr><name><name>cm</name><operator>-&gt;</operator><name>hiarrayrows</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>color</name>       <modifier>*</modifier></type><name>newrowptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Assign a fresh array row index, enlarging storage if needed */</comment>
    <if_stmt><if>if <condition>(<expr><name>newrow</name> <operator>&gt;=</operator> <name><name>cm</name><operator>-&gt;</operator><name>maxarrayrows</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>color</name>       <modifier>*</modifier></type><name>newarray</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>maxarrayrows</name></name> <operator>&gt;=</operator> <name>INT_MAX</name> <operator>/</operator> <operator>(</operator><name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>CERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>newarray</name> <operator>=</operator> <operator>(</operator><name>color</name> <operator>*</operator><operator>)</operator> <call><name>REALLOC</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>hicolormap</name></name></expr></argument>,
                                     <argument><expr><name><name>cm</name><operator>-&gt;</operator><name>maxarrayrows</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator>
                                     <name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>newarray</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>CERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>hicolormap</name></name> <operator>=</operator> <name>newarray</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>maxarrayrows</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>hiarrayrows</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Copy old row data */</comment>
    <expr_stmt><expr><name>newrowptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>cm</name><operator>-&gt;</operator><name>hicolormap</name><index>[<expr><name>newrow</name> <operator>*</operator> <name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newrowptr</name></expr></argument>,
           <argument><expr><operator>&amp;</operator><name><name>cm</name><operator>-&gt;</operator><name>hicolormap</name><index>[<expr><name>oldrow</name> <operator>*</operator> <name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name></expr>]</index></name></expr></argument>,
           <argument><expr><name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Increase color reference counts to reflect new colormap entries */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name><name>newrowptr</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>nuchrs</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

    <return>return <expr><name>newrow</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * newhicolorcols - create a new set of columns in the high colormap
 *
 * Essentially, extends the 2-D array to the right with a copy of itself.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>newhicolorcols</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>color</name>       <modifier>*</modifier></type><name>newarray</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>r</name></decl>,
                <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name> <operator>&gt;=</operator> <name>INT_MAX</name> <operator>/</operator> <operator>(</operator><name><name>cm</name><operator>-&gt;</operator><name>maxarrayrows</name></name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>newarray</name> <operator>=</operator> <operator>(</operator><name>color</name> <operator>*</operator><operator>)</operator> <call><name>REALLOC</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>hicolormap</name></name></expr></argument>,
                                 <argument><expr><name><name>cm</name><operator>-&gt;</operator><name>maxarrayrows</name></name> <operator>*</operator>
                                 <name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>newarray</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>hicolormap</name></name> <operator>=</operator> <name>newarray</name></expr>;</expr_stmt>

    <comment type="block">/* Duplicate existing columns to the right, and increase ref counts */</comment>
    <comment type="block">/* Must work backwards in the array because we realloc'd in place */</comment>
    <for>for <control>(<init><expr><name>r</name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>hiarrayrows</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>r</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>r</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>color</name>       <modifier>*</modifier></type><name>oldrowptr</name> <init>= <expr><operator>&amp;</operator><name><name>newarray</name><index>[<expr><name>r</name> <operator>*</operator> <name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>color</name>       <modifier>*</modifier></type><name>newrowptr</name> <init>= <expr><operator>&amp;</operator><name><name>newarray</name><index>[<expr><name>r</name> <operator>*</operator> <name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>color</name>       <modifier>*</modifier></type><name>newrowptr2</name> <init>= <expr><name>newrowptr</name> <operator>+</operator> <name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>color</name></type>        <name>co</name> <init>= <expr><name><name>oldrowptr</name><index>[<expr><name>c</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>newrowptr</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <name><name>newrowptr2</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <name>co</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>co</name></expr>]</index></name><operator>.</operator><name>nuchrs</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * subcolorcvec - allocate new subcolors to cvec members, fill in arcs
 *
 * For each chr "c" represented by the cvec, do the equivalent of
 * newarc(v-&gt;nfa, PLAIN, subcolor(v-&gt;cm, c), lp, rp);
 *
 * Note that in typical cases, many of the subcolors are the same.
 * While newarc() would discard duplicate arc requests, we can save
 * some cycles by not calling it repetitively to begin with.  This is
 * mechanized with the "lastsubcolor" state variable.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>subcolorcvec</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
             <parameter><decl><type><name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type><name>cv</name></decl></parameter>,
             <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>lp</name></decl></parameter>,
             <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>cm</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>color</name></type>        <name>lastsubcolor</name> <init>= <expr><name>COLORLESS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>chr</name></type>            <name>ch</name></decl>,
                <decl><type ref="prev"/><name>from</name></decl>,
                <decl><type ref="prev"/><name>to</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>chr</name>  <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* ordinary characters */</comment>
    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>cv</name><operator>-&gt;</operator><name>chrs</name></name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <name><name>cv</name><operator>-&gt;</operator><name>nchrs</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>subcoloronechr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastsubcolor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* and the ranges */</comment>
    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>cv</name><operator>-&gt;</operator><name>ranges</name></name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <name><name>cv</name><operator>-&gt;</operator><name>nranges</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr><operator>,</operator> <expr><name>i</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>from</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>to</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>from</name> <operator>&lt;=</operator> <name>MAX_SIMPLE_CHR</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* deal with simple chars one at a time */</comment>
            <decl_stmt><decl><type><name>chr</name></type>            <name>lim</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>to</name> <operator>&lt;=</operator> <name>MAX_SIMPLE_CHR</name><operator>)</operator></expr> ?</condition><then> <expr><name>to</name></expr> </then><else>: <expr><name>MAX_SIMPLE_CHR</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><name>from</name> <operator>&lt;=</operator> <name>lim</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>color</name></type>        <name>sco</name> <init>= <expr><call><name>subcolor</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>sco</name> <operator>!=</operator> <name>lastsubcolor</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>, <argument><expr><name>sco</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>lastsubcolor</name> <operator>=</operator> <name>sco</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>from</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* deal with any part of the range that's above MAX_SIMPLE_CHR */</comment>
        <if_stmt><if>if <condition>(<expr><name>from</name> <operator>&lt;</operator> <name>to</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>subcoloronerange</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastsubcolor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>from</name> <operator>==</operator> <name>to</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>subcoloronechr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastsubcolor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* and deal with cclass if any */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cv</name><operator>-&gt;</operator><name>cclasscode</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>classbit</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>color</name>       <modifier>*</modifier></type><name>pco</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>r</name></decl>,
                    <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>

        <comment type="block">/* Enlarge array if we don't have a column bit assignment for cclass */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name><name>cv</name><operator>-&gt;</operator><name>cclasscode</name></name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name><name>cv</name><operator>-&gt;</operator><name>cclasscode</name></name></expr>]</index></name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>newhicolorcols</name><argument_list>(<argument><expr><name>cm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Apply subcolorhi() and make arc for each entry in relevant cols */</comment>
        <expr_stmt><expr><name>classbit</name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name><name>cv</name><operator>-&gt;</operator><name>cclasscode</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pco</name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>hicolormap</name></name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>r</name> <operator>&lt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>hiarrayrows</name></name></expr>;</condition> <incr><expr><name>r</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;</operator> <name>classbit</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>color</name></type>        <name>sco</name> <init>= <expr><call><name>subcolorhi</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><name>pco</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* add the arc if needed */</comment>
                    <if_stmt><if>if <condition>(<expr><name>sco</name> <operator>!=</operator> <name>lastsubcolor</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>, <argument><expr><name>sco</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>lastsubcolor</name> <operator>=</operator> <name>sco</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>pco</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * subcoloronechr - do subcolorcvec's work for a singleton chr
 *
 * We could just let subcoloronerange do this, but it's a bit more efficient
 * if we exploit the single-chr case.  Also, callers find it useful for this
 * to be able to handle both low and high chr codes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>subcoloronechr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
               <parameter><decl><type><name>chr</name></type> <name>ch</name></decl></parameter>,
               <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>lp</name></decl></parameter>,
               <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>,
               <parameter><decl><type><name>color</name> <modifier>*</modifier></type><name>lastsubcolor</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>cm</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>colormaprange</name> <modifier>*</modifier></type><name>newranges</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numnewranges</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>colormaprange</name> <modifier>*</modifier></type><name>oldrange</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>oldrangen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>newrow</name></decl>;</decl_stmt>

    <comment type="block">/* Easy case for low chr codes */</comment>
    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>&lt;=</operator> <name>MAX_SIMPLE_CHR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>color</name></type>        <name>sco</name> <init>= <expr><call><name>subcolor</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>sco</name> <operator>!=</operator> <operator>*</operator><name>lastsubcolor</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>, <argument><expr><name>sco</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>lastsubcolor</name> <operator>=</operator> <name>sco</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Potentially, we could need two more colormapranges than we have now, if
     * the given chr is in the middle of some existing range.
     */</comment>
    <expr_stmt><expr><name>newranges</name> <operator>=</operator> <operator>(</operator><name>colormaprange</name> <operator>*</operator><operator>)</operator>
        <call><name>MALLOC</name><argument_list>(<argument><expr><operator>(</operator><name><name>cm</name><operator>-&gt;</operator><name>numcmranges</name></name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>colormaprange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>newranges</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>numnewranges</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Ranges before target are unchanged */</comment>
    <for>for <control>(<init><expr><name>oldrange</name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>cmranges</name></name></expr><operator>,</operator> <expr><name>oldrangen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
         <condition><expr><name>oldrangen</name> <operator>&lt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>numcmranges</name></name></expr>;</condition>
         <incr><expr><name>oldrange</name><operator>++</operator></expr><operator>,</operator> <expr><name>oldrangen</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>oldrange</name><operator>-&gt;</operator><name>cmax</name></name> <operator>&gt;=</operator> <name>ch</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>oldrange</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Match target chr against current range */</comment>
    <if_stmt><if>if <condition>(<expr><name>oldrangen</name> <operator>&gt;=</operator> <name><name>cm</name><operator>-&gt;</operator><name>numcmranges</name></name> <operator>||</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmin</name></name> <operator>&gt;</operator> <name>ch</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* chr does not belong to any existing range, make a new one */</comment>
        <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>cmin</name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>cmax</name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
        <comment type="block">/* row state should be cloned from the "all others" row */</comment>
        <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>rownum</name> <operator>=</operator> <name>newrow</name> <operator>=</operator> <call><name>newhicolorrow</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>numnewranges</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>oldrange</name><operator>-&gt;</operator><name>cmin</name></name> <operator>==</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmax</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* we have an existing singleton range matching the chr */</comment>
        <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>oldrange</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>newrow</name> <operator>=</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>rownum</name></name></expr>;</expr_stmt>
        <comment type="block">/* we've now fully processed this old range */</comment>
        <expr_stmt><expr><name>oldrange</name><operator>++</operator></expr><operator>,</operator> <expr><name>oldrangen</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* chr is a subset of this existing range, must split it */</comment>
        <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>&gt;</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmin</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* emit portion of old range before chr */</comment>
            <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>cmin</name> <operator>=</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmin</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>cmax</name> <operator>=</operator> <name>ch</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>rownum</name> <operator>=</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>rownum</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>numnewranges</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* emit chr as singleton range, initially cloning from range */</comment>
        <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>cmin</name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>cmax</name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>rownum</name> <operator>=</operator> <name>newrow</name> <operator>=</operator>
            <call><name>newhicolorrow</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><name><name>oldrange</name><operator>-&gt;</operator><name>rownum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>numnewranges</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>&lt;</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmax</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* emit portion of old range after chr */</comment>
            <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>cmin</name> <operator>=</operator> <name>ch</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>cmax</name> <operator>=</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmax</name></name></expr>;</expr_stmt>
            <comment type="block">/* must clone the row if we are making two new ranges from old */</comment>
            <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>rownum</name> <operator>=</operator>
                <ternary><condition><expr><operator>(</operator><name>ch</name> <operator>&gt;</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmin</name></name><operator>)</operator></expr> ?</condition><then> <expr><call><name>newhicolorrow</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><name><name>oldrange</name><operator>-&gt;</operator><name>rownum</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
                <expr><name><name>oldrange</name><operator>-&gt;</operator><name>rownum</name></name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>numnewranges</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* we've now fully processed this old range */</comment>
        <expr_stmt><expr><name>oldrange</name><operator>++</operator></expr><operator>,</operator> <expr><name>oldrangen</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Update colors in newrow and create arcs as needed */</comment>
    <expr_stmt><expr><call><name>subcoloronerow</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>newrow</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>lastsubcolor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Ranges after target are unchanged */</comment>
    <for>for <control>(<init>;</init> <condition><expr><name>oldrangen</name> <operator>&lt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>numcmranges</name></name></expr>;</condition> <incr><expr><name>oldrange</name><operator>++</operator></expr><operator>,</operator> <expr><name>oldrangen</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>oldrange</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Assert our original space estimate was adequate */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>numnewranges</name> <operator>&lt;=</operator> <operator>(</operator><name><name>cm</name><operator>-&gt;</operator><name>numcmranges</name></name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* And finally, store back the updated list of ranges */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>cmranges</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>cmranges</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>cmranges</name></name> <operator>=</operator> <name>newranges</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>numcmranges</name></name> <operator>=</operator> <name>numnewranges</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * subcoloronerange - do subcolorcvec's work for a high range
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>subcoloronerange</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
                 <parameter><decl><type><name>chr</name></type> <name>from</name></decl></parameter>,
                 <parameter><decl><type><name>chr</name></type> <name>to</name></decl></parameter>,
                 <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>lp</name></decl></parameter>,
                 <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>,
                 <parameter><decl><type><name>color</name> <modifier>*</modifier></type><name>lastsubcolor</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>cm</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>colormaprange</name> <modifier>*</modifier></type><name>newranges</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numnewranges</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>colormaprange</name> <modifier>*</modifier></type><name>oldrange</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>oldrangen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>newrow</name></decl>;</decl_stmt>

    <comment type="block">/* Caller should take care of non-high-range cases */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>from</name> <operator>&gt;</operator> <name>MAX_SIMPLE_CHR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>from</name> <operator>&lt;</operator> <name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Potentially, if we have N non-adjacent ranges, we could need as many as
     * 2N+1 result ranges (consider case where new range spans 'em all).
     */</comment>
    <expr_stmt><expr><name>newranges</name> <operator>=</operator> <operator>(</operator><name>colormaprange</name> <operator>*</operator><operator>)</operator>
        <call><name>MALLOC</name><argument_list>(<argument><expr><operator>(</operator><name><name>cm</name><operator>-&gt;</operator><name>numcmranges</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>colormaprange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>newranges</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>numnewranges</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Ranges before target are unchanged */</comment>
    <for>for <control>(<init><expr><name>oldrange</name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>cmranges</name></name></expr><operator>,</operator> <expr><name>oldrangen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
         <condition><expr><name>oldrangen</name> <operator>&lt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>numcmranges</name></name></expr>;</condition>
         <incr><expr><name>oldrange</name><operator>++</operator></expr><operator>,</operator> <expr><name>oldrangen</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>oldrange</name><operator>-&gt;</operator><name>cmax</name></name> <operator>&gt;=</operator> <name>from</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>oldrange</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Deal with ranges that (partially) overlap the target.  As we process
     * each such range, increase "from" to remove the dealt-with characters
     * from the target range.
     */</comment>
    <while>while <condition>(<expr><name>oldrangen</name> <operator>&lt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>numcmranges</name></name> <operator>&amp;&amp;</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmin</name></name> <operator>&lt;=</operator> <name>to</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>from</name> <operator>&lt;</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmin</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Handle portion of new range that corresponds to no old range */</comment>
            <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>cmin</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>cmax</name> <operator>=</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmin</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <comment type="block">/* row state should be cloned from the "all others" row */</comment>
            <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>rownum</name> <operator>=</operator> <name>newrow</name> <operator>=</operator> <call><name>newhicolorrow</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>numnewranges</name><operator>++</operator></expr>;</expr_stmt>
            <comment type="block">/* Update colors in newrow and create arcs as needed */</comment>
            <expr_stmt><expr><call><name>subcoloronerow</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>newrow</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>lastsubcolor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* We've now fully processed the part of new range before old */</comment>
            <expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmin</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>from</name> <operator>&lt;=</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmin</name></name> <operator>&amp;&amp;</operator> <name>to</name> <operator>&gt;=</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmax</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* old range is fully contained in new, process it in-place */</comment>
            <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>oldrange</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>newrow</name> <operator>=</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>rownum</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmax</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* some part of old range does not overlap new range */</comment>
            <if_stmt><if>if <condition>(<expr><name>from</name> <operator>&gt;</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmin</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* emit portion of old range before new range */</comment>
                <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>cmin</name> <operator>=</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmin</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>cmax</name> <operator>=</operator> <name>from</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>rownum</name> <operator>=</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>rownum</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>numnewranges</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* emit common subrange, initially cloning from old range */</comment>
            <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>cmin</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>cmax</name> <operator>=</operator>
                <ternary><condition><expr><operator>(</operator><name>to</name> <operator>&lt;</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmax</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>to</name></expr> </then><else>: <expr><name><name>oldrange</name><operator>-&gt;</operator><name>cmax</name></name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>rownum</name> <operator>=</operator> <name>newrow</name> <operator>=</operator>
                <call><name>newhicolorrow</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><name><name>oldrange</name><operator>-&gt;</operator><name>rownum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>numnewranges</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>to</name> <operator>&lt;</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmax</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* emit portion of old range after new range */</comment>
                <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>cmin</name> <operator>=</operator> <name>to</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>cmax</name> <operator>=</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmax</name></name></expr>;</expr_stmt>
                <comment type="block">/* must clone the row if we are making two new ranges from old */</comment>
                <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>rownum</name> <operator>=</operator>
                    <ternary><condition><expr><operator>(</operator><name>from</name> <operator>&gt;</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmin</name></name><operator>)</operator></expr> ?</condition><then> <expr><call><name>newhicolorrow</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><name><name>oldrange</name><operator>-&gt;</operator><name>rownum</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
                    <expr><name><name>oldrange</name><operator>-&gt;</operator><name>rownum</name></name></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><name>numnewranges</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>oldrange</name><operator>-&gt;</operator><name>cmax</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* Update colors in newrow and create arcs as needed */</comment>
        <expr_stmt><expr><call><name>subcoloronerow</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>newrow</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>lastsubcolor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* we've now fully processed this old range */</comment>
        <expr_stmt><expr><name>oldrange</name><operator>++</operator></expr><operator>,</operator> <expr><name>oldrangen</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>from</name> <operator>&lt;=</operator> <name>to</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Handle portion of new range that corresponds to no old range */</comment>
        <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>cmin</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>cmax</name> <operator>=</operator> <name>to</name></expr>;</expr_stmt>
        <comment type="block">/* row state should be cloned from the "all others" row */</comment>
        <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name></expr>]</index></name><operator>.</operator><name>rownum</name> <operator>=</operator> <name>newrow</name> <operator>=</operator> <call><name>newhicolorrow</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>numnewranges</name><operator>++</operator></expr>;</expr_stmt>
        <comment type="block">/* Update colors in newrow and create arcs as needed */</comment>
        <expr_stmt><expr><call><name>subcoloronerow</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>newrow</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>lastsubcolor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Ranges after target are unchanged */</comment>
    <for>for <control>(<init>;</init> <condition><expr><name>oldrangen</name> <operator>&lt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>numcmranges</name></name></expr>;</condition> <incr><expr><name>oldrange</name><operator>++</operator></expr><operator>,</operator> <expr><name>oldrangen</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>newranges</name><index>[<expr><name>numnewranges</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>oldrange</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Assert our original space estimate was adequate */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>numnewranges</name> <operator>&lt;=</operator> <operator>(</operator><name><name>cm</name><operator>-&gt;</operator><name>numcmranges</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* And finally, store back the updated list of ranges */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>cmranges</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>cmranges</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>cmranges</name></name> <operator>=</operator> <name>newranges</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cm</name><operator>-&gt;</operator><name>numcmranges</name></name> <operator>=</operator> <name>numnewranges</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * subcoloronerow - do subcolorcvec's work for one new row in the high colormap
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>subcoloronerow</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
               <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>,
               <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>lp</name></decl></parameter>,
               <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>,
               <parameter><decl><type><name>color</name> <modifier>*</modifier></type><name>lastsubcolor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>cm</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>color</name>       <modifier>*</modifier></type><name>pco</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Apply subcolorhi() and make arc for each entry in row */</comment>
    <expr_stmt><expr><name>pco</name> <operator>=</operator> <operator>&amp;</operator><name><name>cm</name><operator>-&gt;</operator><name>hicolormap</name><index>[<expr><name>rownum</name> <operator>*</operator> <name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name></expr>]</index></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name></expr>;</condition> <incr><expr><name>pco</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>color</name></type>        <name>sco</name> <init>= <expr><call><name>subcolorhi</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><name>pco</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* make the arc if needed */</comment>
        <if_stmt><if>if <condition>(<expr><name>sco</name> <operator>!=</operator> <operator>*</operator><name>lastsubcolor</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>, <argument><expr><name>sco</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>lastsubcolor</name> <operator>=</operator> <name>sco</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * okcolors - promote subcolors to full colors
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>okcolors</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
         <parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>colordesc</name></name> <modifier>*</modifier></type><name>cd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>colordesc</name></name> <modifier>*</modifier></type><name>end</name> <init>= <expr><call><name>CDEND</name><argument_list>(<argument><expr><name>cm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>colordesc</name></name> <modifier>*</modifier></type><name>scd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>color</name></type>        <name>co</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>color</name></type>        <name>sco</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>cd</name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>cd</name></name></expr><operator>,</operator> <expr><name>co</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cd</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>cd</name><operator>++</operator></expr><operator>,</operator> <expr><name>co</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>sco</name> <operator>=</operator> <name><name>cd</name><operator>-&gt;</operator><name>sub</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>UNUSEDCOLOR</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>sco</name> <operator>==</operator> <name>NOSUB</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* has no subcolor, no further action */</comment>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>sco</name> <operator>==</operator> <name>co</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* is subcolor, let parent deal with it */</comment>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>cd</name><operator>-&gt;</operator><name>nschrs</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>cd</name><operator>-&gt;</operator><name>nuchrs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* parent empty, its arcs change color to subcolor */</comment>
            <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>sub</name></name> <operator>=</operator> <name>NOSUB</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>scd</name> <operator>=</operator> <operator>&amp;</operator><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>sco</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>scd</name><operator>-&gt;</operator><name>nschrs</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>scd</name><operator>-&gt;</operator><name>nuchrs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>scd</name><operator>-&gt;</operator><name>sub</name></name> <operator>==</operator> <name>sco</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>scd</name><operator>-&gt;</operator><name>sub</name></name> <operator>=</operator> <name>NOSUB</name></expr>;</expr_stmt>
            <while>while <condition>(<expr><operator>(</operator><name>a</name> <operator>=</operator> <name><name>cd</name><operator>-&gt;</operator><name>arcs</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name> <operator>==</operator> <name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>uncolorchain</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name> <operator>=</operator> <name>sco</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>colorchain</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><call><name>freecolor</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* parent's arcs must gain parallel subcolor arcs */</comment>
            <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>sub</name></name> <operator>=</operator> <name>NOSUB</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>scd</name> <operator>=</operator> <operator>&amp;</operator><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name>sco</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>scd</name><operator>-&gt;</operator><name>nschrs</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>scd</name><operator>-&gt;</operator><name>nuchrs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>scd</name><operator>-&gt;</operator><name>sub</name></name> <operator>==</operator> <name>sco</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>scd</name><operator>-&gt;</operator><name>sub</name></name> <operator>=</operator> <name>NOSUB</name></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>cd</name><operator>-&gt;</operator><name>arcs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>colorchain</name></name></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name> <operator>==</operator> <name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>sco</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * colorchain - add this arc to the color chain of its color
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>colorchain</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>,
           <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>colordesc</name></name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><operator>&amp;</operator><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cd</name><operator>-&gt;</operator><name>arcs</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>arcs</name><operator>-&gt;</operator><name>colorchainRev</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>colorchain</name></name> <operator>=</operator> <name><name>cd</name><operator>-&gt;</operator><name>arcs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>colorchainRev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>arcs</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * uncolorchain - delete this arc from the color chain of its color
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>uncolorchain</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>,
             <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>colordesc</name></name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><operator>&amp;</operator><name><name>cm</name><operator>-&gt;</operator><name>cd</name><index>[<expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>aa</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>colorchainRev</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>aa</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>arcs</name></name> <operator>==</operator> <name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>arcs</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>colorchain</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>aa</name><operator>-&gt;</operator><name>colorchain</name></name> <operator>==</operator> <name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aa</name><operator>-&gt;</operator><name>colorchain</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>colorchain</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>colorchain</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>colorchain</name><operator>-&gt;</operator><name>colorchainRev</name></name> <operator>=</operator> <name>aa</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>colorchain</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* paranoia */</comment>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>colorchainRev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * rainbow - add arcs of all full colors (but one) between specified states
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>rainbow</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
        <parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>,
        <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>,
        <parameter><decl><type><name>color</name></type> <name>but</name></decl></parameter>,                <comment type="block">/* COLORLESS if no exceptions */</comment>
        <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>from</name></decl></parameter>,
        <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>colordesc</name></name> <modifier>*</modifier></type><name>cd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>colordesc</name></name> <modifier>*</modifier></type><name>end</name> <init>= <expr><call><name>CDEND</name><argument_list>(<argument><expr><name>cm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>color</name></type>        <name>co</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>cd</name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>cd</name></name></expr><operator>,</operator> <expr><name>co</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cd</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>CISERR</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>cd</name><operator>++</operator></expr><operator>,</operator> <expr><name>co</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UNUSEDCOLOR</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>cd</name><operator>-&gt;</operator><name>sub</name></name> <operator>!=</operator> <name>co</name> <operator>&amp;&amp;</operator> <name>co</name> <operator>!=</operator> <name>but</name> <operator>&amp;&amp;</operator>
            <operator>!</operator><operator>(</operator><name><name>cd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PSEUDO</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * colorcomplement - add arcs of complementary colors
 *
 * The calling sequence ought to be reconciled with cloneouts().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>colorcomplement</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
                <parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>,
                <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>,
                <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>of</name></decl></parameter>,    <comment type="block">/* complements of this guy's PLAIN outarcs */</comment>
                <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>from</name></decl></parameter>,
                <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>colordesc</name></name> <modifier>*</modifier></type><name>cd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>colordesc</name></name> <modifier>*</modifier></type><name>end</name> <init>= <expr><call><name>CDEND</name><argument_list>(<argument><expr><name>cm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>color</name></type>        <name>co</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>of</name> <operator>!=</operator> <name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>cd</name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>cd</name></name></expr><operator>,</operator> <expr><name>co</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cd</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>CISERR</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>cd</name><operator>++</operator></expr><operator>,</operator> <expr><name>co</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UNUSEDCOLOR</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>cd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PSEUDO</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><call><name>findarc</name><argument_list>(<argument><expr><name>of</name></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>, <argument><expr><name>co</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>

<comment type="block">/*
 * dumpcolors - debugging output
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpcolors</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>,
           <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>colordesc</name></name> <modifier>*</modifier></type><name>cd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>colordesc</name></name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>color</name></type>        <name>co</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>chr</name></type>            <name>c</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"max %ld\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>cm</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>CDEND</name><argument_list>(<argument><expr><name>cm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>cd</name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>cd</name></name> <operator>+</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>co</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>cd</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>cd</name><operator>++</operator></expr><operator>,</operator> <expr><name>co</name><operator>++</operator></expr></incr>)</control> <comment type="block">/* skip 0 */</comment>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UNUSEDCOLOR</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>nschrs</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>cd</name><operator>-&gt;</operator><name>nuchrs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>cd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PSEUDO</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"#%2ld(ps): "</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"#%2ld(%2d): "</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>co</name></expr></argument>, <argument><expr><name><name>cd</name><operator>-&gt;</operator><name>nschrs</name></name> <operator>+</operator> <name><name>cd</name><operator>-&gt;</operator><name>nuchrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/*
             * Unfortunately, it's hard to do this next bit more efficiently.
             */</comment>
            <for>for <control>(<init><expr><name>c</name> <operator>=</operator> <name>CHR_MIN</name></expr>;</init> <condition><expr><name>c</name> <operator>&lt;=</operator> <name>MAX_SIMPLE_CHR</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><call><name>GETCOLOR</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>co</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>dumpchr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <comment type="block">/* dump the high colormap if it contains anything interesting */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>hiarrayrows</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>r</name></decl>,
                    <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>color</name> <modifier>*</modifier></type><name>rowptr</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"other:\t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\t%ld"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>cm</name><operator>-&gt;</operator><name>hicolormap</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>r</name> <operator>&lt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>numcmranges</name></name></expr>;</condition> <incr><expr><name>r</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>dumpchr</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>cmranges</name><index>[<expr><name>r</name></expr>]</index></name><operator>.</operator><name>cmin</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>dumpchr</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>cmranges</name><index>[<expr><name>r</name></expr>]</index></name><operator>.</operator><name>cmax</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rowptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>cm</name><operator>-&gt;</operator><name>hicolormap</name><index>[<expr><name><name>cm</name><operator>-&gt;</operator><name>cmranges</name><index>[<expr><name>r</name></expr>]</index></name><operator>.</operator><name>rownum</name> <operator>*</operator> <name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name></expr>]</index></name></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name><name>cm</name><operator>-&gt;</operator><name>hiarraycols</name></name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\t%ld"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>rowptr</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpchr - print a chr
 *
 * Kind of char-centric but works well enough for debug use.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpchr</name><parameter_list>(<parameter><decl><type><name>chr</name></type> <name>c</name></decl></parameter>,
        <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\\\"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'~'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\u%04lx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* REG_DEBUG */</comment>
</unit>
