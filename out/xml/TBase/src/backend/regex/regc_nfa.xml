<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/regex/regc_nfa.c"><comment type="block">/*
 * NFA utilities.
 * This file is #included by regcomp.c.
 *
 * Copyright (c) 1998, 1999 Henry Spencer.  All rights reserved.
 *
 * Development of this software was funded, in part, by Cray Research Inc.,
 * UUNET Communications Services Inc., Sun Microsystems Inc., and Scriptics
 * Corporation, none of whom are responsible for the results.  The author
 * thanks all of them.
 *
 * Redistribution and use in source and binary forms -- with or without
 * modification -- are permitted for any purpose, provided that
 * redistributions in source form retain this entire copyright notice and
 * indicate the origin and nature of any modifications.
 *
 * I'd appreciate being given credit for this package in the documentation
 * of software which uses it, but that is not a requirement.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * HENRY SPENCER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * src/backend/regex/regc_nfa.c
 *
 *
 * One or two things that technically ought to be in here
 * are actually in color.c, thanks to some incestuous relationships in
 * the color chains.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NISERR</name><parameter_list>()</parameter_list></cpp:macro>    <cpp:value>VISERR(nfa-&gt;v)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NERR</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>        <cpp:value>VERR(nfa-&gt;v, (e))</cpp:value></cpp:define>


<comment type="block">/*
 * newnfa - set up an NFA
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type>                <comment type="block">/* the NFA, or NULL */</comment>
<name>newnfa</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
       <parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>,
       <parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>        <comment type="block">/* NULL if primary NFA */</comment>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>nfa</name> <operator>=</operator> <operator>(</operator>struct <name>nfa</name> <operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>nfa</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nfa</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>states</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>slast</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>nstates</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>cm</name></name> <operator>=</operator> <name>cm</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>COLORLESS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>COLORLESS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>        <comment type="block">/* Precedes newfstate so parent is valid. */</comment>
    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>post</name></name> <operator>=</operator> <call><name>newfstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* number 0 */</comment>
    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>pre</name></name> <operator>=</operator> <call><name>newfstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* number 1 */</comment>

    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>init</name></name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* may become invalid later */</comment>
    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>final</name></name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ISERR</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>freenfa</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>rainbow</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>, <argument><expr><name>COLORLESS</name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>pre</name></name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>init</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><literal type="char">'^'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>pre</name></name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>init</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><literal type="char">'^'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>pre</name></name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>init</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rainbow</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>, <argument><expr><name>COLORLESS</name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>final</name></name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>post</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>final</name></name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>post</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>final</name></name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>post</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>ISERR</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>freenfa</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>nfa</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * freenfa - free an entire NFA
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>freenfa</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nins</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>nouts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* don't worry about arcs */</comment>
        <expr_stmt><expr><call><name>freestate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <while>while <condition>(<expr><operator>(</operator><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>free</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>destroystate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>slast</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>nstates</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>pre</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>post</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * newstate - allocate an NFA state, with zero flag value
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type>            <comment type="block">/* NULL on error */</comment>
<name>newstate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

    <comment type="block">/*
     * This is a handy place to check for operation cancel during regex
     * compilation, since no code path will go very long without making a new
     * state or arc.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>CANCEL_REQUESTED</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_CANCEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>nfa</name><operator>-&gt;</operator><name>free</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>free</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>spaceused</name></name> <operator>&gt;=</operator> <name>REG_MAX_COMPILE_SPACE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ETOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator>struct <name>state</name> <operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>spaceused</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>state</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>oas</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>noas</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>nstates</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>no</name></name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>nstates</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>nfa</name><operator>-&gt;</operator><name>states</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>states</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nins</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ins</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nouts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>outs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>nfa</name><operator>-&gt;</operator><name>slast</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>slast</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>slast</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>slast</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>slast</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
    <return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * newfstate - allocate an NFA state with a specified flag value
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type>            <comment type="block">/* NULL on error */</comment>
<name>newfstate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <name>flag</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dropstate - delete a state's inarcs and outarcs and free it
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dropstate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
          <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ins</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
    <while>while <condition>(<expr><operator>(</operator><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><call><name>freestate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * freestate - free a state, which has no in-arcs or out-arcs
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>freestate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
          <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>nins</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>no</name></name> <operator>=</operator> <name>FREESTATE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>s</name> <operator>==</operator> <name><name>nfa</name><operator>-&gt;</operator><name>slast</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>slast</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>prev</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>s</name> <operator>==</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>states</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>free</name></name></expr>;</expr_stmt>        <comment type="block">/* don't delete it, put it on the free list */</comment>
    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * destroystate - really get rid of an already-freed state
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>destroystate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
             <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>arcbatch</name></name> <modifier>*</modifier></type><name>ab</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arcbatch</name></name> <modifier>*</modifier></type><name>abnext</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>no</name></name> <operator>==</operator> <name>FREESTATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>ab</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>oas</name><operator>.</operator><name>next</name></name></expr>;</init> <condition><expr><name>ab</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ab</name> <operator>=</operator> <name>abnext</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>abnext</name> <operator>=</operator> <name><name>ab</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>ab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>spaceused</name></name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>arcbatch</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ins</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>outs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>spaceused</name></name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>state</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * newarc - set up a new arc within an NFA
 *
 * This function checks to make sure that no duplicate arcs are created.
 * In general we never want duplicates.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>newarc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
       <parameter><decl><type><name>int</name></type> <name>t</name></decl></parameter>,
       <parameter><decl><type><name>color</name></type> <name>co</name></decl></parameter>,
       <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>from</name></decl></parameter>,
       <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>from</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>to</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * This is a handy place to check for operation cancel during regex
     * compilation, since no code path will go very long without making a new
     * state or arc.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>CANCEL_REQUESTED</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_CANCEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* check for duplicate arc, using whichever chain is shorter */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>from</name><operator>-&gt;</operator><name>nouts</name></name> <operator>&lt;=</operator> <name><name>to</name><operator>-&gt;</operator><name>nins</name></name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name> <operator>==</operator> <name>to</name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>co</name></name> <operator>==</operator> <name>co</name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>t</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return;</return></block_content></block></if></if_stmt></block_content></block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>to</name><operator>-&gt;</operator><name>ins</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>inchain</name></name></expr></incr>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name> <operator>==</operator> <name>from</name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>co</name></name> <operator>==</operator> <name>co</name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>t</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return;</return></block_content></block></if></if_stmt></block_content></block></for>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* no dup, so create the arc */</comment>
    <expr_stmt><expr><call><name>createarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * createarc - create a new arc within an NFA
 *
 * This function must *only* be used after verifying that there is no existing
 * identical arc (same type/color/from/to).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>createarc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
          <parameter><decl><type><name>int</name></type> <name>t</name></decl></parameter>,
          <parameter><decl><type><name>color</name></type> <name>co</name></decl></parameter>,
          <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>from</name></decl></parameter>,
          <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <comment type="block">/* the arc is physically allocated within its from-state */</comment>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>allocarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name> <operator>=</operator> <name>co</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name> <operator>=</operator> <name>to</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Put the new arc on the beginning, not the end, of the chains; it's
     * simpler here, and freearc() is the same cost either way.  See also the
     * logic in moveins() and its cohorts, as well as fixempties().
     */</comment>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>inchain</name></name> <operator>=</operator> <name><name>to</name><operator>-&gt;</operator><name>ins</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>inchainRev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>ins</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>ins</name><operator>-&gt;</operator><name>inchainRev</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>ins</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>outchain</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>outs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>outchainRev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>from</name><operator>-&gt;</operator><name>outs</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>from</name><operator>-&gt;</operator><name>outs</name><operator>-&gt;</operator><name>outchainRev</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>from</name><operator>-&gt;</operator><name>outs</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>from</name><operator>-&gt;</operator><name>nouts</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>nins</name></name><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>COLORED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>nfa</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>colorchain</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * allocarc - allocate a new out-arc within a state
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type>                <comment type="block">/* NULL for failure */</comment>
<name>allocarc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
         <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <comment type="block">/* shortcut */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>free</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>noas</name></name> <operator>&lt;</operator> <name>ABSIZE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>oas</name><operator>.</operator><name>a</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>noas</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>noas</name></name><operator>++</operator></expr>;</expr_stmt>
        <return>return <expr><name>a</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if none at hand, get more */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>free</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>arcbatch</name></name> <modifier>*</modifier></type><name>newAb</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>spaceused</name></name> <operator>&gt;=</operator> <name>REG_MAX_COMPILE_SPACE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ETOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>newAb</name> <operator>=</operator> <operator>(</operator>struct <name>arcbatch</name> <operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>arcbatch</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>newAb</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>spaceused</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>arcbatch</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newAb</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>oas</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>oas</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>newAb</name></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ABSIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>newAb</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newAb</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>freechain</name> <operator>=</operator> <operator>&amp;</operator><name><name>newAb</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>newAb</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ABSIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>freechain</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>newAb</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>free</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>free</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>freechain</name></name></expr>;</expr_stmt>
    <return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * freearc - free an arc
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>freearc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
        <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>victim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>from</name> <init>= <expr><name><name>victim</name><operator>-&gt;</operator><name>from</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>to</name> <init>= <expr><name><name>victim</name><operator>-&gt;</operator><name>to</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>predecessor</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>victim</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* take it off color chain if necessary */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>COLORED</name><argument_list>(<argument><expr><name>victim</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>nfa</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>uncolorchain</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>, <argument><expr><name>victim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* take it off source's out-chain */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>from</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>predecessor</name> <operator>=</operator> <name><name>victim</name><operator>-&gt;</operator><name>outchainRev</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>predecessor</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>from</name><operator>-&gt;</operator><name>outs</name></name> <operator>==</operator> <name>victim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>from</name><operator>-&gt;</operator><name>outs</name></name> <operator>=</operator> <name><name>victim</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>predecessor</name><operator>-&gt;</operator><name>outchain</name></name> <operator>==</operator> <name>victim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>predecessor</name><operator>-&gt;</operator><name>outchain</name></name> <operator>=</operator> <name><name>victim</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>victim</name><operator>-&gt;</operator><name>outchain</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>victim</name><operator>-&gt;</operator><name>outchain</name><operator>-&gt;</operator><name>outchainRev</name></name> <operator>==</operator> <name>victim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>victim</name><operator>-&gt;</operator><name>outchain</name><operator>-&gt;</operator><name>outchainRev</name></name> <operator>=</operator> <name>predecessor</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>from</name><operator>-&gt;</operator><name>nouts</name></name><operator>--</operator></expr>;</expr_stmt>

    <comment type="block">/* take it off target's in-chain */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>to</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>predecessor</name> <operator>=</operator> <name><name>victim</name><operator>-&gt;</operator><name>inchainRev</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>predecessor</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>ins</name></name> <operator>==</operator> <name>victim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>ins</name></name> <operator>=</operator> <name><name>victim</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>predecessor</name><operator>-&gt;</operator><name>inchain</name></name> <operator>==</operator> <name>victim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>predecessor</name><operator>-&gt;</operator><name>inchain</name></name> <operator>=</operator> <name><name>victim</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>victim</name><operator>-&gt;</operator><name>inchain</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>victim</name><operator>-&gt;</operator><name>inchain</name><operator>-&gt;</operator><name>inchainRev</name></name> <operator>==</operator> <name>victim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>victim</name><operator>-&gt;</operator><name>inchain</name><operator>-&gt;</operator><name>inchainRev</name></name> <operator>=</operator> <name>predecessor</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt>

    <comment type="block">/* clean up and place on from-state's free list */</comment>
    <expr_stmt><expr><name><name>victim</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>victim</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* precautions... */</comment>
    <expr_stmt><expr><name><name>victim</name><operator>-&gt;</operator><name>to</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>victim</name><operator>-&gt;</operator><name>inchain</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>victim</name><operator>-&gt;</operator><name>inchainRev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>victim</name><operator>-&gt;</operator><name>outchain</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>victim</name><operator>-&gt;</operator><name>outchainRev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>victim</name><operator>-&gt;</operator><name>freechain</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>free</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>from</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name>victim</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * changearctarget - flip an arc to have a different to state
 *
 * Caller must have verified that there is no pre-existing duplicate arc.
 *
 * Note that because we store arcs in their from state, we can't easily have
 * a similar changearcsource function.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>changearctarget</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>newto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>oldto</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>predecessor</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oldto</name> <operator>!=</operator> <name>newto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* take it off old target's in-chain */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oldto</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>predecessor</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>inchainRev</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>predecessor</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>oldto</name><operator>-&gt;</operator><name>ins</name></name> <operator>==</operator> <name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>oldto</name><operator>-&gt;</operator><name>ins</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>predecessor</name><operator>-&gt;</operator><name>inchain</name></name> <operator>==</operator> <name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>predecessor</name><operator>-&gt;</operator><name>inchain</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>inchain</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>inchain</name><operator>-&gt;</operator><name>inchainRev</name></name> <operator>==</operator> <name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>inchain</name><operator>-&gt;</operator><name>inchainRev</name></name> <operator>=</operator> <name>predecessor</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>oldto</name><operator>-&gt;</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name> <operator>=</operator> <name>newto</name></expr>;</expr_stmt>

    <comment type="block">/* prepend it to new target's in-chain */</comment>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>inchain</name></name> <operator>=</operator> <name><name>newto</name><operator>-&gt;</operator><name>ins</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>inchainRev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>newto</name><operator>-&gt;</operator><name>ins</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>newto</name><operator>-&gt;</operator><name>ins</name><operator>-&gt;</operator><name>inchainRev</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>newto</name><operator>-&gt;</operator><name>ins</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newto</name><operator>-&gt;</operator><name>nins</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * hasnonemptyout - Does state have a non-EMPTY out arc?
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>hasnonemptyout</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * findarc - find arc, if any, from given source with given type and color
 * If there is more than one such arc, the result is random.
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type>
<name>findarc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
        <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>,
        <parameter><decl><type><name>color</name></type> <name>co</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>type</name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>co</name></name> <operator>==</operator> <name>co</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>a</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cparc - allocate a new arc within an NFA, copying details from old one
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cparc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
      <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>oa</name></decl></parameter>,
      <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>from</name></decl></parameter>,
      <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>oa</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>oa</name><operator>-&gt;</operator><name>co</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * sortins - sort the in arcs of a state by from/color/type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sortins</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
        <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>sortarray</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>n</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>nins</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* nothing to do */</comment>
    <comment type="block">/* make an array of arc pointers ... */</comment>
    <expr_stmt><expr><name>sortarray</name> <operator>=</operator> <operator>(</operator>struct <name>arc</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>arc</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>sortarray</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ins</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>inchain</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>sortarray</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* ... sort the array */</comment>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>sortarray</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>arc</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>sortins_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* ... and rebuild arc list in order */</comment>
    <comment type="block">/* it seems worth special-casing first and last items to simplify loop */</comment>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>sortarray</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ins</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>inchain</name></name> <operator>=</operator> <name><name>sortarray</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>inchainRev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>sortarray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>inchain</name></name> <operator>=</operator> <name><name>sortarray</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>inchainRev</name></name> <operator>=</operator> <name><name>sortarray</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>sortarray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>inchain</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>inchainRev</name></name> <operator>=</operator> <name><name>sortarray</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>sortarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>sortins_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>aa</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>arc</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>bb</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>arc</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <comment type="block">/* we check the fields in the order they are most likely to be different */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>no</name></name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>no</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>no</name></name> <operator>&gt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>no</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>co</name></name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>co</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>co</name></name> <operator>&gt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>co</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>type</name></name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>type</name></name> <operator>&gt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * sortouts - sort the out arcs of a state by to/color/type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sortouts</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
         <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>sortarray</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>n</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>nouts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* nothing to do */</comment>
    <comment type="block">/* make an array of arc pointers ... */</comment>
    <expr_stmt><expr><name>sortarray</name> <operator>=</operator> <operator>(</operator>struct <name>arc</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>arc</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>sortarray</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>sortarray</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* ... sort the array */</comment>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>sortarray</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>arc</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>sortouts_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* ... and rebuild arc list in order */</comment>
    <comment type="block">/* it seems worth special-casing first and last items to simplify loop */</comment>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>sortarray</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>outs</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>outchain</name></name> <operator>=</operator> <name><name>sortarray</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>outchainRev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>sortarray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>outchain</name></name> <operator>=</operator> <name><name>sortarray</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>outchainRev</name></name> <operator>=</operator> <name><name>sortarray</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>sortarray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>outchain</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>outchainRev</name></name> <operator>=</operator> <name><name>sortarray</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>sortarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>sortouts_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>aa</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>arc</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>bb</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>arc</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <comment type="block">/* we check the fields in the order they are most likely to be different */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>no</name></name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>no</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>no</name></name> <operator>&gt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>no</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>co</name></name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>co</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>co</name></name> <operator>&gt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>co</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>type</name></name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>type</name></name> <operator>&gt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Common decision logic about whether to use arc-by-arc operations or
 * sort/merge.  If there's just a few source arcs we cannot recoup the
 * cost of sorting the destination arc list, no matter how large it is.
 * Otherwise, limit the number of arc-by-arc comparisons to about 1000
 * (a somewhat arbitrary choice, but the breakeven point would probably
 * be machine dependent anyway).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BULK_ARC_OP_USE_SORT</name><parameter_list>(<parameter><type><name>nsrcarcs</name></type></parameter>, <parameter><type><name>ndestarcs</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>((nsrcarcs) &lt; 4 ? 0 : ((nsrcarcs) &gt; 32 || (ndestarcs) &gt; 32))</cpp:value></cpp:define>

<comment type="block">/*
 * moveins - move all in arcs of a state to another state
 *
 * You might think this could be done better by just updating the
 * existing arcs, and you would be right if it weren't for the need
 * for duplicate suppression, which makes it easier to just make new
 * ones to exploit the suppression built into newarc.
 *
 * However, if we have a whole lot of arcs to deal with, retail duplicate
 * checks become too slow.  In that case we proceed by sorting and merging
 * the arc lists, and then we can indeed just update the arcs in-place.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>moveins</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
        <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>oldState</name></decl></parameter>,
        <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>newState</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oldState</name> <operator>!=</operator> <name>newState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BULK_ARC_OP_USE_SORT</name><argument_list>(<argument><expr><name><name>oldState</name><operator>-&gt;</operator><name>nins</name></name></expr></argument>, <argument><expr><name><name>newState</name><operator>-&gt;</operator><name>nins</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* With not too many arcs, just do them one at a time */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

        <while>while <condition>(<expr><operator>(</operator><name>a</name> <operator>=</operator> <name><name>oldState</name><operator>-&gt;</operator><name>ins</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>cparc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name></expr></argument>, <argument><expr><name>newState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * With many arcs, use a sort-merge approach.  Note changearctarget()
         * will put the arc onto the front of newState's chain, so it does not
         * break our walk through the sorted part of the chain.
         */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>oa</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>na</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Because we bypass newarc() in this code path, we'd better include a
         * cancel check.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>CANCEL_REQUESTED</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_CANCEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>sortins</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>oldState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sortins</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>newState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>                <comment type="block">/* might have failed to sort */</comment>
        <expr_stmt><expr><name>oa</name> <operator>=</operator> <name><name>oldState</name><operator>-&gt;</operator><name>ins</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>na</name> <operator>=</operator> <name><name>newState</name><operator>-&gt;</operator><name>ins</name></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>oa</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>na</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>oa</name></expr></init></decl>;</decl_stmt>

            <switch>switch <condition>(<expr><call><name>sortins_cmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oa</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>na</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
                    <comment type="block">/* newState does not have anything matching oa */</comment>
                    <expr_stmt><expr><name>oa</name> <operator>=</operator> <name><name>oa</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Rather than doing createarc+freearc, we can just unlink
                     * and relink the existing arc struct.
                     */</comment>
                    <expr_stmt><expr><call><name>changearctarget</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>newState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="number">0</literal></expr>:</case>
                    <comment type="block">/* match, advance in both lists */</comment>
                    <expr_stmt><expr><name>oa</name> <operator>=</operator> <name><name>oa</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>na</name> <operator>=</operator> <name><name>na</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
                    <comment type="block">/* ... and drop duplicate arc from oldState */</comment>
                    <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><operator>+</operator><literal type="number">1</literal></expr>:</case>
                    <comment type="block">/* advance only na; oa might have a match later */</comment>
                    <expr_stmt><expr><name>na</name> <operator>=</operator> <name><name>na</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NOTREACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></while>
        <while>while <condition>(<expr><name>oa</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* newState does not have anything matching oa */</comment>
            <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>oa</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>oa</name> <operator>=</operator> <name><name>oa</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>changearctarget</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>newState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>oldState</name><operator>-&gt;</operator><name>nins</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>oldState</name><operator>-&gt;</operator><name>ins</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * copyins - copy in arcs of a state to another state
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copyins</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
        <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>oldState</name></decl></parameter>,
        <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>newState</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oldState</name> <operator>!=</operator> <name>newState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BULK_ARC_OP_USE_SORT</name><argument_list>(<argument><expr><name><name>oldState</name><operator>-&gt;</operator><name>nins</name></name></expr></argument>, <argument><expr><name><name>newState</name><operator>-&gt;</operator><name>nins</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* With not too many arcs, just do them one at a time */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>oldState</name><operator>-&gt;</operator><name>ins</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>inchain</name></name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>cparc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name></expr></argument>, <argument><expr><name>newState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * With many arcs, use a sort-merge approach.  Note that createarc()
         * will put new arcs onto the front of newState's chain, so it does
         * not break our walk through the sorted part of the chain.
         */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>oa</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>na</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Because we bypass newarc() in this code path, we'd better include a
         * cancel check.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>CANCEL_REQUESTED</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_CANCEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>sortins</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>oldState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sortins</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>newState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>                <comment type="block">/* might have failed to sort */</comment>
        <expr_stmt><expr><name>oa</name> <operator>=</operator> <name><name>oldState</name><operator>-&gt;</operator><name>ins</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>na</name> <operator>=</operator> <name><name>newState</name><operator>-&gt;</operator><name>ins</name></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>oa</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>na</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>oa</name></expr></init></decl>;</decl_stmt>

            <switch>switch <condition>(<expr><call><name>sortins_cmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oa</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>na</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
                    <comment type="block">/* newState does not have anything matching oa */</comment>
                    <expr_stmt><expr><name>oa</name> <operator>=</operator> <name><name>oa</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>createarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name></expr></argument>, <argument><expr><name>newState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="number">0</literal></expr>:</case>
                    <comment type="block">/* match, advance in both lists */</comment>
                    <expr_stmt><expr><name>oa</name> <operator>=</operator> <name><name>oa</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>na</name> <operator>=</operator> <name><name>na</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><operator>+</operator><literal type="number">1</literal></expr>:</case>
                    <comment type="block">/* advance only na; oa might have a match later */</comment>
                    <expr_stmt><expr><name>na</name> <operator>=</operator> <name><name>na</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NOTREACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></while>
        <while>while <condition>(<expr><name>oa</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* newState does not have anything matching oa */</comment>
            <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>oa</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>oa</name> <operator>=</operator> <name><name>oa</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>createarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name></expr></argument>, <argument><expr><name>newState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * mergeins - merge a list of inarcs into a state
 *
 * This is much like copyins, but the source arcs are listed in an array,
 * and are not guaranteed unique.  It's okay to clobber the array contents.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mergeins</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
         <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
         <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>arcarray</name></decl></parameter>,
         <parameter><decl><type><name>int</name></type> <name>arccount</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>na</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>arccount</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Because we bypass newarc() in this code path, we'd better include a
     * cancel check.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>CANCEL_REQUESTED</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_CANCEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Sort existing inarcs as well as proposed new ones */</comment>
    <expr_stmt><expr><call><name>sortins</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* might have failed to sort */</comment>

    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>arcarray</name></expr></argument>, <argument><expr><name>arccount</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>arc</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>sortins_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * arcarray very likely includes dups, so we must eliminate them.  (This
     * could be folded into the next loop, but it's not worth the trouble.)
     */</comment>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arccount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>sortins_cmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arcarray</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arcarray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
                <comment type="block">/* non-dup */</comment>
                <expr_stmt><expr><name><name>arcarray</name><index>[<expr><operator>++</operator><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>arcarray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">0</literal></expr>:</case>
                <comment type="block">/* dup */</comment>
                <break>break;</break>
            <default>default:</default>
                <comment type="block">/* trouble */</comment>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NOTREACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></for>
    <expr_stmt><expr><name>arccount</name> <operator>=</operator> <name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Now merge into s' inchain.  Note that createarc() will put new arcs
     * onto the front of s's chain, so it does not break our walk through the
     * sorted part of the chain.
     */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>na</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ins</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>arccount</name> <operator>&amp;&amp;</operator> <name>na</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name><name>arcarray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><call><name>sortins_cmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>na</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
                <comment type="block">/* s does not have anything matching a */</comment>
                <expr_stmt><expr><call><name>createarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">0</literal></expr>:</case>
                <comment type="block">/* match, advance in both lists */</comment>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>na</name> <operator>=</operator> <name><name>na</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><operator>+</operator><literal type="number">1</literal></expr>:</case>
                <comment type="block">/* advance only na; array might have a match later */</comment>
                <expr_stmt><expr><name>na</name> <operator>=</operator> <name><name>na</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NOTREACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></while>
    <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>arccount</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* s does not have anything matching a */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name><name>arcarray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>createarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * moveouts - move all out arcs of a state to another state
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>moveouts</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
         <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>oldState</name></decl></parameter>,
         <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>newState</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oldState</name> <operator>!=</operator> <name>newState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BULK_ARC_OP_USE_SORT</name><argument_list>(<argument><expr><name><name>oldState</name><operator>-&gt;</operator><name>nouts</name></name></expr></argument>, <argument><expr><name><name>newState</name><operator>-&gt;</operator><name>nouts</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* With not too many arcs, just do them one at a time */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

        <while>while <condition>(<expr><operator>(</operator><name>a</name> <operator>=</operator> <name><name>oldState</name><operator>-&gt;</operator><name>outs</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>cparc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>newState</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * With many arcs, use a sort-merge approach.  Note that createarc()
         * will put new arcs onto the front of newState's chain, so it does
         * not break our walk through the sorted part of the chain.
         */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>oa</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>na</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Because we bypass newarc() in this code path, we'd better include a
         * cancel check.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>CANCEL_REQUESTED</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_CANCEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>sortouts</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>oldState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sortouts</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>newState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>                <comment type="block">/* might have failed to sort */</comment>
        <expr_stmt><expr><name>oa</name> <operator>=</operator> <name><name>oldState</name><operator>-&gt;</operator><name>outs</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>na</name> <operator>=</operator> <name><name>newState</name><operator>-&gt;</operator><name>outs</name></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>oa</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>na</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>oa</name></expr></init></decl>;</decl_stmt>

            <switch>switch <condition>(<expr><call><name>sortouts_cmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oa</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>na</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
                    <comment type="block">/* newState does not have anything matching oa */</comment>
                    <expr_stmt><expr><name>oa</name> <operator>=</operator> <name><name>oa</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>createarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr></argument>, <argument><expr><name>newState</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="number">0</literal></expr>:</case>
                    <comment type="block">/* match, advance in both lists */</comment>
                    <expr_stmt><expr><name>oa</name> <operator>=</operator> <name><name>oa</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>na</name> <operator>=</operator> <name><name>na</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt>
                    <comment type="block">/* ... and drop duplicate arc from oldState */</comment>
                    <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><operator>+</operator><literal type="number">1</literal></expr>:</case>
                    <comment type="block">/* advance only na; oa might have a match later */</comment>
                    <expr_stmt><expr><name>na</name> <operator>=</operator> <name><name>na</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NOTREACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></while>
        <while>while <condition>(<expr><name>oa</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* newState does not have anything matching oa */</comment>
            <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>oa</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>oa</name> <operator>=</operator> <name><name>oa</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>createarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr></argument>, <argument><expr><name>newState</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>oldState</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>oldState</name><operator>-&gt;</operator><name>outs</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * copyouts - copy out arcs of a state to another state
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copyouts</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
         <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>oldState</name></decl></parameter>,
         <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>newState</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oldState</name> <operator>!=</operator> <name>newState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BULK_ARC_OP_USE_SORT</name><argument_list>(<argument><expr><name><name>oldState</name><operator>-&gt;</operator><name>nouts</name></name></expr></argument>, <argument><expr><name><name>newState</name><operator>-&gt;</operator><name>nouts</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* With not too many arcs, just do them one at a time */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>oldState</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>cparc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>newState</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * With many arcs, use a sort-merge approach.  Note that createarc()
         * will put new arcs onto the front of newState's chain, so it does
         * not break our walk through the sorted part of the chain.
         */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>oa</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>na</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Because we bypass newarc() in this code path, we'd better include a
         * cancel check.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>CANCEL_REQUESTED</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_CANCEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>sortouts</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>oldState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sortouts</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>newState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>                <comment type="block">/* might have failed to sort */</comment>
        <expr_stmt><expr><name>oa</name> <operator>=</operator> <name><name>oldState</name><operator>-&gt;</operator><name>outs</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>na</name> <operator>=</operator> <name><name>newState</name><operator>-&gt;</operator><name>outs</name></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>oa</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>na</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>oa</name></expr></init></decl>;</decl_stmt>

            <switch>switch <condition>(<expr><call><name>sortouts_cmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oa</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>na</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
                    <comment type="block">/* newState does not have anything matching oa */</comment>
                    <expr_stmt><expr><name>oa</name> <operator>=</operator> <name><name>oa</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>createarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr></argument>, <argument><expr><name>newState</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="number">0</literal></expr>:</case>
                    <comment type="block">/* match, advance in both lists */</comment>
                    <expr_stmt><expr><name>oa</name> <operator>=</operator> <name><name>oa</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>na</name> <operator>=</operator> <name><name>na</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><operator>+</operator><literal type="number">1</literal></expr>:</case>
                    <comment type="block">/* advance only na; oa might have a match later */</comment>
                    <expr_stmt><expr><name>na</name> <operator>=</operator> <name><name>na</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NOTREACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></while>
        <while>while <condition>(<expr><name>oa</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* newState does not have anything matching oa */</comment>
            <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>oa</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>oa</name> <operator>=</operator> <name><name>oa</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>createarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr></argument>, <argument><expr><name>newState</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cloneouts - copy out arcs of a state to another state pair, modifying type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cloneouts</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
          <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>old</name></decl></parameter>,
          <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>from</name></decl></parameter>,
          <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>to</name></decl></parameter>,
          <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>old</name> <operator>!=</operator> <name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>old</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * delsub - delete a sub-NFA, updating subre pointers if necessary
 *
 * This uses a recursive traversal of the sub-NFA, marking already-seen
 * states using their tmp pointer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>delsub</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
       <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>lp</name></decl></parameter>,        <comment type="block">/* the sub-NFA goes from here... */</comment>
       <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>)</parameter_list>        <comment type="block">/* ...to here, *not* inclusive */</comment>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lp</name> <operator>!=</operator> <name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>                <comment type="block">/* mark end */</comment>

    <expr_stmt><expr><call><name>deltraverse</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* asserts might not hold after failure */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>rp</name><operator>-&gt;</operator><name>nins</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* did the job */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>no</name></name> <operator>!=</operator> <name>FREESTATE</name> <operator>&amp;&amp;</operator> <name><name>rp</name><operator>-&gt;</operator><name>no</name></name> <operator>!=</operator> <name>FREESTATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* no more */</comment>

    <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>                <comment type="block">/* unmark end */</comment>
    <expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>                <comment type="block">/* and begin, marked by deltraverse */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * deltraverse - the recursive heart of delsub
 * This routine's basic job is to destroy all out-arcs of the state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deltraverse</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
            <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>leftend</name></decl></parameter>,
            <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>to</name></decl>;</decl_stmt>

    <comment type="block">/* Since this is recursive, it could be driven to stack overflow */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>STACK_TOO_DEEP</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ETOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* nothing to do */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* already in progress */</comment>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>                    <comment type="block">/* mark as in progress */</comment>

    <while>while <condition>(<expr><operator>(</operator><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>to</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>deltraverse</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>leftend</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>                <comment type="block">/* asserts might not hold after failure */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>to</name><operator>-&gt;</operator><name>tmp</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>nins</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>to</name><operator>-&gt;</operator><name>tmp</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freestate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>no</name></name> <operator>!=</operator> <name>FREESTATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* we're still here */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>s</name> <operator>==</operator> <name>leftend</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>nins</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* and still reachable */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* but have no outarcs */</comment>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>                <comment type="block">/* we're done here */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * dupnfa - duplicate sub-NFA
 *
 * Another recursive traversal, this time using tmp to point to duplicates
 * as well as mark already-seen states.  (You knew there was a reason why
 * it's a state pointer, didn't you? :-))
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dupnfa</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
       <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>start</name></decl></parameter>,        <comment type="block">/* duplicate of subNFA starting here */</comment>
       <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>stop</name></decl></parameter>,        <comment type="block">/* and stopping here */</comment>
       <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>from</name></decl></parameter>,        <comment type="block">/* stringing duplicate from here */</comment>
       <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list>        <comment type="block">/* to here */</comment>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <name>stop</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>stop</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>to</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>duptraverse</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* done, except for clearing out the tmp pointers */</comment>

    <expr_stmt><expr><name><name>stop</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cleartraverse</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * duptraverse - recursive heart of dupnfa
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>duptraverse</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
            <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
            <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>stmp</name></decl></parameter>)</parameter_list> <comment type="block">/* s's duplicate, or NULL */</comment>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <comment type="block">/* Since this is recursive, it could be driven to stack overflow */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>STACK_TOO_DEEP</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ETOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* already done */</comment>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>stmp</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>newstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>stmp</name></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>duptraverse</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr></argument>, <argument><expr><operator>(</operator>struct <name>state</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>tmp</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>cparc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>tmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * cleartraverse - recursive cleanup for algorithms that leave tmp ptrs set
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleartraverse</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
              <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <comment type="block">/* Since this is recursive, it could be driven to stack overflow */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>STACK_TOO_DEEP</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ETOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>cleartraverse</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * single_color_transition - does getting from s1 to s2 cross one PLAIN arc?
 *
 * If traversing from s1 to s2 requires a single PLAIN match (possibly of any
 * of a set of colors), return a state whose outarc list contains only PLAIN
 * arcs of those color(s).  Otherwise return NULL.
 *
 * This is used before optimizing the NFA, so there may be EMPTY arcs, which
 * we should ignore; the possibility of an EMPTY is why the result state could
 * be different from s1.
 *
 * It's worth troubling to handle multiple parallel PLAIN arcs here because a
 * bracket construct such as [abc] might yield either one or several parallel
 * PLAIN arcs depending on earlier atoms in the expression.  We'd rather that
 * that implementation detail not create user-visible performance differences.
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type>
<name>single_color_transition</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <comment type="block">/* Ignore leading EMPTY arc, if any */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s1</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>s1</name><operator>-&gt;</operator><name>outs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>s1</name> <operator>=</operator> <name><name>s1</name><operator>-&gt;</operator><name>outs</name><operator>-&gt;</operator><name>to</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Likewise for any trailing EMPTY arc */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s2</name><operator>-&gt;</operator><name>nins</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>s2</name><operator>-&gt;</operator><name>ins</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>s2</name> <operator>=</operator> <name><name>s2</name><operator>-&gt;</operator><name>ins</name><operator>-&gt;</operator><name>from</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Perhaps we could have a single-state loop in between, if so reject */</comment>
    <if_stmt><if>if <condition>(<expr><name>s1</name> <operator>==</operator> <name>s2</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* s1 must have at least one outarc... */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s1</name><operator>-&gt;</operator><name>outs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* ... and they must all be PLAIN arcs to s2 */</comment>
    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s1</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>PLAIN</name> <operator>||</operator> <name><name>a</name><operator>-&gt;</operator><name>to</name></name> <operator>!=</operator> <name>s2</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <comment type="block">/* OK, return s1 as the possessor of the relevant outarcs */</comment>
    <return>return <expr><name>s1</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * specialcolors - fill in special colors for an NFA
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>specialcolors</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* false colors for BOS, BOL, EOS, EOL */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>nfa</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>pseudocolor</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>pseudocolor</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>pseudocolor</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>pseudocolor</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>COLORLESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>COLORLESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>COLORLESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>COLORLESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * optimize - optimize an NFA
 *
 * The main goal of this function is not so much "optimization" (though it
 * does try to get rid of useless NFA states) as reducing the NFA to a form
 * the regex executor can handle.  The executor, and indeed the cNFA format
 * that is its input, can only handle PLAIN and LACON arcs.  The output of
 * the regex parser also includes EMPTY (do-nothing) arcs, as well as
 * ^, $, AHEAD, and BEHIND constraint arcs, which we must get rid of here.
 * We first get rid of EMPTY arcs and then deal with the constraint arcs.
 * The hardest part of either job is to get rid of circular loops of the
 * target arc type.  We would have to do that in any case, though, as such a
 * loop would otherwise allow the executor to cycle through the loop endlessly
 * without making any progress in the input string.
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>                        <comment type="block">/* re_info bits */</comment>
<name>optimize</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
         <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>                <comment type="block">/* for debug output; NULL none */</comment>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type>            <name>verbose</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>f</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\ninitial cleanup:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>cleanup</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                <comment type="block">/* may simplify situation */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>dumpnfa</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\nempties:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>fixempties</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* get rid of EMPTY arcs */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\nconstraints:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>fixconstraintloops</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get rid of constraint loops */</comment>
    <expr_stmt><expr><call><name>pullback</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* pull back constraints backward */</comment>
    <expr_stmt><expr><call><name>pushfwd</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* push fwd constraints forward */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\nfinal cleanup:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>cleanup</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                <comment type="block">/* final tidying */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>dumpnfa</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><call><name>analyze</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</return>        <comment type="block">/* and analysis */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * pullback - pull back constraints backward to eliminate them
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pullback</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
         <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>                <comment type="block">/* for debug output; NULL none */</comment>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>nexts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>nexta</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>intermediates</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>progress</name></decl>;</decl_stmt>

    <comment type="block">/* find and pull until there are no more */</comment>
    <do>do
    <block>{<block_content>
        <expr_stmt><expr><name>progress</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name>nexts</name></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>nexts</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>intermediates</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name>nexta</name></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name>nexta</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <literal type="char">'^'</literal> <operator>||</operator> <name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BEHIND</name></expr>)</condition><block type="pseudo"><block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>pull</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>intermediates</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>progress</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
            <comment type="block">/* clear tmp fields of intermediate states created here */</comment>
            <while>while <condition>(<expr><name>intermediates</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>ns</name> <init>= <expr><name><name>intermediates</name><operator>-&gt;</operator><name>tmp</name></name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>intermediates</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>intermediates</name> <operator>=</operator> <name>ns</name></expr>;</expr_stmt>
            </block_content>}</block></while>
            <comment type="block">/* if s is now useless, get rid of it */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>nins</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>flag</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>dropstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>progress</name> <operator>&amp;&amp;</operator> <name>f</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>dumpnfa</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><name>progress</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition>;</do>
    <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Any ^ constraints we were able to pull to the start state can now be
     * replaced by PLAIN arcs referencing the BOS or BOL colors.  There should
     * be no other ^ or BEHIND arcs left in the NFA, though we do not check
     * that here (compact() will fail if so).
     */</comment>
    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>pre</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name>nexta</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>nexta</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <literal type="char">'^'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>a</name><operator>-&gt;</operator><name>co</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * pull - pull a back constraint backward past its source state
 *
 * Returns 1 if successful (which it always is unless the source is the
 * start state or we have an internal error), 0 if nothing happened.
 *
 * A significant property of this function is that it deletes no pre-existing
 * states, and no outarcs of the constraint's from state other than the given
 * constraint arc.  This makes the loops in pullback() safe, at the cost that
 * we may leave useless states behind.  Therefore, we leave it to pullback()
 * to delete such states.
 *
 * If the from state has multiple back-constraint outarcs, and/or multiple
 * compatible constraint inarcs, we only need to create one new intermediate
 * state per combination of predecessor and successor states.  *intermediates
 * points to a list of such intermediate states for this from state (chained
 * through their tmp fields).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pull</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
     <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>con</name></decl></parameter>,
     <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>intermediates</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>from</name> <init>= <expr><name><name>con</name><operator>-&gt;</operator><name>from</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>to</name> <init>= <expr><name><name>con</name><operator>-&gt;</operator><name>to</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>nexta</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>from</name> <operator>!=</operator> <name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* should have gotten rid of this earlier */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>from</name><operator>-&gt;</operator><name>flag</name></name></expr>)</condition><block type="pseudo"><block_content>                <comment type="block">/* can't pull back beyond start */</comment>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>from</name><operator>-&gt;</operator><name>nins</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>                            <comment type="block">/* unreachable */</comment>
        <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * First, clone from state if necessary to avoid other outarcs.  This may
     * seem wasteful, but it simplifies the logic, and we'll get rid of the
     * clone state again at the bottom.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>from</name><operator>-&gt;</operator><name>nouts</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>copyins</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* duplicate inarcs */</comment>
        <expr_stmt><expr><call><name>cparc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>con</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* move constraint arc */</comment>
        <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>from</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>con</name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>outs</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>from</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* propagate the constraint into the from state's inarcs */</comment>
    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>ins</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name>nexta</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>nexta</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><call><name>combine</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>INCOMPATIBLE</name></expr>:</case>    <comment type="block">/* destroy the arc */</comment>
                <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>SATISFIED</name></expr>:</case>        <comment type="block">/* no action needed */</comment>
                <break>break;</break>
            <case>case <expr><name>COMPATIBLE</name></expr>:</case>    <comment type="block">/* swap the two arcs, more or less */</comment>
                <comment type="block">/* need an intermediate state, but might have one already */</comment>
                <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <operator>*</operator><name>intermediates</name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>tmp</name></name></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>nins</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>nouts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ins</name><operator>-&gt;</operator><name>from</name></name> <operator>==</operator> <name><name>a</name><operator>-&gt;</operator><name>from</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name><operator>-&gt;</operator><name>to</name></name> <operator>==</operator> <name>to</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <operator>*</operator><name>intermediates</name></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>intermediates</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>cparc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>con</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>cparc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NOTREACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></for>

    <comment type="block">/* remaining inarcs, if any, incorporate the constraint */</comment>
    <expr_stmt><expr><call><name>moveins</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* from state is now useless, but we leave it to pullback() to clean up */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pushfwd - push forward constraints forward to eliminate them
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pushfwd</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
        <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>                <comment type="block">/* for debug output; NULL none */</comment>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>nexts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>nexta</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>intermediates</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>progress</name></decl>;</decl_stmt>

    <comment type="block">/* find and push until there are no more */</comment>
    <do>do
    <block>{<block_content>
        <expr_stmt><expr><name>progress</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name>nexts</name></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>nexts</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>intermediates</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ins</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name>nexta</name></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name>nexta</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <literal type="char">'$'</literal> <operator>||</operator> <name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AHEAD</name></expr>)</condition><block type="pseudo"><block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>push</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>intermediates</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>progress</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
            <comment type="block">/* clear tmp fields of intermediate states created here */</comment>
            <while>while <condition>(<expr><name>intermediates</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>ns</name> <init>= <expr><name><name>intermediates</name><operator>-&gt;</operator><name>tmp</name></name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>intermediates</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>intermediates</name> <operator>=</operator> <name>ns</name></expr>;</expr_stmt>
            </block_content>}</block></while>
            <comment type="block">/* if s is now useless, get rid of it */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>nins</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>flag</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>dropstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>progress</name> <operator>&amp;&amp;</operator> <name>f</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>dumpnfa</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><name>progress</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition>;</do>
    <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Any $ constraints we were able to push to the post state can now be
     * replaced by PLAIN arcs referencing the EOS or EOL colors.  There should
     * be no other $ or AHEAD arcs left in the NFA, though we do not check
     * that here (compact() will fail if so).
     */</comment>
    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>post</name><operator>-&gt;</operator><name>ins</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name>nexta</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>nexta</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>a</name><operator>-&gt;</operator><name>co</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * push - push a forward constraint forward past its destination state
 *
 * Returns 1 if successful (which it always is unless the destination is the
 * post state or we have an internal error), 0 if nothing happened.
 *
 * A significant property of this function is that it deletes no pre-existing
 * states, and no inarcs of the constraint's to state other than the given
 * constraint arc.  This makes the loops in pushfwd() safe, at the cost that
 * we may leave useless states behind.  Therefore, we leave it to pushfwd()
 * to delete such states.
 *
 * If the to state has multiple forward-constraint inarcs, and/or multiple
 * compatible constraint outarcs, we only need to create one new intermediate
 * state per combination of predecessor and successor states.  *intermediates
 * points to a list of such intermediate states for this to state (chained
 * through their tmp fields).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>push</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
     <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>con</name></decl></parameter>,
     <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>intermediates</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>from</name> <init>= <expr><name><name>con</name><operator>-&gt;</operator><name>from</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>to</name> <init>= <expr><name><name>con</name><operator>-&gt;</operator><name>to</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>nexta</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>to</name> <operator>!=</operator> <name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* should have gotten rid of this earlier */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>flag</name></name></expr>)</condition><block type="pseudo"><block_content>                <comment type="block">/* can't push forward beyond end */</comment>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>                            <comment type="block">/* dead end */</comment>
        <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * First, clone to state if necessary to avoid other inarcs.  This may
     * seem wasteful, but it simplifies the logic, and we'll get rid of the
     * clone state again at the bottom.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>nins</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>copyouts</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* duplicate outarcs */</comment>
        <expr_stmt><expr><call><name>cparc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>con</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* move constraint arc */</comment>
        <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>to</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>con</name> <operator>=</operator> <name><name>to</name><operator>-&gt;</operator><name>ins</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>nins</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* propagate the constraint into the to state's outarcs */</comment>
    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>to</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name>nexta</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>nexta</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><call><name>combine</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>INCOMPATIBLE</name></expr>:</case>    <comment type="block">/* destroy the arc */</comment>
                <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>SATISFIED</name></expr>:</case>        <comment type="block">/* no action needed */</comment>
                <break>break;</break>
            <case>case <expr><name>COMPATIBLE</name></expr>:</case>    <comment type="block">/* swap the two arcs, more or less */</comment>
                <comment type="block">/* need an intermediate state, but might have one already */</comment>
                <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <operator>*</operator><name>intermediates</name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>tmp</name></name></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>nins</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>nouts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ins</name><operator>-&gt;</operator><name>from</name></name> <operator>==</operator> <name>from</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name><operator>-&gt;</operator><name>to</name></name> <operator>==</operator> <name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <operator>*</operator><name>intermediates</name></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>intermediates</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>cparc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>con</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>cparc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NOTREACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></for>

    <comment type="block">/* remaining outarcs, if any, incorporate the constraint */</comment>
    <expr_stmt><expr><call><name>moveouts</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* to state is now useless, but we leave it to pushfwd() to clean up */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * combine - constraint lands on an arc, what happens?
 *
 * #def INCOMPATIBLE    1    // destroys arc
 * #def SATISFIED        2    // constraint satisfied
 * #def COMPATIBLE        3    // compatible but not satisfied yet
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>combine</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>con</name></decl></parameter>,
        <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>CA</name><parameter_list>(<parameter><type><name>ct</name></type></parameter>,<parameter><type><name>at</name></type></parameter>)</parameter_list></cpp:macro>     <cpp:value>(((ct)&lt;&lt;CHAR_BIT) | (at))</cpp:value></cpp:define>

    <switch>switch <condition>(<expr><call><name>CA</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><literal type="char">'^'</literal></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>)</argument_list></call></expr>:</case>    <comment type="block">/* newlines are handled separately */</comment>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><literal type="char">'$'</literal></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>)</argument_list></call></expr>:</case>
            <return>return <expr><name>INCOMPATIBLE</name></expr>;</return>
            <break>break;</break>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><name>AHEAD</name></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>)</argument_list></call></expr>:</case>    <comment type="block">/* color constraints meet colors */</comment>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><name>BEHIND</name></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>)</argument_list></call></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>co</name></name> <operator>==</operator> <name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>SATISFIED</name></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><name>INCOMPATIBLE</name></expr>;</return>
            <break>break;</break>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><literal type="char">'^'</literal></expr></argument>, <argument><expr><literal type="char">'^'</literal></expr></argument>)</argument_list></call></expr>:</case>        <comment type="block">/* collision, similar constraints */</comment>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><literal type="char">'$'</literal></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr>:</case>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><name>AHEAD</name></expr></argument>, <argument><expr><name>AHEAD</name></expr></argument>)</argument_list></call></expr>:</case>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><name>BEHIND</name></expr></argument>, <argument><expr><name>BEHIND</name></expr></argument>)</argument_list></call></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>co</name></name> <operator>==</operator> <name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* true duplication */</comment>
                <return>return <expr><name>SATISFIED</name></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><name>INCOMPATIBLE</name></expr>;</return>
            <break>break;</break>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><literal type="char">'^'</literal></expr></argument>, <argument><expr><name>BEHIND</name></expr></argument>)</argument_list></call></expr>:</case>    <comment type="block">/* collision, dissimilar constraints */</comment>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><name>BEHIND</name></expr></argument>, <argument><expr><literal type="char">'^'</literal></expr></argument>)</argument_list></call></expr>:</case>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><literal type="char">'$'</literal></expr></argument>, <argument><expr><name>AHEAD</name></expr></argument>)</argument_list></call></expr>:</case>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><name>AHEAD</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr>:</case>
            <return>return <expr><name>INCOMPATIBLE</name></expr>;</return>
            <break>break;</break>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><literal type="char">'^'</literal></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr>:</case>        <comment type="block">/* constraints passing each other */</comment>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><literal type="char">'^'</literal></expr></argument>, <argument><expr><name>AHEAD</name></expr></argument>)</argument_list></call></expr>:</case>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><name>BEHIND</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr>:</case>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><name>BEHIND</name></expr></argument>, <argument><expr><name>AHEAD</name></expr></argument>)</argument_list></call></expr>:</case>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><literal type="char">'$'</literal></expr></argument>, <argument><expr><literal type="char">'^'</literal></expr></argument>)</argument_list></call></expr>:</case>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><literal type="char">'$'</literal></expr></argument>, <argument><expr><name>BEHIND</name></expr></argument>)</argument_list></call></expr>:</case>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><name>AHEAD</name></expr></argument>, <argument><expr><literal type="char">'^'</literal></expr></argument>)</argument_list></call></expr>:</case>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><name>AHEAD</name></expr></argument>, <argument><expr><name>BEHIND</name></expr></argument>)</argument_list></call></expr>:</case>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><literal type="char">'^'</literal></expr></argument>, <argument><expr><name>LACON</name></expr></argument>)</argument_list></call></expr>:</case>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><name>BEHIND</name></expr></argument>, <argument><expr><name>LACON</name></expr></argument>)</argument_list></call></expr>:</case>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><literal type="char">'$'</literal></expr></argument>, <argument><expr><name>LACON</name></expr></argument>)</argument_list></call></expr>:</case>
        <case>case <expr><call><name>CA</name><argument_list>(<argument><expr><name>AHEAD</name></expr></argument>, <argument><expr><name>LACON</name></expr></argument>)</argument_list></call></expr>:</case>
            <return>return <expr><name>COMPATIBLE</name></expr>;</return>
            <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NOTREACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>INCOMPATIBLE</name></expr>;</return>        <comment type="block">/* for benefit of blind compilers */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * fixempties - get rid of EMPTY arcs
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fixempties</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
           <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>                <comment type="block">/* for debug output; NULL none */</comment>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>nexts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>nexta</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>totalinarcs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>inarcsorig</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>arcarray</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>arccount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>prevnins</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nskip</name></decl>;</decl_stmt>

    <comment type="block">/*
     * First, get rid of any states whose sole out-arc is an EMPTY, since
     * they're basically just aliases for their successor.  The parsing
     * algorithm creates enough of these that it's worth special-casing this.
     */</comment>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name>nexts</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>nexts</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>flag</name></name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>nouts</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>moveins</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>dropstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Similarly, get rid of any state with a single EMPTY in-arc, by folding
     * it into its predecessor.
     */</comment>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name>nexts</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>nexts</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <comment type="block">/* while we're at it, ensure tmp fields are clear for next step */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>flag</name></name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>nins</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ins</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>inchain</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name><name>a</name><operator>-&gt;</operator><name>from</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>moveouts</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>dropstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * For each remaining NFA state, find all other states from which it is
     * reachable by a chain of one or more EMPTY arcs.  Then generate new arcs
     * that eliminate the need for each such chain.
     *
     * We could replace a chain of EMPTY arcs that leads from a "from" state
     * to a "to" state either by pushing non-EMPTY arcs forward (linking
     * directly from "from"'s predecessors to "to") or by pulling them back
     * (linking directly from "from" to "to"'s successors).  We choose to
     * always do the former; this choice is somewhat arbitrary, but the
     * approach below requires that we uniformly do one or the other.
     *
     * Suppose we have a chain of N successive EMPTY arcs (where N can easily
     * approach the size of the NFA).  All of the intermediate states must
     * have additional inarcs and outarcs, else they'd have been removed by
     * the steps above.  Assuming their inarcs are mostly not empties, we will
     * add O(N^2) arcs to the NFA, since a non-EMPTY inarc leading to any one
     * state in the chain must be duplicated to lead to all its successor
     * states as well.  So there is no hope of doing less than O(N^2) work;
     * however, we should endeavor to keep the big-O cost from being even
     * worse than that, which it can easily become without care.  In
     * particular, suppose we were to copy all S1's inarcs forward to S2, and
     * then also to S3, and then later we consider pushing S2's inarcs forward
     * to S3.  If we include the arcs already copied from S1 in that, we'd be
     * doing O(N^3) work.  (The duplicate-arc elimination built into newarc()
     * and its cohorts would get rid of the extra arcs, but not without cost.)
     *
     * We can avoid this cost by treating only arcs that existed at the start
     * of this phase as candidates to be pushed forward.  To identify those,
     * we remember the first inarc each state had to start with.  We rely on
     * the fact that newarc() and friends put new arcs on the front of their
     * to-states' inchains, and that this phase never deletes arcs, so that
     * the original arcs must be the last arcs in their to-states' inchains.
     *
     * So the process here is that, for each state in the NFA, we gather up
     * all non-EMPTY inarcs of states that can reach the target state via
     * EMPTY arcs.  We then sort, de-duplicate, and merge these arcs into the
     * target state's inchain.  (We can safely use sort-merge for this as long
     * as we update each state's original-arcs pointer after we add arcs to
     * it; the sort step of mergeins probably changed the order of the old
     * arcs.)
     *
     * Another refinement worth making is that, because we only add non-EMPTY
     * arcs during this phase, and all added arcs have the same from-state as
     * the non-EMPTY arc they were cloned from, we know ahead of time that any
     * states having only EMPTY outarcs will be useless for lack of outarcs
     * after we drop the EMPTY arcs.  (They cannot gain non-EMPTY outarcs if
     * they had none to start with.)  So we need not bother to update the
     * inchains of such states at all.
     */</comment>

    <comment type="block">/* Remember the states' first original inarcs */</comment>
    <comment type="block">/* ... and while at it, count how many old inarcs there are altogether */</comment>
    <expr_stmt><expr><name>inarcsorig</name> <operator>=</operator> <operator>(</operator>struct <name>arc</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>nstates</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>arc</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>inarcsorig</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>totalinarcs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>inarcsorig</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>no</name></name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ins</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>totalinarcs</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>nins</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Create a workspace for accumulating the inarcs to be added to the
     * current target state.  totalinarcs is probably a considerable
     * overestimate of the space needed, but the NFA is unlikely to be large
     * enough at this point to make it worth being smarter.
     */</comment>
    <expr_stmt><expr><name>arcarray</name> <operator>=</operator> <operator>(</operator>struct <name>arc</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><name>totalinarcs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>arc</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>arcarray</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>inarcsorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* And iterate over the target states */</comment>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* Ignore target states without non-EMPTY outarcs, per note above */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>flag</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>hasnonemptyout</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Find predecessor states and accumulate their original inarcs */</comment>
        <expr_stmt><expr><name>arccount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>s2</name> <operator>=</operator> <call><name>emptyreachable</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>inarcsorig</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>s2</name> <operator>!=</operator> <name>s</name></expr>;</condition> <incr><expr><name>s2</name> <operator>=</operator> <name>nexts</name></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* Add s2's original inarcs to arcarray[], but ignore empties */</comment>
            <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>inarcsorig</name><index>[<expr><name><name>s2</name><operator>-&gt;</operator><name>no</name></name></expr>]</index></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>inchain</name></name></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>arcarray</name><index>[<expr><name>arccount</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="block">/* Reset the tmp fields as we walk back */</comment>
            <expr_stmt><expr><name>nexts</name> <operator>=</operator> <name><name>s2</name><operator>-&gt;</operator><name>tmp</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>arccount</name> <operator>&lt;=</operator> <name>totalinarcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Remember how many original inarcs this state has */</comment>
        <expr_stmt><expr><name>prevnins</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>nins</name></name></expr>;</expr_stmt>

        <comment type="block">/* Add non-duplicate inarcs to target state */</comment>
        <expr_stmt><expr><call><name>mergeins</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>arcarray</name></expr></argument>, <argument><expr><name>arccount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Now we must update the state's inarcsorig pointer */</comment>
        <expr_stmt><expr><name>nskip</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>nins</name></name> <operator>-</operator> <name>prevnins</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ins</name></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>nskip</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name><name>inarcsorig</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>no</name></name></expr>]</index></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>arcarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>inarcsorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Now remove all the EMPTY arcs, since we don't need them anymore.
     */</comment>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name>nexta</name></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>nexta</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <comment type="block">/*
     * And remove any states that have become useless.  (This cleanup is not
     * very thorough, and would be even less so if we tried to combine it with
     * the previous step; but cleanup() will take care of anything we miss.)
     */</comment>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name>nexts</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>nexts</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>nins</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>flag</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>dropstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>dumpnfa</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * emptyreachable - recursively find all states that can reach s by EMPTY arcs
 *
 * The return value is the last such state found.  Its tmp field links back
 * to the next-to-last such state, and so on back to s, so that all these
 * states can be located without searching the whole NFA.
 *
 * Since this is only used in fixempties(), we pass in the inarcsorig[] array
 * maintained by that function.  This lets us skip over all new inarcs, which
 * are certainly not EMPTY arcs.
 *
 * The maximum recursion depth here is equal to the length of the longest
 * loop-free chain of EMPTY arcs, which is surely no more than the size of
 * the NFA ... but that could still be enough to cause trouble.
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type>
<name>emptyreachable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
               <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
               <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>lastfound</name></decl></parameter>,
               <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>inarcsorig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <comment type="block">/* Since this is recursive, it could be driven to stack overflow */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>STACK_TOO_DEEP</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ETOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>lastfound</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>lastfound</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lastfound</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>inarcsorig</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>no</name></name></expr>]</index></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>inchain</name></name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>EMPTY</name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>tmp</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>lastfound</name> <operator>=</operator> <call><name>emptyreachable</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name></expr></argument>, <argument><expr><name>lastfound</name></expr></argument>, <argument><expr><name>inarcsorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>lastfound</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * isconstraintarc - detect whether an arc is of a constraint type
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>isconstraintarc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="char">'^'</literal></expr>:</case>
        <case>case <expr><literal type="char">'$'</literal></expr>:</case>
        <case>case <expr><name>BEHIND</name></expr>:</case>
        <case>case <expr><name>AHEAD</name></expr>:</case>
        <case>case <expr><name>LACON</name></expr>:</case>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></switch>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * hasconstraintout - does state have a constraint out arc?
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>hasconstraintout</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isconstraintarc</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fixconstraintloops - get rid of loops containing only constraint arcs
 *
 * A loop of states that contains only constraint arcs is useless, since
 * passing around the loop represents no forward progress.  Moreover, it
 * would cause infinite looping in pullback/pushfwd, so we need to get rid
 * of such loops before doing that.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fixconstraintloops</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
                   <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>        <comment type="block">/* for debug output; NULL none */</comment>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>nexts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>nexta</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>hasconstraints</name></decl>;</decl_stmt>

    <comment type="block">/*
     * In the trivial case of a state that loops to itself, we can just drop
     * the constraint arc altogether.  This is worth special-casing because
     * such loops are far more common than loops containing multiple states.
     * While we're at it, note whether any constraint arcs survive.
     */</comment>
    <expr_stmt><expr><name>hasconstraints</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name>nexts</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>nexts</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <comment type="block">/* while we're at it, ensure tmp fields are clear for next step */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name>nexta</name></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>nexta</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>isconstraintarc</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name> <operator>==</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>hasconstraints</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <comment type="block">/* If we removed all the outarcs, the state is useless. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>flag</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>dropstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Nothing to do if no remaining constraint arcs */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><name>hasconstraints</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Starting from each remaining NFA state, search outwards for a
     * constraint loop.  If we find a loop, break the loop, then start the
     * search over.  (We could possibly retain some state from the first scan,
     * but it would complicate things greatly, and multi-state constraint
     * loops are rare enough that it's not worth optimizing the case.)
     */</comment>
<label><name>restart</name>:</label>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>findconstraintloop</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>restart</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Now remove any states that have become useless.  (This cleanup is not
     * very thorough, and would be even less so if we tried to combine it with
     * the previous step; but cleanup() will take care of anything we miss.)
     *
     * Because findconstraintloop intentionally doesn't reset all tmp fields,
     * we have to clear them after it's done.  This is a convenient place to
     * do that, too.
     */</comment>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name>nexts</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>nexts</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>nins</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>flag</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>dropstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>dumpnfa</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * findconstraintloop - recursively find a loop of constraint arcs
 *
 * If we find a loop, break it by calling breakconstraintloop(), then
 * return 1; otherwise return 0.
 *
 * State tmp fields are guaranteed all NULL on a success return, because
 * breakconstraintloop does that.  After a failure return, any state that
 * is known not to be part of a loop is marked with s-&gt;tmp == s; this allows
 * us not to have to re-prove that fact on later calls.  (This convention is
 * workable because we already eliminated single-state loops.)
 *
 * Note that the found loop doesn't necessarily include the first state we
 * are called on.  Any loop reachable from that state will do.
 *
 * The maximum recursion depth here is one more than the length of the longest
 * loop-free chain of constraint arcs, which is surely no more than the size
 * of the NFA ... but that could still be enough to cause trouble.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>findconstraintloop</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <comment type="block">/* Since this is recursive, it could be driven to stack overflow */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>STACK_TOO_DEEP</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ETOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>                <comment type="block">/* to exit as quickly as possible */</comment>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Already proven uninteresting? */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>==</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <comment type="block">/* Found a loop involving s */</comment>
        <expr_stmt><expr><call><name>breakconstraintloop</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* The tmp fields have been cleaned up by breakconstraintloop */</comment>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isconstraintarc</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sto</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sto</name> <operator>!=</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>sto</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>findconstraintloop</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>sto</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * If we get here, no constraint loop exists leading out from s.  Mark it
     * with s-&gt;tmp == s so we need not rediscover that fact again later.
     */</comment>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * breakconstraintloop - break a loop of constraint arcs
 *
 * sinitial is any one member state of the loop.  Each loop member's tmp
 * field links to its successor within the loop.  (Note that this function
 * will reset all the tmp fields to NULL.)
 *
 * We can break the loop by, for any one state S1 in the loop, cloning its
 * loop successor state S2 (and possibly following states), and then moving
 * all S1-&gt;S2 constraint arcs to point to the cloned S2.  The cloned S2 should
 * copy any non-constraint outarcs of S2.  Constraint outarcs should be
 * dropped if they point back to S1, else they need to be copied as arcs to
 * similarly cloned states S3, S4, etc.  In general, each cloned state copies
 * non-constraint outarcs, drops constraint outarcs that would lead to itself
 * or any earlier cloned state, and sends other constraint outarcs to newly
 * cloned states.  No cloned state will have any inarcs that aren't constraint
 * arcs or do not lead from S1 or earlier-cloned states.  It's okay to drop
 * constraint back-arcs since they would not take us to any state we've not
 * already been in; therefore, no new constraint loop is created.  In this way
 * we generate a modified NFA that can still represent every useful state
 * sequence, but not sequences that represent state loops with no consumption
 * of input data.  Note that the set of cloned states will certainly include
 * all of the loop member states other than S1, and it may also include
 * non-loop states that are reachable from S2 via constraint arcs.  This is
 * important because there is no guarantee that findconstraintloop found a
 * maximal loop (and searching for one would be NP-hard, so don't try).
 * Frequently the "non-loop states" are actually part of a larger loop that
 * we didn't notice, and indeed there may be several overlapping loops.
 * This technique ensures convergence in such cases, while considering only
 * the originally-found loop does not.
 *
 * If there is only one S1-&gt;S2 constraint arc, then that constraint is
 * certainly satisfied when we enter any of the clone states.  This means that
 * in the common case where many of the constraint arcs are identically
 * labeled, we can merge together clone states linked by a similarly-labeled
 * constraint: if we can get to the first one we can certainly get to the
 * second, so there's no need to distinguish.  This greatly reduces the number
 * of new states needed, so we preferentially break the given loop at a state
 * pair where this is true.
 *
 * Furthermore, it's fairly common to find that a cloned successor state has
 * no outarcs, especially if we're a bit aggressive about removing unnecessary
 * outarcs.  If that happens, then there is simply not any interesting state
 * that can be reached through the predecessor's loop arcs, which means we can
 * break the loop just by removing those loop arcs, with no new states added.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>breakconstraintloop</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sinitial</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>shead</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>stail</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sclone</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>nexts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>refarc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>nexta</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Start by identifying which loop step we want to break at.
     * Preferentially this is one with only one constraint arc.  (XXX are
     * there any other secondary heuristics we want to use here?)  Set refarc
     * to point to the selected lone constraint arc, if there is one.
     */</comment>
    <expr_stmt><expr><name>refarc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name>sinitial</name></expr>;</expr_stmt>
    <do>do
    <block>{<block_content>
        <expr_stmt><expr><name>nexts</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>tmp</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nexts</name> <operator>!=</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* should not see any one-element loops */</comment>
        <if_stmt><if>if <condition>(<expr><name>refarc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>narcs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name> <operator>==</operator> <name>nexts</name> <operator>&amp;&amp;</operator> <call><name>isconstraintarc</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>refarc</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>narcs</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>narcs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>narcs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>refarc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* multiple constraint arcs here, no good */</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <name>nexts</name></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name>s</name> <operator>!=</operator> <name>sinitial</name></expr>)</condition>;</do>

    <if_stmt><if>if <condition>(<expr><name>refarc</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* break at the refarc */</comment>
        <expr_stmt><expr><name>shead</name> <operator>=</operator> <name><name>refarc</name><operator>-&gt;</operator><name>from</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>stail</name> <operator>=</operator> <name><name>refarc</name><operator>-&gt;</operator><name>to</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stail</name> <operator>==</operator> <name><name>shead</name><operator>-&gt;</operator><name>tmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* for lack of a better idea, break after sinitial */</comment>
        <expr_stmt><expr><name>shead</name> <operator>=</operator> <name>sinitial</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>stail</name> <operator>=</operator> <name><name>sinitial</name><operator>-&gt;</operator><name>tmp</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Reset the tmp fields so that we can use them for local storage in
     * clonesuccessorstates.  (findconstraintloop won't mind, since it's just
     * going to abandon its search anyway.)
     */</comment>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/*
     * Recursively build clone state(s) as needed.
     */</comment>
    <expr_stmt><expr><name>sclone</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>sclone</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>clonesuccessorstates</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>stail</name></expr></argument>, <argument><expr><name>sclone</name></expr></argument>, <argument><expr><name>shead</name></expr></argument>, <argument><expr><name>refarc</name></expr></argument>,
                         <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>nstates</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * It's possible that sclone has no outarcs at all, in which case it's
     * useless.  (We don't try extremely hard to get rid of useless states
     * here, but this is an easy and fairly common case.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sclone</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>freestate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>sclone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sclone</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Move shead's constraint-loop arcs to point to sclone, or just drop them
     * if we discovered we don't need sclone.
     */</comment>
    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>shead</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name>nexta</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>nexta</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name> <operator>==</operator> <name>stail</name> <operator>&amp;&amp;</operator> <call><name>isconstraintarc</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>sclone</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>cparc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>shead</name></expr></argument>, <argument><expr><name>sclone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * clonesuccessorstates - create a tree of constraint-arc successor states
 *
 * ssource is the state to be cloned, and sclone is the state to copy its
 * outarcs into.  sclone's inarcs, if any, should already be set up.
 *
 * spredecessor is the original predecessor state that we are trying to build
 * successors for (it may not be the immediate predecessor of ssource).
 * refarc, if not NULL, is the original constraint arc that is known to have
 * been traversed out of spredecessor to reach the successor(s).
 *
 * For each cloned successor state, we transiently create a "donemap" that is
 * a boolean array showing which source states we've already visited for this
 * clone state.  This prevents infinite recursion as well as useless repeat
 * visits to the same state subtree (which can add up fast, since typical NFAs
 * have multiple redundant arc pathways).  Each donemap is a char array
 * indexed by state number.  The donemaps are all of the same size "nstates",
 * which is nfa-&gt;nstates as of the start of the recursion.  This is enough to
 * have entries for all pre-existing states, but *not* entries for clone
 * states created during the recursion.  That's okay since we have no need to
 * mark those.
 *
 * curdonemap is NULL when recursing to a new sclone state, or sclone's
 * donemap when we are recursing without having created a new state (which we
 * do when we decide we can merge a successor state into the current clone
 * state).  outerdonemap is NULL at the top level and otherwise the parent
 * clone state's donemap.
 *
 * The successor states we create and fill here form a strict tree structure,
 * with each state having exactly one predecessor, except that the toplevel
 * state has no inarcs as yet (breakconstraintloop will add its inarcs from
 * spredecessor after we're done).  Thus, we can examine sclone's inarcs back
 * to the root, plus refarc if any, to identify the set of constraints already
 * known valid at the current point.  This allows us to avoid generating extra
 * successor states.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>clonesuccessorstates</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
                     <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>ssource</name></decl></parameter>,
                     <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sclone</name></decl></parameter>,
                     <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>spredecessor</name></decl></parameter>,
                     <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>refarc</name></decl></parameter>,
                     <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>curdonemap</name></decl></parameter>,
                     <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>outerdonemap</name></decl></parameter>,
                     <parameter><decl><type><name>int</name></type> <name>nstates</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>donemap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <comment type="block">/* Since this is recursive, it could be driven to stack overflow */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>STACK_TOO_DEEP</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ETOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If this state hasn't already got a donemap, create one */</comment>
    <expr_stmt><expr><name>donemap</name> <operator>=</operator> <name>curdonemap</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>donemap</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>donemap</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><name>nstates</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>donemap</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>outerdonemap</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Not at outermost recursion level, so copy the outer level's
             * donemap; this ensures that we see states in process of being
             * visited at outer levels, or already merged into predecessor
             * states, as ones we shouldn't traverse back to.
             */</comment>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>donemap</name></expr></argument>, <argument><expr><name>outerdonemap</name></expr></argument>, <argument><expr><name>nstates</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* At outermost level, only spredecessor is off-limits */</comment>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>donemap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nstates</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>spredecessor</name><operator>-&gt;</operator><name>no</name></name> <operator>&lt;</operator> <name>nstates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>donemap</name><index>[<expr><name><name>spredecessor</name><operator>-&gt;</operator><name>no</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Mark ssource as visited in the donemap */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ssource</name><operator>-&gt;</operator><name>no</name></name> <operator>&lt;</operator> <name>nstates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>donemap</name><index>[<expr><name><name>ssource</name><operator>-&gt;</operator><name>no</name></name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>donemap</name><index>[<expr><name><name>ssource</name><operator>-&gt;</operator><name>no</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * We proceed by first cloning all of ssource's outarcs, creating new
     * clone states as needed but not doing more with them than that.  Then in
     * a second pass, recurse to process the child clone states.  This allows
     * us to have only one child clone state per reachable source state, even
     * when there are multiple outarcs leading to the same state.  Also, when
     * we do visit a child state, its set of inarcs is known exactly, which
     * makes it safe to apply the constraint-is-already-checked optimization.
     * Also, this ensures that we've merged all the states we can into the
     * current clone before we recurse to any children, thus possibly saving
     * them from making extra images of those states.
     *
     * While this function runs, child clone states of the current state are
     * marked by setting their tmp fields to point to the original state they
     * were cloned from.  This makes it possible to detect multiple outarcs
     * leading to the same state, and also makes it easy to distinguish clone
     * states from original states (which will have tmp == NULL).
     */</comment>
    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>ssource</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sto</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * We do not consider cloning successor states that have no constraint
         * outarcs; just link to them as-is.  They cannot be part of a
         * constraint loop so there is no need to make copies.  In particular,
         * this rule keeps us from trying to clone the post state, which would
         * be a bad idea.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>isconstraintarc</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>hasconstraintout</name><argument_list>(<argument><expr><name>sto</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>prevclone</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>canmerge</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a2</name></decl>;</decl_stmt>

            <comment type="block">/*
             * Back-link constraint arcs must not be followed.  Nor is there a
             * need to revisit states previously merged into this clone.
             */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>sto</name><operator>-&gt;</operator><name>no</name></name> <operator>&lt;</operator> <name>nstates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>donemap</name><index>[<expr><name><name>sto</name><operator>-&gt;</operator><name>no</name></name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Check whether we already have a child clone state for this
             * source state.
             */</comment>
            <expr_stmt><expr><name>prevclone</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>a2</name> <operator>=</operator> <name><name>sclone</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a2</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a2</name> <operator>=</operator> <name><name>a2</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>a2</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>tmp</name></name> <operator>==</operator> <name>sto</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>prevclone</name> <operator>=</operator> <name><name>a2</name><operator>-&gt;</operator><name>to</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="block">/*
             * If this arc is labeled the same as refarc, or the same as any
             * arc we must have traversed to get to sclone, then no additional
             * constraints need to be met to get to sto, so we should just
             * merge its outarcs into sclone.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>refarc</name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name><name>refarc</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>co</name></name> <operator>==</operator> <name><name>refarc</name><operator>-&gt;</operator><name>co</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>canmerge</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>canmerge</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>sclone</name></expr>;</init> <condition><expr><name><name>s</name><operator>-&gt;</operator><name>ins</name></name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ins</name><operator>-&gt;</operator><name>from</name></name></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nins</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
                        <name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>ins</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>co</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>ins</name><operator>-&gt;</operator><name>co</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>canmerge</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>canmerge</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * We can merge into sclone.  If we previously made a child
                 * clone state, drop it; there's no need to visit it.  (This
                 * can happen if ssource has multiple pathways to sto, and we
                 * only just now found one that is provably a no-op.)
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>prevclone</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>dropstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>prevclone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* kills our outarc, too */</comment>

                <comment type="block">/* Recurse to merge sto's outarcs into sclone */</comment>
                <expr_stmt><expr><call><name>clonesuccessorstates</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>,
                                     <argument><expr><name>sto</name></expr></argument>,
                                     <argument><expr><name>sclone</name></expr></argument>,
                                     <argument><expr><name>spredecessor</name></expr></argument>,
                                     <argument><expr><name>refarc</name></expr></argument>,
                                     <argument><expr><name>donemap</name></expr></argument>,
                                     <argument><expr><name>outerdonemap</name></expr></argument>,
                                     <argument><expr><name>nstates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* sto should now be marked as previously visited */</comment>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>NISERR</name><argument_list>()</argument_list></call> <operator>||</operator> <name><name>donemap</name><index>[<expr><name><name>sto</name><operator>-&gt;</operator><name>no</name></name></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>prevclone</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * We already have a clone state for this successor, so just
                 * make another arc to it.
                 */</comment>
                <expr_stmt><expr><call><name>cparc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>sclone</name></expr></argument>, <argument><expr><name>prevclone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * We need to create a new successor clone state.
                 */</comment>
                <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>stoclone</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>stoclone</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>stoclone</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* Mark it as to what it's a clone of */</comment>
                <expr_stmt><expr><name><name>stoclone</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>sto</name></expr>;</expr_stmt>
                <comment type="block">/* ... and add the outarc leading to it */</comment>
                <expr_stmt><expr><call><name>cparc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>sclone</name></expr></argument>, <argument><expr><name>stoclone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Non-constraint outarcs just get copied to sclone, as do outarcs
             * leading to states with no constraint outarc.
             */</comment>
            <expr_stmt><expr><call><name>cparc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>sclone</name></expr></argument>, <argument><expr><name>sto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * If we are at outer level for this clone state, recurse to all its child
     * clone states, clearing their tmp fields as we go.  (If we're not
     * outermost for sclone, leave this to be done by the outer call level.)
     * Note that if we have multiple outarcs leading to the same clone state,
     * it will only be recursed-to once.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>curdonemap</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>sclone</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>stoclone</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sto</name> <init>= <expr><name><name>stoclone</name><operator>-&gt;</operator><name>tmp</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>sto</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>stoclone</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>clonesuccessorstates</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>,
                                     <argument><expr><name>sto</name></expr></argument>,
                                     <argument><expr><name>stoclone</name></expr></argument>,
                                     <argument><expr><name>spredecessor</name></expr></argument>,
                                     <argument><expr><name>refarc</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>donemap</name></expr></argument>,
                                     <argument><expr><name>nstates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Don't forget to free sclone's donemap when done with it */</comment>
        <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>donemap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cleanup - clean up NFA after optimizations
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleanup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>nexts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>n</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* clear out unreachable or dead-end states */</comment>
    <comment type="block">/* use pre to mark reachable, then post to mark can-reach-post */</comment>
    <expr_stmt><expr><call><name>markreachable</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>pre</name></name></expr></argument>, <argument><expr><operator>(</operator>struct <name>state</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>pre</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>markcanreach</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>post</name></name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>pre</name></name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>post</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name>nexts</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>nexts</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>!=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>post</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>flag</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>dropstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>NISERR</name><argument_list>()</argument_list></call> <operator>||</operator> <name><name>nfa</name><operator>-&gt;</operator><name>post</name><operator>-&gt;</operator><name>nins</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nfa</name><operator>-&gt;</operator><name>post</name><operator>-&gt;</operator><name>tmp</name></name> <operator>==</operator> <name><name>nfa</name><operator>-&gt;</operator><name>post</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cleartraverse</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>pre</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>NISERR</name><argument_list>()</argument_list></call> <operator>||</operator> <name><name>nfa</name><operator>-&gt;</operator><name>post</name><operator>-&gt;</operator><name>nins</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nfa</name><operator>-&gt;</operator><name>post</name><operator>-&gt;</operator><name>tmp</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* the nins==0 (final unreachable) case will be caught later */</comment>

    <comment type="block">/* renumber surviving states */</comment>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>no</name></name> <operator>=</operator> <name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>nfa</name><operator>-&gt;</operator><name>nstates</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * markreachable - recursive marking of reachable states
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>markreachable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
              <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
              <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>okay</name></decl></parameter>,    <comment type="block">/* consider only states with this mark */</comment>
              <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>mark</name></decl></parameter>)</parameter_list>    <comment type="block">/* the value to mark with */</comment>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <comment type="block">/* Since this is recursive, it could be driven to stack overflow */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>STACK_TOO_DEEP</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ETOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>!=</operator> <name>okay</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>mark</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>markreachable</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr></argument>, <argument><expr><name>okay</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * markcanreach - recursive marking of states which can reach here
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>markcanreach</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
             <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
             <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>okay</name></decl></parameter>,    <comment type="block">/* consider only states with this mark */</comment>
             <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>mark</name></decl></parameter>)</parameter_list>    <comment type="block">/* the value to mark with */</comment>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <comment type="block">/* Since this is recursive, it could be driven to stack overflow */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>STACK_TOO_DEEP</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ETOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>!=</operator> <name>okay</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>mark</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ins</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>inchain</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>markcanreach</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name></expr></argument>, <argument><expr><name>okay</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * analyze - ascertain potentially-useful facts about an optimized NFA
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>                        <comment type="block">/* re_info bits to be ORed in */</comment>
<name>analyze</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>aa</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>NISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>nfa</name><operator>-&gt;</operator><name>pre</name><operator>-&gt;</operator><name>outs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>REG_UIMPOSSIBLE</name></expr>;</return></block_content></block></if></if_stmt>
    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>pre</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <for>for <control>(<init><expr><name>aa</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>aa</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>aa</name> <operator>=</operator> <name><name>aa</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>to</name></name> <operator>==</operator> <name><name>nfa</name><operator>-&gt;</operator><name>post</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>REG_UEMPTYMATCH</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for></block_content></block></for>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * compact - construct the compact representation of an NFA
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compact</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
        <parameter><decl><type><name><name>struct</name> <name>cnfa</name></name> <modifier>*</modifier></type><name>cnfa</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>nstates</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>narcs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>carc</name></name> <modifier>*</modifier></type><name>ca</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>carc</name></name> <modifier>*</modifier></type><name>first</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>NISERR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nstates</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>narcs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>nstates</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>narcs</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>nouts</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* need one extra for endmarker */</comment>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>cnfa</name><operator>-&gt;</operator><name>stflags</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><name>nstates</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cnfa</name><operator>-&gt;</operator><name>states</name></name> <operator>=</operator> <operator>(</operator>struct <name>carc</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><name>nstates</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>carc</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cnfa</name><operator>-&gt;</operator><name>arcs</name></name> <operator>=</operator> <operator>(</operator>struct <name>carc</name> <operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><name>narcs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>carc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cnfa</name><operator>-&gt;</operator><name>stflags</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>states</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>arcs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>cnfa</name><operator>-&gt;</operator><name>stflags</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>cnfa</name><operator>-&gt;</operator><name>stflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>cnfa</name><operator>-&gt;</operator><name>states</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>cnfa</name><operator>-&gt;</operator><name>states</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>cnfa</name><operator>-&gt;</operator><name>arcs</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>cnfa</name><operator>-&gt;</operator><name>arcs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>cnfa</name><operator>-&gt;</operator><name>nstates</name></name> <operator>=</operator> <name>nstates</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cnfa</name><operator>-&gt;</operator><name>pre</name></name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>pre</name><operator>-&gt;</operator><name>no</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cnfa</name><operator>-&gt;</operator><name>post</name></name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>post</name><operator>-&gt;</operator><name>no</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cnfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cnfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cnfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cnfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cnfa</name><operator>-&gt;</operator><name>ncolors</name></name> <operator>=</operator> <call><name>maxcolor</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cnfa</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>ca</name> <operator>=</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>arcs</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name><name>s</name><operator>-&gt;</operator><name>no</name></name> <operator>&lt;</operator> <name>nstates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cnfa</name><operator>-&gt;</operator><name>stflags</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>no</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cnfa</name><operator>-&gt;</operator><name>states</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>no</name></name></expr>]</index></name> <operator>=</operator> <name>ca</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>first</name> <operator>=</operator> <name>ca</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control><block type="pseudo"><block_content>
            <switch>switch <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>PLAIN</name></expr>:</case>
                    <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>co</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>to</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>no</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ca</name><operator>++</operator></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>LACON</name></expr>:</case>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>no</name></name> <operator>!=</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>pre</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>co</name></name> <operator>=</operator> <operator>(</operator><name>color</name><operator>)</operator> <operator>(</operator><name><name>cnfa</name><operator>-&gt;</operator><name>ncolors</name></name> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>co</name></name><operator>)</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>to</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>no</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ca</name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cnfa</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>HASLACONS</name></expr>;</expr_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <expr_stmt><expr><call><name>NERR</name><argument_list>(<argument><expr><name>REG_ASSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch></block_content></block></for>
        <expr_stmt><expr><call><name>carcsort</name><argument_list>(<argument><expr><name>first</name></expr></argument>, <argument><expr><name>ca</name> <operator>-</operator> <name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>co</name></name> <operator>=</operator> <name>COLORLESS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>to</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>ca</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ca</name> <operator>==</operator> <operator>&amp;</operator><name><name>cnfa</name><operator>-&gt;</operator><name>arcs</name><index>[<expr><name>narcs</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cnfa</name><operator>-&gt;</operator><name>nstates</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* mark no-progress states */</comment>
    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>pre</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cnfa</name><operator>-&gt;</operator><name>stflags</name><index>[<expr><name><name>a</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>no</name></name></expr>]</index></name> <operator>=</operator> <name>CNFA_NOPROGRESS</name></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>cnfa</name><operator>-&gt;</operator><name>stflags</name><index>[<expr><name><name>nfa</name><operator>-&gt;</operator><name>pre</name><operator>-&gt;</operator><name>no</name></name></expr>]</index></name> <operator>=</operator> <name>CNFA_NOPROGRESS</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * carcsort - sort compacted-NFA arcs by color
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>carcsort</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>carc</name></name> <modifier>*</modifier></type><name>first</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>first</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>carc</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>carc_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>carc_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>carc</name></name> <modifier>*</modifier></type><name>aa</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>carc</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>carc</name></name> <modifier>*</modifier></type><name>bb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>carc</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>co</name></name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>co</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>co</name></name> <operator>&gt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>co</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>to</name></name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>to</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>to</name></name> <operator>&gt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>to</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * freecnfa - free a compacted NFA
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>freecnfa</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cnfa</name></name> <modifier>*</modifier></type><name>cnfa</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cnfa</name><operator>-&gt;</operator><name>nstates</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* not empty already */</comment>
    <expr_stmt><expr><name><name>cnfa</name><operator>-&gt;</operator><name>nstates</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>cnfa</name><operator>-&gt;</operator><name>stflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>cnfa</name><operator>-&gt;</operator><name>states</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>cnfa</name><operator>-&gt;</operator><name>arcs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpnfa - dump an NFA in human-readable form
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpnfa</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>,
        <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nstates</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>narcs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"pre %d, post %d"</literal></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>pre</name><operator>-&gt;</operator><name>no</name></name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>post</name><operator>-&gt;</operator><name>no</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>nfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>COLORLESS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">", bos [%ld]"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>nfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>nfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>COLORLESS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">", bol [%ld]"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>nfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>nfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>COLORLESS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">", eos [%ld]"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>nfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>nfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>COLORLESS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">", eol [%ld]"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>nfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>states</name></name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>dumpstate</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nstates</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>narcs</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>nouts</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"total of %d states, %d arcs\n"</literal></expr></argument>, <argument><expr><name>nstates</name></expr></argument>, <argument><expr><name>narcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>nfa</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>dumpcolors</name><argument_list>(<argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>                <comment type="block">/* subordinates of dumpnfa */</comment>

<comment type="block">/*
 * dumpstate - dump an NFA state in human-readable form
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpstate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
          <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%d%s%c"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>no</name></name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"T"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
            <argument><expr><ternary><condition><expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>flag</name></name><operator>)</operator></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>flag</name></name></expr> </then><else>: <expr><literal type="char">'.'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>prev</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\tstate chain bad\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\tno out arcs\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>dumparcs</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ins</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>inchain</name></name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name> <operator>!=</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\tlink from %d to %d on %d's in-chain\n"</literal></expr></argument>,
                    <argument><expr><name><name>a</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>no</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>no</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>no</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * dumparcs - dump out-arcs in human-readable form
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumparcs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
         <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <comment type="block">/* printing oldest arcs first is usually clearer */</comment>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>outs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>outchain</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <do>do
    <block>{<block_content>
        <expr_stmt><expr><call><name>dumparc</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchainRev</name></name></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
    <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumparc - dump one outarc in readable form, including prefixing tab
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumparc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
        <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
        <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>aa</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>arcbatch</name></name> <modifier>*</modifier></type><name>ab</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PLAIN</name></expr>:</case>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"[%ld]"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AHEAD</name></expr>:</case>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"&gt;%ld&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>BEHIND</name></expr>:</case>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"&lt;%ld&lt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LACON</name></expr>:</case>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%ld:"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'^'</literal></expr>:</case>
        <case>case <expr><literal type="char">'$'</literal></expr>:</case>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%c%d"</literal></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>EMPTY</name></expr>:</case>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"0x%x/0%lo"</literal></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>co</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name> <operator>!=</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"?%d?"</literal></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>no</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <for>for <control>(<init><expr><name>ab</name> <operator>=</operator> <operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>oas</name></name></expr>;</init> <condition><expr><name>ab</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ab</name> <operator>=</operator> <name><name>ab</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>aa</name> <operator>=</operator> <operator>&amp;</operator><name><name>ab</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</init> <condition><expr><name>aa</name> <operator>&lt;</operator> <operator>&amp;</operator><name><name>ab</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ABSIZE</name></expr>]</index></name></expr>;</condition> <incr><expr><name>aa</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name>aa</name> <operator>==</operator> <name>a</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>            <comment type="block">/* NOTE BREAK OUT */</comment>
        <if_stmt><if>if <condition>(<expr><name>aa</name> <operator>&lt;</operator> <operator>&amp;</operator><name><name>ab</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ABSIZE</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* propagate break */</comment>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* NOTE BREAK OUT */</comment>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>ab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"?!?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>        <comment type="block">/* not in allocated space */</comment>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"-&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>to</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>no</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>aa</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>ins</name></name></expr>;</init> <condition><expr><name>aa</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>aa</name> <operator>=</operator> <name><name>aa</name><operator>-&gt;</operator><name>inchain</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name>aa</name> <operator>==</operator> <name>a</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>                <comment type="block">/* NOTE BREAK OUT */</comment>
    <if_stmt><if>if <condition>(<expr><name>aa</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"?!?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>        <comment type="block">/* missing from in-chain */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* REG_DEBUG */</comment>

<comment type="block">/*
 * dumpcnfa - dump a compacted NFA in human-readable form
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpcnfa</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cnfa</name></name> <modifier>*</modifier></type><name>cnfa</name></decl></parameter>,
         <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>st</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"pre %d, post %d"</literal></expr></argument>, <argument><expr><name><name>cnfa</name><operator>-&gt;</operator><name>pre</name></name></expr></argument>, <argument><expr><name><name>cnfa</name><operator>-&gt;</operator><name>post</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cnfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>COLORLESS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">", bos [%ld]"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cnfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>COLORLESS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">", bol [%ld]"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cnfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>COLORLESS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">", eos [%ld]"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cnfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>COLORLESS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">", eol [%ld]"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cnfa</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>HASLACONS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">", haslacons"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>st</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>st</name> <operator>&lt;</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>nstates</name></name></expr>;</condition> <incr><expr><name>st</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>dumpcstate</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>cnfa</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>                <comment type="block">/* subordinates of dumpcnfa */</comment>

<comment type="block">/*
 * dumpcstate - dump a compacted-NFA state in human-readable form
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpcstate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>st</name></decl></parameter>,
           <parameter><decl><type><name><name>struct</name> <name>cnfa</name></name> <modifier>*</modifier></type><name>cnfa</name></decl></parameter>,
           <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>carc</name></name> <modifier>*</modifier></type><name>ca</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>pos</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%d%s"</literal></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>cnfa</name><operator>-&gt;</operator><name>stflags</name><index>[<expr><name>st</name></expr>]</index></name> <operator>&amp;</operator> <name>CNFA_NOPROGRESS</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">":"</literal></expr> </then><else>: <expr><literal type="string">"."</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>ca</name> <operator>=</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>states</name><index>[<expr><name>st</name></expr>]</index></name></expr>;</init> <condition><expr><name><name>ca</name><operator>-&gt;</operator><name>co</name></name> <operator>!=</operator> <name>COLORLESS</name></expr>;</condition> <incr><expr><name>ca</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>ca</name><operator>-&gt;</operator><name>co</name></name> <operator>&lt;</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>ncolors</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\t[%ld]-&gt;%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>ca</name><operator>-&gt;</operator><name>co</name></name></expr></argument>, <argument><expr><name><name>ca</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\t:%ld:-&gt;%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>ca</name><operator>-&gt;</operator><name>co</name></name> <operator>-</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>ncolors</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>ca</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>ca</name> <operator>==</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>states</name><index>[<expr><name>st</name></expr>]</index></name> <operator>||</operator> <name>pos</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* REG_DEBUG */</comment>
</unit>
