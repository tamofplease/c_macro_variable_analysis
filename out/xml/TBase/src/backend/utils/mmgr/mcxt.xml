<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/mmgr/mcxt.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 *
 * mcxt.c
 *      POSTGRES memory context management code.
 *
 * This module handles context management operations that are independent
 * of the particular kind of context being operated on.  It calls
 * context-type-specific operations via the function pointers in a
 * context's MemoryContextMethods struct.
 *
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/utils/mmgr/mcxt.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block" format="doxygen">/*****************************************************************************
 *      GLOBAL MEMORY                                                             *
 *****************************************************************************/</comment>

<comment type="block">/*
 * CurrentMemoryContext
 *        Default memory context for allocations.
 */</comment>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>CurrentMemoryContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Standard top-level contexts. For a description of the purpose of each
 * of these contexts, refer to src/backend/utils/mmgr/README
 */</comment>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>TopMemoryContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>ErrorContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>PostmasterContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>CacheMemoryContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>MessageContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>TopTransactionContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>CurTransactionContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* This is a transient link to the active portal's memory context: */</comment>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>PortalContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>AuditContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MemoryContextCallResetCallbacks</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MemoryContextStatsInternal</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,
                           <parameter><decl><type><name>bool</name></type> <name>print</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_children</name></decl></parameter>,
                           <parameter><decl><type><name>MemoryContextCounters</name> <modifier>*</modifier></type><name>totals</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>allocTopCxt</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * You should not do memory allocations within a critical section, because
 * an out-of-memory error will be escalated to a PANIC. To enforce that
 * rule, the allocation functions Assert that.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AssertNotInCriticalSection</name><parameter_list>(<parameter><type><name>context</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>Assert(CritSectionCount == 0 || (context)-&gt;allowInCritSection)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/*****************************************************************************
 *      EXPORTED ROUTINES                                                         *
 *****************************************************************************/</comment>


<comment type="block">/*
 * MemoryContextInit
 *        Start up the memory-context subsystem.
 *
 * This must be called before creating contexts or allocating memory in
 * contexts.  TopMemoryContext and ErrorContext are initialized here;
 * other contexts must be created afterwards.
 *
 * In normal multi-backend operation, this is called once during
 * postmaster startup, and not at all by individual backend startup
 * (since the backends inherit an already-initialized context subsystem
 * by virtue of being forked off the postmaster).  But in an EXEC_BACKEND
 * build, each process must do this for itself.
 *
 * In a standalone backend this must be called during backend startup.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name>TopMemoryContext</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * First, initialize TopMemoryContext, which will hold the MemoryContext
     * nodes for all other contexts.  (There is special-case code in
     * MemoryContextCreate() to handle this call.)
     */</comment>
    <expr_stmt><expr><name>TopMemoryContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><operator>(</operator><name>MemoryContext</name><operator>)</operator> <name>NULL</name></expr></argument>,
                                             <argument><expr><literal type="string">"TopMemoryContext"</literal></expr></argument>,
                                             <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Not having any other place to point CurrentMemoryContext, make it point
     * to TopMemoryContext.  Caller should change this soon!
     */</comment>
    <expr_stmt><expr><name>CurrentMemoryContext</name> <operator>=</operator> <name>TopMemoryContext</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize ErrorContext as an AllocSetContext with slow growth rate ---
     * we don't really expect much to be allocated in it. More to the point,
     * require it to contain at least 8K at all times. This is the only case
     * where retained memory in a context is *essential* --- we want to be
     * sure ErrorContext still has some memory even if we've run out
     * elsewhere! Also, allow allocations in ErrorContext within a critical
     * section. Otherwise a PANIC will cause an assertion failure in the error
     * reporting code, before printing out the real cause of the failure.
     *
     * This should be the last step in this function, as elog.c assumes memory
     * management works once ErrorContext is non-null.
     */</comment>
    <expr_stmt><expr><name>ErrorContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                         <argument><expr><literal type="string">"ErrorContext"</literal></expr></argument>,
                                         <argument><expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
                                         <argument><expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
                                         <argument><expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextAllowInCriticalSection</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextReset
 *        Release all space allocated within a context and delete all its
 *        descendant contexts (but not the named context itself).
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextReset</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* save a function call in common case where there are no children */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextDeleteChildren</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* save a function call if no pallocs since startup or last reset */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextResetOnly</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextResetOnly
 *        Release all space allocated within a context.
 *        Nothing is done to the context's descendant contexts.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextResetOnly</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Nothing to do if no pallocs since startup or last reset */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextCallResetCallbacks</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>reset</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VALGRIND_DESTROY_MEMPOOL</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VALGRIND_CREATE_MEMPOOL</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextResetChildren
 *        Release all space allocated within a context's descendants,
 *        but don't delete the contexts themselves.  The named context
 *        itself is not touched.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextResetChildren</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>child</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>child</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name></expr>;</init> <condition><expr><name>child</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>child</name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>nextchild</name></name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextResetChildren</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextResetOnly</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextDelete
 *        Delete a context and its descendants, and release all space
 *        allocated therein.
 *
 * The type-specific delete routine removes all subsidiary storage
 * for the context, but we have to delete the context node itself,
 * as well as recurse to get the children.  We must also delink the
 * node from its parent, if it has one.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextDelete</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* We had better not be deleting TopMemoryContext ... */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name> <operator>!=</operator> <name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* And not CurrentMemoryContext, either */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name> <operator>!=</operator> <name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextDeleteChildren</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * It's not entirely clear whether 'tis better to do this before or after
     * delinking the context; but an error in a callback will likely result in
     * leaking the whole context (if it's not a root context) if we do it
     * after, so let's do it before.
     */</comment>
    <expr_stmt><expr><call><name>MemoryContextCallResetCallbacks</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We delink the context from its parent before deleting it, so that if
     * there's an error we won't have deleted/busted contexts still attached
     * to the context tree.  Better a leak than a crash.
     */</comment>
    <expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>delete_context</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VALGRIND_DESTROY_MEMPOOL</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextDeleteChildren
 *        Delete all the descendants of the named context and release all
 *        space allocated therein.  The named context itself is not touched.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextDeleteChildren</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * MemoryContextDelete will delink the child from me, so just iterate as
     * long as there is a child.
     */</comment>
    <while>while <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextRegisterResetCallback
 *        Register a function to be called before next context reset/delete.
 *        Such callbacks will be called in reverse order of registration.
 *
 * The caller is responsible for allocating a MemoryContextCallback struct
 * to hold the info about this callback request, and for filling in the
 * "func" and "arg" fields in the struct to show what function to call with
 * what argument.  Typically the callback struct should be allocated within
 * the specified context, since that means it will automatically be freed
 * when no longer needed.
 *
 * There is no API for deregistering a callback once registered.  If you
 * want it to not do anything anymore, adjust the state pointed to by its
 * "arg" to indicate that.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextRegisterResetCallback</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>,
                                   <parameter><decl><type><name>MemoryContextCallback</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Push onto head so this will be called before older registrants. */</comment>
    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>reset_cbs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>reset_cbs</name></name> <operator>=</operator> <name>cb</name></expr>;</expr_stmt>
    <comment type="block">/* Mark the context as non-reset (it probably is already). */</comment>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextCallResetCallbacks
 *        Internal function to call all registered callbacks for context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MemoryContextCallResetCallbacks</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContextCallback</name> <modifier>*</modifier></type><name>cb</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We pop each callback from the list before calling.  That way, if an
     * error occurs inside the callback, we won't try to call it a second time
     * in the likely event that we reset or delete the context later.
     */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>cb</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>reset_cbs</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>reset_cbs</name></name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call>(<modifier>*</modifier><name><name>cb</name><operator>-&gt;</operator><name>func</name></name>) <argument_list>(<argument><expr><name><name>cb</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextSetParent
 *        Change a context to belong to a new parent (or no parent).
 *
 * We provide this as an API function because it is sometimes useful to
 * change a context's lifespan after creation.  For example, a context
 * might be created underneath a transient context, filled with data,
 * and then reparented underneath CacheMemoryContext to make it long-lived.
 * In this way no special effort is needed to get rid of the context in case
 * a failure occurs before its contents are completely set up.
 *
 * Callers often assume that this function cannot fail, so don't put any
 * elog(ERROR) calls in it.
 *
 * A possible caller error is to reparent a context under itself, creating
 * a loop in the context graph.  We assert here that context != new_parent,
 * but checking for multi-level loops seems more trouble than it's worth.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextSetParent</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>new_parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>context</name> <operator>!=</operator> <name>new_parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Fast path if it's got correct parent already */</comment>
    <if_stmt><if>if <condition>(<expr><name>new_parent</name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Delink from existing parent, if any */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>parent</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>prevchild</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>prevchild</name><operator>-&gt;</operator><name>nextchild</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>nextchild</name></name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>==</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>nextchild</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>nextchild</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nextchild</name><operator>-&gt;</operator><name>prevchild</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>prevchild</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* And relink */</comment>
    <if_stmt><if>if <condition>(<expr><name>new_parent</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>new_parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>new_parent</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>prevchild</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nextchild</name></name> <operator>=</operator> <name><name>new_parent</name><operator>-&gt;</operator><name>firstchild</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>new_parent</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>new_parent</name><operator>-&gt;</operator><name>firstchild</name><operator>-&gt;</operator><name>prevchild</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>new_parent</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>prevchild</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nextchild</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextAllowInCriticalSection
 *        Allow/disallow allocations in this memory context within a critical
 *        section.
 *
 * Normally, memory allocations are not allowed within a critical section,
 * because a failure would lead to PANIC.  There are a few exceptions to
 * that, like allocations related to debugging code that is not supposed to
 * be enabled in production.  This function can be used to exempt specific
 * memory contexts from the assertion in palloc().
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextAllowInCriticalSection</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>allowInCritSection</name></name> <operator>=</operator> <name>allow</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GetMemoryChunkSpace
 *        Given a currently-allocated chunk, determine the total space
 *        it occupies (including all memory-allocation overhead).
 *
 * This is useful for measuring the total space occupied by a set of
 * allocated chunks.
 */</comment>
<function><type><name>Size</name></type>
<name>GetMemoryChunkSpace</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name> <init>= <expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>get_chunk_space</name></name><operator>)</operator> <operator>(</operator><name>context</name><operator>,</operator>
                                                <name>pointer</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextGetParent
 *        Get the parent context (if any) of the specified context
 */</comment>
<function><type><name>MemoryContext</name></type>
<name>MemoryContextGetParent</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name><name>context</name><operator>-&gt;</operator><name>parent</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextIsEmpty
 *        Is a memory context empty of any allocated space?
 */</comment>
<function><type><name>bool</name></type>
<name>MemoryContextIsEmpty</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * For now, we consider a memory context nonempty if it has any children;
     * perhaps this should be changed later.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Otherwise use the type-specific inquiry */</comment>
    <return>return <expr><call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>is_empty</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextStats
 *        Print statistics about the named context and all its descendants.
 *
 * This is just a debugging utility, so it's not very fancy.  However, we do
 * make some effort to summarize when the output would otherwise be very long.
 * The statistics are sent to stderr.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextStats</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* A hard-wired limit on the number of children is usually good enough */</comment>
    <expr_stmt><expr><call><name>MemoryContextStatsDetail</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextStatsDetail
 *
 * Entry point for use if you want to vary the number of child contexts shown.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextStatsDetail</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_children</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContextCounters</name></type> <name>grand_totals</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>grand_totals</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>grand_totals</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextStatsInternal</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>max_children</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>grand_totals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
            <argument><expr><literal type="string">"Grand total: %zu bytes in %zd blocks; %zu free (%zd chunks); %zu used\n"</literal></expr></argument>,
            <argument><expr><name><name>grand_totals</name><operator>.</operator><name>totalspace</name></name></expr></argument>, <argument><expr><name><name>grand_totals</name><operator>.</operator><name>nblocks</name></name></expr></argument>,
            <argument><expr><name><name>grand_totals</name><operator>.</operator><name>freespace</name></name></expr></argument>, <argument><expr><name><name>grand_totals</name><operator>.</operator><name>freechunks</name></name></expr></argument>,
            <argument><expr><name><name>grand_totals</name><operator>.</operator><name>totalspace</name></name> <operator>-</operator> <name><name>grand_totals</name><operator>.</operator><name>freespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextStatsInternal
 *        One recursion level for MemoryContextStats
 *
 * Print this context if print is true, but in any case accumulate counts into
 * *totals (if given).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MemoryContextStatsInternal</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,
                           <parameter><decl><type><name>bool</name></type> <name>print</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_children</name></decl></parameter>,
                           <parameter><decl><type><name>MemoryContextCounters</name> <modifier>*</modifier></type><name>totals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContextCounters</name></type> <name>local_totals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>child</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ichild</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Examine the context itself */</comment>
    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>stats</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>print</name></expr></argument>, <argument><expr><name>totals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Examine children.  If there are more than max_children of them, we do
     * not print the rest explicitly, but just summarize them.
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>local_totals</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>local_totals</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>child</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name></expr><operator>,</operator> <expr><name>ichild</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
         <condition><expr><name>child</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
         <incr><expr><name>child</name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>nextchild</name></name></expr><operator>,</operator> <expr><name>ichild</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>ichild</name> <operator>&lt;</operator> <name>max_children</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MemoryContextStatsInternal</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                                       <argument><expr><name>print</name></expr></argument>, <argument><expr><name>max_children</name></expr></argument>,
                                       <argument><expr><name>totals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MemoryContextStatsInternal</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                                       <argument><expr><name>false</name></expr></argument>, <argument><expr><name>max_children</name></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><name>local_totals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Deal with excess children */</comment>
    <if_stmt><if>if <condition>(<expr><name>ichild</name> <operator>&gt;</operator> <name>max_children</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>print</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>level</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><literal type="string">"%d more child contexts containing %zu total in %zd blocks; %zu free (%zd chunks); %zu used\n"</literal></expr></argument>,
                    <argument><expr><name>ichild</name> <operator>-</operator> <name>max_children</name></expr></argument>,
                    <argument><expr><name><name>local_totals</name><operator>.</operator><name>totalspace</name></name></expr></argument>,
                    <argument><expr><name><name>local_totals</name><operator>.</operator><name>nblocks</name></name></expr></argument>,
                    <argument><expr><name><name>local_totals</name><operator>.</operator><name>freespace</name></name></expr></argument>,
                    <argument><expr><name><name>local_totals</name><operator>.</operator><name>freechunks</name></name></expr></argument>,
                    <argument><expr><name><name>local_totals</name><operator>.</operator><name>totalspace</name></name> <operator>-</operator> <name><name>local_totals</name><operator>.</operator><name>freespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>totals</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>totals</name><operator>-&gt;</operator><name>nblocks</name></name> <operator>+=</operator> <name><name>local_totals</name><operator>.</operator><name>nblocks</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>totals</name><operator>-&gt;</operator><name>freechunks</name></name> <operator>+=</operator> <name><name>local_totals</name><operator>.</operator><name>freechunks</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>totals</name><operator>-&gt;</operator><name>totalspace</name></name> <operator>+=</operator> <name><name>local_totals</name><operator>.</operator><name>totalspace</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>totals</name><operator>-&gt;</operator><name>freespace</name></name> <operator>+=</operator> <name><name>local_totals</name><operator>.</operator><name>freespace</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextCheck
 *        Check all chunks in the named context.
 *
 * This is just a debugging utility, so it's not fancy.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEMORY_CONTEXT_CHECKING</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>MemoryContextCheck</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>child</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>check</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>child</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name></expr>;</init> <condition><expr><name>child</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>child</name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>nextchild</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextCheck</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * MemoryContextContains
 *        Detect whether an allocated chunk of memory belongs to a given
 *        context or not.
 *
 * Caution: this test is reliable as long as 'pointer' does point to
 * a chunk of memory allocated from *some* context.  If 'pointer' points
 * at memory obtained in some other way, there is a small chance of a
 * false-positive result, since the bits right before it might look like
 * a valid chunk header by chance.
 */</comment>
<function><type><name>bool</name></type>
<name>MemoryContextContains</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>ptr_context</name></decl>;</decl_stmt>

    <comment type="block">/*
     * NB: Can't use GetMemoryChunkContext() here - that performs assertions
     * that aren't acceptable here since we might be passed memory not
     * allocated by any memory context.
     *
     * Try to detect bogus pointers handed to us, poorly though we can.
     * Presumably, a pointer that isn't MAXALIGNED isn't pointing at an
     * allocated chunk.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>pointer</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>pointer</name> <operator>!=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * OK, it's probably safe to look at the context.
     */</comment>
    <expr_stmt><expr><name>ptr_context</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>MemoryContext</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pointer</name><operator>)</operator> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

    <return>return <expr><name>ptr_context</name> <operator>==</operator> <name>context</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*--------------------
 * MemoryContextCreate
 *        Context-type-independent part of context creation.
 *
 * This is only intended to be called by context-type-specific
 * context creation routines, not by the unwashed masses.
 *
 * The context creation procedure is a little bit tricky because
 * we want to be sure that we don't leave the context tree invalid
 * in case of failure (such as insufficient memory to allocate the
 * context node itself).  The procedure goes like this:
 *    1.  Context-type-specific routine first calls MemoryContextCreate(),
 *        passing the appropriate tag/size/methods values (the methods
 *        pointer will ordinarily point to statically allocated data).
 *        The parent and name parameters usually come from the caller.
 *    2.  MemoryContextCreate() attempts to allocate the context node,
 *        plus space for the name.  If this fails we can ereport() with no
 *        damage done.
 *    3.  We fill in all of the type-independent MemoryContext fields.
 *    4.  We call the type-specific init routine (using the methods pointer).
 *        The init routine is required to make the node minimally valid
 *        with zero chance of failure --- it can't allocate more memory,
 *        for example.
 *    5.  Now we have a minimally valid node that can behave correctly
 *        when told to reset or delete itself.  We link the node to its
 *        parent (if any), making the node part of the context tree.
 *    6.  We return to the context-type-specific routine, which finishes
 *        up type-specific initialization.  This routine can now do things
 *        that might fail (like allocate more memory), so long as it's
 *        sure the node is left in a state that delete will handle.
 *
 * This protocol doesn't prevent us from leaking memory if step 6 fails
 * during creation of a top-level context, since there's no parent link
 * in that case.  However, if you run out of memory while you're building
 * a top-level context, you might as well go home anyway...
 *
 * Normally, the context node and the name are allocated from
 * TopMemoryContext (NOT from the parent context, since the node must
 * survive resets of its parent context!).  However, this routine is itself
 * used to create TopMemoryContext!  If we see that TopMemoryContext is NULL,
 * we assume we are creating TopMemoryContext and use malloc() to allocate
 * the node.
 *
 * Note that the name field of a MemoryContext does not point to
 * separately-allocated storage, so it should not be freed at context
 * deletion.
 *--------------------
 */</comment>
<function><type><name>MemoryContext</name></type>
<name>MemoryContextCreate</name><parameter_list>(<parameter><decl><type><name>NodeTag</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>,
                    <parameter><decl><type><name>MemoryContextMethods</name> <modifier>*</modifier></type><name>methods</name></decl></parameter>,
                    <parameter><decl><type><name>MemoryContext</name></type> <name>parent</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>node</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>needed</name> <init>= <expr><name>size</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* creating new memory contexts is not allowed in a critical section */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CritSectionCount</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get space for node and name */</comment>
    <if_stmt><if>if <condition>(<expr><name>TopMemoryContext</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Normal case: allocate the node in TopMemoryContext */</comment>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>MemoryContext</name><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                                  <argument><expr><name>needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Special case for startup: use good ol' malloc */</comment>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>MemoryContext</name><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Initialize the node as best we can */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>tag</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <name>methods</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* for the moment */</comment>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prevchild</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nextchild</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Type-specific routine finishes any other essential initialization */</comment>
    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>node</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>init</name></name>) <argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* OK to link node to parent (if any) */</comment>
    <comment type="block">/* Could use MemoryContextSetParent here, but doesn't seem worthwhile */</comment>
    <if_stmt><if>if <condition>(<expr><name>parent</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nextchild</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>firstchild</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>firstchild</name><operator>-&gt;</operator><name>prevchild</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
        <comment type="block">/* inherit allowInCritSection flag from parent */</comment>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>allowInCritSection</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>allowInCritSection</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>VALGRIND_CREATE_MEMPOOL</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return to type-specific creation routine to finish up */</comment>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextAlloc
 *        Allocate space within the specified context.
 *
 * This could be turned into a macro, but we'd have to import
 * nodes/memnodes.h into postgres.h which seems a bad idea.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>MemoryContextAlloc</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu."</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>VALGRIND_MEMPOOL_ALLOC</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextAllocZero
 *        Like MemoryContextAlloc, but clears allocated memory
 *
 *    We could just call MemoryContextAlloc then clear the memory, but this
 *    is a very common combination, so we provide the combined operation.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>MemoryContextAllocZero</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu."</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>VALGRIND_MEMPOOL_ALLOC</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemSetAligned</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextAllocZeroAligned
 *        MemoryContextAllocZero where length is suitable for MemSetLoop
 *
 *    This might seem overly specialized, but it's not because newNode()
 *    is so often called with compile-time-constant sizes.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>MemoryContextAllocZeroAligned</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu."</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>VALGRIND_MEMPOOL_ALLOC</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemSetLoop</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextAllocExtended
 *        Allocate space within the specified context using the given flags.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>MemoryContextAllocExtended</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MCXT_ALLOC_HUGE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AllocHugeSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
        <operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MCXT_ALLOC_HUGE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MCXT_ALLOC_NO_OOM</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu."</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>VALGRIND_MEMPOOL_ALLOC</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MCXT_ALLOC_ZERO</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemSetAligned</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>palloc</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* duplicates MemoryContextAlloc to avoid increased overhead */</comment>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>CurrentMemoryContext</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>CurrentMemoryContext</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name>) <argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu."</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>VALGRIND_MEMPOOL_ALLOC</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>palloc0</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* duplicates MemoryContextAllocZero to avoid increased overhead */</comment>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>CurrentMemoryContext</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>CurrentMemoryContext</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name>) <argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu."</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>VALGRIND_MEMPOOL_ALLOC</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemSetAligned</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>palloc_extended</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* duplicates MemoryContextAllocExtended to avoid increased overhead */</comment>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MCXT_ALLOC_HUGE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AllocHugeSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
        <operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MCXT_ALLOC_HUGE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>CurrentMemoryContext</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>CurrentMemoryContext</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name>) <argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MCXT_ALLOC_NO_OOM</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu."</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>VALGRIND_MEMPOOL_ALLOC</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MCXT_ALLOC_ZERO</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemSetAligned</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pfree
 *        Release an allocated chunk.
 */</comment>
<function><type><name>void</name></type>
<name>pfree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name> <init>= <expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>free_p</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VALGRIND_MEMPOOL_FREE</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * repalloc
 *        Adjust the size of a previously allocated chunk.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>repalloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name> <init>= <expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* isReset must be false already */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>realloc</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu."</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>VALGRIND_MEMPOOL_CHANGE</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextAllocHuge
 *        Allocate (possibly-expansive) space within the specified context.
 *
 * See considerations in comment at MaxAllocHugeSize.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>MemoryContextAllocHuge</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocHugeSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu."</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>VALGRIND_MEMPOOL_ALLOC</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * repalloc_huge
 *        Adjust the size of a previously allocated chunk, permitting a large
 *        value.  The previous allocation need not have been "huge".
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>repalloc_huge</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name> <init>= <expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocHugeSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* isReset must be false already */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>realloc</name></name>) <argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu."</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>VALGRIND_MEMPOOL_CHANGE</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextStrdup
 *        Like strdup(), but allocate from the specified context
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>MemoryContextStrdup</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>nstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nstr</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>nstr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>pstrdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pnstrdup
 *        Like pstrdup(), but append null byte to a
 *        not-necessarily-null-terminated input string.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pnstrdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gen_alloc.h"</cpp:file></cpp:include>

<function_decl><type><name>void</name> <modifier>*</modifier></type><name>current_memcontext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name> <modifier>*</modifier></type><name>current_memcontext</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <return>return<expr><operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>CurrentMemoryContext</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type><name>allocTopCxt</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><operator>(</operator><name>Size</name><operator>)</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>Gen_Alloc</name></type> <name>genAlloc_class</name> <init>= <expr><block>{<expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>MemoryContextAlloc</name></expr>,
                            <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>MemoryContextAllocZero</name></expr>,
                            <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>repalloc</name></expr>,
                            <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pfree</name></expr>,
                            <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>current_memcontext</name></expr>,
                            <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>allocTopCxt</name></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Make copy of string with all trailing newline characters removed.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pchomp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>n</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>in</name><index>[<expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
    <return>return <expr><call><name>pnstrdup</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive>    <cpp:macro><name>MAX_MCTX_STAT_LENGTH</name></cpp:macro>    <cpp:value>2048</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>char</name>     <modifier>*</modifier></type><name>mctx_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>     <modifier>*</modifier></type><name>parent_mctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>level</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>index_on_parent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>    <name>self_totalspace</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>    <name>self_freespace</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>    <name>all_totalspace</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>    <name>all_freespace</name></decl>;</decl_stmt>
}</block></struct></type><name>MctxStat</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int</name></type>    <name>currIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MctxStat</name></type>    <name><name>mctxstat</name><index>[<expr><name>MAX_MCTX_STAT_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>    
}</block></struct></type> <name>ShmMgr_State</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_mctx_stat</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>, 
                    <parameter><decl><type><name>MemoryContext</name></type> <name>parent</name></decl></parameter>, 
                    <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,
                    <parameter><decl><type><name>int</name></type> <name>ind_on_parent</name></decl></parameter>, 
                    <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>ind_on_stat</name></decl></parameter>, 
                    <parameter><decl><type><name>MctxStat</name> <modifier>*</modifier></type><name>stat_arr</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>int</name></type> <name>get_mctx_stat</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>, 
                    <parameter><decl><type><name>MemoryContext</name></type> <name>parent</name></decl></parameter>, 
                    <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,
                    <parameter><decl><type><name>int</name></type> <name>ind_on_parent</name></decl></parameter>, 
                    <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>ind_on_stat</name></decl></parameter>, 
                    <parameter><decl><type><name>MctxStat</name> <modifier>*</modifier></type><name>stat_arr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type>    <name>iter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>child_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>itr_indx_on_stat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>next_ind_on_stat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MctxStat</name> <modifier>*</modifier></type> <name>stat</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name>ind_on_stat</name> <operator>&gt;=</operator> <name>MAX_MCTX_STAT_LENGTH</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>ind_on_stat</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>stat</name> <operator>=</operator> <operator>&amp;</operator><name><name>stat_arr</name><index>[<expr><name>ind_on_stat</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>mctx_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>mctx</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>parent_mctx</name></name> <operator>=</operator> <ternary><condition><expr><name>parent</name></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>index_on_parent</name></name> <operator>=</operator> <name>ind_on_parent</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>self_freespace</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>self_totalspace</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>,<argument><expr><name>AllocSetContext</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>AllocSetStats_Output</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stat</name><operator>-&gt;</operator><name>self_totalspace</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stat</name><operator>-&gt;</operator><name>self_freespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>all_freespace</name></name> <operator>=</operator> <name><name>stat</name><operator>-&gt;</operator><name>self_freespace</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>all_totalspace</name></name> <operator>=</operator> <name><name>stat</name><operator>-&gt;</operator><name>self_totalspace</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>itr_indx_on_stat</name> <operator>=</operator> <name>ind_on_stat</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>child_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>iter</name> <operator>=</operator> <name><name>mctx</name><operator>-&gt;</operator><name>firstchild</name></name></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>iter</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>next_ind_on_stat</name> <operator>=</operator> <call><name>get_mctx_stat</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>mctx</name></expr></argument>, <argument><expr><name>level</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>child_index</name></expr></argument>, <argument><expr><name>itr_indx_on_stat</name></expr></argument>, <argument><expr><name>stat_arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iter</name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>nextchild</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>all_freespace</name></name> <operator>+=</operator> <name><name>stat_arr</name><index>[<expr><name>itr_indx_on_stat</name></expr>]</index></name><operator>.</operator><name>all_freespace</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>all_totalspace</name></name> <operator>+=</operator> <name><name>stat_arr</name><index>[<expr><name>itr_indx_on_stat</name></expr>]</index></name><operator>.</operator><name>all_totalspace</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>itr_indx_on_stat</name> <operator>=</operator> <name>next_ind_on_stat</name></expr>;</expr_stmt>
         
        <expr_stmt><expr><name>child_index</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    
    <return>return <expr><name>itr_indx_on_stat</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int32</name></type> <name>get_total_memory_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LINUX_KERNEL_PAGE_SIZE</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILE_BUF_LEN</name></cpp:macro>           <cpp:value>1024</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>int32</name></type>  <name>size</name>          <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>Size</name></type>   <name>nTotalPage</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>   <name>nRssPage</name>      <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>   <name>nSharePage</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>   <name><name>kfile</name><index>[<expr><name>FILE_BUF_LEN</name></expr>]</index></name>   <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>   <name><name>linebuf</name><index>[<expr><name>FILE_BUF_LEN</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>   <modifier>*</modifier></type><name>handle</name>       <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShmMgr_State</name>    <modifier>*</modifier></type><name>mctx_status</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* try to use linux kernel info to calculate first*/</comment>    
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>kfile</name></expr></argument>, <argument><expr><name>FILE_BUF_LEN</name></expr></argument>, <argument><expr><literal type="string">"/proc/%d/statm"</literal></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>handle</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>kfile</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>handle</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"open file:%s failed for %s"</literal></expr></argument>, <argument><expr><name>kfile</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mctx_status</name> <operator>=</operator> <operator>(</operator><name>ShmMgr_State</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmMgr_State</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>get_mctx_stat</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>all_totalspace</name> <operator>+</operator> <operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>/</operator> <operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>mctx_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>linebuf</name></expr></argument>, <argument><expr><name>FILE_BUF_LEN</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* read first three value of the file */</comment>
            <if_stmt><if>if <condition>(<expr><literal type="number">3</literal> <operator>==</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>linebuf</name></expr></argument>, <argument><expr><literal type="string">"%lu %lu %lu"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nTotalPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nRssPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSharePage</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>nRssPage</name> <operator>&gt;=</operator> <name>nSharePage</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>nRssPage</name> <operator>-</operator> <name>nSharePage</name><operator>)</operator> <operator>*</operator> <name>LINUX_KERNEL_PAGE_SIZE</name> <operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>                
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>            
        <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>        
    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
