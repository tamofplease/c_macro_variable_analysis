<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/mmgr/dsa.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * dsa.c
 *      Dynamic shared memory areas.
 *
 * This module provides dynamic shared memory areas which are built on top of
 * DSM segments.  While dsm.c allows segments of memory of shared memory to be
 * created and shared between backends, it isn't designed to deal with small
 * objects.  A DSA area is a shared memory heap usually backed by one or more
 * DSM segments which can allocate memory using dsa_allocate() and dsa_free().
 * Alternatively, it can be created in pre-existing shared memory, including a
 * DSM segment, and then create extra DSM segments as required.  Unlike the
 * regular system heap, it deals in pseudo-pointers which must be converted to
 * backend-local pointers before they are dereferenced.  These pseudo-pointers
 * can however be shared with other backends, and can be used to construct
 * shared data structures.
 *
 * Each DSA area manages a set of DSM segments, adding new segments as
 * required and detaching them when they are no longer needed.  Each segment
 * contains a number of 4KB pages, a free page manager for tracking
 * consecutive runs of free pages, and a page map for tracking the source of
 * objects allocated on each page.  Allocation requests above 8KB are handled
 * by choosing a segment and finding consecutive free pages in its free page
 * manager.  Allocation requests for smaller sizes are handled using pools of
 * objects of a selection of sizes.  Each pool consists of a number of 16 page
 * (64KB) superblocks allocated in the same way as large objects.  Allocation
 * of large objects and new superblocks is serialized by a single LWLock, but
 * allocation of small objects from pre-existing superblocks uses one LWLock
 * per pool.  Currently there is one pool, and therefore one lock, per size
 * class.  Per-core pools to increase concurrency and strategies for reducing
 * the resulting fragmentation are areas for future research.  Each superblock
 * is managed with a 'span', which tracks the superblock's freelist.  Free
 * requests are handled by looking in the page map to find which span an
 * address was allocated from, so that small objects can be returned to the
 * appropriate free list, and large object pages can be returned directly to
 * the free page map.  When allocating, simple heuristics for selecting
 * segments and superblocks try to encourage occupied memory to be
 * concentrated, increasing the likelihood that whole superblocks can become
 * empty and be returned to the free page manager, and whole segments can
 * become empty and be returned to the operating system.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *      src/backend/utils/mmgr/dsa.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/atomics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/dsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/dsa.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/freepage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<comment type="block">/*
 * The size of the initial DSM segment that backs a dsa_area created by
 * dsa_create.  After creating some number of segments of this size we'll
 * double this size, and so on.  Larger segments may be created if necessary
 * to satisfy large requests.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_INITIAL_SEGMENT_SIZE</name></cpp:macro> <cpp:value>((Size) (1 * 1024 * 1024))</cpp:value></cpp:define>

<comment type="block">/*
 * How many segments to create before we double the segment size.  If this is
 * low, then there is likely to be a lot of wasted space in the largest
 * segment.  If it is high, then we risk running out of segment slots (see
 * dsm.c's limits on total number of segments), or limiting the total size
 * an area can manage when using small pointers.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_NUM_SEGMENTS_AT_EACH_SIZE</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<comment type="block">/*
 * The number of bits used to represent the offset part of a dsa_pointer.
 * This controls the maximum size of a segment, the maximum possible
 * allocation size and also the maximum number of segments per area.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_DSA_POINTER</name> <operator>==</operator> <literal type="number">4</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_OFFSET_WIDTH</name></cpp:macro> <cpp:value>27</cpp:value></cpp:define>        <comment type="block">/* 32 segments of size up to 128MB */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_OFFSET_WIDTH</name></cpp:macro> <cpp:value>40</cpp:value></cpp:define>        <comment type="block">/* 1024 segments of size up to 1TB */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * The maximum number of DSM segments that an area can own, determined by
 * the number of bits remaining (but capped at 1024).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_MAX_SEGMENTS</name></cpp:macro> \
    <cpp:value>Min(1024, (1 &lt;&lt; ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))</cpp:value></cpp:define>

<comment type="block">/* The bitmask for extracting the offset from a dsa_pointer. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_OFFSET_BITMASK</name></cpp:macro> <cpp:value>(((dsa_pointer) 1 &lt;&lt; DSA_OFFSET_WIDTH) - 1)</cpp:value></cpp:define>

<comment type="block">/* The maximum size of a DSM segment. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_MAX_SEGMENT_SIZE</name></cpp:macro> <cpp:value>((Size) 1 &lt;&lt; DSA_OFFSET_WIDTH)</cpp:value></cpp:define>

<comment type="block">/* Number of pages (see FPM_PAGE_SIZE) per regular superblock. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_PAGES_PER_SUPERBLOCK</name></cpp:macro>        <cpp:value>16</cpp:value></cpp:define>

<comment type="block">/*
 * A magic number used as a sanity check for following DSM segments belonging
 * to a DSA area (this number will be XORed with the area handle and
 * the segment index).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_SEGMENT_HEADER_MAGIC</name></cpp:macro> <cpp:value>0x0ce26608</cpp:value></cpp:define>

<comment type="block">/* Build a dsa_pointer given a segment number and offset. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_MAKE_POINTER</name><parameter_list>(<parameter><type><name>segment_number</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>(((dsa_pointer) (segment_number) &lt;&lt; DSA_OFFSET_WIDTH) | (offset))</cpp:value></cpp:define>

<comment type="block">/* Extract the segment number from a dsa_pointer. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_EXTRACT_SEGMENT_NUMBER</name><parameter_list>(<parameter><type><name>dp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((dp) &gt;&gt; DSA_OFFSET_WIDTH)</cpp:value></cpp:define>

<comment type="block">/* Extract the offset from a dsa_pointer. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_EXTRACT_OFFSET</name><parameter_list>(<parameter><type><name>dp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((dp) &amp; DSA_OFFSET_BITMASK)</cpp:value></cpp:define>

<comment type="block">/* The type used for index segment indexes (zero based). */</comment>
<typedef>typedef <type><name>Size</name></type> <name>dsa_segment_index</name>;</typedef>

<comment type="block">/* Sentinel value for dsa_segment_index indicating 'none' or 'end'. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_SEGMENT_INDEX_NONE</name></cpp:macro> <cpp:value>(~(dsa_segment_index)0)</cpp:value></cpp:define>

<comment type="block">/*
 * How many bins of segments do we have?  The bins are used to categorize
 * segments by their largest contiguous run of free pages.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_NUM_SEGMENT_BINS</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<comment type="block">/*
 * What is the lowest bin that holds segments that *might* have n contiguous
 * free pages?    There is no point in looking in segments in lower bins; they
 * definitely can't service a request for n free pages.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>contiguous_pages_to_segment_bin</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Min(fls(n), DSA_NUM_SEGMENT_BINS - 1)</cpp:value></cpp:define>

<comment type="block">/* Macros for access to locks. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_AREA_LOCK</name><parameter_list>(<parameter><type><name>area</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;area-&gt;control-&gt;lock)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_SCLASS_LOCK</name><parameter_list>(<parameter><type><name>area</name></type></parameter>, <parameter><type><name>sclass</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;area-&gt;control-&gt;pools[sclass].lock)</cpp:value></cpp:define>

<comment type="block">/*
 * The header for an individual segment.  This lives at the start of each DSM
 * segment owned by a DSA area including the first segment (where it appears
 * as part of the dsa_area_control struct).
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <comment type="block">/* Sanity check magic value. */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>magic</name></decl>;</decl_stmt>
    <comment type="block">/* Total number of pages in this segment (excluding metadata area). */</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>usable_pages</name></decl>;</decl_stmt>
    <comment type="block">/* Total size of this segment in bytes. */</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Index of the segment that precedes this one in the same segment bin, or
     * DSA_SEGMENT_INDEX_NONE if this is the first one.
     */</comment>
    <decl_stmt><decl><type><name>dsa_segment_index</name></type> <name>prev</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Index of the segment that follows this one in the same segment bin, or
     * DSA_SEGMENT_INDEX_NONE if this is the last one.
     */</comment>
    <decl_stmt><decl><type><name>dsa_segment_index</name></type> <name>next</name></decl>;</decl_stmt>
    <comment type="block">/* The index of the bin that contains this segment. */</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>bin</name></decl>;</decl_stmt>

    <comment type="block">/*
     * A flag raised to indicate that this segment is being returned to the
     * operating system and has been unpinned.
     */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>freed</name></decl>;</decl_stmt>
}</block></struct></type> <name>dsa_segment_header</name>;</typedef>

<comment type="block">/*
 * Metadata for one superblock.
 *
 * For most blocks, span objects are stored out-of-line; that is, the span
 * object is not stored within the block itself.  But, as an exception, for a
 * "span of spans", the span object is stored "inline".  The allocation is
 * always exactly one page, and the dsa_area_span object is located at
 * the beginning of that page.  The size class is DSA_SCLASS_BLOCK_OF_SPANS,
 * and the remaining fields are used just as they would be in an ordinary
 * block.  We can't allocate spans out of ordinary superblocks because
 * creating an ordinary superblock requires us to be able to allocate a span
 * *first*.  Doing it this way avoids that circularity.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>pool</name></decl>;</decl_stmt>            <comment type="block">/* Containing pool. */</comment>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>prevspan</name></decl>;</decl_stmt>        <comment type="block">/* Previous span. */</comment>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>nextspan</name></decl>;</decl_stmt>        <comment type="block">/* Next span. */</comment>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>start</name></decl>;</decl_stmt>            <comment type="block">/* Starting address. */</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>npages</name></decl>;</decl_stmt>            <comment type="block">/* Length of span in pages. */</comment>
    <decl_stmt><decl><type><name>uint16</name></type>        <name>size_class</name></decl>;</decl_stmt>        <comment type="block">/* Size class. */</comment>
    <decl_stmt><decl><type><name>uint16</name></type>        <name>ninitialized</name></decl>;</decl_stmt>    <comment type="block">/* Maximum number of objects ever allocated. */</comment>
    <decl_stmt><decl><type><name>uint16</name></type>        <name>nallocatable</name></decl>;</decl_stmt>    <comment type="block">/* Number of objects currently allocatable. */</comment>
    <decl_stmt><decl><type><name>uint16</name></type>        <name>firstfree</name></decl>;</decl_stmt>        <comment type="block">/* First object on free list. */</comment>
    <decl_stmt><decl><type><name>uint16</name></type>        <name>nmax</name></decl>;</decl_stmt>            <comment type="block">/* Maximum number of objects ever possible. */</comment>
    <decl_stmt><decl><type><name>uint16</name></type>        <name>fclass</name></decl>;</decl_stmt>            <comment type="block">/* Current fullness class. */</comment>
}</block></struct></type> <name>dsa_area_span</name>;</typedef>

<comment type="block">/*
 * Given a pointer to an object in a span, access the index of the next free
 * object in the same span (ie in the span's freelist) as an L-value.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NextFreeObjectIndex</name><parameter_list>(<parameter><type><name>object</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(* (uint16 *) (object))</cpp:value></cpp:define>

<comment type="block">/*
 * Small allocations are handled by dividing a single block of memory into
 * many small objects of equal size.  The possible allocation sizes are
 * defined by the following array.  Larger size classes are spaced more widely
 * than smaller size classes.  We fudge the spacing for size classes &gt;1kB to
 * avoid space wastage: based on the knowledge that we plan to allocate 64kB
 * blocks, we bump the maximum object size up to the largest multiple of
 * 8 bytes that still lets us fit the same number of objects into one block.
 *
 * NB: Because of this fudging, if we were ever to use differently-sized blocks
 * for small allocations, these size classes would need to be reworked to be
 * optimal for the new size.
 *
 * NB: The optimal spacing for size classes, as well as the size of the blocks
 * out of which small objects are allocated, is not a question that has one
 * right answer.  Some allocators (such as tcmalloc) use more closely-spaced
 * size classes than we do here, while others (like aset.c) use more
 * widely-spaced classes.  Spacing the classes more closely avoids wasting
 * memory within individual chunks, but also means a larger number of
 * potentially-unfilled blocks.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16</name></type> <name><name>dsa_size_classes</name><index>[]</index></name> <init>= <expr><block>{
    <expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_area_span</name></expr></argument>)</argument_list></sizeof></expr>, <expr><literal type="number">0</literal></expr>,    <comment type="block">/* special size classes */</comment>
    <expr><literal type="number">8</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">40</literal></expr>, <expr><literal type="number">48</literal></expr>, <expr><literal type="number">56</literal></expr>, <expr><literal type="number">64</literal></expr>,    <comment type="block">/* 8 classes separated by 8 bytes */</comment>
    <expr><literal type="number">80</literal></expr>, <expr><literal type="number">96</literal></expr>, <expr><literal type="number">112</literal></expr>, <expr><literal type="number">128</literal></expr>,            <comment type="block">/* 4 classes separated by 16 bytes */</comment>
    <expr><literal type="number">160</literal></expr>, <expr><literal type="number">192</literal></expr>, <expr><literal type="number">224</literal></expr>, <expr><literal type="number">256</literal></expr>,            <comment type="block">/* 4 classes separated by 32 bytes */</comment>
    <expr><literal type="number">320</literal></expr>, <expr><literal type="number">384</literal></expr>, <expr><literal type="number">448</literal></expr>, <expr><literal type="number">512</literal></expr>,            <comment type="block">/* 4 classes separated by 64 bytes */</comment>
    <expr><literal type="number">640</literal></expr>, <expr><literal type="number">768</literal></expr>, <expr><literal type="number">896</literal></expr>, <expr><literal type="number">1024</literal></expr>,        <comment type="block">/* 4 classes separated by 128 bytes */</comment>
    <expr><literal type="number">1280</literal></expr>, <expr><literal type="number">1560</literal></expr>, <expr><literal type="number">1816</literal></expr>, <expr><literal type="number">2048</literal></expr>,        <comment type="block">/* 4 classes separated by ~256 bytes */</comment>
    <expr><literal type="number">2616</literal></expr>, <expr><literal type="number">3120</literal></expr>, <expr><literal type="number">3640</literal></expr>, <expr><literal type="number">4096</literal></expr>,        <comment type="block">/* 4 classes separated by ~512 bytes */</comment>
    <expr><literal type="number">5456</literal></expr>, <expr><literal type="number">6552</literal></expr>, <expr><literal type="number">7280</literal></expr>, <expr><literal type="number">8192</literal></expr>        <comment type="block">/* 4 classes separated by ~1024 bytes */</comment>
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_NUM_SIZE_CLASSES</name></cpp:macro>                <cpp:value>lengthof(dsa_size_classes)</cpp:value></cpp:define>

<comment type="block">/* Special size classes. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_SCLASS_BLOCK_OF_SPANS</name></cpp:macro>        <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_SCLASS_SPAN_LARGE</name></cpp:macro>            <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/*
 * The following lookup table is used to map the size of small objects
 * (less than 1kB) onto the corresponding size class.  To use this table,
 * round the size of the object up to the next multiple of 8 bytes, and then
 * index into this array.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8</name></type> <name><name>dsa_size_class_map</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>,
    <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">17</literal></expr>,
    <expr><literal type="number">18</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">19</literal></expr>,
    <expr><literal type="number">20</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">21</literal></expr>,
    <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>,
    <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>,
    <expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>,
    <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_SIZE_CLASS_MAP_QUANTUM</name></cpp:macro>    <cpp:value>8</cpp:value></cpp:define>

<comment type="block">/*
 * Superblocks are binned by how full they are.  Generally, each fullness
 * class corresponds to one quartile, but the block being used for
 * allocations is always at the head of the list for fullness class 1,
 * regardless of how full it really is.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_FULLNESS_CLASSES</name></cpp:macro>        <cpp:value>4</cpp:value></cpp:define>

<comment type="block">/*
 * A dsa_area_pool represents a set of objects of a given size class.
 *
 * Perhaps there should be multiple pools for the same size class for
 * contention avoidance, but for now there is just one!
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <comment type="block">/* A lock protecting access to this pool. */</comment>
    <decl_stmt><decl><type><name>LWLock</name></type>        <name>lock</name></decl>;</decl_stmt>
    <comment type="block">/* A set of linked lists of spans, arranged by fullness. */</comment>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name><name>spans</name><index>[<expr><name>DSA_FULLNESS_CLASSES</name></expr>]</index></name></decl>;</decl_stmt>
    <comment type="block">/* Should we pad this out to a cacheline boundary? */</comment>
}</block></struct></type> <name>dsa_area_pool</name>;</typedef>

<comment type="block">/*
 * The control block for an area.  This lives in shared memory, at the start of
 * the first DSM segment controlled by this area.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <comment type="block">/* The segment header for the first segment. */</comment>
    <decl_stmt><decl><type><name>dsa_segment_header</name></type> <name>segment_header</name></decl>;</decl_stmt>
    <comment type="block">/* The handle for this area. */</comment>
    <decl_stmt><decl><type><name>dsa_handle</name></type>    <name>handle</name></decl>;</decl_stmt>
    <comment type="block">/* The handles of the segments owned by this area. */</comment>
    <decl_stmt><decl><type><name>dsm_handle</name></type>    <name><name>segment_handles</name><index>[<expr><name>DSA_MAX_SEGMENTS</name></expr>]</index></name></decl>;</decl_stmt>
    <comment type="block">/* Lists of segments, binned by maximum contiguous run of free pages. */</comment>
    <decl_stmt><decl><type><name>dsa_segment_index</name></type> <name><name>segment_bins</name><index>[<expr><name>DSA_NUM_SEGMENT_BINS</name></expr>]</index></name></decl>;</decl_stmt>
    <comment type="block">/* The object pools for each size class. */</comment>
    <decl_stmt><decl><type><name>dsa_area_pool</name></type> <name><name>pools</name><index>[<expr><name>DSA_NUM_SIZE_CLASSES</name></expr>]</index></name></decl>;</decl_stmt>
    <comment type="block">/* The total size of all active segments. */</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>total_segment_size</name></decl>;</decl_stmt>
    <comment type="block">/* The maximum total size of backing storage we are allowed. */</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>max_total_segment_size</name></decl>;</decl_stmt>
    <comment type="block">/* Highest used segment index in the history of this area. */</comment>
    <decl_stmt><decl><type><name>dsa_segment_index</name></type> <name>high_segment_index</name></decl>;</decl_stmt>
    <comment type="block">/* The reference count for this area. */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>refcnt</name></decl>;</decl_stmt>
    <comment type="block">/* A flag indicating that this area has been pinned. */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>pinned</name></decl>;</decl_stmt>
    <comment type="block">/* The number of times that segments have been freed. */</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>freed_segment_counter</name></decl>;</decl_stmt>
    <comment type="block">/* The LWLock tranche ID. */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>lwlock_tranche_id</name></decl>;</decl_stmt>
    <comment type="block">/* The general lock (protects everything except object pools). */</comment>
    <decl_stmt><decl><type><name>LWLock</name></type>        <name>lock</name></decl>;</decl_stmt>
}</block></struct></type> <name>dsa_area_control</name>;</typedef>

<comment type="block">/* Given a pointer to a pool, find a dsa_pointer. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DsaAreaPoolToDsaPointer</name><parameter_list>(<parameter><type><name>area</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>    \
    <cpp:value>DSA_MAKE_POINTER(0, (char *) p - (char *) area-&gt;control)</cpp:value></cpp:define>

<comment type="block">/*
 * A dsa_segment_map is stored within the backend-private memory of each
 * individual backend.  It holds the base address of the segment within that
 * backend, plus the addresses of key objects within the segment.  Those
 * could instead be derived from the base address but it's handy to have them
 * around.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>segment</name></decl>;</decl_stmt>        <comment type="block">/* DSM segment */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>mapped_address</name></decl>;</decl_stmt> <comment type="block">/* Address at which segment is mapped */</comment>
    <decl_stmt><decl><type><name>dsa_segment_header</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt> <comment type="block">/* Header (same as mapped_address) */</comment>
    <decl_stmt><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl>;</decl_stmt>        <comment type="block">/* Free page manager within segment. */</comment>
    <decl_stmt><decl><type><name>dsa_pointer</name> <modifier>*</modifier></type><name>pagemap</name></decl>;</decl_stmt>        <comment type="block">/* Page map within segment. */</comment>
}</block></struct></type> <name>dsa_segment_map</name>;</typedef>

<comment type="block">/*
 * Per-backend state for a storage area.  Backends obtain one of these by
 * creating an area or attaching to an existing one using a handle.  Each
 * process that needs to use an area uses its own object to track where the
 * segments are mapped.
 */</comment>
<struct>struct <name>dsa_area</name>
<block>{
    <comment type="block">/* Pointer to the control object in shared memory. */</comment>
    <decl_stmt><decl><type><name>dsa_area_control</name> <modifier>*</modifier></type><name>control</name></decl>;</decl_stmt>

    <comment type="block">/* Has the mapping been pinned? */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>mapping_pinned</name></decl>;</decl_stmt>

    <comment type="block">/*
     * This backend's array of segment maps, ordered by segment index
     * corresponding to control-&gt;segment_handles.  Some of the area's segments
     * may not be mapped in in this backend yet, and some slots may have been
     * freed and need to be detached; these operations happen on demand.
     */</comment>
    <decl_stmt><decl><type><name>dsa_segment_map</name></type> <name><name>segment_maps</name><index>[<expr><name>DSA_MAX_SEGMENTS</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* The highest segment index this backend has ever mapped. */</comment>
    <decl_stmt><decl><type><name>dsa_segment_index</name></type> <name>high_segment_index</name></decl>;</decl_stmt>

    <comment type="block">/* The last observed freed_segment_counter. */</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>freed_segment_counter</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_SPAN_NOTHING_FREE</name></cpp:macro>    <cpp:value>((uint16) -1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSA_SUPERBLOCK_SIZE</name></cpp:macro> <cpp:value>(DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)</cpp:value></cpp:define>

<comment type="block">/* Given a pointer to a segment_map, obtain a segment index number. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get_segment_index</name><parameter_list>(<parameter><type><name>area</name></type></parameter>, <parameter><type><name>segment_map_ptr</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>(segment_map_ptr - &amp;area-&gt;segment_maps[0])</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_span</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>dsa_pointer</name></type> <name>span_pointer</name></decl></parameter>,
          <parameter><decl><type><name>dsa_area_pool</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>, <parameter><decl><type><name>dsa_pointer</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>npages</name></decl></parameter>,
          <parameter><decl><type><name>uint16</name></type> <name>size_class</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>transfer_first_span</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>dsa_area_pool</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>,
                    <parameter><decl><type><name>int</name></type> <name>fromclass</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>toclass</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>dsa_pointer</name></type> <name>alloc_object</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size_class</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ensure_active_superblock</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>dsa_area_pool</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>,
                         <parameter><decl><type><name>int</name></type> <name>size_class</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>dsa_segment_map</name> <modifier>*</modifier></type><name>get_segment_by_index</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>,
                     <parameter><decl><type><name>dsa_segment_index</name></type> <name>index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>destroy_superblock</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>dsa_pointer</name></type> <name>span_pointer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>unlink_span</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>span</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_span_to_fullness_class</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>span</name></decl></parameter>,
                           <parameter><decl><type><name>dsa_pointer</name></type> <name>span_pointer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fclass</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>unlink_segment</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>dsa_segment_map</name> <modifier>*</modifier></type><name>segment_map</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>dsa_segment_map</name> <modifier>*</modifier></type><name>get_best_segment</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>npages</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>dsa_segment_map</name> <modifier>*</modifier></type><name>make_new_segment</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>requested_pages</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>dsa_area</name> <modifier>*</modifier></type><name>create_internal</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>place</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
                <parameter><decl><type><name>int</name></type> <name>tranche_id</name></decl></parameter>,
                <parameter><decl><type><name>dsm_handle</name></type> <name>control_handle</name></decl></parameter>,
                <parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>control_segment</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>dsa_area</name> <modifier>*</modifier></type><name>attach_internal</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>place</name></decl></parameter>, <parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>segment</name></decl></parameter>,
                <parameter><decl><type><name>dsa_handle</name></type> <name>handle</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_for_freed_segments</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_for_freed_segments_locked</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Create a new shared area in a new DSM segment.  Further DSM segments will
 * be allocated as required to extend the available space.
 *
 * We can't allocate a LWLock tranche_id within this function, because tranche
 * IDs are a scarce resource; there are only 64k available, using low numbers
 * when possible matters, and we have no provision for recycling them.  So,
 * we require the caller to provide one.
 */</comment>
<function><type><name>dsa_area</name> <modifier>*</modifier></type>
<name>dsa_create</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>tranche_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>segment</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_area</name>   <modifier>*</modifier></type><name>area</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Create the DSM segment that will hold the shared control object and the
     * first segment of usable space.
     */</comment>
    <expr_stmt><expr><name>segment</name> <operator>=</operator> <call><name>dsm_create</name><argument_list>(<argument><expr><name>DSA_INITIAL_SEGMENT_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * All segments backing this area are pinned, so that DSA can explicitly
     * control their lifetime (otherwise a newly created segment belonging to
     * this area might be freed when the only backend that happens to have it
     * mapped in ends, corrupting the area).
     */</comment>
    <expr_stmt><expr><call><name>dsm_pin_segment</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create a new DSA area with the control object in this segment. */</comment>
    <expr_stmt><expr><name>area</name> <operator>=</operator> <call><name>create_internal</name><argument_list>(<argument><expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>DSA_INITIAL_SEGMENT_SIZE</name></expr></argument>,
                           <argument><expr><name>tranche_id</name></expr></argument>,
                           <argument><expr><call><name>dsm_segment_handle</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clean up when the control segment detaches. */</comment>
    <expr_stmt><expr><call><name>on_dsm_detach</name><argument_list>(<argument><expr><name>segment</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dsa_on_dsm_detach_release_in_place</name></expr></argument>,
                  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>area</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a new shared area in an existing shared memory space, which may be
 * either DSM or Postmaster-initialized memory.  DSM segments will be
 * allocated as required to extend the available space, though that can be
 * prevented with dsa_set_size_limit(area, size) using the same size provided
 * to dsa_create_in_place.
 *
 * Areas created in-place must eventually be released by the backend that
 * created them and all backends that attach to them.  This can be done
 * explicitly with dsa_release_in_place, or, in the special case that 'place'
 * happens to be in a pre-existing DSM segment, by passing in a pointer to the
 * segment so that a detach hook can be registered with the containing DSM
 * segment.
 *
 * See dsa_create() for a note about the tranche arguments.
 */</comment>
<function><type><name>dsa_area</name> <modifier>*</modifier></type>
<name>dsa_create_in_place</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>place</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
                    <parameter><decl><type><name>int</name></type> <name>tranche_id</name></decl></parameter>, <parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>segment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dsa_area</name>   <modifier>*</modifier></type><name>area</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>area</name> <operator>=</operator> <call><name>create_internal</name><argument_list>(<argument><expr><name>place</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>tranche_id</name></expr></argument>,
                           <argument><expr><name>DSM_HANDLE_INVALID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Clean up when the control segment detaches, if a containing DSM segment
     * was provided.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>segment</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>on_dsm_detach</name><argument_list>(<argument><expr><name>segment</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dsa_on_dsm_detach_release_in_place</name></expr></argument>,
                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>place</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>area</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Obtain a handle that can be passed to other processes so that they can
 * attach to the given area.  Cannot be called for areas created with
 * dsa_create_in_place.
 */</comment>
<function><type><name>dsa_handle</name></type>
<name>dsa_get_handle</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>handle</name></name> <operator>!=</operator> <name>DSM_HANDLE_INVALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>handle</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Attach to an area given a handle generated (possibly in another process) by
 * dsa_get_handle.  The area must have been created with dsa_create (not
 * dsa_create_in_place).
 */</comment>
<function><type><name>dsa_area</name> <modifier>*</modifier></type>
<name>dsa_attach</name><parameter_list>(<parameter><decl><type><name>dsa_handle</name></type> <name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>segment</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_area</name>   <modifier>*</modifier></type><name>area</name></decl>;</decl_stmt>

    <comment type="block">/*
     * An area handle is really a DSM segment handle for the first segment, so
     * we go ahead and attach to that.
     */</comment>
    <expr_stmt><expr><name>segment</name> <operator>=</operator> <call><name>dsm_attach</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>segment</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not attach to dynamic shared area"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>area</name> <operator>=</operator> <call><name>attach_internal</name><argument_list>(<argument><expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>segment</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clean up when the control segment detaches. */</comment>
    <expr_stmt><expr><call><name>on_dsm_detach</name><argument_list>(<argument><expr><name>segment</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dsa_on_dsm_detach_release_in_place</name></expr></argument>,
                  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>area</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Attach to an area that was created with dsa_create_in_place.  The caller
 * must somehow know the location in memory that was used when the area was
 * created, though it may be mapped at a different virtual address in this
 * process.
 *
 * See dsa_create_in_place for note about releasing in-place areas, and the
 * optional 'segment' argument which can be provided to allow automatic
 * release if the containing memory happens to be a DSM segment.
 */</comment>
<function><type><name>dsa_area</name> <modifier>*</modifier></type>
<name>dsa_attach_in_place</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>place</name></decl></parameter>, <parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>segment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dsa_area</name>   <modifier>*</modifier></type><name>area</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>area</name> <operator>=</operator> <call><name>attach_internal</name><argument_list>(<argument><expr><name>place</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>DSM_HANDLE_INVALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Clean up when the control segment detaches, if a containing DSM segment
     * was provided.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>segment</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>on_dsm_detach</name><argument_list>(<argument><expr><name>segment</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dsa_on_dsm_detach_release_in_place</name></expr></argument>,
                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>place</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>area</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Release a DSA area that was produced by dsa_create_in_place or
 * dsa_attach_in_place.  The 'segment' argument is ignored but provides an
 * interface suitable for on_dsm_detach, for the convenience of users who want
 * to create a DSA segment inside an existing DSM segment and have it
 * automatically released when the containing DSM segment is detached.
 * 'place' should be the address of the place where the area was created.
 *
 * This callback is automatically registered for the DSM segment containing
 * the control object of in-place areas when a segment is provided to
 * dsa_create_in_place or dsa_attach_in_place, and also for all areas created
 * with dsa_create.
 */</comment>
<function><type><name>void</name></type>
<name>dsa_on_dsm_detach_release_in_place</name><parameter_list>(<parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>segment</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>place</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>dsa_release_in_place</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>place</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Release a DSA area that was produced by dsa_create_in_place or
 * dsa_attach_in_place.  The 'code' argument is ignored but provides an
 * interface suitable for on_shmem_exit or before_shmem_exit, for the
 * convenience of users who want to create a DSA segment inside shared memory
 * other than a DSM segment and have it automatically release at backend exit.
 * 'place' should be the address of the place where the area was created.
 */</comment>
<function><type><name>void</name></type>
<name>dsa_on_shmem_exit_release_in_place</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>place</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>dsa_release_in_place</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>place</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Release a DSA area that was produced by dsa_create_in_place or
 * dsa_attach_in_place.  It is preferable to use one of the 'dsa_on_XXX'
 * callbacks so that this is managed automatically, because failure to release
 * an area created in-place leaks its segments permanently.
 *
 * This is also called automatically for areas produced by dsa_create or
 * dsa_attach as an implementation detail.
 */</comment>
<function><type><name>void</name></type>
<name>dsa_release_in_place</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>place</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dsa_area_control</name> <modifier>*</modifier></type><name>control</name> <init>= <expr><operator>(</operator><name>dsa_area_control</name> <operator>*</operator><operator>)</operator> <name>place</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>control</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>segment_header</name><operator>.</operator><name>magic</name></name> <operator>==</operator>
           <operator>(</operator><name>DSA_SEGMENT_HEADER_MAGIC</name> <operator>^</operator> <name><name>control</name><operator>-&gt;</operator><name>handle</name></name> <operator>^</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>refcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>control</name><operator>-&gt;</operator><name>refcnt</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>control</name><operator>-&gt;</operator><name>high_segment_index</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>dsm_handle</name></type>    <name>handle</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>handle</name> <operator>=</operator> <name><name>control</name><operator>-&gt;</operator><name>segment_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>handle</name> <operator>!=</operator> <name>DSM_HANDLE_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>dsm_unpin_segment</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>control</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Keep a DSA area attached until end of session or explicit detach.
 *
 * By default, areas are owned by the current resource owner, which means they
 * are detached automatically when that scope ends.
 */</comment>
<function><type><name>void</name></type>
<name>dsa_pin_mapping</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>area</name><operator>-&gt;</operator><name>mapping_pinned</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>mapping_pinned</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>area</name><operator>-&gt;</operator><name>high_segment_index</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segment</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>dsm_pin_mapping</name><argument_list>(<argument><expr><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate memory in this storage area.  The return value is a dsa_pointer
 * that can be passed to other processes, and converted to a local pointer
 * with dsa_get_address.  'flags' is a bitmap which should be constructed
 * from the following values:
 *
 * DSA_ALLOC_HUGE allows allocations &gt;= 1GB.  Otherwise, such allocations
 * will result in an ERROR.
 *
 * DSA_ALLOC_NO_OOM causes this function to return InvalidDsaPointer when
 * no memory is available or a size limit establed by dsa_set_size_limit
 * would be exceeded.  Otherwise, such allocations will result in an ERROR.
 *
 * DSA_ALLOC_ZERO causes the allocated memory to be zeroed.  Otherwise, the
 * contents of newly-allocated memory are indeterminate.
 *
 * These flags correspond to similarly named flags used by
 * MemoryContextAllocExtended().  See also the macros dsa_allocate and
 * dsa_allocate0 which expand to a call to this function with commonly used
 * flags.
 */</comment>
<function><type><name>dsa_pointer</name></type>
<name>dsa_allocate_extended</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>uint16</name></type>        <name>size_class</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>start_pointer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_segment_map</name> <modifier>*</modifier></type><name>segment_map</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Sanity check on huge individual allocation size. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>DSA_ALLOC_HUGE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AllocHugeSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
        <operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>DSA_ALLOC_HUGE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid DSA memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If bigger than the largest size class, just grab a run of pages from
     * the free page manager, instead of allocating an object from a pool.
     * There will still be a span, but it's a special class of span that
     * manages this whole allocation and simply gives all pages back to the
     * free page manager when dsa_free is called.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <name><name>dsa_size_classes</name><index>[<expr><call><name>lengthof</name><argument_list>(<argument><expr><name>dsa_size_classes</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Size</name></type>        <name>npages</name> <init>= <expr><call><name>fpm_size_to_pages</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Size</name></type>        <name>first_page</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>span_pointer</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dsa_area_pool</name> <modifier>*</modifier></type><name>pool</name> <init>= <expr><operator>&amp;</operator><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>pools</name><index>[<expr><name>DSA_SCLASS_SPAN_LARGE</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Obtain a span object. */</comment>
        <expr_stmt><expr><name>span_pointer</name> <operator>=</operator> <call><name>alloc_object</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>DSA_SCLASS_BLOCK_OF_SPANS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name>span_pointer</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Raise error unless asked not to. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>DSA_ALLOC_NO_OOM</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on DSA request of size %zu."</literal></expr></argument>,
								   <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>InvalidDsaPointer</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Find a segment from which to allocate. */</comment>
        <expr_stmt><expr><name>segment_map</name> <operator>=</operator> <call><name>get_best_segment</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>segment_map</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>segment_map</name> <operator>=</operator> <call><name>make_new_segment</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>segment_map</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Can't make any more segments: game over. */</comment>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>span_pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Raise error unless asked not to. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MCXT_ALLOC_NO_OOM</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on DSA request of size %zu."</literal></expr></argument>,
                                   <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>InvalidDsaPointer</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Ask the free page manager for a run of pages.  This should always
         * succeed, since both get_best_segment and make_new_segment should
         * only return a non-NULL pointer if it actually contains enough
         * contiguous freespace.  If it does fail, something in our backend
         * private state is out of whack, so use FATAL to kill the process.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FreePageManagerGet</name><argument_list>(<argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>fpm</name></name></expr></argument>, <argument><expr><name>npages</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>first_page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                 <argument><expr><literal type="string">"dsa_allocate could not find %zu free pages"</literal></expr></argument>, <argument><expr><name>npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>start_pointer</name> <operator>=</operator> <call><name>DSA_MAKE_POINTER</name><argument_list>(<argument><expr><call><name>get_segment_index</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>segment_map</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name>first_page</name> <operator>*</operator> <name>FPM_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Initialize span and pagemap. */</comment>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>DSA_SCLASS_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>DSA_SCLASS_SPAN_LARGE</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>init_span</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>span_pointer</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>start_pointer</name></expr></argument>, <argument><expr><name>npages</name></expr></argument>,
                  <argument><expr><name>DSA_SCLASS_SPAN_LARGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>pagemap</name><index>[<expr><name>first_page</name></expr>]</index></name> <operator>=</operator> <name>span_pointer</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_SCLASS_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>DSA_SCLASS_SPAN_LARGE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Zero-initialize the memory if requested. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>DSA_ALLOC_ZERO</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>start_pointer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <return>return <expr><name>start_pointer</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Map allocation to a size class. */</comment>
    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>dsa_size_class_map</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>DSA_SIZE_CLASS_MAP_QUANTUM</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>mapidx</name></decl>;</decl_stmt>

        <comment type="block">/* For smaller sizes we have a lookup table... */</comment>
        <expr_stmt><expr><name>mapidx</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>size</name> <operator>+</operator> <name>DSA_SIZE_CLASS_MAP_QUANTUM</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator>
                  <name>DSA_SIZE_CLASS_MAP_QUANTUM</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>size_class</name> <operator>=</operator> <name><name>dsa_size_class_map</name><index>[<expr><name>mapidx</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint16</name></type>        <name>min</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint16</name></type>        <name>max</name></decl>;</decl_stmt>

        <comment type="block">/* ... and for the rest we search by binary chop. */</comment>
        <expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>dsa_size_class_map</name><index>[<expr><call><name>lengthof</name><argument_list>(<argument><expr><name>dsa_size_class_map</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>dsa_size_classes</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <while>while <condition>(<expr><name>min</name> <operator>&lt;</operator> <name>max</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>uint16</name></type>        <name>mid</name> <init>= <expr><operator>(</operator><name>min</name> <operator>+</operator> <name>max</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint16</name></type>        <name>class_size</name> <init>= <expr><name><name>dsa_size_classes</name><index>[<expr><name>mid</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>class_size</name> <operator>&lt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>min</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>max</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><name>size_class</name> <operator>=</operator> <name>min</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>size</name> <operator>&lt;=</operator> <name><name>dsa_size_classes</name><index>[<expr><name>size_class</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>size_class</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>size</name> <operator>&gt;</operator> <name><name>dsa_size_classes</name><index>[<expr><name>size_class</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Attempt to allocate an object from the appropriate pool. */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>alloc_object</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>size_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check for failure to allocate. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Raise error unless asked not to. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>DSA_ALLOC_NO_OOM</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on DSA request of size %zu."</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>InvalidDsaPointer</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Zero-initialize the memory if requested. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>DSA_ALLOC_ZERO</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free memory obtained with dsa_allocate.
 */</comment>
<function><type><name>void</name></type>
<name>dsa_free</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>dsa_pointer</name></type> <name>dp</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>dsa_segment_map</name> <modifier>*</modifier></type><name>segment_map</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>pageno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>span_pointer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>span</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>superblock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>object</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size_class</name></decl>;</decl_stmt>

    <comment type="block">/* Make sure we don't have a stale segment in the slot 'dp' refers to. */</comment>
    <expr_stmt><expr><call><name>check_for_freed_segments</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Locate the object, span and pool. */</comment>
    <expr_stmt><expr><name>segment_map</name> <operator>=</operator> <call><name>get_segment_by_index</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><call><name>DSA_EXTRACT_SEGMENT_NUMBER</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pageno</name> <operator>=</operator> <call><name>DSA_EXTRACT_OFFSET</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>FPM_PAGE_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>span_pointer</name> <operator>=</operator> <name><name>segment_map</name><operator>-&gt;</operator><name>pagemap</name><index>[<expr><name>pageno</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>span</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>span_pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>superblock</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>object</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>size_class</name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>size_class</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>dsa_size_classes</name><index>[<expr><name>size_class</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Special case for large objects that live in a special span: we return
     * those pages directly to the free page manager and free the span.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>span</name><operator>-&gt;</operator><name>size_class</name></name> <operator>==</operator> <name>DSA_SCLASS_SPAN_LARGE</name></expr>)</condition>
    <block>{<block_content>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CLOBBER_FREED_MEMORY</name></cpp:ifdef>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><literal type="number">0x7f</literal></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>npages</name></name> <operator>*</operator> <name>FPM_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* Give pages back to free page manager. */</comment>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FreePageManagerPut</name><argument_list>(<argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>fpm</name></name></expr></argument>,
                           <argument><expr><call><name>DSA_EXTRACT_OFFSET</name><argument_list>(<argument><expr><name><name>span</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <name>FPM_PAGE_SIZE</name></expr></argument>,
                           <argument><expr><name><name>span</name><operator>-&gt;</operator><name>npages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Unlink span. */</comment>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>DSA_SCLASS_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>DSA_SCLASS_SPAN_LARGE</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>unlink_span</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_SCLASS_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>DSA_SCLASS_SPAN_LARGE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Free the span object so it can be reused. */</comment>
        <expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>span_pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CLOBBER_FREED_MEMORY</name></cpp:ifdef>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><literal type="number">0x7f</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>DSA_SCLASS_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>size_class</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Put the object on the span's freelist. */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>object</name> <operator>&gt;=</operator> <name>superblock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>object</name> <operator>&lt;</operator> <name>superblock</name> <operator>+</operator> <name>DSA_SUPERBLOCK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>object</name> <operator>-</operator> <name>superblock</name><operator>)</operator> <operator>%</operator> <name>size</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NextFreeObjectIndex</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>firstfree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>firstfree</name></name> <operator>=</operator> <operator>(</operator><name>object</name> <operator>-</operator> <name>superblock</name><operator>)</operator> <operator>/</operator> <name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>++</operator><name><name>span</name><operator>-&gt;</operator><name>nallocatable</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * See if the span needs to moved to a different fullness class, or be
     * freed so its pages can be given back to the segment.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>span</name><operator>-&gt;</operator><name>nallocatable</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>span</name><operator>-&gt;</operator><name>fclass</name></name> <operator>==</operator> <name>DSA_FULLNESS_CLASSES</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * The block was completely full and is located in the
         * highest-numbered fullness class, which is never scanned for free
         * chunks.  We must move it to the next-lower fullness class.
         */</comment>
        <expr_stmt><expr><call><name>unlink_span</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>add_span_to_fullness_class</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>span</name></expr></argument>, <argument><expr><name>span_pointer</name></expr></argument>,
                                   <argument><expr><name>DSA_FULLNESS_CLASSES</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If this is the only span, and there is no active span, then we
         * should probably move this span to fullness class 1.  (Otherwise if
         * you allocate exactly all the objects in the only span, it moves to
         * class 3, then you free them all, it moves to 2, and then is given
         * back, leaving no active span).
         */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>span</name><operator>-&gt;</operator><name>nallocatable</name></name> <operator>==</operator> <name><name>span</name><operator>-&gt;</operator><name>nmax</name></name> <operator>&amp;&amp;</operator>
             <operator>(</operator><name><name>span</name><operator>-&gt;</operator><name>fclass</name></name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>span</name><operator>-&gt;</operator><name>prevspan</name></name> <operator>!=</operator> <name>InvalidDsaPointer</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * This entire block is free, and it's not the active block for this
         * size class.  Return the memory to the free page manager. We don't
         * do this for the active block to prevent hysteresis: if we
         * repeatedly allocate and free the only chunk in the active block, it
         * will be very inefficient if we deallocate and reallocate the block
         * every time.
         */</comment>
        <expr_stmt><expr><call><name>destroy_superblock</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>span_pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_SCLASS_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>size_class</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Obtain a backend-local address for a dsa_pointer.  'dp' must point to
 * memory allocated by the given area (possibly in another process) that
 * hasn't yet been freed.  This may cause a segment to be mapped into the
 * current process if required, and may cause freed segments to be unmapped.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>dsa_get_address</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>dsa_pointer</name></type> <name>dp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dsa_segment_index</name></type> <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>offset</name></decl>;</decl_stmt>

    <comment type="block">/* Convert InvalidDsaPointer to NULL. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Process any requests to detach from freed segments. */</comment>
    <expr_stmt><expr><call><name>check_for_freed_segments</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Break the dsa_pointer into its components. */</comment>
    <expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>DSA_EXTRACT_SEGMENT_NUMBER</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>DSA_EXTRACT_OFFSET</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>index</name> <operator>&lt;</operator> <name>DSA_MAX_SEGMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if we need to cause this segment to be mapped in. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>mapped_address</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Call for effect (we don't need the result). */</comment>
        <expr_stmt><expr><call><name>get_segment_by_index</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>mapped_address</name> <operator>+</operator> <name>offset</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Pin this area, so that it will continue to exist even if all backends
 * detach from it.  In that case, the area can still be reattached to if a
 * handle has been recorded somewhere.
 */</comment>
<function><type><name>void</name></type>
<name>dsa_pin</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>pinned</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"dsa_area already pinned"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>pinned</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>++</operator><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>refcnt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Undo the effects of dsa_pin, so that the given area can be freed when no
 * backends are attached to it.  May be called only if dsa_pin has been
 * called.
 */</comment>
<function><type><name>void</name></type>
<name>dsa_unpin</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>refcnt</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>pinned</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"dsa_area not pinned"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>pinned</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>--</operator><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>refcnt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set the total size limit for this area.  This limit is checked whenever new
 * segments need to be allocated from the operating system.  If the new size
 * limit is already exceeded, this has no immediate effect.
 *
 * Note that the total virtual memory usage may be temporarily larger than
 * this limit when segments have been freed, but not yet detached by all
 * backends that have attached to them.
 */</comment>
<function><type><name>void</name></type>
<name>dsa_set_size_limit</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>max_total_segment_size</name></name> <operator>=</operator> <name>limit</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Aggressively free all spare memory in the hope of returning DSM segments to
 * the operating system.
 */</comment>
<function><type><name>void</name></type>
<name>dsa_trim</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>size_class</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Trim in reverse pool order so we get to the spans-of-spans last, just
     * in case any become entirely free while processing all the other pools.
     */</comment>
    <for>for <control>(<init><expr><name>size_class</name> <operator>=</operator> <name>DSA_NUM_SIZE_CLASSES</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>size_class</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>size_class</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>dsa_area_pool</name> <modifier>*</modifier></type><name>pool</name> <init>= <expr><operator>&amp;</operator><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>pools</name><index>[<expr><name>size_class</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>span_pointer</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>size_class</name> <operator>==</operator> <name>DSA_SCLASS_SPAN_LARGE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Large object frees give back segments aggressively already. */</comment>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Search fullness class 1 only.  That is where we expect to find an
         * entirely empty superblock (entirely empty superblocks in other
         * fullness classes are returned to the free page map by dsa_free).
         */</comment>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>DSA_SCLASS_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>size_class</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>span_pointer</name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name>span_pointer</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>span_pointer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>next</name> <init>= <expr><name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>span</name><operator>-&gt;</operator><name>nallocatable</name></name> <operator>==</operator> <name><name>span</name><operator>-&gt;</operator><name>nmax</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>destroy_superblock</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>span_pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>span_pointer</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_SCLASS_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>size_class</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Print out debugging information about the internal state of the shared
 * memory area.
 */</comment>
<function><type><name>void</name></type>
<name>dsa_dump</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Note: This gives an inconsistent snapshot as it acquires and releases
     * individual locks as it goes...
     */</comment>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_for_freed_segments_locked</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"dsa_area handle %x:\n"</literal></expr></argument>, <argument><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  max_total_segment_size: %zu\n"</literal></expr></argument>,
            <argument><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>max_total_segment_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  total_segment_size: %zu\n"</literal></expr></argument>,
            <argument><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>total_segment_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  refcnt: %d\n"</literal></expr></argument>, <argument><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>refcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  pinned: %c\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>pinned</name></name></expr> ?</condition><then> <expr><literal type="char">'t'</literal></expr> </then><else>: <expr><literal type="char">'f'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  segment bins:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DSA_NUM_SEGMENT_BINS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>segment_bins</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>DSA_SEGMENT_INDEX_NONE</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>dsa_segment_index</name></type> <name>segment_index</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><literal type="string">"    segment bin %zu (at least %d contiguous pages free):\n"</literal></expr></argument>,
                    <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>segment_index</name> <operator>=</operator> <name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>segment_bins</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>segment_index</name> <operator>!=</operator> <name>DSA_SEGMENT_INDEX_NONE</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>dsa_segment_map</name> <modifier>*</modifier></type><name>segment_map</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>segment_map</name> <operator>=</operator>
                    <call><name>get_segment_by_index</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>segment_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                        <argument><expr><literal type="string">"      segment index %zu, usable_pages = %zu, "</literal>
                        <literal type="string">"contiguous_pages = %zu, mapped at %p\n"</literal></expr></argument>,
                        <argument><expr><name>segment_index</name></expr></argument>,
                        <argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>usable_pages</name></name></expr></argument>,
                        <argument><expr><call><name>fpm_largest</name><argument_list>(<argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>fpm</name></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>segment_index</name> <operator>=</operator> <name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  pools:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DSA_NUM_SIZE_CLASSES</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>DSA_SCLASS_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>DSA_FULLNESS_CLASSES</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>pools</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>spans</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>DSA_SCLASS_BLOCK_OF_SPANS</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"    pool for blocks of span objects:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>DSA_SCLASS_SPAN_LARGE</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"    pool for large object spans:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                        <argument><expr><literal type="string">"    pool for size class %zu (object size %hu bytes):\n"</literal></expr></argument>,
                        <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>dsa_size_classes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>DSA_FULLNESS_CLASSES</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>pools</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>spans</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"      fullness class %zu is empty\n"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>span_pointer</name> <init>= <expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>pools</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>spans</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"      fullness class %zu:\n"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <while>while <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name>span_pointer</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>span</name></decl>;</decl_stmt>

                        <expr_stmt><expr><name>span</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>span_pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                                <argument><expr><literal type="string">"        span descriptor at "</literal>
                                <name>DSA_POINTER_FORMAT</name> <literal type="string">", superblock at "</literal>
                                <name>DSA_POINTER_FORMAT</name>
                                <literal type="string">", pages = %zu, objects free = %hu/%hu\n"</literal></expr></argument>,
                                <argument><expr><name>span_pointer</name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>npages</name></name></expr></argument>,
                                <argument><expr><name><name>span</name><operator>-&gt;</operator><name>nallocatable</name></name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>nmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>span_pointer</name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name></expr>;</expr_stmt>
                    </block_content>}</block></while>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_SCLASS_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Return the smallest size that you can successfully provide to
 * dsa_create_in_place.
 */</comment>
<function><type><name>Size</name></type>
<name>dsa_minimum_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>pages</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_area_control</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
        <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageManager</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Figure out how many pages we need, including the page map... */</comment>
    <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>size</name> <operator>+</operator> <name>FPM_PAGE_SIZE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>FPM_PAGE_SIZE</name><operator>)</operator> <operator>&gt;</operator> <name>pages</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>++</operator><name>pages</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dsa_pointer</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>pages</name> <operator>*</operator> <name>FPM_PAGE_SIZE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Workhorse function for dsa_create and dsa_create_in_place.
 */</comment>
<function><type><specifier>static</specifier> <name>dsa_area</name> <modifier>*</modifier></type>
<name>create_internal</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>place</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
                <parameter><decl><type><name>int</name></type> <name>tranche_id</name></decl></parameter>,
                <parameter><decl><type><name>dsm_handle</name></type> <name>control_handle</name></decl></parameter>,
                <parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>control_segment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dsa_area_control</name> <modifier>*</modifier></type><name>control</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_area</name>   <modifier>*</modifier></type><name>area</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_segment_map</name> <modifier>*</modifier></type><name>segment_map</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>usable_pages</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>total_pages</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>metadata_bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Sanity check on the space we have to work in. */</comment>
    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <call><name>dsa_minimum_size</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"dsa_area space must be at least %zu, but %zu provided"</literal></expr></argument>,
             <argument><expr><call><name>dsa_minimum_size</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Now figure out how much space is usable */</comment>
    <expr_stmt><expr><name>total_pages</name> <operator>=</operator> <name>size</name> <operator>/</operator> <name>FPM_PAGE_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>metadata_bytes</name> <operator>=</operator>
        <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_area_control</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
        <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageManager</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
        <name>total_pages</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dsa_pointer</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <comment type="block">/* Add padding up to next page boundary. */</comment>
    <if_stmt><if>if <condition>(<expr><name>metadata_bytes</name> <operator>%</operator> <name>FPM_PAGE_SIZE</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>metadata_bytes</name> <operator>+=</operator> <name>FPM_PAGE_SIZE</name> <operator>-</operator> <operator>(</operator><name>metadata_bytes</name> <operator>%</operator> <name>FPM_PAGE_SIZE</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>metadata_bytes</name> <operator>&lt;=</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>usable_pages</name> <operator>=</operator> <operator>(</operator><name>size</name> <operator>-</operator> <name>metadata_bytes</name><operator>)</operator> <operator>/</operator> <name>FPM_PAGE_SIZE</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize the dsa_area_control object located at the start of the
     * space.
     */</comment>
    <expr_stmt><expr><name>control</name> <operator>=</operator> <operator>(</operator><name>dsa_area_control</name> <operator>*</operator><operator>)</operator> <name>place</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>segment_header</name><operator>.</operator><name>magic</name></name> <operator>=</operator>
        <name>DSA_SEGMENT_HEADER_MAGIC</name> <operator>^</operator> <name>control_handle</name> <operator>^</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>segment_header</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>DSA_SEGMENT_INDEX_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>segment_header</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name>DSA_SEGMENT_INDEX_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>segment_header</name><operator>.</operator><name>usable_pages</name></name> <operator>=</operator> <name>usable_pages</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>segment_header</name><operator>.</operator><name>freed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>segment_header</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>DSA_INITIAL_SEGMENT_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <name>control_handle</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>max_total_segment_size</name></name> <operator>=</operator> <operator>(</operator><name>Size</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>total_segment_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>control</name><operator>-&gt;</operator><name>segment_handles</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsm_handle</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>DSA_MAX_SEGMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>segment_handles</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>control_handle</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DSA_NUM_SEGMENT_BINS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>segment_bins</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>DSA_SEGMENT_INDEX_NONE</name></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>high_segment_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>refcnt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>freed_segment_counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>lwlock_tranche_id</name></name> <operator>=</operator> <name>tranche_id</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Create the dsa_area object that this backend will use to access the
     * area.  Other backends will need to obtain their own dsa_area object by
     * attaching.
     */</comment>
    <expr_stmt><expr><name>area</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_area</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>control</name></name> <operator>=</operator> <name>control</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>mapping_pinned</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_segment_map</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>DSA_MAX_SEGMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>high_segment_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>freed_segment_counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>control</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>-&gt;</operator><name>lwlock_tranche_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DSA_NUM_SIZE_CLASSES</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><call><name>DSA_SCLASS_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name><name>control</name><operator>-&gt;</operator><name>lwlock_tranche_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* Set up the segment map for this process's mapping. */</comment>
    <expr_stmt><expr><name>segment_map</name> <operator>=</operator> <operator>&amp;</operator><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>segment</name></name> <operator>=</operator> <name>control_segment</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name> <operator>=</operator> <name>place</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <operator>(</operator><name>dsa_segment_header</name> <operator>*</operator><operator>)</operator> <name>place</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>fpm</name></name> <operator>=</operator> <operator>(</operator><name>FreePageManager</name> <operator>*</operator><operator>)</operator>
        <operator>(</operator><name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name> <operator>+</operator>
         <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_area_control</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>pagemap</name></name> <operator>=</operator> <operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator>
        <operator>(</operator><name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name> <operator>+</operator>
         <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_area_control</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
         <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageManager</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Set up the free page map. */</comment>
    <expr_stmt><expr><call><name>FreePageManagerInitialize</name><argument_list>(<argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>fpm</name></name></expr></argument>, <argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* There can be 0 usable pages if size is dsa_minimum_size(). */</comment>

    <if_stmt><if>if <condition>(<expr><name>usable_pages</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FreePageManagerPut</name><argument_list>(<argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>fpm</name></name></expr></argument>, <argument><expr><name>metadata_bytes</name> <operator>/</operator> <name>FPM_PAGE_SIZE</name></expr></argument>,
                           <argument><expr><name>usable_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Put this segment into the appropriate bin. */</comment>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>segment_bins</name><index>[<expr><call><name>contiguous_pages_to_segment_bin</name><argument_list>(<argument><expr><name>usable_pages</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>bin</name></name> <operator>=</operator> <call><name>contiguous_pages_to_segment_bin</name><argument_list>(<argument><expr><name>usable_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>area</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Workhorse function for dsa_attach and dsa_attach_in_place.
 */</comment>
<function><type><specifier>static</specifier> <name>dsa_area</name> <modifier>*</modifier></type>
<name>attach_internal</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>place</name></decl></parameter>, <parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>segment</name></decl></parameter>, <parameter><decl><type><name>dsa_handle</name></type> <name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dsa_area_control</name> <modifier>*</modifier></type><name>control</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_area</name>   <modifier>*</modifier></type><name>area</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_segment_map</name> <modifier>*</modifier></type><name>segment_map</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>control</name> <operator>=</operator> <operator>(</operator><name>dsa_area_control</name> <operator>*</operator><operator>)</operator> <name>place</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>handle</name></name> <operator>==</operator> <name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>segment_handles</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>segment_header</name><operator>.</operator><name>magic</name></name> <operator>==</operator>
           <operator>(</operator><name>DSA_SEGMENT_HEADER_MAGIC</name> <operator>^</operator> <name>handle</name> <operator>^</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Build the backend-local area object. */</comment>
    <expr_stmt><expr><name>area</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_area</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>control</name></name> <operator>=</operator> <name>control</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>mapping_pinned</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_segment_map</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>DSA_MAX_SEGMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>high_segment_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Set up the segment map for this process's mapping. */</comment>
    <expr_stmt><expr><name>segment_map</name> <operator>=</operator> <operator>&amp;</operator><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>segment</name></name> <operator>=</operator> <name>segment</name></expr>;</expr_stmt> <comment type="block">/* NULL for in-place */</comment>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name> <operator>=</operator> <name>place</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <operator>(</operator><name>dsa_segment_header</name> <operator>*</operator><operator>)</operator> <name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>fpm</name></name> <operator>=</operator> <operator>(</operator><name>FreePageManager</name> <operator>*</operator><operator>)</operator>
        <operator>(</operator><name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_area_control</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>pagemap</name></name> <operator>=</operator> <operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator>
        <operator>(</operator><name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_area_control</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
         <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageManager</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Bump the reference count. */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>refcnt</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We can't attach to a DSA area that has already been destroyed. */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not attach to dynamic shared area"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>++</operator><name><name>control</name><operator>-&gt;</operator><name>refcnt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>freed_segment_counter</name></name> <operator>=</operator> <name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>freed_segment_counter</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>area</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add a new span to fullness class 1 of the indicated pool.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_span</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>,
          <parameter><decl><type><name>dsa_pointer</name></type> <name>span_pointer</name></decl></parameter>,
          <parameter><decl><type><name>dsa_area_pool</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>, <parameter><decl><type><name>dsa_pointer</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>npages</name></decl></parameter>,
          <parameter><decl><type><name>uint16</name></type> <name>size_class</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>span_pointer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>obsize</name> <init>= <expr><name><name>dsa_size_classes</name><index>[<expr><name>size_class</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * The per-pool lock must be held because we manipulate the span list for
     * this pool.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><call><name>DSA_SCLASS_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>size_class</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Push this span onto the front of the span list for fullness class 1. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>head</name> <init>= <expr><operator>(</operator><name>dsa_area_span</name> <operator>*</operator><operator>)</operator>
        <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>head</name><operator>-&gt;</operator><name>prevspan</name></name> <operator>=</operator> <name>span_pointer</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>pool</name></name> <operator>=</operator> <call><name>DsaAreaPoolToDsaPointer</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>prevspan</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>span_pointer</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>npages</name></name> <operator>=</operator> <name>npages</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>size_class</name></name> <operator>=</operator> <name>size_class</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>ninitialized</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>size_class</name> <operator>==</operator> <name>DSA_SCLASS_BLOCK_OF_SPANS</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * A block-of-spans contains its own descriptor, so mark one object as
         * initialized and reduce the count of allocatable objects by one.
         * Doing this here has the side effect of also reducing nmax by one,
         * which is important to make sure we free this object at the correct
         * time.
         */</comment>
        <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>ninitialized</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>nallocatable</name></name> <operator>=</operator> <name>FPM_PAGE_SIZE</name> <operator>/</operator> <name>obsize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>size_class</name> <operator>!=</operator> <name>DSA_SCLASS_SPAN_LARGE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>nallocatable</name></name> <operator>=</operator> <name>DSA_SUPERBLOCK_SIZE</name> <operator>/</operator> <name>obsize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>firstfree</name></name> <operator>=</operator> <name>DSA_SPAN_NOTHING_FREE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>nmax</name></name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>nallocatable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>fclass</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Transfer the first span in one fullness class to the head of another
 * fullness class.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>transfer_first_span</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>,
                    <parameter><decl><type><name>dsa_area_pool</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fromclass</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>toclass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>span_pointer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>span</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>nextspan</name></decl>;</decl_stmt>

    <comment type="block">/* Can't do it if source list is empty. */</comment>
    <expr_stmt><expr><name>span_pointer</name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><name>fromclass</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name>span_pointer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Remove span from head of source list. */</comment>
    <expr_stmt><expr><name>span</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>span_pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><name>fromclass</name></expr>]</index></name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>nextspan</name> <operator>=</operator> <operator>(</operator><name>dsa_area_span</name> <operator>*</operator><operator>)</operator>
            <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nextspan</name><operator>-&gt;</operator><name>prevspan</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Add span to head of target list. */</comment>
    <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><name>toclass</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><name>toclass</name></expr>]</index></name> <operator>=</operator> <name>span_pointer</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>nextspan</name> <operator>=</operator> <operator>(</operator><name>dsa_area_span</name> <operator>*</operator><operator>)</operator>
            <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nextspan</name><operator>-&gt;</operator><name>prevspan</name></name> <operator>=</operator> <name>span_pointer</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>fclass</name></name> <operator>=</operator> <name>toclass</name></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate one object of the requested size class from the given area.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>dsa_pointer</name></type>
<name>alloc_object</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size_class</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dsa_area_pool</name> <modifier>*</modifier></type><name>pool</name> <init>= <expr><operator>&amp;</operator><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>pools</name><index>[<expr><name>size_class</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>span</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>block</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>object</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Even though ensure_active_superblock can in turn call alloc_object if
     * it needs to allocate a new span, that's always from a different pool,
     * and the order of lock acquisition is always the same, so it's OK that
     * we hold this lock for the duration of this function.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><call><name>DSA_SCLASS_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>size_class</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>DSA_SCLASS_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>size_class</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If there's no active superblock, we must successfully obtain one or
     * fail the request.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>ensure_active_superblock</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>size_class</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * There should be a block in fullness class 1 at this point, and it
         * should never be completely full.  Thus we can either pop an object
         * from the free list or, failing that, initialize a new object.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>span</name> <operator>=</operator> <operator>(</operator><name>dsa_area_span</name> <operator>*</operator><operator>)</operator>
            <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>span</name><operator>-&gt;</operator><name>nallocatable</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>block</name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>start</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>size_class</name> <operator>&lt;</operator> <name>DSA_NUM_SIZE_CLASSES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>dsa_size_classes</name><index>[<expr><name>size_class</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>span</name><operator>-&gt;</operator><name>firstfree</name></name> <operator>!=</operator> <name>DSA_SPAN_NOTHING_FREE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>block</name> <operator>+</operator> <name><name>span</name><operator>-&gt;</operator><name>firstfree</name></name> <operator>*</operator> <name>size</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>object</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>firstfree</name></name> <operator>=</operator> <call><name>NextFreeObjectIndex</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>block</name> <operator>+</operator> <name><name>span</name><operator>-&gt;</operator><name>ninitialized</name></name> <operator>*</operator> <name>size</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>++</operator><name><name>span</name><operator>-&gt;</operator><name>ninitialized</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><operator>--</operator><name><name>span</name><operator>-&gt;</operator><name>nallocatable</name></name></expr>;</expr_stmt>

        <comment type="block">/* If it's now full, move it to the highest-numbered fullness class. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>span</name><operator>-&gt;</operator><name>nallocatable</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>transfer_first_span</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>DSA_FULLNESS_CLASSES</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><call><name>DSA_SCLASS_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>size_class</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_SCLASS_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>size_class</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ensure an active (i.e. fullness class 1) superblock, unless all existing
 * superblocks are completely full and no more can be allocated.
 *
 * Fullness classes K of 0..N are loosely intended to represent blocks whose
 * utilization percentage is at least K/N, but we only enforce this rigorously
 * for the highest-numbered fullness class, which always contains exactly
 * those blocks that are completely full.  It's otherwise acceptable for a
 * block to be in a higher-numbered fullness class than the one to which it
 * logically belongs.  In addition, the active block, which is always the
 * first block in fullness class 1, is permitted to have a higher allocation
 * percentage than would normally be allowable for that fullness class; we
 * don't move it until it's completely full, and then it goes to the
 * highest-numbered fullness class.
 *
 * It might seem odd that the active block is the head of fullness class 1
 * rather than fullness class 0, but experience with other allocators has
 * shown that it's usually better to allocate from a block that's moderately
 * full rather than one that's nearly empty.  Insofar as is reasonably
 * possible, we want to avoid performing new allocations in a block that would
 * otherwise become empty soon.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ensure_active_superblock</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>dsa_area_pool</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>,
                         <parameter><decl><type><name>int</name></type> <name>size_class</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>span_pointer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>start_pointer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>obsize</name> <init>= <expr><name><name>dsa_size_classes</name><index>[<expr><name>size_class</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>nmax</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>fclass</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>npages</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>first_page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_segment_map</name> <modifier>*</modifier></type><name>segment_map</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><call><name>DSA_SCLASS_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>size_class</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Compute the number of objects that will fit in a block of this size
     * class.  Span-of-spans blocks are just a single page, and the first
     * object isn't available for use because it describes the block-of-spans
     * itself.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>size_class</name> <operator>==</operator> <name>DSA_SCLASS_BLOCK_OF_SPANS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nmax</name> <operator>=</operator> <name>FPM_PAGE_SIZE</name> <operator>/</operator> <name>obsize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>nmax</name> <operator>=</operator> <name>DSA_SUPERBLOCK_SIZE</name> <operator>/</operator> <name>obsize</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * If fullness class 1 is empty, try to find a span to put in it by
     * scanning higher-numbered fullness classes (excluding the last one,
     * whose blocks are certain to all be completely full).
     */</comment>
    <for>for <control>(<init><expr><name>fclass</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>fclass</name> <operator>&lt;</operator> <name>DSA_FULLNESS_CLASSES</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>fclass</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>span_pointer</name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><name>fclass</name></expr>]</index></name></expr>;</expr_stmt>

        <while>while <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name>span_pointer</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>tfclass</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>span</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>nextspan</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>prevspan</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>next_span_pointer</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>span</name> <operator>=</operator> <operator>(</operator><name>dsa_area_span</name> <operator>*</operator><operator>)</operator>
                <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>span_pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>next_span_pointer</name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name></expr>;</expr_stmt>

            <comment type="block">/* Figure out what fullness class should contain this span. */</comment>
            <expr_stmt><expr><name>tfclass</name> <operator>=</operator> <operator>(</operator><name>nmax</name> <operator>-</operator> <name><name>span</name><operator>-&gt;</operator><name>nallocatable</name></name><operator>)</operator>
                <operator>*</operator> <operator>(</operator><name>DSA_FULLNESS_CLASSES</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>nmax</name></expr>;</expr_stmt>

            <comment type="block">/* Look up next span. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>nextspan</name> <operator>=</operator> <operator>(</operator><name>dsa_area_span</name> <operator>*</operator><operator>)</operator>
                    <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>nextspan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/*
             * If utilization has dropped enough that this now belongs in some
             * other fullness class, move it there.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>tfclass</name> <operator>&lt;</operator> <name>fclass</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Remove from the current fullness class list. */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><name>fclass</name></expr>]</index></name> <operator>==</operator> <name>span_pointer</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* It was the head; remove it. */</comment>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>span</name><operator>-&gt;</operator><name>prevspan</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><name>fclass</name></expr>]</index></name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>nextspan</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>nextspan</name><operator>-&gt;</operator><name>prevspan</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* It was not the head. */</comment>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>span</name><operator>-&gt;</operator><name>prevspan</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>prevspan</name> <operator>=</operator> <operator>(</operator><name>dsa_area_span</name> <operator>*</operator><operator>)</operator>
                        <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>prevspan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>prevspan</name><operator>-&gt;</operator><name>nextspan</name></name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>nextspan</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>nextspan</name><operator>-&gt;</operator><name>prevspan</name></name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>prevspan</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* Push onto the head of the new fullness class list. */</comment>
                <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><name>tfclass</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><name>tfclass</name></expr>]</index></name> <operator>=</operator> <name>span_pointer</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>prevspan</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>nextspan</name> <operator>=</operator> <operator>(</operator><name>dsa_area_span</name> <operator>*</operator><operator>)</operator>
                        <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>nextspan</name><operator>-&gt;</operator><name>prevspan</name></name> <operator>=</operator> <name>span_pointer</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>fclass</name></name> <operator>=</operator> <name>tfclass</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Advance to next span on list. */</comment>
            <expr_stmt><expr><name>span_pointer</name> <operator>=</operator> <name>next_span_pointer</name></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/* Stop now if we found a suitable block. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * If there are no blocks that properly belong in fullness class 1, pick
     * one from some other fullness class and move it there anyway, so that we
     * have an allocation target.  Our last choice is to transfer a block
     * that's almost empty (and might become completely empty soon if left
     * alone), but even that is better than failing, which is what we must do
     * if there are no blocks at all with freespace.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>fclass</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>fclass</name> <operator>&lt;</operator> <name>DSA_FULLNESS_CLASSES</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>fclass</name></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>transfer_first_span</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>fclass</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>transfer_first_span</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We failed to find an existing span with free objects, so we need to
     * allocate a new superblock and construct a new span to manage it.
     *
     * First, get a dsa_area_span object to describe the new superblock block
     * ... unless this allocation is for a dsa_area_span object, in which case
     * that's surely not going to work.  We handle that case by storing the
     * span describing a block-of-spans inline.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>size_class</name> <operator>!=</operator> <name>DSA_SCLASS_BLOCK_OF_SPANS</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>span_pointer</name> <operator>=</operator> <call><name>alloc_object</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>DSA_SCLASS_BLOCK_OF_SPANS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name>span_pointer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>npages</name> <operator>=</operator> <name>DSA_PAGES_PER_SUPERBLOCK</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Find or create a segment and allocate the superblock. */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>segment_map</name> <operator>=</operator> <call><name>get_best_segment</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>segment_map</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>segment_map</name> <operator>=</operator> <call><name>make_new_segment</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>segment_map</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This shouldn't happen: get_best_segment() or make_new_segment()
	 * promised that we can successfully allocate npages.
	 */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FreePageManagerGet</name><argument_list>(<argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>fpm</name></name></expr></argument>, <argument><expr><name>npages</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>first_page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
			 <argument><expr><literal type="string">"dsa_allocate could not find %zu free pages for superblock"</literal></expr></argument>,
			 <argument><expr><name>npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Compute the start of the superblock. */</comment>
    <expr_stmt><expr><name>start_pointer</name> <operator>=</operator>
        <call><name>DSA_MAKE_POINTER</name><argument_list>(<argument><expr><call><name>get_segment_index</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>segment_map</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>first_page</name> <operator>*</operator> <name>FPM_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If this is a block-of-spans, carve the descriptor right out of the
     * allocated space.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>size_class</name> <operator>==</operator> <name>DSA_SCLASS_BLOCK_OF_SPANS</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We have a pointer into the segment.  We need to build a dsa_pointer
         * from the segment index and offset into the segment.
         */</comment>
        <expr_stmt><expr><name>span_pointer</name> <operator>=</operator> <name>start_pointer</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Initialize span and pagemap. */</comment>
    <expr_stmt><expr><call><name>init_span</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>span_pointer</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>start_pointer</name></expr></argument>, <argument><expr><name>npages</name></expr></argument>, <argument><expr><name>size_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npages</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>pagemap</name><index>[<expr><name>first_page</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>span_pointer</name></expr>;</expr_stmt></block_content></block></for>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the segment map corresponding to a given segment index, mapping the
 * segment in if necessary.  For internal segment book-keeping, this is called
 * with the area lock held.  It is also called by dsa_free and dsa_get_address
 * without any locking, relying on the fact they have a known live segment
 * index and they always call check_for_freed_segments to ensures that any
 * freed segment occupying the same slot is detached first.
 */</comment>
<function><type><specifier>static</specifier> <name>dsa_segment_map</name> <modifier>*</modifier></type>
<name>get_segment_by_index</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>dsa_segment_index</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>mapped_address</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>dsm_handle</name></type>    <name>handle</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>segment</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dsa_segment_map</name> <modifier>*</modifier></type><name>segment_map</name></decl>;</decl_stmt>

        <comment type="block">/*
         * If we are reached by dsa_free or dsa_get_address, there must be at
         * least one object allocated in the referenced segment.  Otherwise,
         * their caller has a double-free or access-after-free bug, which we
         * have no hope of detecting.  So we know it's safe to access this
         * array slot without holding a lock; it won't change underneath us.
         * Furthermore, we know that we can see the latest contents of the
         * slot, as explained in check_for_freed_segments, which those
         * functions call before arriving here.
         */</comment>
        <expr_stmt><expr><name>handle</name> <operator>=</operator> <name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>segment_handles</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/* It's an error to try to access an unused slot. */</comment>
        <if_stmt><if>if <condition>(<expr><name>handle</name> <operator>==</operator> <name>DSM_HANDLE_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                 <argument><expr><literal type="string">"dsa_area could not attach to a segment that has been freed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>segment</name> <operator>=</operator> <call><name>dsm_attach</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>segment</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"dsa_area could not attach to segment"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>area</name><operator>-&gt;</operator><name>mapping_pinned</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>dsm_pin_mapping</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>segment_map</name> <operator>=</operator> <operator>&amp;</operator><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>segment</name></name> <operator>=</operator> <name>segment</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name> <operator>=</operator> <call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator>
            <operator>(</operator><name>dsa_segment_header</name> <operator>*</operator><operator>)</operator> <name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>fpm</name></name> <operator>=</operator> <operator>(</operator><name>FreePageManager</name> <operator>*</operator><operator>)</operator>
            <operator>(</operator><name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name> <operator>+</operator>
             <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_segment_header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>pagemap</name></name> <operator>=</operator> <operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator>
            <operator>(</operator><name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name> <operator>+</operator>
             <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_segment_header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
             <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageManager</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

        <comment type="block">/* Remember the highest index this backend has ever mapped. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>area</name><operator>-&gt;</operator><name>high_segment_index</name></name> <operator>&lt;</operator> <name>index</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>high_segment_index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator>
               <operator>(</operator><name>DSA_SEGMENT_HEADER_MAGIC</name> <operator>^</operator> <name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>handle</name></name> <operator>^</operator> <name>index</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Callers of dsa_get_address() and dsa_free() don't hold the area lock,
	 * but it's a bug in the calling code and undefined behavior if the
	 * address is not live (ie if the segment might possibly have been freed,
	 * they're trying to use a dangling pointer).
	 *
	 * For dsa.c code that holds the area lock to manipulate segment_bins
	 * lists, it would be a bug if we ever reach a freed segment here.  After
	 * it's marked as freed, the only thing any backend should do with it is
	 * unmap it, and it should always have done that in
	 * check_for_freed_segments_locked() before arriving here to resolve an
	 * index to a segment_map.
	 *
	 * Either way we can assert that we aren't returning a freed segment.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>header</name><operator>-&gt;</operator><name>freed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>&amp;</operator><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a superblock to the free page manager.  If the underlying segment
 * has become entirely free, then return it to the operating system.
 *
 * The appropriate pool lock must be held.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>destroy_superblock</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>dsa_pointer</name></type> <name>span_pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>span_pointer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size_class</name> <init>= <expr><name><name>span</name><operator>-&gt;</operator><name>size_class</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_segment_map</name> <modifier>*</modifier></type><name>segment_map</name></decl>;</decl_stmt>

    <comment type="block">/* Remove it from its fullness class list. */</comment>
    <expr_stmt><expr><call><name>unlink_span</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Note: Here we acquire the area lock while we already hold a per-pool
     * lock.  We never hold the area lock and then take a pool lock, or we
     * could deadlock.
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_for_freed_segments_locked</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>segment_map</name> <operator>=</operator>
		<call><name>get_segment_by_index</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><call><name>DSA_EXTRACT_SEGMENT_NUMBER</name><argument_list>(<argument><expr><name><name>span</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FreePageManagerPut</name><argument_list>(<argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>fpm</name></name></expr></argument>,
                       <argument><expr><call><name>DSA_EXTRACT_OFFSET</name><argument_list>(<argument><expr><name><name>span</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <name>FPM_PAGE_SIZE</name></expr></argument>,
                       <argument><expr><name><name>span</name><operator>-&gt;</operator><name>npages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Check if the segment is now entirely free. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>fpm_largest</name><argument_list>(<argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>fpm</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>usable_pages</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>dsa_segment_index</name></type> <name>index</name> <init>= <expr><call><name>get_segment_index</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>segment_map</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* If it's not the segment with extra control data, free it. */</comment>
        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Give it back to the OS, and allow other backends to detect that
             * they need to detach.
             */</comment>
            <expr_stmt><expr><call><name>unlink_segment</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>segment_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>freed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>total_segment_size</name></name> <operator>&gt;=</operator>
                   <name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>total_segment_size</name></name> <operator>-=</operator>
                <name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>dsm_unpin_segment</name><argument_list>(<argument><expr><call><name>dsm_segment_handle</name><argument_list>(<argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>segment</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>segment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>segment_handles</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>DSM_HANDLE_INVALID</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>++</operator><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>freed_segment_counter</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>segment</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Span-of-spans blocks store the span which describes them within the
     * block itself, so freeing the storage implicitly frees the descriptor
     * also.  If this is a block of any other type, we need to separately free
     * the span object also.  This recursive call to dsa_free will acquire the
     * span pool's lock.  We can't deadlock because the acquisition order is
     * always some other pool and then the span pool.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>size_class</name> <operator>!=</operator> <name>DSA_SCLASS_BLOCK_OF_SPANS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>span_pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>unlink_span</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>span</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>prevspan</name></name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>prevspan</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>span</name><operator>-&gt;</operator><name>prevspan</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>prevspan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>nextspan</name></name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>dsa_area_pool</name> <modifier>*</modifier></type><name>pool</name> <init>= <expr><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><name><name>span</name><operator>-&gt;</operator><name>fclass</name></name></expr>]</index></name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_span_to_fullness_class</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>span</name></decl></parameter>,
                           <parameter><decl><type><name>dsa_pointer</name></type> <name>span_pointer</name></decl></parameter>,
                           <parameter><decl><type><name>int</name></type> <name>fclass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dsa_area_pool</name> <modifier>*</modifier></type><name>pool</name> <init>= <expr><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><name>fclass</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>dsa_area_span</name> <modifier>*</modifier></type><name>head</name> <init>= <expr><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>,
                                              <argument><expr><name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><name>fclass</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>head</name><operator>-&gt;</operator><name>prevspan</name></name> <operator>=</operator> <name>span_pointer</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>prevspan</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>nextspan</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><name>fclass</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>spans</name><index>[<expr><name>fclass</name></expr>]</index></name> <operator>=</operator> <name>span_pointer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>fclass</name></name> <operator>=</operator> <name>fclass</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Detach from an area that was either created or attached to by this process.
 */</comment>
<function><type><name>void</name></type>
<name>dsa_detach</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Detach from all segments. */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>area</name><operator>-&gt;</operator><name>high_segment_index</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segment</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

    <comment type="block">/*
     * Note that 'detaching' (= detaching from DSM segments) doesn't include
     * 'releasing' (= adjusting the reference count).  It would be nice to
     * combine these operations, but client code might never get around to
     * calling dsa_detach because of an error path, and a detach hook on any
     * particular segment is too late to detach other segments in the area
     * without risking a 'leak' warning in the non-error path.
     */</comment>

    <comment type="block">/* Free the backend-local area object. */</comment>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unlink a segment from the bin that contains it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>unlink_segment</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>dsa_segment_map</name> <modifier>*</modifier></type><name>segment_map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>prev</name></name> <operator>!=</operator> <name>DSA_SEGMENT_INDEX_NONE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>dsa_segment_map</name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>get_segment_by_index</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>segment_bins</name><index>[<expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>bin</name></name></expr>]</index></name> <operator>==</operator>
               <call><name>get_segment_index</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>segment_map</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>segment_bins</name><index>[<expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>bin</name></name></expr>]</index></name> <operator>=</operator>
            <name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>DSA_SEGMENT_INDEX_NONE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>dsa_segment_map</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>get_segment_by_index</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find a segment that could satisfy a request for 'npages' of contiguous
 * memory, or return NULL if none can be found.  This may involve attaching to
 * segments that weren't previously attached so that we can query their free
 * pages map.
 */</comment>
<function><type><specifier>static</specifier> <name>dsa_segment_map</name> <modifier>*</modifier></type>
<name>get_best_segment</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>npages</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>bin</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_for_freed_segments_locked</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>npages</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Start searching from the first bin that *might* have enough contiguous
     * pages.
     */</comment>
    <for>for <control>(<init><expr><name>bin</name> <operator>=</operator> <call><name>contiguous_pages_to_segment_bin</name><argument_list>(<argument><expr><name>npages</name></expr></argument>)</argument_list></call></expr>;</init>
         <condition><expr><name>bin</name> <operator>&lt;</operator> <name>DSA_NUM_SEGMENT_BINS</name></expr>;</condition>
         <incr><expr><operator>++</operator><name>bin</name></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * The minimum contiguous size that any segment in this bin should
         * have.  We'll re-bin if we see segments with fewer.
         */</comment>
        <decl_stmt><decl><type><name>Size</name></type>        <name>threshold</name> <init>= <expr><operator>(</operator><name>Size</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>bin</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dsa_segment_index</name></type> <name>segment_index</name></decl>;</decl_stmt>

        <comment type="block">/* Search this bin for a segment with enough contiguous space. */</comment>
        <expr_stmt><expr><name>segment_index</name> <operator>=</operator> <name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>segment_bins</name><index>[<expr><name>bin</name></expr>]</index></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>segment_index</name> <operator>!=</operator> <name>DSA_SEGMENT_INDEX_NONE</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>dsa_segment_map</name> <modifier>*</modifier></type><name>segment_map</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>dsa_segment_index</name></type> <name>next_segment_index</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Size</name></type>        <name>contiguous_pages</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>segment_map</name> <operator>=</operator> <call><name>get_segment_by_index</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>segment_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>next_segment_index</name> <operator>=</operator> <name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>contiguous_pages</name> <operator>=</operator> <call><name>fpm_largest</name><argument_list>(<argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>fpm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Not enough for the request, still enough for this bin. */</comment>
            <if_stmt><if>if <condition>(<expr><name>contiguous_pages</name> <operator>&gt;=</operator> <name>threshold</name> <operator>&amp;&amp;</operator> <name>contiguous_pages</name> <operator>&lt;</operator> <name>npages</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>segment_index</name> <operator>=</operator> <name>next_segment_index</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Re-bin it if it's no longer in the appropriate bin. */</comment>
            <if_stmt><if>if <condition>(<expr><name>contiguous_pages</name> <operator>&lt;</operator> <name>threshold</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Size</name></type>        <name>new_bin</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>new_bin</name> <operator>=</operator> <call><name>contiguous_pages_to_segment_bin</name><argument_list>(<argument><expr><name>contiguous_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Remove it from its current bin. */</comment>
                <expr_stmt><expr><call><name>unlink_segment</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>segment_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Push it onto the front of its new bin. */</comment>
                <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>DSA_SEGMENT_INDEX_NONE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator>
                    <name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>segment_bins</name><index>[<expr><name>new_bin</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>bin</name></name> <operator>=</operator> <name>new_bin</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>segment_bins</name><index>[<expr><name>new_bin</name></expr>]</index></name> <operator>=</operator> <name>segment_index</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>DSA_SEGMENT_INDEX_NONE</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>dsa_segment_map</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>get_segment_by_index</name><argument_list>(<argument><expr><name>area</name></expr></argument>,
                                                <argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>next</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>bin</name></name> <operator>==</operator> <name>new_bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>segment_index</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * But fall through to see if it's enough to satisfy this
                 * request anyway....
                 */</comment>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Check if we are done. */</comment>
            <if_stmt><if>if <condition>(<expr><name>contiguous_pages</name> <operator>&gt;=</operator> <name>npages</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>segment_map</name></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/* Continue searching the same bin. */</comment>
            <expr_stmt><expr><name>segment_index</name> <operator>=</operator> <name>next_segment_index</name></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></for>

    <comment type="block">/* Not found. */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a new segment that can handle at least requested_pages.  Returns
 * NULL if the requested total size limit or maximum allowed number of
 * segments would be exceeded.
 */</comment>
<function><type><specifier>static</specifier> <name>dsa_segment_map</name> <modifier>*</modifier></type>
<name>make_new_segment</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>requested_pages</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>dsa_segment_index</name></type> <name>new_index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>metadata_bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>total_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>total_pages</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>usable_pages</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_segment_map</name> <modifier>*</modifier></type><name>segment_map</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>segment</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Find a segment slot that is not in use (linearly for now). */</comment>
    <for>for <control>(<init><expr><name>new_index</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>new_index</name> <operator>&lt;</operator> <name>DSA_MAX_SEGMENTS</name></expr>;</condition> <incr><expr><operator>++</operator><name>new_index</name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>segment_handles</name><index>[<expr><name>new_index</name></expr>]</index></name> <operator>==</operator> <name>DSM_HANDLE_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>new_index</name> <operator>==</operator> <name>DSA_MAX_SEGMENTS</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If the total size limit is already exceeded, then we exit early and
     * avoid arithmetic wraparound in the unsigned expressions below.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>total_segment_size</name></name> <operator>&gt;=</operator>
        <name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>max_total_segment_size</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * The size should be at least as big as requested, and at least big
     * enough to follow a geometric series that approximately doubles the
     * total storage each time we create a new segment.  We use geometric
     * growth because the underlying DSM system isn't designed for large
     * numbers of segments (otherwise we might even consider just using one
     * DSM segment for each large allocation and for each superblock, and then
     * we wouldn't need to use FreePageManager).
     *
     * We decide on a total segment size first, so that we produce tidy
     * power-of-two sized segments.  This is a good property to have if we
     * move to huge pages in the future.  Then we work back to the number of
     * pages we can fit.
     */</comment>
    <expr_stmt><expr><name>total_size</name> <operator>=</operator> <name>DSA_INITIAL_SEGMENT_SIZE</name> <operator>*</operator>
        <operator>(</operator><operator>(</operator><name>Size</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>new_index</name> <operator>/</operator> <name>DSA_NUM_SEGMENTS_AT_EACH_SIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>total_size</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>total_size</name></expr></argument>, <argument><expr><name>DSA_MAX_SEGMENT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>total_size</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>total_size</name></expr></argument>,
                     <argument><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>max_total_segment_size</name></name> <operator>-</operator>
                     <name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>total_segment_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>total_pages</name> <operator>=</operator> <name>total_size</name> <operator>/</operator> <name>FPM_PAGE_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>metadata_bytes</name> <operator>=</operator>
        <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_segment_header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
        <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageManager</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
        <sizeof>sizeof<argument_list>(<argument><expr><name>dsa_pointer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>total_pages</name></expr>;</expr_stmt>

    <comment type="block">/* Add padding up to next page boundary. */</comment>
    <if_stmt><if>if <condition>(<expr><name>metadata_bytes</name> <operator>%</operator> <name>FPM_PAGE_SIZE</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>metadata_bytes</name> <operator>+=</operator> <name>FPM_PAGE_SIZE</name> <operator>-</operator> <operator>(</operator><name>metadata_bytes</name> <operator>%</operator> <name>FPM_PAGE_SIZE</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>total_size</name> <operator>&lt;=</operator> <name>metadata_bytes</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>usable_pages</name> <operator>=</operator> <operator>(</operator><name>total_size</name> <operator>-</operator> <name>metadata_bytes</name><operator>)</operator> <operator>/</operator> <name>FPM_PAGE_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>metadata_bytes</name> <operator>+</operator> <name>usable_pages</name> <operator>*</operator> <name>FPM_PAGE_SIZE</name> <operator>&lt;=</operator> <name>total_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* See if that is enough... */</comment>
    <if_stmt><if>if <condition>(<expr><name>requested_pages</name> <operator>&gt;</operator> <name>usable_pages</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We'll make an odd-sized segment, working forward from the requested
         * number of pages.
         */</comment>
        <expr_stmt><expr><name>usable_pages</name> <operator>=</operator> <name>requested_pages</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>metadata_bytes</name> <operator>=</operator>
            <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_segment_header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
            <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageManager</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
            <name>usable_pages</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dsa_pointer</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

        <comment type="block">/* Add padding up to next page boundary. */</comment>
        <if_stmt><if>if <condition>(<expr><name>metadata_bytes</name> <operator>%</operator> <name>FPM_PAGE_SIZE</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>metadata_bytes</name> <operator>+=</operator> <name>FPM_PAGE_SIZE</name> <operator>-</operator> <operator>(</operator><name>metadata_bytes</name> <operator>%</operator> <name>FPM_PAGE_SIZE</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>total_size</name> <operator>=</operator> <name>metadata_bytes</name> <operator>+</operator> <name>usable_pages</name> <operator>*</operator> <name>FPM_PAGE_SIZE</name></expr>;</expr_stmt>

        <comment type="block">/* Is that too large for dsa_pointer's addressing scheme? */</comment>
        <if_stmt><if>if <condition>(<expr><name>total_size</name> <operator>&gt;</operator> <name>DSA_MAX_SEGMENT_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* Would that exceed the limit? */</comment>
        <if_stmt><if>if <condition>(<expr><name>total_size</name> <operator>&gt;</operator> <name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>max_total_segment_size</name></name> <operator>-</operator>
            <name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>total_segment_size</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create the segment. */</comment>
    <expr_stmt><expr><name>segment</name> <operator>=</operator> <call><name>dsm_create</name><argument_list>(<argument><expr><name>total_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>segment</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>dsm_pin_segment</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>area</name><operator>-&gt;</operator><name>mapping_pinned</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>dsm_pin_mapping</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Store the handle in shared memory to be found by index. */</comment>
    <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>segment_handles</name><index>[<expr><name>new_index</name></expr>]</index></name> <operator>=</operator>
        <call><name>dsm_segment_handle</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Track the highest segment index in the history of the area. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>high_segment_index</name></name> <operator>&lt;</operator> <name>new_index</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>high_segment_index</name></name> <operator>=</operator> <name>new_index</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Track the highest segment index this backend has ever mapped. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>area</name><operator>-&gt;</operator><name>high_segment_index</name></name> <operator>&lt;</operator> <name>new_index</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>high_segment_index</name></name> <operator>=</operator> <name>new_index</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Track total size of all segments. */</comment>
    <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>total_segment_size</name></name> <operator>+=</operator> <name>total_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>total_segment_size</name></name> <operator>&lt;=</operator>
           <name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>max_total_segment_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Build a segment map for this segment in this backend. */</comment>
    <expr_stmt><expr><name>segment_map</name> <operator>=</operator> <operator>&amp;</operator><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><name>new_index</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>segment</name></name> <operator>=</operator> <name>segment</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name> <operator>=</operator> <call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <operator>(</operator><name>dsa_segment_header</name> <operator>*</operator><operator>)</operator> <name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>fpm</name></name> <operator>=</operator> <operator>(</operator><name>FreePageManager</name> <operator>*</operator><operator>)</operator>
        <operator>(</operator><name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name> <operator>+</operator>
         <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_segment_header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>pagemap</name></name> <operator>=</operator> <operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator>
        <operator>(</operator><name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name> <operator>+</operator>
         <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_segment_header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
         <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageManager</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Set up the free page map. */</comment>
    <expr_stmt><expr><call><name>FreePageManagerInitialize</name><argument_list>(<argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>fpm</name></name></expr></argument>, <argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>mapped_address</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FreePageManagerPut</name><argument_list>(<argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>fpm</name></name></expr></argument>, <argument><expr><name>metadata_bytes</name> <operator>/</operator> <name>FPM_PAGE_SIZE</name></expr></argument>,
                       <argument><expr><name>usable_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set up the segment header and put it in the appropriate bin. */</comment>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator>
        <name>DSA_SEGMENT_HEADER_MAGIC</name> <operator>^</operator> <name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>handle</name></name> <operator>^</operator> <name>new_index</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>usable_pages</name></name> <operator>=</operator> <name>usable_pages</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>total_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>bin</name></name> <operator>=</operator> <call><name>contiguous_pages_to_segment_bin</name><argument_list>(<argument><expr><name>usable_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>DSA_SEGMENT_INDEX_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator>
        <name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>segment_bins</name><index>[<expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>bin</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>freed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>segment_bins</name><index>[<expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>bin</name></name></expr>]</index></name> <operator>=</operator> <name>new_index</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>DSA_SEGMENT_INDEX_NONE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>dsa_segment_map</name> <modifier>*</modifier></type><name>next</name> <init>=
        <expr><call><name>get_segment_by_index</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>next</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>bin</name></name> <operator>==</operator> <name><name>segment_map</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>new_index</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>segment_map</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if any segments have been freed by destroy_superblock, so we can
 * detach from them in this backend.  This function is called by
 * dsa_get_address and dsa_free to make sure that a dsa_pointer they have
 * received can be resolved to the correct segment.
 *
 * The danger we want to defend against is that there could be an old segment
 * mapped into a given slot in this backend, and the dsa_pointer they have
 * might refer to some new segment in the same slot.  So those functions must
 * be sure to process all instructions to detach from a freed segment that had
 * been generated by the time this process received the dsa_pointer, before
 * they call get_segment_by_index.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_for_freed_segments</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>freed_segment_counter</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Any other process that has freed a segment has incremented
     * free_segment_counter while holding an LWLock, and that must precede any
     * backend creating a new segment in the same slot while holding an
     * LWLock, and that must precede the creation of any dsa_pointer pointing
     * into the new segment which might reach us here, and the caller must
     * have sent the dsa_pointer to this process using appropriate memory
     * synchronization (some kind of locking or atomic primitive or system
     * call).  So all we need to do on the reading side is ask for the load of
     * freed_segment_counter to follow the caller's load of the dsa_pointer it
     * has, and we can be sure to detect any segments that had been freed as
     * of the time that the dsa_pointer reached this process.
     */</comment>
    <expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>freed_segment_counter</name> <operator>=</operator> <name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>freed_segment_counter</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>area</name><operator>-&gt;</operator><name>freed_segment_counter</name></name> <operator>!=</operator> <name>freed_segment_counter</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Check all currently mapped segments to find what's been freed. */</comment>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>check_for_freed_segments_locked</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Workhorse for check_for_freed_segments(), and also used directly in path
 * where the area lock is already held.  This should be called after acquiring
 * the lock but before looking up any segment by index number, to make sure we
 * unmap any stale segments that might have previously had the same index as a
 * current segment.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_for_freed_segments_locked</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>freed_segment_counter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><call><name>DSA_AREA_LOCK</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>freed_segment_counter</name> <operator>=</operator> <name><name>area</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>freed_segment_counter</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>area</name><operator>-&gt;</operator><name>freed_segment_counter</name></name> <operator>!=</operator> <name>freed_segment_counter</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>area</name><operator>-&gt;</operator><name>high_segment_index</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>header</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                <name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>header</name><operator>-&gt;</operator><name>freed</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segment</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>header</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>segment_maps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapped_address</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>area</name><operator>-&gt;</operator><name>freed_segment_counter</name></name> <operator>=</operator> <name>freed_segment_counter</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
