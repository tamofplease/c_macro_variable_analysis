<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/cache/relcryptmap.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 *
 * relcryptmap.c
 *   relation file crypt map
 *
 * Portions Copyright (c) 2018, Tbase Global Development Group
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *    src/backend/utils/cache/relcryptmap.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/namespace.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufpage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buffile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplestore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgwriter.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_mls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"contrib/sm/sm4.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcrypt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcryptmisc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/relcryptstorage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcryptmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relfilenodemap.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls_extension.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRYPT_KEY_MAP_FILENAME</name></cpp:macro>                  <cpp:value>"pg_crypt_key.map"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRYPT_KEY_MAP_FILEMAGIC</name></cpp:macro>                 <cpp:value>0x952701</cpp:value></cpp:define>    <comment type="block">/* version ID value */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRYPT_KEY_PAGE_SIZE</name></cpp:macro>                     <cpp:value>8192</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRYPT_KEY_BUF_SIZE</name></cpp:macro>                      <cpp:value>(8192 - VARHDRSZ)</cpp:value></cpp:define>
<comment type="block">/* there are CRYPT_KEY_INFO_HASHTABLE_INIT_SIZE crypt keys, hope this is enough */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRYPT_KEY_INFO_HASHTABLE_INIT_SIZE</name></cpp:macro>      <cpp:value>256</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRYPT_KEY_INFO_HASHTABLE_MAX_SIZE</name></cpp:macro>       <cpp:value>CRYPT_KEY_INFO_HASHTABLE_INIT_SIZE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRYPT_KEY_INFO_HASHTABLE_NUM_PARITIONS</name></cpp:macro>  <cpp:value>16</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_CRYPT_MAP_FILENAME</name></cpp:macro>                  <cpp:value>"pg_rel_crypt.map"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_CRYPT_MAP_FILEMAGIC</name></cpp:macro>                 <cpp:value>0x952702</cpp:value></cpp:define>    <comment type="block">/* version ID value */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_CRYPT_HASHTABLE_MAX_SIZE</name></cpp:macro>            <cpp:value>((g_rel_crypt_hash_size &gt; (1 &lt;&lt; 20))? g_rel_crypt_hash_size : (1 &lt;&lt; 20))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_CRYPT_HASHTABLE_INIT_SIZE</name></cpp:macro>           <cpp:value>g_rel_crypt_hash_size</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_CRYPT_HASHTABLE_NUM_PARTITIONS</name></cpp:macro>      <cpp:value>128</cpp:value></cpp:define>


<typedef>typedef <type><struct>struct <name>tagCryptKeyInfoLockData</name>
<block>{
    <comment type="block">/* LWLocks */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>lwlock_tranche_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LWLockPadded</name></type> <name><name>locks</name><index>[<expr><name>CRYPT_KEY_INFO_HASHTABLE_NUM_PARITIONS</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>CryptKeyInfoLockData</name>;</typedef>
<typedef>typedef <type><name>CryptKeyInfoLockData</name> <modifier>*</modifier></type> <name>CryptKeyInfoLock</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type> <name>g_crypt_key_info_hash</name>             <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>CryptKeyInfoLock</name></type> <name>g_crypt_key_info_lock</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>crypt_key_info_hash_code</name><parameter_list>(<parameter><type><name>_algo_id</name></type></parameter>)</parameter_list></cpp:macro>              <cpp:value>(get_hash_value(g_crypt_key_info_hash, (void *)(_algo_id)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>crypt_key_info_hash_partition</name><parameter_list>(<parameter><type><name>_hashcode</name></type></parameter>)</parameter_list></cpp:macro>         <cpp:value>((_hashcode) % CRYPT_KEY_INFO_HASHTABLE_NUM_PARITIONS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>crypt_key_info_hash_get_partition_lock</name><parameter_list>(<parameter><type><name>_partid</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;(g_crypt_key_info_lock-&gt;locks[(_partid)].lock))</cpp:value></cpp:define>


<typedef>typedef <type><struct>struct <name>tagRelCryptLockData</name>
<block>{
    <comment type="block">/* LWLocks */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>lwlock_tranche_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LWLockPadded</name></type> <name><name>locks</name><index>[<expr><name>REL_CRYPT_HASHTABLE_NUM_PARTITIONS</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>RelCryptLockData</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>RelCryptLockData</name> <modifier>*</modifier></type> <name>g_rel_crypt_lock</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name>             <modifier>*</modifier></type> <name>g_rel_crypt_hash</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rel_crypt_hash_partition</name><parameter_list>(<parameter><type><name>_hashcode</name></type></parameter>)</parameter_list></cpp:macro>     <cpp:value>((_hashcode) % REL_CRYPT_HASHTABLE_NUM_PARTITIONS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rel_crypt_get_partition_lock</name><parameter_list>(<parameter><type><name>_partid</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>(&amp;(g_rel_crypt_lock-&gt;locks[(_partid)].lock))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rel_crypt_hash_code</name><parameter_list>(<parameter><type><name>_rnode</name></type></parameter>)</parameter_list></cpp:macro>             <cpp:value>(get_hash_value(g_rel_crypt_hash, (void *) (_rnode)))</cpp:value></cpp:define>

<comment type="block">/* 
 * this struct describes dump file mapping of relfilenode and algoid, it is a fix size.
 * we encrypt it with encrypt_procedure, the function use text* type as input,
 * therefore, we keep the struct size as 4k - VARHDRSZ, that means obligate 4 bytes for VARHDR.
 */</comment>
<comment type="block">/* (4096 - sizeof(int)*4) / sizeof(RelCryptMapElement) = ((4096 / sizeof(RelCryptMapElement)) - 1)*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_CRYPT_MAP_ELEMENT_CNT_PER_PAGE</name></cpp:macro>  <cpp:value>255</cpp:value></cpp:define> 
<typedef>typedef <type><struct>struct <name>tagRelCryptMapFile</name>
<block>{
    <decl_stmt><decl><type><name>int</name></type>                 <name>magic</name></decl>;</decl_stmt>          <comment type="block">/* always REL_CRYPT_MAP_FILEMAGIC */</comment>
    <decl_stmt><decl><type><name>pg_crc32c</name></type>           <name>crc</name></decl>;</decl_stmt>            <comment type="block">/* CRC of followings */</comment>
    <decl_stmt><decl><type><name>int</name></type>                 <name>element_count</name></decl>;</decl_stmt>  <comment type="block">/* how many rel file node in RelCryptEntry array */</comment>
    <decl_stmt><decl><type><name>RelCryptEntry</name></type>       <name><name>elements</name><index>[<expr><name>REL_CRYPT_MAP_ELEMENT_CNT_PER_PAGE</name></expr>]</index></name></decl>;</decl_stmt>   
}</block></struct></type> <name>RelCryptMapFile</name>;</typedef>

<comment type="block">/*
 * this struct describes crypt key info into dump files, the size of file is variable,
 * cause the necessary infos needed are different among sym crypt, non-sym crypt, udf crypt.
 * while, we also try to keep memory aligned, that means every 8k page having one CryptKeyMapFile header,
 * and the count of keys record in element_count.
 */</comment>
<typedef>typedef <type><struct>struct <name>tagCryptKeyMapFile</name>
<block>{
    <decl_stmt><decl><type><name>int</name></type>                 <name>magic</name></decl>;</decl_stmt>          <comment type="block">/* always CRYPT_KEY_MAP_FILEMAGIC */</comment>
    <decl_stmt><decl><type><name>pg_crc32c</name></type>           <name>crc</name></decl>;</decl_stmt>            <comment type="block">/* CRC of followings */</comment>
    <decl_stmt><decl><type><name>int</name></type>                 <name>element_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                 <name>total_len</name></decl>;</decl_stmt>      <comment type="block">/* the whole length of valid bytes contains CryptKeyMapFile header */</comment>
}</block></struct></type> <name>CryptKeyMapFile</name>;</typedef>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MARK</name><argument_list>(<argument><expr><literal type="string">"crypt key manager"</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>crypt_key_info_init</name><parameter_list>(<parameter><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>crypt_key_info_hash_algoid_cmp</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>crypt_key_info_load_mapfile_inner</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>key_info_from_map</name></decl></parameter>, <parameter><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>crypt_key_info_write_mapfile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>crypt_key_info_mapfile_get_next_key</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type> <name>keysize_out</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>crypt_key_info_key_serialization</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset_input</name></decl></parameter>, <parameter><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey_input</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>crypt_key_info_key_deserialization</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey_output</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>crypt_key_info_map_check</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>CryptKeyMapFile</name> <modifier>*</modifier><modifier>*</modifier></type><name>map_output</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type> <name>crypt_key_info_init</name><parameter_list>(<parameter><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>option</name></decl> ;</decl_stmt>

    <expr_stmt><expr><name>option</name> <operator>=</operator> <name><name>cryptkey</name><operator>-&gt;</operator><name>option</name></name></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>cryptkey</name></expr></argument>, <argument><expr><literal type="number">0x0</literal></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>CryptKeyInfoEntry</name></expr></argument>, <argument><expr><name>udf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>CRYPT_KEY_INFO_OPTION_UDF</name> <operator>==</operator> <name>option</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name></name></expr></argument>, <argument><expr><literal type="number">0x0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CryptKeyInfoUDF</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>CRYPT_KEY_INFO_OPTION_ANYKEY</name> <operator>==</operator> <name>option</name> <operator>||</operator> <name>CRYPT_KEY_INFO_OPTION_UDF</name> <operator>==</operator> <name>option</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name></name></expr></argument>, <argument><expr><literal type="number">0x0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CryptKeyInfoKeyPair</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>crypt_key_info_free</name><parameter_list>(<parameter><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>cryptkey</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cryptkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return;</return>
</block_content>}</block></function>

<function><type><name>CryptKeyInfo</name></type> <name>crypt_key_info_alloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>option</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cryptkey</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CryptKeyInfoEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>option</name></name>  <operator>=</operator> <name>option</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name></name>     <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>CRYPT_KEY_INFO_OPTION_UDF</name> <operator>==</operator> <name>option</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CryptKeyInfoUDF</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>CRYPT_KEY_INFO_OPTION_UDF</name> <operator>==</operator> <name>option</name> <operator>||</operator> <name>CRYPT_KEY_INFO_OPTION_ANYKEY</name> <operator>==</operator> <name>option</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CryptKeyInfoKeyPair</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <return>return <expr><name>cryptkey</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>cyprt_key_info_hash_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type>    <name>info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>    <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>i</name></decl>;</decl_stmt>
    <comment type="block">/* assume no locking is needed yet */</comment>

    <comment type="block">/* BufferTag maps to Buffer */</comment>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name>          <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AlgoId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name>        <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CryptKeyInfoEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>num_partitions</name></name>   <operator>=</operator> <name>CRYPT_KEY_INFO_HASHTABLE_NUM_PARITIONS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>match</name></name>            <operator>=</operator> <name>crypt_key_info_hash_algoid_cmp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>g_crypt_key_info_hash</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"crypt key info shared hash table"</literal></expr></argument>,
                                          <argument><expr><name>CRYPT_KEY_INFO_HASHTABLE_INIT_SIZE</name></expr></argument>, 
                                          <argument><expr><name>CRYPT_KEY_INFO_HASHTABLE_MAX_SIZE</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
        								  <argument><expr><name>HASH_ELEM</name>  <operator>|</operator> <name>HASH_PARTITION</name> <operator>|</operator> <name>HASH_COMPARE</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>g_crypt_key_info_lock</name> <operator>=</operator> <operator>(</operator><name>CryptKeyInfoLock</name><operator>)</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"crypt key info lock shmem"</literal></expr></argument>,
                                                              <argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CryptKeyInfoLockData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
                                                              <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_crypt_key_info_lock</name><operator>-&gt;</operator><name>lwlock_tranche_id</name></name> <operator>=</operator> <name>LWTRANCHE_CRYPT_KEY_INFO_LOCK</name></expr>;</expr_stmt>
        
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>CRYPT_KEY_INFO_HASHTABLE_NUM_PARITIONS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>g_crypt_key_info_lock</name><operator>-&gt;</operator><name>locks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lock</name><operator>)</operator></expr></argument>, <argument><expr><name><name>g_crypt_key_info_lock</name><operator>-&gt;</operator><name>lwlock_tranche_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        
        <expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name><name>g_crypt_key_info_lock</name><operator>-&gt;</operator><name>lwlock_tranche_id</name></name></expr></argument>, <argument><expr><literal type="string">"crypt key info lock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return;</return>
</block_content>}</block></function>

<function><type><name>Size</name></type> <name>crypt_key_info_hash_shmem_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>add_size</name><argument_list>(<argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>CRYPT_KEY_INFO_HASHTABLE_MAX_SIZE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CryptKeyInfoEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>
                    , <argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CryptKeyInfoLockData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>crypt_key_info_hash_algoid_cmp</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>AlgoId</name> <modifier>*</modifier></type><name>tagPtr1</name> <init>= <expr><name>key1</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tagPtr2</name> <init>= <expr><name>key2</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tagPtr1</name> <operator>==</operator> <operator>*</operator><name>tagPtr2</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>crypt_key_info_hash_insert</name><parameter_list>(<parameter><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey_input</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>write_wal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>in_building_procedure</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>     <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>   <name>hashcode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>      <name>partitionno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LWLock</name>    <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>      <name>option</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>      <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>    <name>algo_id</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>algo_id</name> <operator>=</operator> <name><name>cryptkey_input</name><operator>-&gt;</operator><name>algo_id</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>option</name>  <operator>=</operator> <name><name>cryptkey_input</name><operator>-&gt;</operator><name>option</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name>    <operator>=</operator> <call><name>crypt_key_info_cal_key_size</name><argument_list>(<argument><expr><name>cryptkey_input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>hashcode</name>      <operator>=</operator> <call><name>crypt_key_info_hash_code</name><argument_list>(<argument><expr><operator>&amp;</operator><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>partitionno</name>   <operator>=</operator> <call><name>crypt_key_info_hash_partition</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>crypt_key_info_hash_get_partition_lock</name><argument_list>(<argument><expr><name>partitionno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>cryptkey</name> <operator>=</operator> <operator>(</operator><name>CryptKeyInfo</name><operator>)</operator><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>g_crypt_key_info_hash</name></expr></argument>,
                                                    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>algo_id</name></expr></argument>,
                                                    <argument><expr><name>hashcode</name></expr></argument>,
                                                    <argument><expr><name>HASH_ENTER</name></expr></argument>,
                                                    <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>found</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>false</name> <operator>==</operator> <name>in_building_procedure</name><operator>)</operator>
            <operator>&amp;&amp;</operator><operator>(</operator><name>CRYPT_DEFAULT_INNER_ALGO_ID</name> <operator>!=</operator> <name>algo_id</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>RequestFlushCryptkeyMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>algo_id</name></name>                 <operator>=</operator> <name>algo_id</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>option</name></name>                  <operator>=</operator> <name><name>cryptkey_input</name><operator>-&gt;</operator><name>option</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keysize</name></name>                 <operator>=</operator> <name><name>cryptkey_input</name><operator>-&gt;</operator><name>keysize</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>password</name></name></expr></argument>,          <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>password</name></name></expr></argument>,         <argument><expr><name>CRYPT_KEY_INFO_MAX_PASSWORD_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>,       <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>,      <argument><expr><name>CRYPT_KEY_INFO_MAX_OPT_ARGS_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* guomi sm4 */</comment>
        <expr_stmt><expr><call><name>sm4_setkey_enc</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>sm4_ctx_encrypt</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>password</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sm4_setkey_dec</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>sm4_ctx_decrypt</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>password</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>CRYPT_KEY_INFO_OPTION_UDF</name> <operator>==</operator> <name>option</name> <operator>||</operator> <name>CRYPT_KEY_INFO_OPTION_ANYKEY</name> <operator>==</operator> <name>option</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>CRYPT_KEY_INFO_OPTION_UDF</name> <operator>==</operator> <name>option</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_oid</name></name>             <operator>=</operator> <name><name>cryptkey_input</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_oid</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_oid</name></name>             <operator>=</operator> <name><name>cryptkey_input</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_oid</name></name></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_prosrc</name></name></expr></argument>,    <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_prosrc</name></name></expr></argument>,   <argument><expr><name>CRYPT_KEY_INFO_PROC_SRC_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_probin</name></name></expr></argument>,    <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_probin</name></name></expr></argument>,   <argument><expr><name>CRYPT_KEY_INFO_PROC_BIN_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_prosrc</name></name></expr></argument>,    <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_prosrc</name></name></expr></argument>,   <argument><expr><name>CRYPT_KEY_INFO_PROC_SRC_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_probin</name></name></expr></argument>,    <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_probin</name></name></expr></argument>,   <argument><expr><name>CRYPT_KEY_INFO_PROC_BIN_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* load function address for shared lib */</comment>
                    <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_func</name></name> <operator>=</operator> <call><name>load_external_function</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_probin</name></name></expr></argument>, 
                                                                        <argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_prosrc</name></name></expr></argument>,
                                                                        <argument><expr><name>true</name></expr></argument>, 
                                                                        <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_func</name></name> <operator>=</operator> <call><name>load_external_function</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_probin</name></name></expr></argument>, 
                                                                        <argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_prosrc</name></name></expr></argument>,
                                                                        <argument><expr><name>true</name></expr></argument>, 
                                                                        <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>publickey</name></name></expr></argument>,         <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>publickey</name></name></expr></argument>,        <argument><expr><name>CRYPT_KEY_INFO_MAX_PUBKEY_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>privatekey</name></name></expr></argument>,        <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>privatekey</name></name></expr></argument>,       <argument><expr><name>CRYPT_KEY_INFO_MAX_PRIKEY_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Critical section done */</comment>
    <if_stmt><if>if <condition>(<expr><name>write_wal</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>CRYPT_DEFAULT_INNER_ALGO_ID</name> <operator>!=</operator> <name>algo_id</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name></decl>;</decl_stmt>
        
        <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>crypt_key_info_key_serialization</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cryptkey_input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* now errors are fatal ... */</comment>
        <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_REL_CRYPT_ID</name></expr></argument>, <argument><expr><name>XLOG_CRYPT_KEY_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* As always, WAL must hit the disk before the data update does */</comment>
        <expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>                
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>write_wal</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_building_procedure</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name> <operator>!=</operator> <name>algo_id</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, new crypt key insert, need checkpoint to flush, "</literal>
                            <literal type="string">"algo_id:%d, option:%d, option_args:%s"</literal></expr></argument>, 
                            <argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, default crypt key insert, should NOT happen, position 1, "</literal>
                            <literal type="string">"algo_id:%d, option:%d, option_args:%s"</literal></expr></argument>, 
                            <argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name> <operator>!=</operator> <name>algo_id</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, new crypt key insert concurrently, procedure duplicate xlog insert, "</literal>
                                <literal type="string">"need checkpoint to flush, algo_id:%d, option:%d, option_args:%s"</literal></expr></argument>, 
                                <argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, default crypt key insert, should NOT happen, position 2, "</literal>
                            <literal type="string">"algo_id:%d, option:%d, option_args:%s"</literal></expr></argument>, 
                            <argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, default crypt key insert, should NOT happen, position 3, "</literal>
                            <literal type="string">"algo_id:%d, option:%d, option_args:%s"</literal></expr></argument>, 
                            <argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_building_procedure</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name> <operator>!=</operator> <name>algo_id</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, new crypt key insert in REDO procedure, need checkpoint to flush, "</literal>
                            <literal type="string">"algo_id:%d, option:%d, option_args:%s"</literal></expr></argument>, 
                            <argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, default crypt key insert, key should be loaded in postmaster start up, "</literal>
                            <literal type="string">"should NOT happen, position 4, algo_id:%d, option:%d, option_args:%s"</literal></expr></argument>, 
                            <argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name> <operator>!=</operator> <name>algo_id</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, new crypt key insert concurrently, duplicate xlog insert in REDO procedure, "</literal>
                                <literal type="string">"need checkpoint to flush, algo_id:%d, option:%d, option_args:%s"</literal></expr></argument>, 
                                <argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, default crypt key insert, should NOT happen, position 5, "</literal>
                            <literal type="string">"algo_id:%d, option:%d, option_args:%s"</literal></expr></argument>, 
                            <argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name> <operator>!=</operator> <name>algo_id</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, new crypt key insert in loading crypt key map, "</literal>
                            <literal type="string">"algo_id:%d, option:%d, option_args:%s"</literal></expr></argument>, 
                            <argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, default crypt key insert, postmaster maybe starting up, "</literal>
                            <literal type="string">"loading crypt key map, algo_id:%d, option:%d, option_args:%s"</literal></expr></argument>, 
                            <argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name> <operator>!=</operator> <name>algo_id</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, new crypt key insert, duplicate crypt key in crypt key map, "</literal>
                                <literal type="string">"should NOT happen, position 6, algo_id:%d, option:%d, option_args:%s"</literal></expr></argument>, 
                                <argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, default crypt key insert, should NOT happen, position 7, "</literal>
                                <literal type="string">"algo_id:%d, option:%d, option_args:%s"</literal></expr></argument>, 
                                <argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>cryptkey_input</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>crypt_key_info_hash_lookup</name><parameter_list>(<parameter><decl><type><name>AlgoId</name></type> <name>algo_id</name></decl></parameter>, <parameter><decl><type><name>CryptKeyInfo</name> <modifier>*</modifier></type> <name>cryptkey_ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>   <name>hashcode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>      <name>partitionno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LWLock</name>    <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>     <name>found</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>hashcode</name>      <operator>=</operator> <call><name>crypt_key_info_hash_code</name><argument_list>(<argument><expr><operator>&amp;</operator><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>partitionno</name>   <operator>=</operator> <call><name>crypt_key_info_hash_partition</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>crypt_key_info_hash_get_partition_lock</name><argument_list>(<argument><expr><name>partitionno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cryptkey</name> <operator>=</operator> <operator>(</operator><name>CryptKeyInfo</name><operator>)</operator><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>g_crypt_key_info_hash</name></expr></argument>,
                                                    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>algo_id</name></expr></argument>,
                                                    <argument><expr><name>hashcode</name></expr></argument>,
                                                    <argument><expr><name>HASH_FIND</name></expr></argument>,
                                                    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>cryptkey</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>cryptkey_ret</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>cryptkey_ret</name> <operator>=</operator> <name>cryptkey</name></expr>;</expr_stmt>
            <comment type="line">//memcpy((char*)relcrypt_ret, relcrypt, sizeof(CryptKeyInfoEntry));</comment>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>crypt_key_info_map_check</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>CryptKeyMapFile</name> <modifier>*</modifier><modifier>*</modifier></type><name>map_output</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>pg_crc32c</name></type>   <name>crc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CryptKeyMapFile</name> <modifier>*</modifier></type> <name>map</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>            <modifier>*</modifier></type> <name>decrypt_buf</name></decl>;</decl_stmt>
    
    <comment type="block">/* decrpyt */</comment>
    <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>*</operator><name>map_output</name></expr>;</expr_stmt>
    
    <comment type="block">/* decrypt map file */</comment>
    <expr_stmt><expr><name>decrypt_buf</name> <operator>=</operator> <call><name>decrypt_procedure</name><argument_list>(<argument><expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name></expr></argument>, <argument><expr><operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><name>buffer</name></expr></argument>, <argument><expr><name>INVALID_CONTEXT_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>map</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>decrypt_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>decrypt_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>crypt_free</name><argument_list>(<argument><expr><name>decrypt_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* check for correct magic number, etc */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>CRYPT_KEY_MAP_FILEMAGIC</name> <operator>||</operator>
        <name><name>map</name><operator>-&gt;</operator><name>element_count</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
        <name><name>map</name><operator>-&gt;</operator><name>total_len</name></name> <operator>&gt;</operator> <name>CRYPT_KEY_BUF_SIZE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"crypt key file contains invalid data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* verify the CRC */</comment>
    <expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>map</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>CRYPT_KEY_BUF_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EQ_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"crypt key file contains incorrect checksum"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>crypt_key_info_load_mapfile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CryptKeyMapFile</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CryptKeyInfo</name></type>     <name>cryptkey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>mapfilename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>loop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>current_key_info_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>current_key_info_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BufFile</name>    <modifier>*</modifier></type><name>buffile</name></decl>;</decl_stmt>

    <comment type="block">/* STEP 1, for default crypt key */</comment>
    <expr_stmt><expr><call><name>crypt_key_info_load_default_key</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* STEP 2, OTHERS */</comment>        
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>mapfilename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapfilename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><literal type="string">"global"</literal></expr></argument>, <argument><expr><name>CRYPT_KEY_MAP_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>buffile</name> <operator>=</operator> <call><name>BufFileOpen</name><argument_list>(<argument><expr><name>mapfilename</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>buffile</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>buffer</name>   <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>CRYPT_KEY_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>map</name>      <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>CRYPT_KEY_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cryptkey</name> <operator>=</operator> <call><name>crypt_key_info_alloc</name><argument_list>(<argument><expr><name>CRYPT_KEY_INFO_OPTION_UDF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* ---- TODO ---- there should be loop to read map file */</comment>
    <do>do<block>{<block_content>
        <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_CRYPT_KEY_MAP_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name>buffile</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>CRYPT_KEY_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>len</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>CRYPT_KEY_PAGE_SIZE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not read datalen:%d in crypt key bufFile, readlen:%d."</literal></expr></argument>, 
                <argument><expr><name>CRYPT_KEY_PAGE_SIZE</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
        <comment type="block">/* get one valid buffer */</comment>
        <expr_stmt><expr><call><name>crypt_key_info_map_check</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* load buffer context */</comment>
        <expr_stmt><expr><name>offset</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CryptKeyMapFile</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>                
        <block>{<block_content>
             <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, postmaster is starting up, ----load begin----"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <for>for <control>(<init><expr><name>loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>loop</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>element_count</name></name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>total_len</name></name></expr>;</condition> <incr><expr><name>loop</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>current_key_info_offset</name> <operator>=</operator> <call><name>crypt_key_info_mapfile_get_next_key</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>map</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_key_info_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>crypt_key_info_load_mapfile_inner</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>map</name> <operator>+</operator> <name>current_key_info_offset</name></expr></argument>, <argument><expr><name>cryptkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>current_key_info_offset</name> <operator>+</operator> <name>current_key_info_len</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>                
        <block>{<block_content>
             <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, postmaster is starting up, ----load end----"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&lt;</operator> <name>CRYPT_KEY_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
    </block_content>}</block>while<condition>(<expr><literal type="number">1</literal></expr>)</condition>;</do>

    <if_stmt><if>if <condition>(<expr><call><name>BufFileReadDone</name><argument_list>(<argument><expr><name>buffile</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name>buffile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no data in crypt key buffile while reading data."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* ---- TODO ---- there should be loop to read map file */</comment>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>crypt_key_info_free</name><argument_list>(<argument><expr><name>cryptkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>crypt_key_info_load_mapfile_inner</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>key_info_from_map</name></decl></parameter>, <parameter><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>crypt_key_info_key_deserialization</name><argument_list>(<argument><expr><name>key_info_from_map</name></expr></argument>, <argument><expr><name>cryptkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>crypt_key_info_hash_insert</name><argument_list>(<argument><expr><name>cryptkey</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>crypt_key_info_load_default_key</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>cryptkey</name><operator>=</operator> <call><name>crypt_key_info_alloc</name><argument_list>(<argument><expr><name>CRYPT_KEY_INFO_OPTION_SYMKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>cryt_ky_inf_fil_stru_for_deflt_alg</name><argument_list>(<argument><expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name></expr></argument>, <argument><expr><name>cryptkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* no wal_write and no need to flush map file */</comment>
    <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>                
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, crypt_key_info_load_default_key, algo_id:%d, option:%d, option_args:%s"</literal></expr></argument>, 
            <argument><expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name></expr></argument>, <argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>crypt_key_info_hash_insert</name><argument_list>(<argument><expr><name>cryptkey</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  

    <expr_stmt><expr><call><name>crypt_key_info_free</name><argument_list>(<argument><expr><name>cryptkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>cryt_ky_inf_fil_stru_for_deflt_alg</name><parameter_list>(<parameter><decl><type><name>AlgoId</name></type> <name>algo_id</name></decl></parameter>, <parameter><decl><type><name>CryptKeyInfo</name></type>  <name>cryptkey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>option_char</name> <init>= <expr><literal type="string">"cipher-algo=AES128, compress-algo=2, compress-level=9"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type> <name>option_text</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type> <name>passwd_text</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>algo_id</name></name> <operator>=</operator> <name>algo_id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>option</name></name> <operator>=</operator> <name>CRYPT_KEY_INFO_OPTION_SYMKEY</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>passwd_text</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>VARHDRSZ</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>MLS_USER_DEFAULT_PASSWD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>passwd_text</name></expr></argument>, <argument><expr><name>VARHDRSZ</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>MLS_USER_DEFAULT_PASSWD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>passwd_text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MLS_USER_DEFAULT_PASSWD</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>MLS_USER_DEFAULT_PASSWD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>option_text</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>VARHDRSZ</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>option_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>option_text</name></expr></argument>, <argument><expr><name>VARHDRSZ</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>option_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>option_text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>option_char</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>option_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>password</name></name></expr></argument>,    <argument><expr><name>passwd_text</name></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>passwd_text</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>, <argument><expr><name>option_text</name></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>option_text</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keysize</name></name> <operator>=</operator> <call><name>crypt_key_info_cal_key_size</name><argument_list>(<argument><expr><name>cryptkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>option_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>    
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type> <name>default_private_key_dearmor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type> <name>default_public_key_dearmor</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>option</name></name> <operator>=</operator> <name>CRYPT_KEY_INFO_OPTION_ANYKEY</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>default_private_key_dearmor</name> <operator>=</operator> <call><name>crypt_key_info_get_dearmor_key</name><argument_list>(<argument><expr><call><name>transparent_crypt_get_private_key</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>default_public_key_dearmor</name>  <operator>=</operator> <call><name>crypt_key_info_get_dearmor_key</name><argument_list>(<argument><expr><call><name>transparent_crypt_get_pub_key</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>default_public_key_dearmor</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>CRYPT_KEY_INFO_MAX_PUBKEY_LEN</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"public key dearmor is over length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>default_private_key_dearmor</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>CRYPT_KEY_INFO_MAX_PRIKEY_LEN</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"private key dearmor is over length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>publickey</name></name></expr></argument>,  <argument><expr><name>default_public_key_dearmor</name></expr></argument>,  <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>default_public_key_dearmor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>privatekey</name></name></expr></argument>, <argument><expr><name>default_private_key_dearmor</name></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>default_private_key_dearmor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>crypt_key_info_map_init</name><parameter_list>(<parameter><decl><type><name>CryptKeyMapFile</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>map</name></expr></argument>, <argument><expr><literal type="number">0x0</literal></expr></argument>, <argument><expr><name>CRYPT_KEY_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>CRYPT_KEY_MAP_FILEMAGIC</name></expr>;</expr_stmt>
    
    <return>return;</return>
</block_content>}</block></function>   
<function><type><specifier>static</specifier> <name>void</name></type> <name>crypt_key_info_write_mapfile_post</name><parameter_list>(<parameter><decl><type><name>CryptKeyMapFile</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>element_cnt</name></decl></parameter>, <parameter><decl><type><name>BufFile</name> <modifier>*</modifier></type><name>buffile</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type> <name>need_encrypt_text</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type> <name>encrypt_text</name></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>need_encrypt_text</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>need_encrypt_text</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>CRYPT_KEY_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* fill header */</comment>
    <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>element_count</name></name> <operator>=</operator> <name>element_cnt</name></expr>;</expr_stmt>

    <comment type="block">/* crc */</comment>
    <expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>map</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>CRYPT_KEY_BUF_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* encrypt procedure */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>need_encrypt_text</name></expr></argument>, <argument><expr><literal type="number">0x0</literal></expr></argument>, <argument><expr><name>CRYPT_KEY_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>need_encrypt_text</name></expr></argument>, <argument><expr><name>CRYPT_KEY_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>need_encrypt_text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>CRYPT_KEY_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* use default algo, so no need to consider about page_new_output */</comment>
    <expr_stmt><expr><name>encrypt_text</name> <operator>=</operator> <call><name>encrypt_procedure</name><argument_list>(<argument><expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name></expr></argument>, <argument><expr><name>need_encrypt_text</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* this should not happen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>encrypt_text</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>CRYPT_KEY_PAGE_SIZE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"encyrypt crypt key mapfile page is oversize:%lu"</literal></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>encrypt_text</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* write */</comment>
    <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_CRYPT_KEY_MAP_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name>buffile</name></expr></argument>,<argument><expr><name>encrypt_text</name></expr></argument>,<argument><expr><name>CRYPT_KEY_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>crypt_free</name><argument_list>(<argument><expr><name>encrypt_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>crypt_key_info_cal_key_size</name><parameter_list>(<parameter><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>option</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>option</name> <operator>=</operator> <name><name>cryptkey</name><operator>-&gt;</operator><name>option</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>size</name>   <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>CryptKeyInfoEntry</name></expr></argument>, <argument><expr><name>udf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch<condition>(<expr><name>option</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>CRYPT_KEY_INFO_OPTION_SYMKEY</name></expr>:</case>
        <case>case <expr><name>CRYPT_KEY_INFO_OPTION_SM4</name></expr>:</case>
            <break>break;</break>
        <case>case <expr><name>CRYPT_KEY_INFO_OPTION_ANYKEY</name></expr>:</case>
            <expr_stmt><expr><name>size</name> <operator>=</operator> <name>size</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>publickey</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>privatekey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>CRYPT_KEY_INFO_OPTION_UDF</name></expr>:</case>            
            <expr_stmt><expr><name>size</name> <operator>=</operator> <name>size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> <operator>=</operator> <name>size</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_prosrc</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_probin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> <operator>=</operator> <name>size</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_prosrc</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_probin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> <operator>=</operator> <name>size</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>publickey</name></name></expr></argument>)</argument_list></call>  <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>privatekey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default :</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown option, when cal key size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    
    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>crypt_key_info_write_mapfile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>              <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>              <name>loop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>              <name>keysize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>              <name>lock_loop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>mapfilename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>mapfilename_new</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BufFile</name>         <modifier>*</modifier></type><name>buffile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type>  <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CryptKeyInfo</name></type>     <name>cryptkey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>CryptKeyMapFile</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <comment type="block">/*
     * check the change from last flush
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>NeedFlushCryptkeyMap</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>mapfilename</name>     <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mapfilename_new</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>mapfilename</name></expr></argument>,     <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,    <argument><expr><literal type="string">"global"</literal></expr></argument>, <argument><expr><name>CRYPT_KEY_MAP_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>mapfilename_new</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s.%d"</literal></expr></argument>, <argument><expr><literal type="string">"global"</literal></expr></argument>, <argument><expr><name>CRYPT_KEY_MAP_FILENAME</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>buffer</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>CRYPT_KEY_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* init */</comment>
    <expr_stmt><expr><call><name>crypt_key_info_map_init</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>buffile</name> <operator>=</operator> <call><name>BufFileOpen</name><argument_list>(<argument><expr><name>mapfilename_new</name></expr></argument>, <argument><expr><operator>(</operator><name>O_WRONLY</name><operator>|</operator><name>O_CREAT</name><operator>|</operator><name>PG_BINARY</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>S_IRUSR</name><operator>|</operator><name>S_IWUSR</name><operator>)</operator></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* lock all partition lock*/</comment>
    <for>for <control>(<init><expr><name>lock_loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lock_loop</name> <operator>&lt;</operator> <name>CRYPT_KEY_INFO_HASHTABLE_NUM_PARITIONS</name></expr>;</condition> <incr><expr><name>lock_loop</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>crypt_key_info_hash_get_partition_lock</name><argument_list>(<argument><expr><name>lock_loop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>  

    <do>do<block>{<block_content>
        <comment type="block">/* init */</comment>
        <expr_stmt><expr><name>loop</name>   <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CryptKeyMapFile</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>g_crypt_key_info_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><operator>(</operator><name>cryptkey</name> <operator>=</operator> <operator>(</operator><name>CryptKeyInfo</name><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name> <operator>!=</operator> <name><name>cryptkey</name><operator>-&gt;</operator><name>algo_id</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>keysize</name> <operator>=</operator> <name><name>cryptkey</name><operator>-&gt;</operator><name>keysize</name></name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>+</operator> <name>keysize</name> <operator>&gt;</operator> <name>CRYPT_KEY_BUF_SIZE</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* current buffer is full, flush it */</comment>
                    <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>element_count</name></name> <operator>=</operator> <name>loop</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>total_len</name></name>     <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>crypt_key_info_write_mapfile_post</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>, <argument><expr><name>buffile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* next round, init */</comment>
                    <expr_stmt><expr><name>loop</name>   <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CryptKeyMapFile</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>crypt_key_info_map_init</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* fill in current buffer */</comment>
                <expr_stmt><expr><call><name>crypt_key_info_key_serialization</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>cryptkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <expr_stmt><expr><name>loop</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <name>keysize</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>

        <comment type="block">/* hash is empty, flush */</comment>
        <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>element_count</name></name> <operator>=</operator> <name>loop</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>total_len</name></name>     <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>crypt_key_info_write_mapfile_post</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>, <argument><expr><name>buffile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>while<condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>

    <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_CRYPT_KEY_MAP_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name>buffile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* atom action */</comment>
    <expr_stmt><expr><call><name>rename</name><argument_list>(<argument><expr><name>mapfilename_new</name></expr></argument>, <argument><expr><name>mapfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   

    <comment type="block">/* release all */</comment>
    <for>for <control>(<init><expr><name>lock_loop</name> <operator>=</operator> <name>CRYPT_KEY_INFO_HASHTABLE_NUM_PARITIONS</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>lock_loop</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>lock_loop</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>crypt_key_info_hash_get_partition_lock</name><argument_list>(<argument><expr><name>lock_loop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* finish this flush, so clear and wait for next */</comment>
    <expr_stmt><expr><call><name>ClearRequestFlushCryptkeyMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>                
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, crypt key hash changed, finish flushing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>mapfilename</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mapfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>mapfilename_new</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mapfilename_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>crypt_key_info_mapfile_get_next_key</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type> <name>keysize_out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>cryptkey</name> <operator>=</operator> <operator>(</operator><name>CryptKeyInfo</name><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>keysize_out</name> <operator>=</operator> <name><name>cryptkey</name><operator>-&gt;</operator><name>keysize</name></name></expr>;</expr_stmt>

    <return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>crypt_key_info_key_serialization</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset_input</name></decl></parameter>, <parameter><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>option</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>option</name> <operator>=</operator> <name><name>cryptkey</name><operator>-&gt;</operator><name>option</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>CryptKeyInfoEntry</name></expr></argument>, <argument><expr><name>udf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name> <operator>+</operator> <name>offset_input</name></expr></argument>, <argument><expr><name>cryptkey</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>offset_input</name></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>option</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>CRYPT_KEY_INFO_OPTION_SYMKEY</name></expr>:</case>
        <case>case <expr><name>CRYPT_KEY_INFO_OPTION_SM4</name></expr>:</case>
            <break>break;</break>
        <case>case <expr><name>CRYPT_KEY_INFO_OPTION_ANYKEY</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>publickey</name></name><operator>)</operator></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>publickey</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>publickey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>privatekey</name></name><operator>)</operator></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>privatekey</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>privatekey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"keypair is NULL, when anykey serialization"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>CRYPT_KEY_INFO_OPTION_UDF</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_oid</name></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_oid</name></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_prosrc</name></name></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_prosrc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_prosrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_probin</name></name><operator>)</operator></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_probin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_probin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_prosrc</name></name><operator>)</operator></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_prosrc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_prosrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_probin</name></name><operator>)</operator></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_probin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_probin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"udf is NULL, when udf serialization"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            
                <if_stmt><if>if <condition>(<expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>publickey</name></name><operator>)</operator></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>publickey</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>publickey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>privatekey</name></name><operator>)</operator></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>privatekey</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>privatekey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"keypair is NULL, when udf serialization"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <break>break;</break>
            </block_content>}</block>   
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown option, when serialize key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>crypt_key_info_key_deserialization</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey_output</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>           <name>option</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>           <name>offset</name></decl>;</decl_stmt>

    <comment type="block">/* clear base */</comment>
    <expr_stmt><expr><call><name>crypt_key_info_init</name><argument_list>(<argument><expr><name>cryptkey_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* copy common part */</comment>
    <expr_stmt><expr><name>offset</name>  <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>CryptKeyInfoEntry</name></expr></argument>, <argument><expr><name>udf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>cryptkey_output</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get useful option */</comment>
    <expr_stmt><expr><name>option</name>  <operator>=</operator> <name><name>cryptkey_output</name><operator>-&gt;</operator><name>option</name></name></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>option</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>CRYPT_KEY_INFO_OPTION_SYMKEY</name></expr>:</case>
        <case>case <expr><name>CRYPT_KEY_INFO_OPTION_SM4</name></expr>:</case>
            <break>break;</break>
        <case>case <expr><name>CRYPT_KEY_INFO_OPTION_ANYKEY</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>cryptkey_output</name><operator>-&gt;</operator><name>keypair</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey_output</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>publickey</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>buffer</name><operator>+</operator><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>buffer</name><operator>+</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey_output</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>privatekey</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>buffer</name><operator>+</operator><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>buffer</name><operator>+</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"keypair is NULL, when anykey deserialization"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>CRYPT_KEY_INFO_OPTION_UDF</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>cryptkey_output</name><operator>-&gt;</operator><name>udf</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>cryptkey_output</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_oid</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>cryptkey_output</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_oid</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey_output</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_prosrc</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>buffer</name><operator>+</operator><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>buffer</name><operator>+</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey_output</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_probin</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>buffer</name><operator>+</operator><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>buffer</name><operator>+</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey_output</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_prosrc</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>buffer</name><operator>+</operator><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>buffer</name><operator>+</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey_output</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_probin</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>buffer</name><operator>+</operator><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>buffer</name><operator>+</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"udf is NULL, when udf deserialization"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                
                <if_stmt><if>if <condition>(<expr><name><name>cryptkey_output</name><operator>-&gt;</operator><name>keypair</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey_output</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>publickey</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>buffer</name><operator>+</operator><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>buffer</name><operator>+</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey_output</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>privatekey</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>buffer</name><operator>+</operator><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>buffer</name><operator>+</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"keypair is NULL, when udf deserialization"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <break>break;</break>
            </block_content>}</block>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown crypt key info:%d "</literal></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    
    <return>return;</return>
</block_content>}</block></function>




<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MARK</name><argument_list>(<argument><expr><literal type="string">"rel crypt manager"</literal></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_CRYPT_MAPFILE_BUF_SIZE</name></cpp:macro>  <cpp:value>(4096 - VARHDRSZ)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_CRYPT_MAPFILE_PAGE_SIZE</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>rel_crypt_hash_key_cmp</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rel_crypt_mapfile_check</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>RelCryptMapFile</name> <modifier>*</modifier><modifier>*</modifier></type> <name>map_output</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rel_crypt_write_mapfile_init</name><parameter_list>(<parameter><decl><type><name>RelCryptMapFile</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rel_crypt_load_default</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>void</name></type> <name>rel_crypt_redo</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint8</name></type>                 <name>info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>CryptKeyInfo</name></type>  <name>cryptkey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>                <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>cryptkey</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>cryptkey</name> <operator>=</operator> <call><name>crypt_key_info_alloc</name><argument_list>(<argument><expr><name>CRYPT_KEY_INFO_OPTION_UDF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr>;</expr_stmt>
    
    <switch>switch<condition>(<expr><name>info</name> <operator>&amp;</operator> <name>XLR_RMGR_INFO_MASK</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>XLOG_CRYPT_KEY_INSERT</name></expr>:</case>
            <block>{<block_content>   
                <decl_stmt><decl><type><name>CryptKeyInfo</name></type>  <name>xlrec</name></decl>;</decl_stmt>
                
                <expr_stmt><expr><name>buffer</name> <operator>=</operator>  <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>crypt_key_info_key_deserialization</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>cryptkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>                
                <block>{<block_content>   
                    <expr_stmt><expr><name>xlrec</name>   <operator>=</operator> <operator>(</operator><name>CryptKeyInfo</name><operator>)</operator><name>buffer</name></expr>;</expr_stmt>
                    
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, redo XLOG_CRYPT_KEY_INSERT, algo_id:%d, option:%d, size:%d, option_args:%s"</literal></expr></argument>, 
                        <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>algo_id</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>keysize</name></name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>crypt_key_info_hash_insert</name><argument_list>(<argument><expr><name>cryptkey</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>XLOG_CRYPT_KEY_DELETE</name></expr>:</case>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"xlog type is comming, info:%u"</literal></expr></argument>, <argument><expr><name>XLOG_CRYPT_KEY_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>XLOG_REL_CRYPT_INSERT</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>xl_rel_crypt_insert</name> <modifier>*</modifier></type> <name>xlrec</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>xl_rel_crypt_insert</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>                
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, redo XLOG_REL_CRYPT_INSERT, relfilenode:%d:%d:%d, algo_id:%d"</literal></expr></argument>, 
                        <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                        <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>algo_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>rel_crypt_hash_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>xlrec</name><operator>-&gt;</operator><name>rnode</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>algo_id</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>XLOG_REL_CRYPT_DELETE</name></expr>:</case>
            <block>{<block_content>
        	    <decl_stmt><decl><type><name>xl_rel_crypt_delete</name> <modifier>*</modifier></type><name>xlrec</name></decl>;</decl_stmt>
        	    <expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>xl_rel_crypt_delete</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        	    <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>
	            <block>{<block_content>
        	    	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_DELETE, redo XLOG_REL_CRYPT_DELETE, relfilenode:%d:%d:%d, algo_id:%d"</literal></expr></argument>,
        	    			<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
        	    			<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>algo_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	            </block_content>}</block></if></if_stmt>
        	    <expr_stmt><expr><call><name>rel_crypt_hash_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>xlrec</name><operator>-&gt;</operator><name>rnode</name></name><operator>)</operator></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
            </block_content>}</block>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"recrypt redo, unknown info, info:%u"</literal></expr></argument>, <argument><expr><name>info</name> <operator>&amp;</operator> <name>XLR_RMGR_INFO_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>rel_cyprt_hash_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type>    <name>info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>    <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>i</name></decl>;</decl_stmt>
    <comment type="block">/* assume no locking is needed yet */</comment>

    <comment type="block">/* BufferTag maps to Buffer */</comment>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name>    <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name>  <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelCryptEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>num_partitions</name></name> <operator>=</operator> <name>REL_CRYPT_HASHTABLE_NUM_PARTITIONS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>rel_crypt_hash_key_cmp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>g_rel_crypt_hash</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"relation crypt table"</literal></expr></argument>,
                                  <argument><expr><name>REL_CRYPT_HASHTABLE_INIT_SIZE</name></expr></argument>, 
                                  <argument><expr><name>REL_CRYPT_HASHTABLE_MAX_SIZE</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
                                  <argument><expr><name>HASH_ELEM</name>  <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_PARTITION</name> <operator>|</operator> <name>HASH_COMPARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>g_rel_crypt_lock</name> <operator>=</operator> <operator>(</operator><name>RelCryptLockData</name> <operator>*</operator><operator>)</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"global relation crypt data"</literal></expr></argument>,
                                                      <argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelCryptLockData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_rel_crypt_lock</name><operator>-&gt;</operator><name>lwlock_tranche_id</name></name> <operator>=</operator> <name>LWTRANCHE_REL_CRYPT_LOCK</name></expr>;</expr_stmt>
        
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>REL_CRYPT_HASHTABLE_NUM_PARTITIONS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>g_rel_crypt_lock</name><operator>-&gt;</operator><name>locks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lock</name><operator>)</operator></expr></argument>, <argument><expr><name><name>g_rel_crypt_lock</name><operator>-&gt;</operator><name>lwlock_tranche_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        
        <expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name><name>g_rel_crypt_lock</name><operator>-&gt;</operator><name>lwlock_tranche_id</name></name></expr></argument>, <argument><expr><literal type="string">"rel crypt lock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return;</return>
</block_content>}</block></function>
<function><type><name>Size</name></type> <name>rel_crypt_hash_shmem_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>add_size</name><argument_list>(<argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>REL_CRYPT_HASHTABLE_MAX_SIZE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelCryptEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, 
                    <argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelCryptLockData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>rel_crypt_hash_key_cmp</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>RelFileNode</name> <modifier>*</modifier></type><name>tagPtr1</name> <init>= <expr><name>key1</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tagPtr2</name> <init>= <expr><name>key2</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tagPtr1</name><operator>-&gt;</operator><name>relNode</name></name> <operator>==</operator> <name><name>tagPtr2</name><operator>-&gt;</operator><name>relNode</name></name>
        <operator>&amp;&amp;</operator> <name><name>tagPtr1</name><operator>-&gt;</operator><name>dbNode</name></name> <operator>==</operator> <name><name>tagPtr2</name><operator>-&gt;</operator><name>dbNode</name></name> 
        <operator>&amp;&amp;</operator> <name><name>tagPtr1</name><operator>-&gt;</operator><name>spcNode</name></name> <operator>==</operator> <name><name>tagPtr2</name><operator>-&gt;</operator><name>spcNode</name></name></expr> )</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * this function is used to remove hash elem
 *
 * if write_wal is true, remove action will write wal
 */</comment>
<function><type><name>void</name></type> <name>remove_rel_crypt_hash_elem</name><parameter_list>(<parameter><decl><type><name>RelCrypt</name></type> <name>relCrypt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>write_wal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>relCrypt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * if the algo_id is invalid, skip
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>relCrypt</name><operator>-&gt;</operator><name>algo_id</name></name> <operator>==</operator> <name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name></expr>)</condition>
		<block>{<block_content>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/*
		 * do remove the rnode and algo_id map in rel_crypt_hash table
	     */</comment>
		<expr_stmt><expr><call><name>rel_crypt_hash_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>relCrypt</name><operator>-&gt;</operator><name>relfilenode</name></name><operator>)</operator></expr></argument>, <argument><expr><name>write_wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * do delete rel crypt hash elem about a rnode
 */</comment>
<function><type><name>void</name></type> <name>rel_crypt_hash_delete</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rnode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>write_wal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelCrypt</name></type> <name>relCrypt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>     <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>hashcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 	 <name>partitionno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>	<modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hashcode</name> <operator>=</operator> <call><name>rel_crypt_hash_code</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partitionno</name>   <operator>=</operator> <call><name>rel_crypt_hash_partition</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>rel_crypt_get_partition_lock</name><argument_list>(<argument><expr><name>partitionno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relCrypt</name> <operator>=</operator> <operator>(</operator><name>RelCrypt</name><operator>)</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>g_rel_crypt_hash</name></expr></argument>,
	                                                  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>rnode</name></expr></argument>,
	                                                  <argument><expr><name>hashcode</name></expr></argument>,
	                                                  <argument><expr><name>HASH_REMOVE</name></expr></argument>,
	                                                  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * need to flush crypt map in next checkpoint
		 */</comment>
		<expr_stmt><expr><call><name>RequestFlushRelcryptMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Critical section
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>found</name> <operator>&amp;&amp;</operator> <name>write_wal</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_rel_crypt_delete</name></type> <name>xlrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name></decl>;</decl_stmt>

		<comment type="block">/* now errors are fatal ... */</comment>
		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>rnode</name></name>   <operator>=</operator> <name><name>relCrypt</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>algo_id</name></name> <operator>=</operator> <name><name>relCrypt</name><operator>-&gt;</operator><name>algo_id</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xlrec</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_rel_crypt_delete</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_REL_CRYPT_ID</name></expr></argument>, <argument><expr><name>XLOG_REL_CRYPT_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* As always, WAL must hit the disk before the data update does */</comment>
		<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>rel_crypt_hash_insert</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>AlgoId</name></type> <name>algo_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>write_wal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>in_building_procedure</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RelCrypt</name></type> <name>relcrypt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>     <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>   <name>hashcode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>      <name>partitionno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LWLock</name>    <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>hashcode</name>      <operator>=</operator> <call><name>rel_crypt_hash_code</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>partitionno</name>   <operator>=</operator> <call><name>rel_crypt_hash_partition</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>rel_crypt_get_partition_lock</name><argument_list>(<argument><expr><name>partitionno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>relcrypt</name> <operator>=</operator> <operator>(</operator><name>RelCrypt</name><operator>)</operator><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>g_rel_crypt_hash</name></expr></argument>,
                                                    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>rnode</name></expr></argument>,
                                                    <argument><expr><name>hashcode</name></expr></argument>,
                                                    <argument><expr><name>HASH_ENTER</name></expr></argument>,
                                                    <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>relcrypt</name><operator>-&gt;</operator><name>algo_id</name></name>        <operator>=</operator> <name>algo_id</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>false</name> <operator>==</operator> <name>in_building_procedure</name><operator>)</operator> 
            <operator>&amp;&amp;</operator> <operator>(</operator><name>CRYPT_DEFAULT_INNER_ALGO_ID</name> <operator>!=</operator> <name>algo_id</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* need to flush crypt map */</comment>
            <expr_stmt><expr><call><name>RequestFlushRelcryptMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Critical section */</comment>
    <if_stmt><if>if <condition>(<expr><name>write_wal</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>CRYPT_DEFAULT_INNER_ALGO_ID</name> <operator>!=</operator> <name>algo_id</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>xl_rel_crypt_insert</name></type> <name>xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>lsn</name></decl>;</decl_stmt>

        <comment type="block">/* now errors are fatal ... */</comment>
        <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>rnode</name></name>   <operator>=</operator> <operator>*</operator><name>rnode</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>algo_id</name></name> <operator>=</operator> <name>algo_id</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xlrec</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_rel_crypt_insert</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_REL_CRYPT_ID</name></expr></argument>, <argument><expr><name>XLOG_REL_CRYPT_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* As always, WAL must hit the disk before the data update does */</comment>
        <expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* release lock here, in case of xlog insert by other concurrently */</comment>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>                
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>write_wal</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_building_procedure</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name> <operator>!=</operator> <name>algo_id</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, new rel crypt insert and need checkpoint to flush later, "</literal>
                                    <literal type="string">"relfilenode:%d:%d:%d, algo_id:%d"</literal></expr></argument>, 
                                    <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>relNode</name></name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, default rel crypt insert, shoule NOT happen, postion 1, "</literal>
                                    <literal type="string">"relfilenode:%d:%d:%d, algo_id:%d"</literal></expr></argument>, 
                                    <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>relNode</name></name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name> <operator>!=</operator> <name>algo_id</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, new rel crypt insert concurrently, shoule NOT happen, postion 2, "</literal>
                                    <literal type="string">"relfilenode:%d:%d:%d, algo_id:%d"</literal></expr></argument>, 
                                    <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>relNode</name></name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, default rel crypt insert, shoule NOT happen, postion 3, "</literal>
                                    <literal type="string">"relfilenode:%d:%d:%d, algo_id:%d"</literal></expr></argument>, 
                                    <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>relNode</name></name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, rel crypt insert, shoule NOT happen, postion 4, "</literal>
                                    <literal type="string">"relfilenode:%d:%d:%d, algo_id:%d"</literal></expr></argument>, 
                                    <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>relNode</name></name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_building_procedure</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name> <operator>!=</operator> <name>algo_id</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, new rel crypt insert in REDO procedure, "</literal>
                                    <literal type="string">"checkpoint needs to flush later, relfilenode:%d:%d:%d, algo_id:%d"</literal></expr></argument>, 
                                    <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>relNode</name></name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, default rel crypt insert, shoule NOT happen, postion 5, "</literal>
                                    <literal type="string">"relfilenode:%d:%d:%d, algo_id:%d"</literal></expr></argument>, 
                                    <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>relNode</name></name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name> <operator>!=</operator> <name>algo_id</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, new rel crypt insert concurrently, "</literal>
                                    <literal type="string">"while there shoule NO DUPLICATE xlog insert, postion 6, "</literal>
                                    <literal type="string">"relfilenode:%d:%d:%d, algo_id:%d"</literal></expr></argument>, 
                                    <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>relNode</name></name></expr></argument>,<argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, default rel crypt insert, shoule NOT happen, postion 7, "</literal>
                                    <literal type="string">"relfilenode:%d:%d:%d, algo_id:%d"</literal></expr></argument>, 
                                    <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>relNode</name></name></expr></argument>,<argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name> <operator>!=</operator> <name>algo_id</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, new rel crypt insert, here we are loading relcrypt map, "</literal>
                                    <literal type="string">"and keep in shmem hash, relfilenode:%d:%d:%d, algo_id:%d"</literal></expr></argument>, 
                                    <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>relNode</name></name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, default rel crypt insert, first open algorithm relation, "</literal>
                                    <literal type="string">"maybe dboid is invalid, relfilenode:%d:%d:%d, algo_id:%d"</literal></expr></argument>, 
                                    <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>relNode</name></name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name> <operator>!=</operator> <name>algo_id</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, new rel crypt insert concurrently, "</literal>
                                    <literal type="string">"while there shoule NO DUPLICATE in rel crypt map, postion 8, "</literal>
                                    <literal type="string">"relfilenode:%d:%d:%d, algo_id:%d"</literal></expr></argument>, 
                                    <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>relNode</name></name></expr></argument>,<argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, default rel crypt insert, shoule NOT happen, postion 9, "</literal>
                                    <literal type="string">"relfilenode:%d:%d:%d, algo_id:%d"</literal></expr></argument>, 
                                    <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>relNode</name></name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return;</return>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>rel_crypt_hash_lookup</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>RelCrypt</name></type> <name>relcrypt_ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RelCrypt</name></type> <name>relcrypt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>   <name>hashcode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>      <name>partitionno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LWLock</name>    <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>     <name>found</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>hashcode</name>      <operator>=</operator> <call><name>rel_crypt_hash_code</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>partitionno</name>   <operator>=</operator> <call><name>rel_crypt_hash_partition</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>rel_crypt_get_partition_lock</name><argument_list>(<argument><expr><name>partitionno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>relcrypt</name> <operator>=</operator> <operator>(</operator><name>RelCrypt</name><operator>)</operator><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>g_rel_crypt_hash</name></expr></argument>,
                                                    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>rnode</name></expr></argument>,
                                                    <argument><expr><name>hashcode</name></expr></argument>,
                                                    <argument><expr><name>HASH_FIND</name></expr></argument>,
                                                    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>relcrypt</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>relcrypt_ret</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>relcrypt_ret</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>relcrypt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelCryptEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rel_crypt_mapfile_check</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>RelCryptMapFile</name> <modifier>*</modifier><modifier>*</modifier></type> <name>map_output</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>pg_crc32c</name></type>   <name>crc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelCryptMapFile</name> <modifier>*</modifier></type> <name>map</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>            <modifier>*</modifier></type> <name>decrypt_buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>*</operator><name>map_output</name></expr>;</expr_stmt>
    
    <comment type="block">/* decrypt map file */</comment>
    <expr_stmt><expr><name>decrypt_buf</name> <operator>=</operator> <call><name>decrypt_procedure</name><argument_list>(<argument><expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name></expr></argument>, <argument><expr><operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><name>buffer</name></expr></argument>, <argument><expr><name>INVALID_CONTEXT_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>map</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>decrypt_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>decrypt_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>crypt_free</name><argument_list>(<argument><expr><name>decrypt_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* check for correct magic number, etc */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>REL_CRYPT_MAP_FILEMAGIC</name> <operator>||</operator>
        <name><name>map</name><operator>-&gt;</operator><name>element_count</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
        <name><name>map</name><operator>-&gt;</operator><name>element_count</name></name> <operator>&gt;</operator> <name>REL_CRYPT_MAP_ELEMENT_CNT_PER_PAGE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rel crypt mapping file contains invalid data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* verify the CRC */</comment>
    <expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>map</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>REL_CRYPT_MAPFILE_BUF_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EQ_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rel crypt mapping file contains incorrect checksum"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>rel_crypt_load_default</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <name>GLOBALTABLESPACE_OID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <name>TransparentCryptPolicyAlgorithmId</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>                
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, when postmaster start, load default, relfilenode:%d:%d:%d, algo_id:%d"</literal></expr></argument>, 
                        <argument><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                        <argument><expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>rel_crypt_hash_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>rel_crypt_load_mapfile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RelCryptMapFile</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>mapfilename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>BufFile</name>    <modifier>*</modifier></type><name>buffile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>loop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>len</name></decl>;</decl_stmt>

    <comment type="block">/*STEP 1, when postmaster startup, load rnode of pg_transparent_crypt_policy_algorithm */</comment>
    <expr_stmt><expr><call><name>rel_crypt_load_default</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*STEP 2*/</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>mapfilename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapfilename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><literal type="string">"global"</literal></expr></argument>, <argument><expr><name>REL_CRYPT_MAP_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>buffile</name> <operator>=</operator> <call><name>BufFileOpen</name><argument_list>(<argument><expr><name>mapfilename</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>buffile</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>REL_CRYPT_MAPFILE_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>map</name>    <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>REL_CRYPT_MAPFILE_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* ---- TODO ---- there should be loop to read map file */</comment>
    <do>do<block>{<block_content>
        <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_REL_CRYPT_MAP_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name>buffile</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REL_CRYPT_MAPFILE_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>len</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* file is empty */</comment>
            <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>REL_CRYPT_MAPFILE_PAGE_SIZE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not read datalen:%d in relcrypt bufFile."</literal></expr></argument>, <argument><expr><name>REL_CRYPT_MAPFILE_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* get one valid buffer */</comment>
        <expr_stmt><expr><call><name>rel_crypt_mapfile_check</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>                
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, postmaster is starting up, ----load begin----"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <for>for <control>(<init><expr><name>loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>loop</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>element_count</name></name></expr>;</condition> <incr><expr><name>loop</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>rel_crypt_hash_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>map</name><operator>-&gt;</operator><name>elements</name><index>[<expr><name>loop</name></expr>]</index></name><operator>.</operator><name>relfilenode</name><operator>)</operator></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>elements</name><index>[<expr><name>loop</name></expr>]</index></name><operator>.</operator><name>algo_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>                
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, postmaster is starting up, ----load end----"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>while<condition>(<expr><literal type="number">1</literal></expr>)</condition>;</do>
    <comment type="block">/* ---- TODO ---- there should be loop to read map file */</comment>

    <if_stmt><if>if <condition>(<expr><call><name>BufFileReadDone</name><argument_list>(<argument><expr><name>buffile</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name>buffile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no data in relcrypt buffile while reading data."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>rel_crypt_write_mapfile_init</name><parameter_list>(<parameter><decl><type><name>RelCryptMapFile</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><literal type="number">0x0</literal></expr></argument>, <argument><expr><name>REL_CRYPT_MAPFILE_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>REL_CRYPT_MAP_FILEMAGIC</name></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>rel_crypt_write_mapfile_post</name><parameter_list>(<parameter><decl><type><name>RelCryptMapFile</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>element_cnt</name></decl></parameter>, <parameter><decl><type><name>BufFile</name> <modifier>*</modifier></type> <name>buffile</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type> <name>need_encrypt_text</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type> <name>encrypt_text</name></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>need_encrypt_text</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>need_encrypt_text</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>REL_CRYPT_MAPFILE_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* fill header */</comment>
    <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>element_count</name></name> <operator>=</operator> <name>element_cnt</name></expr>;</expr_stmt>

    <comment type="block">/* crc procedure */</comment>
    <expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>map</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>REL_CRYPT_MAPFILE_BUF_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* encrypt procedure */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>need_encrypt_text</name></expr></argument>, <argument><expr><literal type="number">0x0</literal></expr></argument>, <argument><expr><name>REL_CRYPT_MAPFILE_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>need_encrypt_text</name></expr></argument>, <argument><expr><name>REL_CRYPT_MAPFILE_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>need_encrypt_text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>map</name></expr></argument>, <argument><expr><name>REL_CRYPT_MAPFILE_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* use default algo, so no need to consider about page_new_output */</comment>
    <expr_stmt><expr><name>encrypt_text</name> <operator>=</operator> <call><name>encrypt_procedure</name><argument_list>(<argument><expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name></expr></argument>, <argument><expr><name>need_encrypt_text</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* this should not happen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>encrypt_text</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>REL_CRYPT_MAPFILE_PAGE_SIZE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"encyrypt rel crypt mapfile page is oversize:%lu"</literal></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>encrypt_text</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* flush down */</comment>
    <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_REL_CRYPT_MAP_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name>buffile</name></expr></argument>, <argument><expr><name>encrypt_text</name></expr></argument>, <argument><expr><name>REL_CRYPT_MAPFILE_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>crypt_free</name><argument_list>(<argument><expr><name>encrypt_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * if is_backup is true, it means to backup the pg_rel_crypt.map
 * to pg_rel_crypt.map.backup, if is_backup is false, it means
 * flush the data to disk
 */</comment>
<function><type><name>void</name></type> <name>rel_crypt_write_mapfile</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_backup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>              <name>loop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>              <name>lock_loop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>mapfilename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>mapfilename_new</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type>  <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelCryptEntry</name>   <modifier>*</modifier></type><name>relcrypt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BufFile</name>         <modifier>*</modifier></type><name>buffile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>RelCryptMapFile</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <comment type="block">/*
     * check the change from last flush
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>NeedFlushRelcryptMap</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>mapfilename</name>     <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mapfilename_new</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * if backup the file, the filename will be renamed as pg_rel_crypt.map.backup
     * else the file named as pg_rel_crypt.map
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_backup</name></expr>)</condition>
    <block>{<block_content>
    	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>mapfilename</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s.backup"</literal></expr></argument>, <argument><expr><literal type="string">"global"</literal></expr></argument>, <argument><expr><name>REL_CRYPT_MAP_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>mapfilename</name></expr></argument>,     <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,    <argument><expr><literal type="string">"global"</literal></expr></argument>, <argument><expr><name>REL_CRYPT_MAP_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>mapfilename_new</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s.%d"</literal></expr></argument>, <argument><expr><literal type="string">"global"</literal></expr></argument>, <argument><expr><name>REL_CRYPT_MAP_FILENAME</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>buffile</name> <operator>=</operator> <call><name>BufFileOpen</name><argument_list>(<argument><expr><name>mapfilename_new</name></expr></argument>, <argument><expr><operator>(</operator><name>O_WRONLY</name><operator>|</operator><name>O_CREAT</name><operator>|</operator><name>PG_BINARY</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>S_IRUSR</name><operator>|</operator><name>S_IWUSR</name><operator>)</operator></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* prepare for buffer */</comment>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>map</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>REL_CRYPT_MAPFILE_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>rel_crypt_write_mapfile_init</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* lock all partition lock*/</comment>
    <for>for <control>(<init><expr><name>lock_loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lock_loop</name> <operator>&lt;</operator> <name>REL_CRYPT_HASHTABLE_NUM_PARTITIONS</name></expr>;</condition> <incr><expr><name>lock_loop</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>rel_crypt_get_partition_lock</name><argument_list>(<argument><expr><name>lock_loop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>  

    <do>do<block>{<block_content>
        <expr_stmt><expr><name>loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>g_rel_crypt_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><operator>(</operator><name>relcrypt</name> <operator>=</operator> <operator>(</operator><name>RelCryptEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* skip default algo id */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>relcrypt</name><operator>-&gt;</operator><name>algo_id</name></name> <operator>==</operator> <name>CRYPT_DEFAULT_INNER_ALGO_ID</name></expr>)</condition>
            <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>elements</name><index>[<expr><name>loop</name></expr>]</index></name><operator>.</operator><name>relfilenode</name> <operator>=</operator> <name><name>relcrypt</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>elements</name><index>[<expr><name>loop</name></expr>]</index></name><operator>.</operator><name>algo_id</name>     <operator>=</operator> <name><name>relcrypt</name><operator>-&gt;</operator><name>algo_id</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>loop</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>loop</name> <operator>&gt;=</operator> <name>REL_CRYPT_MAP_ELEMENT_CNT_PER_PAGE</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* this buffer is full, flush it */</comment>
                <expr_stmt><expr><call><name>rel_crypt_write_mapfile_post</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>, <argument><expr><name>buffile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <comment type="block">/* after flush one buffer, init buffer again */</comment>
                <expr_stmt><expr><name>loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>rel_crypt_write_mapfile_init</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>

        <comment type="block">/* hash is empty, flush buffer */</comment>
        <expr_stmt><expr><call><name>rel_crypt_write_mapfile_post</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>, <argument><expr><name>buffile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_REL_CRYPT_MAP_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name>buffile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        
    </block_content>}</block>while<condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>

    <comment type="block">/* atom action */</comment>
    <expr_stmt><expr><call><name>rename</name><argument_list>(<argument><expr><name>mapfilename_new</name></expr></argument>, <argument><expr><name>mapfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   

    <comment type="block">/* release all */</comment>
    <for>for <control>(<init><expr><name>lock_loop</name> <operator>=</operator> <name>REL_CRYPT_HASHTABLE_NUM_PARTITIONS</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>lock_loop</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>lock_loop</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>rel_crypt_get_partition_lock</name><argument_list>(<argument><expr><name>lock_loop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for> 

    <expr_stmt><expr><call><name>ClearRequestFlushRelcryptMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>                
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, rel crypt hash changed, finish flushing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>mapfilename_new</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mapfilename_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>mapfilename</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mapfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <return>return;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>bool</name></type> <name>userid_is_mls_user</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>DEFAULT_ROLE_MLS_SYS_USERID</name> <operator>==</operator> <name>userid</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name>userid</name></expr></argument>,<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>MLS_USER_PREFIX</name></expr></argument>,
                      <argument><expr><name>MLS_USER_PREFIX_LEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>is_mls_user</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>g_is_mls_user</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>is_mls_root_user</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>DEFAULT_ROLE_MLS_SYS_USERID</name> <operator>==</operator> <call><name>GetAuthenticatedUserId</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MARK</name><argument_list>(<argument><expr><literal type="string">"extern"</literal></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>Datum</name></type> <name>pg_rel_crypt_hash_dump</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_REL_CRYPT_DUMP_COLUMN_NUM</name></cpp:macro>    <cpp:value>5</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type> <name>rsinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>        <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Tuplestorestate</name><modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>   <name>per_query_ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>   <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>lock_loop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>loop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelCryptEntry</name> <modifier>*</modifier></type> <name>relcrypt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>            <name><name>values</name><index>[<expr><name>PG_REL_CRYPT_DUMP_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name><name>nulls</name><index>[<expr><name>PG_REL_CRYPT_DUMP_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"execute by mls user please"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rsinfo</name> <operator>=</operator> <operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr>;</expr_stmt>

    <comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
    <if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
                        <literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Build a tuple descriptor for our result type */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>PG_REL_CRYPT_DUMP_COLUMN_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* lock all partition lock*/</comment>
    <for>for <control>(<init><expr><name>lock_loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lock_loop</name> <operator>&lt;</operator> <name>REL_CRYPT_HASHTABLE_NUM_PARTITIONS</name></expr>;</condition> <incr><expr><name>lock_loop</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>rel_crypt_get_partition_lock</name><argument_list>(<argument><expr><name>lock_loop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>  

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>g_rel_crypt_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>relcrypt</name> <operator>=</operator> <operator>(</operator><name>RelCryptEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>loop</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name><name>relcrypt</name><operator>-&gt;</operator><name>relfilenode</name><operator>.</operator><name>dbNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name><name>relcrypt</name><operator>-&gt;</operator><name>relfilenode</name><operator>.</operator><name>spcNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name><name>relcrypt</name><operator>-&gt;</operator><name>relfilenode</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>relcrypt</name><operator>-&gt;</operator><name>algo_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    
    <comment type="block">/* release all */</comment>
    <for>for <control>(<init><expr><name>lock_loop</name> <operator>=</operator> <name>REL_CRYPT_HASHTABLE_NUM_PARTITIONS</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>lock_loop</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>lock_loop</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>rel_crypt_get_partition_lock</name><argument_list>(<argument><expr><name>lock_loop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for> 

    <comment type="block">/* clean up and return the tuplestore */</comment>
    <expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>pg_crypt_key_hash_dump</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CRYPT_KEY_DUMP_COLUMN_NUM</name></cpp:macro>    <cpp:value>13</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type> <name>rsinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>       <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Tuplestorestate</name><modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>   <name>per_query_ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>   <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>lock_loop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>loop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CryptKeyInfo</name></type>    <name>cryptkey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>           <name><name>values</name><index>[<expr><name>PG_CRYPT_KEY_DUMP_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name><name>nulls</name><index>[<expr><name>PG_CRYPT_KEY_DUMP_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"execute by mls user please"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rsinfo</name> <operator>=</operator> <operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr>;</expr_stmt>

    <comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
    <if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
                        <literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Build a tuple descriptor for our result type */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>PG_CRYPT_KEY_DUMP_COLUMN_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* lock all partition lock*/</comment>
    <for>for <control>(<init><expr><name>lock_loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lock_loop</name> <operator>&lt;</operator> <name>CRYPT_KEY_INFO_HASHTABLE_NUM_PARITIONS</name></expr>;</condition> <incr><expr><name>lock_loop</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>crypt_key_info_hash_get_partition_lock</name><argument_list>(<argument><expr><name>lock_loop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>  

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>g_crypt_key_info_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>cryptkey</name> <operator>=</operator> <operator>(</operator><name>CryptKeyInfo</name><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>loop</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>algo_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>password</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name>  <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name>  <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name></name> <operator>&amp;&amp;</operator> <name>CRYPT_KEY_INFO_OPTION_UDF</name> <operator>==</operator> <name><name>cryptkey</name><operator>-&gt;</operator><name>option</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name>  <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name>  <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name>  <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_prosrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">8</literal></expr>]</index></name>  <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_probin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name>  <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_prosrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_probin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name>  <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name>  <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name>  <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name>  <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name>  <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name>  <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name>  <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name>  <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name>  <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name>  <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name></name> <operator>&amp;&amp;</operator> <name>CRYPT_KEY_INFO_OPTION_UDF</name> <operator>==</operator> <name><name>cryptkey</name><operator>-&gt;</operator><name>option</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>publickey</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>privatekey</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    
    <comment type="block">/* release all */</comment>
    <for>for <control>(<init><expr><name>lock_loop</name> <operator>=</operator> <name>CRYPT_KEY_INFO_HASHTABLE_NUM_PARITIONS</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>lock_loop</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>lock_loop</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>crypt_key_info_hash_get_partition_lock</name><argument_list>(<argument><expr><name>lock_loop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* clean up and return the tuplestore */</comment>
    <expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check the relfilenode exist
 */</comment>
<function><type><name>bool</name></type> <name>CheckRelFileNodeExists</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rnode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelidByRelfilenode</name><argument_list>(<argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * mark the invalid elem in g_rel_crypt_hash to delete
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type> <name>MarkRelCryptInvalid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type> <name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>lock_loop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelCryptEntry</name> <modifier>*</modifier></type><name>relcrypt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_exist</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* lock all partition lock */</comment>
	<for>for <control>(<init><expr><name>lock_loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lock_loop</name> <operator>&lt;</operator> <name>REL_CRYPT_HASHTABLE_NUM_PARTITIONS</name></expr>;</condition> <incr><expr><name>lock_loop</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>rel_crypt_get_partition_lock</name><argument_list>(<argument><expr><name>lock_loop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>g_rel_crypt_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>relcrypt</name> <operator>=</operator> <operator>(</operator><name>RelCryptEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		 <comment type="block">/* only deal with current database */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>relcrypt</name><operator>-&gt;</operator><name>relfilenode</name><operator>.</operator><name>dbNode</name></name> <operator>!=</operator> <name>MyDatabaseId</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>is_exist</name> <operator>=</operator> <call><name>CheckRelFileNodeExists</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>relcrypt</name><operator>-&gt;</operator><name>relfilenode</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_exist</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"check relfilenode exist, dbNode:%d, spcNode:%d, relNode:%d"</literal></expr></argument>,
			     <argument><expr><name><name>relcrypt</name><operator>-&gt;</operator><name>relfilenode</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>relcrypt</name><operator>-&gt;</operator><name>relfilenode</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>relcrypt</name><operator>-&gt;</operator><name>relfilenode</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>relcrypt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* release all */</comment>
	<for>for <control>(<init><expr><name>lock_loop</name> <operator>=</operator> <name>REL_CRYPT_HASHTABLE_NUM_PARTITIONS</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>lock_loop</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>lock_loop</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>rel_crypt_get_partition_lock</name><argument_list>(<argument><expr><name>lock_loop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * do checkpoint to flush crypt map file to disk
 */</comment>
<function><type><name>void</name></type> <name>CheckPointRelCrypt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CheckPointRelCrypt check to flush crypt mapfile BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>rel_crypt_write_mapfile</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>crypt_key_info_write_mapfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CheckPointRelCrypt check to flush crypt mapfile END"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * if system in startup state, need to flush crypt map file
 */</comment>
<function><type><name>void</name></type> <name>StartupReachConsistentState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"StartupReachConsistentState check to flush crypt mapfile BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>rel_crypt_write_mapfile</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>crypt_key_info_write_mapfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"StartupReachConsistentState check to flush crypt mapfile END"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return;</return>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
