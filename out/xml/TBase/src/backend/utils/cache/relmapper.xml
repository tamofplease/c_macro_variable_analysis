<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/cache/relmapper.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * relmapper.c
 *      Catalog-to-filenode mapping
 *
 * For most tables, the physical file underlying the table is specified by
 * pg_class.relfilenode.  However, that obviously won't work for pg_class
 * itself, nor for the other "nailed" catalogs for which we have to be able
 * to set up working Relation entries without access to pg_class.  It also
 * does not work for shared catalogs, since there is no practical way to
 * update other databases' pg_class entries when relocating a shared catalog.
 * Therefore, for these special catalogs (henceforth referred to as "mapped
 * catalogs") we rely on a separately maintained file that shows the mapping
 * from catalog OIDs to filenode numbers.  Each database has a map file for
 * its local mapped catalogs, and there is a separate map file for shared
 * catalogs.  Mapped catalogs have zero in their pg_class.relfilenode entries.
 *
 * Relocation of a normal table is committed (ie, the new physical file becomes
 * authoritative) when the pg_class row update commits.  For mapped catalogs,
 * the act of updating the map file is effectively commit of the relocation.
 * We postpone the file update till just before commit of the transaction
 * doing the rewrite, but there is necessarily a window between.  Therefore
 * mapped catalogs can only be relocated by operations such as VACUUM FULL
 * and CLUSTER, which make no transactionally-significant changes: it must be
 * safe for the new file to replace the old, even if the transaction itself
 * aborts.  An important factor here is that the indexes and toast table of
 * a mapped catalog must also be mapped, so that the rewrites/relocations of
 * all these files commit in a single map file update rather than being tied
 * to transaction commit.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/utils/cache/relmapper.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relmapper.h"</cpp:file></cpp:include>


<comment type="block">/*
 * The map file is critical data: we have no automatic method for recovering
 * from loss or corruption of it.  We use a CRC so that we can detect
 * corruption.  To minimize the risk of failed updates, the map file should
 * be kept to no more than one standard-size disk sector (ie 512 bytes),
 * and we use overwrite-in-place rather than playing renaming games.
 * The struct layout below is designed to occupy exactly 512 bytes, which
 * might make filesystem updates a bit more efficient.
 *
 * Entries in the mappings[] array are in no particular order.  We could
 * speed searching by insisting on OID order, but it really shouldn't be
 * worth the trouble given the intended size of the mapping sets.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELMAPPER_FILENAME</name></cpp:macro>        <cpp:value>"pg_filenode.map"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELMAPPER_FILEMAGIC</name></cpp:macro>        <cpp:value>0x592717</cpp:value></cpp:define>    <comment type="block">/* version ID value */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_MAPPINGS</name></cpp:macro>            <cpp:value>62</cpp:value></cpp:define>    <comment type="block">/* 62 * 8 + 16 = 512 */</comment>

<typedef>typedef <type><struct>struct <name>RelMapping</name>
<block>{
    <decl_stmt><decl><type><name>Oid</name></type>            <name>mapoid</name></decl>;</decl_stmt>            <comment type="block">/* OID of a catalog */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>mapfilenode</name></decl>;</decl_stmt>    <comment type="block">/* its filenode number */</comment>
}</block></struct></type> <name>RelMapping</name>;</typedef>

<typedef>typedef <type><struct>struct <name>RelMapFile</name>
<block>{
    <decl_stmt><decl><type><name>int32</name></type>        <name>magic</name></decl>;</decl_stmt>            <comment type="block">/* always RELMAPPER_FILEMAGIC */</comment>
    <decl_stmt><decl><type><name>int32</name></type>        <name>num_mappings</name></decl>;</decl_stmt>    <comment type="block">/* number of valid RelMapping entries */</comment>
    <decl_stmt><decl><type><name>RelMapping</name></type>    <name><name>mappings</name><index>[<expr><name>MAX_MAPPINGS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_crc32c</name></type>    <name>crc</name></decl>;</decl_stmt>            <comment type="block">/* CRC of all above */</comment>
    <decl_stmt><decl><type><name>int32</name></type>        <name>pad</name></decl>;</decl_stmt>            <comment type="block">/* to make the struct size be 512 exactly */</comment>
}</block></struct></type> <name>RelMapFile</name>;</typedef>

<comment type="block">/*
 * The currently known contents of the shared map file and our database's
 * local map file are stored here.  These can be reloaded from disk
 * immediately whenever we receive an update sinval message.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>RelMapFile</name></type> <name>shared_map</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>RelMapFile</name></type> <name>local_map</name></decl>;</decl_stmt>

<comment type="block">/*
 * We use the same RelMapFile data structure to track uncommitted local
 * changes in the mappings (but note the magic and crc fields are not made
 * valid in these variables).  Currently, map updates are not allowed within
 * subtransactions, so one set of transaction-level changes is sufficient.
 *
 * The active_xxx variables contain updates that are valid in our transaction
 * and should be honored by RelationMapOidToFilenode.  The pending_xxx
 * variables contain updates we have been told about that aren't active yet;
 * they will become active at the next CommandCounterIncrement.  This setup
 * lets map updates act similarly to updates of pg_class rows, ie, they
 * become visible only at the next CommandCounterIncrement boundary.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>RelMapFile</name></type> <name>active_shared_updates</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>RelMapFile</name></type> <name>active_local_updates</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>RelMapFile</name></type> <name>pending_shared_updates</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>RelMapFile</name></type> <name>pending_local_updates</name></decl>;</decl_stmt>


<comment type="block">/* non-export function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>apply_map_update</name><parameter_list>(<parameter><decl><type><name>RelMapFile</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>fileNode</name></decl></parameter>,
                 <parameter><decl><type><name>bool</name></type> <name>add_okay</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>merge_map_updates</name><parameter_list>(<parameter><decl><type><name>RelMapFile</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RelMapFile</name> <modifier>*</modifier></type><name>updates</name></decl></parameter>,
                  <parameter><decl><type><name>bool</name></type> <name>add_okay</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_relmap_file</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>shared</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_relmap_file</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>shared</name></decl></parameter>, <parameter><decl><type><name>RelMapFile</name> <modifier>*</modifier></type><name>newmap</name></decl></parameter>,
                  <parameter><decl><type><name>bool</name></type> <name>write_wal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>send_sinval</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>preserve_files</name></decl></parameter>,
                  <parameter><decl><type><name>Oid</name></type> <name>dbid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>tsid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbpath</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>perform_relmap_update</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>shared</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RelMapFile</name> <modifier>*</modifier></type><name>updates</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * RelationMapOidToFilenode
 *
 * The raison d' etre ... given a relation OID, look up its filenode.
 *
 * Although shared and local relation OIDs should never overlap, the caller
 * always knows which we need --- so pass that information to avoid useless
 * searching.
 *
 * Returns InvalidOid if the OID is not known (which should never happen,
 * but the caller is in a better position to report a meaningful error).
 */</comment>
<function><type><name>Oid</name></type>
<name>RelationMapOidToFilenode</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shared</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>RelMapFile</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* If there are active updates, believe those over the main maps */</comment>
    <if_stmt><if>if <condition>(<expr><name>shared</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>&amp;</operator><name>active_shared_updates</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>num_mappings</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapoid</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapfilenode</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>&amp;</operator><name>shared_map</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>num_mappings</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapoid</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapfilenode</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>&amp;</operator><name>active_local_updates</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>num_mappings</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapoid</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapfilenode</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>&amp;</operator><name>local_map</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>num_mappings</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapoid</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapfilenode</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RelationMapFilenodeToOid
 *
 * Do the reverse of the normal direction of mapping done in
 * RelationMapOidToFilenode.
 *
 * This is not supposed to be used during normal running but rather for
 * information purposes when looking at the filesystem or xlog.
 *
 * Returns InvalidOid if the OID is not known; this can easily happen if the
 * relfilenode doesn't pertain to a mapped relation.
 */</comment>
<function><type><name>Oid</name></type>
<name>RelationMapFilenodeToOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>filenode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shared</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>RelMapFile</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* If there are active updates, believe those over the main maps */</comment>
    <if_stmt><if>if <condition>(<expr><name>shared</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>&amp;</operator><name>active_shared_updates</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>num_mappings</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>filenode</name> <operator>==</operator> <name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapfilenode</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapoid</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>&amp;</operator><name>shared_map</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>num_mappings</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>filenode</name> <operator>==</operator> <name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapfilenode</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapoid</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>&amp;</operator><name>active_local_updates</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>num_mappings</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>filenode</name> <operator>==</operator> <name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapfilenode</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapoid</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>&amp;</operator><name>local_map</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>num_mappings</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>filenode</name> <operator>==</operator> <name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapfilenode</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapoid</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RelationMapUpdateMap
 *
 * Install a new relfilenode mapping for the specified relation.
 *
 * If immediate is true (or we're bootstrapping), the mapping is activated
 * immediately.  Otherwise it is made pending until CommandCounterIncrement.
 */</comment>
<function><type><name>void</name></type>
<name>RelationMapUpdateMap</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>fileNode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shared</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>immediate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RelMapFile</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * In bootstrap mode, the mapping gets installed in permanent map.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>shared</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>&amp;</operator><name>shared_map</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>&amp;</operator><name>local_map</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * We don't currently support map changes within subtransactions. This
         * could be done with more bookkeeping infrastructure, but it doesn't
         * presently seem worth it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot change relation mapping within subtransaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>immediate</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Make it active, but only locally */</comment>
            <if_stmt><if>if <condition>(<expr><name>shared</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>&amp;</operator><name>active_shared_updates</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>&amp;</operator><name>active_local_updates</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Make it pending */</comment>
            <if_stmt><if>if <condition>(<expr><name>shared</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>&amp;</operator><name>pending_shared_updates</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>&amp;</operator><name>pending_local_updates</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>apply_map_update</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>fileNode</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * apply_map_update
 *
 * Insert a new mapping into the given map variable, replacing any existing
 * mapping for the same relation.
 *
 * In some cases the caller knows there must be an existing mapping; pass
 * add_okay = false to draw an error if not.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_map_update</name><parameter_list>(<parameter><decl><type><name>RelMapFile</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>fileNode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>add_okay</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Replace any existing mapping */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>num_mappings</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapoid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapfilenode</name> <operator>=</operator> <name>fileNode</name></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Nope, need to add a new mapping */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>add_okay</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attempt to apply a mapping to unmapped relation %u"</literal></expr></argument>,
             <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>num_mappings</name></name> <operator>&gt;=</operator> <name>MAX_MAPPINGS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ran out of space in relation map"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name><name>map</name><operator>-&gt;</operator><name>num_mappings</name></name></expr>]</index></name><operator>.</operator><name>mapoid</name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name><name>map</name><operator>-&gt;</operator><name>num_mappings</name></name></expr>]</index></name><operator>.</operator><name>mapfilenode</name> <operator>=</operator> <name>fileNode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>num_mappings</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * merge_map_updates
 *
 * Merge all the updates in the given pending-update map into the target map.
 * This is just a bulk form of apply_map_update.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>merge_map_updates</name><parameter_list>(<parameter><decl><type><name>RelMapFile</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RelMapFile</name> <modifier>*</modifier></type><name>updates</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>add_okay</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>updates</name><operator>-&gt;</operator><name>num_mappings</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>apply_map_update</name><argument_list>(<argument><expr><name>map</name></expr></argument>,
                         <argument><expr><name><name>updates</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapoid</name></expr></argument>,
                         <argument><expr><name><name>updates</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapfilenode</name></expr></argument>,
                         <argument><expr><name>add_okay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * RelationMapRemoveMapping
 *
 * Remove a relation's entry in the map.  This is only allowed for "active"
 * (but not committed) local mappings.  We need it so we can back out the
 * entry for the transient target file when doing VACUUM FULL/CLUSTER on
 * a mapped relation.
 */</comment>
<function><type><name>void</name></type>
<name>RelationMapRemoveMapping</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RelMapFile</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><operator>&amp;</operator><name>active_local_updates</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>num_mappings</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapoid</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Found it, collapse it out */</comment>
            <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name><name>map</name><operator>-&gt;</operator><name>num_mappings</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>num_mappings</name></name><operator>--</operator></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find temporary mapping for relation %u"</literal></expr></argument>,
         <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationMapInvalidate
 *
 * This routine is invoked for SI cache flush messages.  We must re-read
 * the indicated map file.  However, we might receive a SI message in a
 * process that hasn't yet, and might never, load the mapping files;
 * for example the autovacuum launcher, which *must not* try to read
 * a local map since it is attached to no particular database.
 * So, re-read only if the map is valid now.
 */</comment>
<function><type><name>void</name></type>
<name>RelationMapInvalidate</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>shared</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>shared</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>shared_map</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>RELMAPPER_FILEMAGIC</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>load_relmap_file</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>local_map</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>RELMAPPER_FILEMAGIC</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>load_relmap_file</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationMapInvalidateAll
 *
 * Reload all map files.  This is used to recover from SI message buffer
 * overflow: we can't be sure if we missed an inval message.
 * Again, reload only currently-valid maps.
 */</comment>
<function><type><name>void</name></type>
<name>RelationMapInvalidateAll</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>shared_map</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>RELMAPPER_FILEMAGIC</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>load_relmap_file</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>local_map</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>RELMAPPER_FILEMAGIC</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>load_relmap_file</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtCCI_RelationMap
 *
 * Activate any "pending" relation map updates at CommandCounterIncrement time.
 */</comment>
<function><type><name>void</name></type>
<name>AtCCI_RelationMap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pending_shared_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>merge_map_updates</name><argument_list>(<argument><expr><operator>&amp;</operator><name>active_shared_updates</name></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name>pending_shared_updates</name></expr></argument>,
                          <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pending_shared_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pending_local_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>merge_map_updates</name><argument_list>(<argument><expr><operator>&amp;</operator><name>active_local_updates</name></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name>pending_local_updates</name></expr></argument>,
                          <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pending_local_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtEOXact_RelationMap
 *
 * Handle relation mapping at main-transaction commit or abort.
 *
 * During commit, this must be called as late as possible before the actual
 * transaction commit, so as to minimize the window where the transaction
 * could still roll back after committing map changes.  Although nothing
 * critically bad happens in such a case, we still would prefer that it
 * not happen, since we'd possibly be losing useful updates to the relations'
 * pg_class row(s).
 *
 * During abort, we just have to throw away any pending map changes.
 * Normal post-abort cleanup will take care of fixing relcache entries.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_RelationMap</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We should not get here with any "pending" updates.  (We could
         * logically choose to treat such as committed, but in the current
         * code this should never happen.)
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pending_shared_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pending_local_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Write any active updates to the actual map files, then reset them.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>active_shared_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>perform_relmap_update</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>active_shared_updates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>active_shared_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>active_local_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>perform_relmap_update</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>active_local_updates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>active_local_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Abort --- drop all local and pending updates */</comment>
        <expr_stmt><expr><name><name>active_shared_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>active_local_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pending_shared_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pending_local_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtPrepare_RelationMap
 *
 * Handle relation mapping at PREPARE.
 *
 * Currently, we don't support preparing any transaction that changes the map.
 */</comment>
<function><type><name>void</name></type>
<name>AtPrepare_RelationMap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>active_shared_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <name><name>active_local_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <name><name>pending_shared_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <name><name>pending_local_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot PREPARE a transaction that modified relation mapping"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CheckPointRelationMap
 *
 * This is called during a checkpoint.  It must ensure that any relation map
 * updates that were WAL-logged before the start of the checkpoint are
 * securely flushed to disk and will not need to be replayed later.  This
 * seems unlikely to be a performance-critical issue, so we use a simple
 * method: we just take and release the RelationMappingLock.  This ensures
 * that any already-logged map update is complete, because write_relmap_file
 * will fsync the map file before the lock is released.
 */</comment>
<function><type><name>void</name></type>
<name>CheckPointRelationMap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>RelationMappingLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>RelationMappingLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationMapFinishBootstrap
 *
 * Write out the initial relation mapping files at the completion of
 * bootstrap.  All the mapped files should have been made known to us
 * via RelationMapUpdateMap calls.
 */</comment>
<function><type><name>void</name></type>
<name>RelationMapFinishBootstrap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Shouldn't be anything "pending" ... */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>active_shared_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>active_local_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pending_shared_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pending_local_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Write the files; no WAL or sinval needed */</comment>
    <expr_stmt><expr><call><name>write_relmap_file</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shared_map</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                      <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>GLOBALTABLESPACE_OID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>write_relmap_file</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>local_map</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                      <argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>MyDatabaseTableSpace</name></expr></argument>, <argument><expr><name>DatabasePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationMapInitialize
 *
 * This initializes the mapper module at process startup.  We can't access the
 * database yet, so just make sure the maps are empty.
 */</comment>
<function><type><name>void</name></type>
<name>RelationMapInitialize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* The static variables should initialize to zeroes, but let's be sure */</comment>
    <expr_stmt><expr><name><name>shared_map</name><operator>.</operator><name>magic</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>        <comment type="block">/* mark it not loaded */</comment>
    <expr_stmt><expr><name><name>local_map</name><operator>.</operator><name>magic</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>shared_map</name><operator>.</operator><name>num_mappings</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>local_map</name><operator>.</operator><name>num_mappings</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>active_shared_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>active_local_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pending_shared_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pending_local_updates</name><operator>.</operator><name>num_mappings</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationMapInitializePhase2
 *
 * This is called to prepare for access to pg_database during startup.
 * We should be able to read the shared map file now.
 */</comment>
<function><type><name>void</name></type>
<name>RelationMapInitializePhase2</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * In bootstrap mode, the map file isn't there yet, so do nothing.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Load the shared map file, die on error.
     */</comment>
    <expr_stmt><expr><call><name>load_relmap_file</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationMapInitializePhase3
 *
 * This is called as soon as we have determined MyDatabaseId and set up
 * DatabasePath.  At this point we should be able to read the local map file.
 */</comment>
<function><type><name>void</name></type>
<name>RelationMapInitializePhase3</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * In bootstrap mode, the map file isn't there yet, so do nothing.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Load the local map file, die on error.
     */</comment>
    <expr_stmt><expr><call><name>load_relmap_file</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * load_relmap_file -- load data from the shared or local map file
 *
 * Because the map file is essential for access to core system catalogs,
 * failure to read it is a fatal error.
 *
 * Note that the local case requires DatabasePath to be set up.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_relmap_file</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>shared</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RelMapFile</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>mapfilename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_crc32c</name></type>    <name>crc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>fd</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>shared</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>mapfilename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapfilename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"global/%s"</literal></expr></argument>,
                 <argument><expr><name>RELMAPPER_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>&amp;</operator><name>shared_map</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>mapfilename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapfilename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,
                 <argument><expr><name>DatabasePath</name></expr></argument>, <argument><expr><name>RELMAPPER_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>&amp;</operator><name>local_map</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Read data ... */</comment>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>mapfilename</name></expr></argument>,
                           <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open relation mapping file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>mapfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Note: we could take RelationMappingLock in shared mode here, but it
     * seems unnecessary since our read() should be atomic against any
     * concurrent updater's write().  If the file is updated shortly after we
     * look, the sinval signaling mechanism will make us re-read it before we
     * are able to access any relation that's affected by the change.
     */</comment>
    <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_RELATION_MAP_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelMapFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelMapFile</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read relation mapping file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>mapfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for correct magic number, etc */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>RELMAPPER_FILEMAGIC</name> <operator>||</operator>
        <name><name>map</name><operator>-&gt;</operator><name>num_mappings</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
        <name><name>map</name><operator>-&gt;</operator><name>num_mappings</name></name> <operator>&gt;</operator> <name>MAX_MAPPINGS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation mapping file \"%s\" contains invalid data"</literal></expr></argument>,
                        <argument><expr><name>mapfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* verify the CRC */</comment>
    <expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>map</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RelMapFile</name></expr></argument>, <argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EQ_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation mapping file \"%s\" contains incorrect checksum"</literal></expr></argument>,
                        <argument><expr><name>mapfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write out a new shared or local map file with the given contents.
 *
 * The magic number and CRC are automatically updated in *newmap.  On
 * success, we copy the data to the appropriate permanent static variable.
 *
 * If write_wal is TRUE then an appropriate WAL message is emitted.
 * (It will be false for bootstrap and WAL replay cases.)
 *
 * If send_sinval is TRUE then a SI invalidation message is sent.
 * (This should be true except in bootstrap case.)
 *
 * If preserve_files is TRUE then the storage manager is warned not to
 * delete the files listed in the map.
 *
 * Because this may be called during WAL replay when MyDatabaseId,
 * DatabasePath, etc aren't valid, we require the caller to pass in suitable
 * values.  The caller is also responsible for being sure no concurrent
 * map update could be happening.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_relmap_file</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>shared</name></decl></parameter>, <parameter><decl><type><name>RelMapFile</name> <modifier>*</modifier></type><name>newmap</name></decl></parameter>,
                  <parameter><decl><type><name>bool</name></type> <name>write_wal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>send_sinval</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>preserve_files</name></decl></parameter>,
                  <parameter><decl><type><name>Oid</name></type> <name>dbid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>tsid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbpath</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelMapFile</name> <modifier>*</modifier></type><name>realmap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>mapfilename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*
     * Fill in the overhead fields and update CRC.
     */</comment>
    <expr_stmt><expr><name><name>newmap</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>RELMAPPER_FILEMAGIC</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>newmap</name><operator>-&gt;</operator><name>num_mappings</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>newmap</name><operator>-&gt;</operator><name>num_mappings</name></name> <operator>&gt;</operator> <name>MAX_MAPPINGS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attempt to write bogus relation mapping"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name><name>newmap</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name><name>newmap</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newmap</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RelMapFile</name></expr></argument>, <argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name><name>newmap</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Open the target file.  We prefer to do this before entering the
     * critical section, so that an open() failure need not force PANIC.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>shared</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>mapfilename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapfilename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"global/%s"</literal></expr></argument>,
                 <argument><expr><name>RELMAPPER_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>realmap</name> <operator>=</operator> <operator>&amp;</operator><name>shared_map</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>mapfilename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapfilename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,
                 <argument><expr><name>dbpath</name></expr></argument>, <argument><expr><name>RELMAPPER_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>realmap</name> <operator>=</operator> <operator>&amp;</operator><name>local_map</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>mapfilename</name></expr></argument>,
                           <argument><expr><name>O_WRONLY</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>,
                           <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open relation mapping file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>mapfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>write_wal</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>xl_relmap_update</name></type> <name>xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>lsn</name></decl>;</decl_stmt>

        <comment type="block">/* now errors are fatal ... */</comment>
        <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>dbid</name></name> <operator>=</operator> <name>dbid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>tsid</name></name> <operator>=</operator> <name>tsid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nbytes</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelMapFile</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xlrec</name><operator>)</operator></expr></argument>, <argument><expr><name>MinSizeOfRelmapUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newmap</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelMapFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_RELMAP_ID</name></expr></argument>, <argument><expr><name>XLOG_RELMAP_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* As always, WAL must hit the disk before the data update does */</comment>
        <expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_RELATION_MAP_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>newmap</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelMapFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelMapFile</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to relation mapping file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>mapfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We choose to fsync the data to disk before considering the task done.
     * It would be possible to relax this if it turns out to be a performance
     * issue, but it would complicate checkpointing --- see notes for
     * CheckPointRelationMap.
     */</comment>
    <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_RELATION_MAP_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync relation mapping file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>mapfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close relation mapping file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>mapfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Now that the file is safely on disk, send sinval message to let other
     * backends know to re-read it.  We must do this inside the critical
     * section: if for some reason we fail to send the message, we have to
     * force a database-wide PANIC.  Otherwise other backends might continue
     * execution with stale mapping information, which would be catastrophic
     * as soon as others began to use the now-committed data.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>send_sinval</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>CacheInvalidateRelmap</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Make sure that the files listed in the map are not deleted if the outer
     * transaction aborts.  This had better be within the critical section
     * too: it's not likely to fail, but if it did, we'd arrive at transaction
     * abort with the files still vulnerable.  PANICing will leave things in a
     * good state on-disk.
     *
     * Note: we're cheating a little bit here by assuming that mapped files
     * are either in pg_global or the database's default tablespace.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>preserve_files</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int32</name></type>        <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>newmap</name><operator>-&gt;</operator><name>num_mappings</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <name>tsid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>=</operator> <name>dbid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <name><name>newmap</name><operator>-&gt;</operator><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mapfilenode</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RelationPreserveStorage</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Success, update permanent copy */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>realmap</name></expr></argument>, <argument><expr><name>newmap</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelMapFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Critical section done */</comment>
    <if_stmt><if>if <condition>(<expr><name>write_wal</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Merge the specified updates into the appropriate "real" map,
 * and write out the changes.  This function must be used for committing
 * updates during normal multiuser operation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>perform_relmap_update</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>shared</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RelMapFile</name> <modifier>*</modifier></type><name>updates</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RelMapFile</name></type>    <name>newmap</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Anyone updating a relation's mapping info should take exclusive lock on
     * that rel and hold it until commit.  This ensures that there will not be
     * concurrent updates on the same mapping value; but there could easily be
     * concurrent updates on different values in the same file. We cover that
     * by acquiring the RelationMappingLock, re-reading the target file to
     * ensure it's up to date, applying the updates, and writing the data
     * before releasing RelationMappingLock.
     *
     * There is only one RelationMappingLock.  In principle we could try to
     * have one per mapping file, but it seems unlikely to be worth the
     * trouble.
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>RelationMappingLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Be certain we see any other updates just made */</comment>
    <expr_stmt><expr><call><name>load_relmap_file</name><argument_list>(<argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Prepare updated data in a local variable */</comment>
    <if_stmt><if>if <condition>(<expr><name>shared</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shared_map</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelMapFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>local_map</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelMapFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Apply the updates to newmap.  No new mappings should appear, unless
     * somebody is adding indexes to system catalogs.
     */</comment>
    <expr_stmt><expr><call><name>merge_map_updates</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newmap</name></expr></argument>, <argument><expr><name>updates</name></expr></argument>, <argument><expr><name>allowSystemTableMods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Write out the updated map and do other necessary tasks */</comment>
    <expr_stmt><expr><call><name>write_relmap_file</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newmap</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                      <argument><expr><operator>(</operator><ternary><condition><expr><name>shared</name></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><name>MyDatabaseId</name></expr></else></ternary><operator>)</operator></expr></argument>,
                      <argument><expr><operator>(</operator><ternary><condition><expr><name>shared</name></expr> ?</condition><then> <expr><name>GLOBALTABLESPACE_OID</name></expr> </then><else>: <expr><name>MyDatabaseTableSpace</name></expr></else></ternary><operator>)</operator></expr></argument>,
                      <argument><expr><name>DatabasePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now we can release the lock */</comment>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>RelationMappingLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RELMAP resource manager's routines
 */</comment>
<function><type><name>void</name></type>
<name>relmap_redo</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint8</name></type>        <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Backup blocks are not used in relmap records */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecHasAnyBlockRefs</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_RELMAP_UPDATE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>xl_relmap_update</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_relmap_update</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RelMapFile</name></type>    <name>newmap</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>dbpath</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelMapFile</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"relmap_redo: wrong size %u in relmap update record"</literal></expr></argument>,
                 <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>nbytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newmap</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>newmap</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* We need to construct the pathname for this database */</comment>
        <expr_stmt><expr><name>dbpath</name> <operator>=</operator> <call><name>GetDatabasePath</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>dbid</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>tsid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Write out the new map and send sinval, but of course don't write a
         * new WAL entry.  There's no surrounding transaction to tell to
         * preserve files, either.
         *
         * There shouldn't be anyone else updating relmaps during WAL replay,
         * so we don't bother to take the RelationMappingLock.  We would need
         * to do so if load_relmap_file needed to interlock against writers.
         */</comment>
        <expr_stmt><expr><call><name>write_relmap_file</name><argument_list>(<argument><expr><operator>(</operator><name><name>xlrec</name><operator>-&gt;</operator><name>dbid</name></name> <operator>==</operator> <name>InvalidOid</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>newmap</name></expr></argument>,
                          <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                          <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>dbid</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>tsid</name></name></expr></argument>, <argument><expr><name>dbpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dbpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"relmap_redo: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
