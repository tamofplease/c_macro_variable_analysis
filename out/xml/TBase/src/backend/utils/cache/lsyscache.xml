<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/cache/lsyscache.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * lsyscache.c
 *      Convenience routines for common queries in the system catalog cache.
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *      src/backend/utils/cache/lsyscache.c
 *
 * NOTES
 *      Eventually, the index information should go through here, too.
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bootstrap/bootstrap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_transform.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_group.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_key_values.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Hook for plugins to get control in get_attavgwidth() */</comment>
<decl_stmt><decl><type><name>get_attavgwidth_hook_type</name></type> <name>get_attavgwidth_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*                ---------- AMOP CACHES ----------                         */</comment>

<comment type="block">/*
 * op_in_opfamily
 *
 *        Return t iff operator 'opno' is in operator family 'opfamily'.
 *
 * This function only considers search operators, not ordering operators.
 */</comment>
<function><type><name>bool</name></type>
<name>op_in_opfamily</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>SearchSysCacheExists3</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>,
                                 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>AMOP_SEARCH</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_op_opfamily_strategy
 *
 *        Get the operator's strategy number within the specified opfamily,
 *        or 0 if it's not a member of the opfamily.
 *
 * This function only considers search operators, not ordering operators.
 */</comment>
<function><type><name>int</name></type>
<name>get_op_opfamily_strategy</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>amop_tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>,
                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>AMOP_SEARCH</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>amop_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>amop_tup</name><operator>-&gt;</operator><name>amopstrategy</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_op_opfamily_sortfamily
 *
 *        If the operator is an ordering operator within the specified opfamily,
 *        return its amopsortfamily OID; else return InvalidOid.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_op_opfamily_sortfamily</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>amop_tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>,
                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>AMOP_ORDER</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>amop_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>amop_tup</name><operator>-&gt;</operator><name>amopsortfamily</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_op_opfamily_properties
 *
 *        Get the operator's strategy number and declared input data types
 *        within the specified opfamily.
 *
 * Caller should already have verified that opno is a member of opfamily,
 * therefore we raise an error if the tuple is not found.
 */</comment>
<function><type><name>void</name></type>
<name>get_op_opfamily_properties</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ordering_op</name></decl></parameter>,
                           <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>strategy</name></decl></parameter>,
                           <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>lefttype</name></decl></parameter>,
                           <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>righttype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>amop_tup</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>,
                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><ternary><condition><expr><name>ordering_op</name></expr> ?</condition><then> <expr><name>AMOP_ORDER</name></expr> </then><else>: <expr><name>AMOP_SEARCH</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"operator %u is not a member of opfamily %u"</literal></expr></argument>,
             <argument><expr><name>opno</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>amop_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <name><name>amop_tup</name><operator>-&gt;</operator><name>amopstrategy</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>lefttype</name> <operator>=</operator> <name><name>amop_tup</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>righttype</name> <operator>=</operator> <name><name>amop_tup</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_opfamily_member
 *        Get the OID of the operator that implements the specified strategy
 *        with the specified datatypes for the specified opfamily.
 *
 * Returns InvalidOid if there is no pg_amop entry for the given keys.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_opfamily_member</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>lefttype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>righttype</name></decl></parameter>,
                    <parameter><decl><type><name>int16</name></type> <name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>amop_tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache4</name><argument_list>(<argument><expr><name>AMOPSTRATEGY</name></expr></argument>,
                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>lefttype</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>righttype</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>amop_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>amop_tup</name><operator>-&gt;</operator><name>amopopr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_ordering_op_properties
 *        Given the OID of an ordering operator (a btree "&lt;" or "&gt;" operator),
 *        determine its opfamily, its declared input datatype, and its
 *        strategy number (BTLessStrategyNumber or BTGreaterStrategyNumber).
 *
 * Returns TRUE if successful, FALSE if no matching pg_amop entry exists.
 * (This indicates that the operator is not a valid ordering operator.)
 *
 * Note: the operator could be registered in multiple families, for example
 * if someone were to build a "reverse sort" opfamily.  This would result in
 * uncertainty as to whether "ORDER BY USING op" would default to NULLS FIRST
 * or NULLS LAST, as well as inefficient planning due to failure to match up
 * pathkeys that should be the same.  So we want a determinate result here.
 * Because of the way the syscache search works, we'll use the interpretation
 * associated with the opfamily with smallest OID, which is probably
 * determinate enough.  Since there is no longer any particularly good reason
 * to build reverse-sort opfamilies, it doesn't seem worth expending any
 * additional effort on ensuring consistency.
 */</comment>
<function><type><name>bool</name></type>
<name>get_ordering_op_properties</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>,
                           <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opfamily</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opcintype</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* ensure outputs are initialized on failure */</comment>
    <expr_stmt><expr><operator>*</operator><name>opfamily</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>opcintype</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Search pg_amop to see if the target operator is registered as the "&lt;"
     * or "&gt;" operator of any btree opfamily.
     */</comment>
    <expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>aform</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* must be btree */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>!=</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amopstrategy</name></name> <operator>==</operator> <name>BTLessStrategyNumber</name> <operator>||</operator>
            <name><name>aform</name><operator>-&gt;</operator><name>amopstrategy</name></name> <operator>==</operator> <name>BTGreaterStrategyNumber</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Found it ... should have consistent input types */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name> <operator>==</operator> <name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Found a suitable opfamily, return info */</comment>
                <expr_stmt><expr><operator>*</operator><name>opfamily</name> <operator>=</operator> <name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>opcintype</name> <operator>=</operator> <name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <name><name>aform</name><operator>-&gt;</operator><name>amopstrategy</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_equality_op_for_ordering_op
 *        Get the OID of the datatype-specific btree equality operator
 *        associated with an ordering operator (a "&lt;" or "&gt;" operator).
 *
 * If "reverse" isn't NULL, also set *reverse to FALSE if the operator is "&lt;",
 * TRUE if it's "&gt;"
 *
 * Returns InvalidOid if no matching equality operator can be found.
 * (This indicates that the operator is not a valid ordering operator.)
 */</comment>
<function><type><name>Oid</name></type>
<name>get_equality_op_for_ordering_op</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>reverse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>opfamily</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>opcintype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>        <name>strategy</name></decl>;</decl_stmt>

    <comment type="block">/* Find the operator in pg_amop */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>get_ordering_op_properties</name><argument_list>(<argument><expr><name>opno</name></expr></argument>,
                                   <argument><expr><operator>&amp;</operator><name>opfamily</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opcintype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Found a suitable opfamily, get matching equality operator */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
                                     <argument><expr><name>opcintype</name></expr></argument>,
                                     <argument><expr><name>opcintype</name></expr></argument>,
                                     <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>reverse</name> <operator>=</operator> <operator>(</operator><name>strategy</name> <operator>==</operator> <name>BTGreaterStrategyNumber</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_ordering_op_for_equality_op
 *        Get the OID of a datatype-specific btree ordering operator
 *        associated with an equality operator.  (If there are multiple
 *        possibilities, assume any one will do.)
 *
 * This function is used when we have to sort data before unique-ifying,
 * and don't much care which sorting op is used as long as it's compatible
 * with the intended equality operator.  Since we need a sorting operator,
 * it should be single-data-type even if the given operator is cross-type.
 * The caller specifies whether to find an op for the LHS or RHS data type.
 *
 * Returns InvalidOid if no matching ordering operator can be found.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_ordering_op_for_equality_op</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_lhs_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Search pg_amop to see if the target operator is registered as the "="
     * operator of any btree opfamily.
     */</comment>
    <expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>aform</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* must be btree */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>!=</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amopstrategy</name></name> <operator>==</operator> <name>BTEqualStrategyNumber</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Found a suitable opfamily, get matching ordering operator */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>typid</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>typid</name> <operator>=</operator> <ternary><condition><expr><name>use_lhs_type</name></expr> ?</condition><then> <expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr> </then><else>: <expr><name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>,
                                         <argument><expr><name>typid</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>,
                                         <argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <comment type="block">/* failure probably shouldn't happen, but keep looking if so */</comment>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_mergejoin_opfamilies
 *        Given a putatively mergejoinable operator, return a list of the OIDs
 *        of the btree opfamilies in which it represents equality.
 *
 * It is possible (though at present unusual) for an operator to be equality
 * in more than one opfamily, hence the result is a list.  This also lets us
 * return NIL if the operator is not found in any opfamilies.
 *
 * The planner currently uses simple equal() tests to compare the lists
 * returned by this function, which makes the list order relevant, though
 * strictly speaking it should not be.  Because of the way syscache list
 * searches are handled, in normal operation the result will be sorted by OID
 * so everything works fine.  If running with system index usage disabled,
 * the result ordering is unspecified and hence the planner might fail to
 * recognize optimization opportunities ... but that's hardly a scenario in
 * which performance is good anyway, so there's no point in expending code
 * or cycles here to guarantee the ordering in that case.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_mergejoin_opfamilies</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Search pg_amop to see if the target operator is registered as the "="
     * operator of any btree opfamily.
     */</comment>
    <expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>aform</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* must be btree equality */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>==</operator> <name>BTREE_AM_OID</name> <operator>&amp;&amp;</operator>
            <name><name>aform</name><operator>-&gt;</operator><name>amopstrategy</name></name> <operator>==</operator> <name>BTEqualStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_compatible_hash_operators
 *        Get the OID(s) of hash equality operator(s) compatible with the given
 *        operator, but operating on its LHS and/or RHS datatype.
 *
 * An operator for the LHS type is sought and returned into *lhs_opno if
 * lhs_opno isn't NULL.  Similarly, an operator for the RHS type is sought
 * and returned into *rhs_opno if rhs_opno isn't NULL.
 *
 * If the given operator is not cross-type, the results should be the same
 * operator, but in cross-type situations they will be different.
 *
 * Returns true if able to find the requested operator(s), false if not.
 * (This indicates that the operator should not have been marked oprcanhash.)
 */</comment>
<function><type><name>bool</name></type>
<name>get_compatible_hash_operators</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>,
                              <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>lhs_opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>rhs_opno</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Ensure output args are initialized on failure */</comment>
    <if_stmt><if>if <condition>(<expr><name>lhs_opno</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>lhs_opno</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>rhs_opno</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>rhs_opno</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Search pg_amop to see if the target operator is registered as the "="
     * operator of any hash opfamily.  If the operator is registered in
     * multiple opfamilies, assume we can use any one.
     */</comment>
    <expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>aform</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>==</operator> <name>HASH_AM_OID</name> <operator>&amp;&amp;</operator>
            <name><name>aform</name><operator>-&gt;</operator><name>amopstrategy</name></name> <operator>==</operator> <name>HTEqualStrategyNumber</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* No extra lookup needed if given operator is single-type */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name> <operator>==</operator> <name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>lhs_opno</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>lhs_opno</name> <operator>=</operator> <name>opno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>rhs_opno</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>rhs_opno</name> <operator>=</operator> <name>opno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Get the matching single-type operator(s).  Failure probably
             * shouldn't happen --- it implies a bogus opfamily --- but
             * continue looking if so.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>lhs_opno</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>lhs_opno</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>,
                                                <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr></argument>,
                                                <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr></argument>,
                                                <argument><expr><name>HTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>lhs_opno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <comment type="block">/* Matching LHS found, done if caller doesn't want RHS */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>rhs_opno</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>rhs_opno</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>rhs_opno</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>,
                                                <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr></argument>,
                                                <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr></argument>,
                                                <argument><expr><name>HTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>rhs_opno</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Forget any LHS operator from this opfamily */</comment>
                    <if_stmt><if>if <condition>(<expr><name>lhs_opno</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><operator>*</operator><name>lhs_opno</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* Matching RHS found, so done */</comment>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_op_hash_functions
 *		Get the OID(s) of the standard hash support function(s) compatible with
 *		the given operator, operating on its LHS and/or RHS datatype as required.
 *
 * A function for the LHS type is sought and returned into *lhs_procno if
 * lhs_procno isn't NULL.  Similarly, a function for the RHS type is sought
 * and returned into *rhs_procno if rhs_procno isn't NULL.
 *
 * If the given operator is not cross-type, the results should be the same
 * function, but in cross-type situations they will be different.
 *
 * Returns true if able to find the requested function(s), false if not.
 * (This indicates that the operator should not have been marked oprcanhash.)
 */</comment>
<function><type><name>bool</name></type>
<name>get_op_hash_functions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>,
                      <parameter><decl><type><name>RegProcedure</name> <modifier>*</modifier></type><name>lhs_procno</name></decl></parameter>, <parameter><decl><type><name>RegProcedure</name> <modifier>*</modifier></type><name>rhs_procno</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Ensure output args are initialized on failure */</comment>
    <if_stmt><if>if <condition>(<expr><name>lhs_procno</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>lhs_procno</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>rhs_procno</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>rhs_procno</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Search pg_amop to see if the target operator is registered as the "="
     * operator of any hash opfamily.  If the operator is registered in
     * multiple opfamilies, assume we can use any one.
     */</comment>
    <expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>aform</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>==</operator> <name>HASH_AM_OID</name> <operator>&amp;&amp;</operator>
            <name><name>aform</name><operator>-&gt;</operator><name>amopstrategy</name></name> <operator>==</operator> <name>HTEqualStrategyNumber</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Get the matching support function(s).  Failure probably
             * shouldn't happen --- it implies a bogus opfamily --- but
             * continue looking if so.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>lhs_procno</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>lhs_procno</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>,
                                                <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr></argument>,
                                                <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr></argument>,
												<argument><expr><name>HASHSTANDARD_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>lhs_procno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <comment type="block">/* Matching LHS found, done if caller doesn't want RHS */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>rhs_procno</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* Only one lookup needed if given operator is single-type */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name> <operator>==</operator> <name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>rhs_procno</name> <operator>=</operator> <operator>*</operator><name>lhs_procno</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>rhs_procno</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>rhs_procno</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>,
                                                <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr></argument>,
                                                <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr></argument>,
												<argument><expr><name>HASHSTANDARD_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>rhs_procno</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Forget any LHS function from this opfamily */</comment>
                    <if_stmt><if>if <condition>(<expr><name>lhs_procno</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><operator>*</operator><name>lhs_procno</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* Matching RHS found, so done */</comment>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_op_btree_interpretation
 *        Given an operator's OID, find out which btree opfamilies it belongs to,
 *        and what properties it has within each one.  The results are returned
 *        as a palloc'd list of OpBtreeInterpretation structs.
 *
 * In addition to the normal btree operators, we consider a &lt;&gt; operator to be
 * a "member" of an opfamily if its negator is an equality operator of the
 * opfamily.  ROWCOMPARE_NE is returned as the strategy number for this case.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_op_btree_interpretation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OpBtreeInterpretation</name> <modifier>*</modifier></type><name>thisresult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Find all the pg_amop entries containing the operator.
     */</comment>
    <expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>op_tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>op_form</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>op_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>op_strategy</name></decl>;</decl_stmt>

        <comment type="block">/* must be btree */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>op_form</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>!=</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Get the operator's btree strategy number */</comment>
        <expr_stmt><expr><name>op_strategy</name> <operator>=</operator> <operator>(</operator><name>StrategyNumber</name><operator>)</operator> <name><name>op_form</name><operator>-&gt;</operator><name>amopstrategy</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>op_strategy</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>op_strategy</name> <operator>&lt;=</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>thisresult</name> <operator>=</operator> <operator>(</operator><name>OpBtreeInterpretation</name> <operator>*</operator><operator>)</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OpBtreeInterpretation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thisresult</name><operator>-&gt;</operator><name>opfamily_id</name></name> <operator>=</operator> <name><name>op_form</name><operator>-&gt;</operator><name>amopfamily</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thisresult</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>op_strategy</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thisresult</name><operator>-&gt;</operator><name>oplefttype</name></name> <operator>=</operator> <name><name>op_form</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thisresult</name><operator>-&gt;</operator><name>oprighttype</name></name> <operator>=</operator> <name><name>op_form</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>thisresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we didn't find any btree opfamily containing the operator, perhaps
     * it is a &lt;&gt; operator.  See if it has a negator that is in an opfamily.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>op_negator</name> <init>= <expr><call><name>get_negator</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>op_negator</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>,
                                          <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>op_negator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>op_tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>op_form</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>op_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>op_strategy</name></decl>;</decl_stmt>

                <comment type="block">/* must be btree */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>op_form</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>!=</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <comment type="block">/* Get the operator's btree strategy number */</comment>
                <expr_stmt><expr><name>op_strategy</name> <operator>=</operator> <operator>(</operator><name>StrategyNumber</name><operator>)</operator> <name><name>op_form</name><operator>-&gt;</operator><name>amopstrategy</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>op_strategy</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>op_strategy</name> <operator>&lt;=</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Only consider negators that are = */</comment>
                <if_stmt><if>if <condition>(<expr><name>op_strategy</name> <operator>!=</operator> <name>BTEqualStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <comment type="block">/* OK, report it with "strategy" ROWCOMPARE_NE */</comment>
                <expr_stmt><expr><name>thisresult</name> <operator>=</operator> <operator>(</operator><name>OpBtreeInterpretation</name> <operator>*</operator><operator>)</operator>
                    <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OpBtreeInterpretation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>thisresult</name><operator>-&gt;</operator><name>opfamily_id</name></name> <operator>=</operator> <name><name>op_form</name><operator>-&gt;</operator><name>amopfamily</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>thisresult</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>ROWCOMPARE_NE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>thisresult</name><operator>-&gt;</operator><name>oplefttype</name></name> <operator>=</operator> <name><name>op_form</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>thisresult</name><operator>-&gt;</operator><name>oprighttype</name></name> <operator>=</operator> <name><name>op_form</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>thisresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * equality_ops_are_compatible
 *        Return TRUE if the two given equality operators have compatible
 *        semantics.
 *
 * This is trivially true if they are the same operator.  Otherwise,
 * we look to see if they can be found in the same btree or hash opfamily.
 * Either finding allows us to assume that they have compatible notions
 * of equality.  (The reason we need to do these pushups is that one might
 * be a cross-type operator; for instance int24eq vs int4eq.)
 */</comment>
<function><type><name>bool</name></type>
<name>equality_ops_are_compatible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno1</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opno2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Easy if they're the same operator */</comment>
    <if_stmt><if>if <condition>(<expr><name>opno1</name> <operator>==</operator> <name>opno2</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We search through all the pg_amop entries for opno1.
     */</comment>
    <expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>op_tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>op_form</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>op_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* must be btree or hash */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>op_form</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>==</operator> <name>BTREE_AM_OID</name> <operator>||</operator>
            <name><name>op_form</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>==</operator> <name>HASH_AM_OID</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>op_in_opfamily</name><argument_list>(<argument><expr><name>opno2</name></expr></argument>, <argument><expr><name><name>op_form</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*                ---------- AMPROC CACHES ----------                         */</comment>

<comment type="block">/*
 * get_opfamily_proc
 *        Get the OID of the specified support function
 *        for the specified opfamily and datatypes.
 *
 * Returns InvalidOid if there is no pg_amproc entry for the given keys.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_opfamily_proc</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>lefttype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>righttype</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>procnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_amproc</name></type> <name>amproc_tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RegProcedure</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache4</name><argument_list>(<argument><expr><name>AMPROCNUM</name></expr></argument>,
                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>lefttype</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>righttype</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>procnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>amproc_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_amproc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>amproc_tup</name><operator>-&gt;</operator><name>amproc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*                ---------- ATTRIBUTE CACHES ----------                     */</comment>

<comment type="block">/*
 * get_attname
 *        Given the relation id and the attribute number,
 *        return the "attname" field from the attribute relation.
 *
 * Note: returns a palloc'd copy of the string, or NULL if no such attribute.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_attname</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_relid_attribute_name
 *
 * Same as above routine get_attname(), except that error
 * is handled by elog() instead of returning NULL.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_relid_attribute_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator> <call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type> <name>parentId</name> <init>= <expr><call><name>get_interval_parent_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not get interval parent for relation %u"</literal></expr></argument>,
                        <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>relid</name> <operator>=</operator> <name>parentId</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>attname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute %d of relation %u"</literal></expr></argument>,
             <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>attname</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_attnum
 *
 *        Given the relation id and the attribute name,
 *        return the "attnum" field from the attribute relation.
 *
 *        Returns InvalidAttrNumber if the attr doesn't exist (or is dropped).
 */</comment>
<function><type><name>AttrNumber</name></type>
<name>get_attnum</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidAttrNumber</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_attidentity
 *
 *        Given the relation id and the attribute name,
 *        return the "attidentity" field from the attribute relation.
 *
 *        Returns '\0' if not found.
 *
 *        Since no identity is represented by '\0', this can also be used as a
 *        Boolean test.
 */</comment>
<function><type><name>char</name></type>
<name>get_attidentity</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>attidentity</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><literal type="char">'\0'</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_atttype
 *
 *        Given the relation OID and the attribute number with the relation,
 *        return the attribute type OID.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_atttype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_atttypmod
 *
 *        Given the relation id and the attribute number,
 *        return the "atttypmod" field from the attribute relation.
 */</comment>
<function><type><name>int32</name></type>
<name>get_atttypmod</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_atttypetypmodcoll
 *
 *        A three-fer: given the relation id and the attribute number,
 *        fetch atttypid, atttypmod, and attcollation in a single cache lookup.
 *
 * Unlike the otherwise-similar get_atttype/get_atttypmod, this routine
 * raises an error if it can't obtain the information.
 */</comment>
<function><type><name>void</name></type>
<name>get_atttypetypmodcoll</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>,
                      <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typid</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>typmod</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute %d of relation %u"</literal></expr></argument>,
             <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>att_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>typid</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>typmod</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>collid</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*                ---------- COLLATION CACHE ----------                     */</comment>

<comment type="block">/*
 * get_collation_name
 *        Returns the name of a given pg_collation entry.
 *
 * Returns a palloc'd copy of the string, or NULL if no such constraint.
 *
 * NOTE: since collation name is not unique, be wary of code that uses this
 * for anything except preparing error messages.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_collation_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>colloid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>colloid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>colltup</name> <init>= <expr><operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>colltup</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<comment type="block">/*
 * get_collation_namespace
 *        Returns the namespace id of a given pg_collation entry.
 *
 * Returns an Oid of the collation's namespace.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_collation_namespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>colloid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>colloid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>colltup</name> <init>= <expr><operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>         <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>colltup</name><operator>-&gt;</operator><name>collnamespace</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * get_collation_encoding
 *        Returns the encoding of a given pg_collation entry.
 *
 * Returns the collation's encoding, or -1 if entry does not exist.
 */</comment>
<function><type><name>int32</name></type>
<name>get_collation_encoding</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>colloid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>colloid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>colltup</name> <init>= <expr><operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>         <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>colltup</name><operator>-&gt;</operator><name>collencoding</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * get_collid
 *      Given a collation name, encoding and namespace OID, look up
 * the collation OID.
 *
 * Returns InvalidOid if there is no such collation
 */</comment>
<function><type><name>Oid</name></type>
<name>get_collid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>collname</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>collencoding</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collnsp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>GetSysCacheOid</name><argument_list>(<argument><expr><name>COLLNAMEENCNSP</name></expr></argument>,
                          <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>collname</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>collencoding</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>collnsp</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*                ---------- CONSTRAINT CACHE ----------                     */</comment>

<comment type="block">/*
 * get_constraint_name
 *        Returns the name of a given pg_constraint entry.
 *
 * Returns a palloc'd copy of the string, or NULL if no such constraint.
 *
 * NOTE: since constraint name is not unique, be wary of code that uses this
 * for anything except preparing error messages.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_constraint_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>conoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>conoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>contup</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>contup</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_constraint_name_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>conoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>conoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>contup</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>contup</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>relid</name> <operator>=</operator> <name><name>contup</name><operator>-&gt;</operator><name>conrelid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not get constraint name and relid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*                ---------- LANGUAGE CACHE ----------                     */</comment>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_language_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>langoid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>LANGOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>langoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_language</name></type> <name>lantup</name> <init>= <expr><operator>(</operator><name>Form_pg_language</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>lantup</name><operator>-&gt;</operator><name>lanname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for language %u"</literal></expr></argument>,
             <argument><expr><name>langoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*                ---------- OPCLASS CACHE ----------                         */</comment>

<comment type="block">/*
 * get_opclass_family
 *
 *        Returns the OID of the operator family the opclass belongs to.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_opclass_family</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opclass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>cla_tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cla_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>cla_tup</name><operator>-&gt;</operator><name>opcfamily</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_opclass_input_type
 *
 *        Returns the OID of the datatype the opclass indexes.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_opclass_input_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opclass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>cla_tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cla_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>cla_tup</name><operator>-&gt;</operator><name>opcintype</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*                ---------- OPERATOR CACHE ----------                     */</comment>

<comment type="block">/*
 * get_opcode
 *
 *        Returns the regproc id of the routine used to implement an
 *        operator given the operator oid.
 */</comment>
<function><type><name>RegProcedure</name></type>
<name>get_opcode</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RegProcedure</name></type> <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprcode</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><operator>(</operator><name>RegProcedure</name><operator>)</operator> <name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_opname
 *      returns the name of the operator with the given opno
 *
 * Note: returns a palloc'd copy of the string, or NULL if no such operator.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_opname</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>optup</name><operator>-&gt;</operator><name>oprname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_op_rettype
 *        Given operator oid, return the operator's result type.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_op_rettype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprresult</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * op_input_types
 *
 *        Returns the left and right input datatypes for an operator
 *        (InvalidOid if not relevant).
 */</comment>
<function><type><name>void</name></type>
<name>op_input_types</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>lefttype</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>righttype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* shouldn't happen */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>optup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>lefttype</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprleft</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>righttype</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprright</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * op_mergejoinable
 *
 * Returns true if the operator is potentially mergejoinable.  (The planner
 * will fail to find any mergejoin plans unless there are suitable btree
 * opfamily entries for this operator and associated sortops.  The pg_operator
 * flag is just a hint to tell the planner whether to bother looking.)
 *
 * In some cases (currently only array_eq and record_eq), mergejoinability
 * depends on the specific input data type the operator is invoked for, so
 * that must be passed as well. We currently assume that only one input's type
 * is needed to check this --- by convention, pass the left input's data type.
 */</comment>
<function><type><name>bool</name></type>
<name>op_mergejoinable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

    <comment type="block">/*
     * For array_eq or record_eq, we can sort if the element or field types
     * are all sortable.  We could implement all the checks for that here, but
     * the typcache already does that and caches the results too, so let's
     * rely on the typcache.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>opno</name> <operator>==</operator> <name>ARRAY_EQ_OP</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>inputtype</name></expr></argument>, <argument><expr><name>TYPECACHE_CMP_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc</name></name> <operator>==</operator> <name>F_BTARRAYCMP</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>opno</name> <operator>==</operator> <name>RECORD_EQ_OP</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>inputtype</name></expr></argument>, <argument><expr><name>TYPECACHE_CMP_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc</name></name> <operator>==</operator> <name>F_BTRECORDCMP</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* For all other operators, rely on pg_operator.oprcanmerge */</comment>
        <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprcanmerge</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * op_hashjoinable
 *
 * Returns true if the operator is hashjoinable.  (There must be a suitable
 * hash opfamily entry for this operator if it is so marked.)
 *
 * In some cases (currently only array_eq), hashjoinability depends on the
 * specific input data type the operator is invoked for, so that must be
 * passed as well.  We currently assume that only one input's type is needed
 * to check this --- by convention, pass the left input's data type.
 */</comment>
<function><type><name>bool</name></type>
<name>op_hashjoinable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

    <comment type="block">/* As in op_mergejoinable, let the typcache handle the hard cases */</comment>
    <comment type="block">/* Eventually we'll need a similar case for record_eq ... */</comment>
    <if_stmt><if>if <condition>(<expr><name>opno</name> <operator>==</operator> <name>ARRAY_EQ_OP</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>inputtype</name></expr></argument>, <argument><expr><name>TYPECACHE_HASH_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_proc</name></name> <operator>==</operator> <name>F_HASH_ARRAY</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* For all other operators, rely on pg_operator.oprcanhash */</comment>
        <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprcanhash</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * op_strict
 *
 * Get the proisstrict flag for the operator's underlying function.
 */</comment>
<function><type><name>bool</name></type>
<name>op_strict</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RegProcedure</name></type> <name>funcid</name> <init>= <expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>funcid</name> <operator>==</operator> <operator>(</operator><name>RegProcedure</name><operator>)</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"operator %u does not exist"</literal></expr></argument>, <argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><call><name>func_strict</name><argument_list>(<argument><expr><operator>(</operator><name>Oid</name><operator>)</operator> <name>funcid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * op_volatile
 *
 * Get the provolatile flag for the operator's underlying function.
 */</comment>
<function><type><name>char</name></type>
<name>op_volatile</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RegProcedure</name></type> <name>funcid</name> <init>= <expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>funcid</name> <operator>==</operator> <operator>(</operator><name>RegProcedure</name><operator>)</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"operator %u does not exist"</literal></expr></argument>, <argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><call><name>func_volatile</name><argument_list>(<argument><expr><operator>(</operator><name>Oid</name><operator>)</operator> <name>funcid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_commutator
 *
 *        Returns the corresponding commutator of an operator.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_commutator</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprcom</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_negator
 *
 *        Returns the corresponding negator of an operator.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_negator</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprnegate</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_oprrest
 *
 *        Returns procedure id for computing selectivity of an operator.
 */</comment>
<function><type><name>RegProcedure</name></type>
<name>get_oprrest</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RegProcedure</name></type> <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprrest</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><operator>(</operator><name>RegProcedure</name><operator>)</operator> <name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_oprjoin
 *
 *        Returns procedure id for computing selectivity of a join.
 */</comment>
<function><type><name>RegProcedure</name></type>
<name>get_oprjoin</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RegProcedure</name></type> <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprjoin</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><operator>(</operator><name>RegProcedure</name><operator>)</operator> <name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*                ---------- FUNCTION CACHE ----------                     */</comment>

<comment type="block">/*
 * get_func_name
 *      returns the name of the function with the given funcid
 *
 * Note: returns a palloc'd copy of the string, or NULL if no such function.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_func_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>functup</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>functup</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_namespace
 *
 *        Returns the pg_namespace OID associated with a given function.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_func_namespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>functup</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>functup</name><operator>-&gt;</operator><name>pronamespace</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_rettype
 *        Given procedure id, return the function's result type.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_func_rettype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>prorettype</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_nargs
 *        Given procedure id, return the number of arguments.
 */</comment>
<function><type><name>int</name></type>
<name>get_func_nargs</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>pronargs</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_signature
 *        Given procedure id, return the function's argument and result types.
 *        (The return value is the result type.)
 *
 * The arguments are returned as a palloc'd array.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_func_signature</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>argtypes</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procstruct</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>procstruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>procstruct</name><operator>-&gt;</operator><name>prorettype</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>nargs</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>procstruct</name><operator>-&gt;</operator><name>pronargs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>nargs</name> <operator>==</operator> <name><name>procstruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>dim1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>argtypes</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>*</operator><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>argtypes</name></expr></argument>, <argument><expr><name><name>procstruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><operator>*</operator><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_variadictype
 *        Given procedure id, return the function's provariadic field.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_func_variadictype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>provariadic</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_retset
 *        Given procedure id, return the function's proretset flag.
 */</comment>
<function><type><name>bool</name></type>
<name>get_func_retset</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>proretset</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * func_strict
 *        Given procedure id, return the function's proisstrict flag.
 */</comment>
<function><type><name>bool</name></type>
<name>func_strict</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>proisstrict</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * func_volatile
 *        Given procedure id, return the function's provolatile flag.
 */</comment>
<function><type><name>char</name></type>
<name>func_volatile</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>provolatile</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * func_parallel
 *        Given procedure id, return the function's proparallel flag.
 */</comment>
<function><type><name>char</name></type>
<name>func_parallel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>proparallel</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_leakproof
 *       Given procedure id, return the function's leakproof field.
 */</comment>
<function><type><name>bool</name></type>
<name>get_func_leakproof</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>proleakproof</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_cost
 *        Given procedure id, return the function's procost field.
 */</comment>
<function><type><name>float4</name></type>
<name>get_func_cost</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float4</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>procost</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_rows
 *        Given procedure id, return the function's prorows field.
 */</comment>
<function><type><name>float4</name></type>
<name>get_func_rows</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float4</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>prorows</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*                ---------- RELATION CACHE ----------                     */</comment>

<comment type="block">/*
 * get_relname_relid
 *        Given name and namespace of a relation, look up the OID.
 *
 * Returns InvalidOid if there is no such relation.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_relname_relid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relnamespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>RELNAMENSP</name></expr></argument>,
                           <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/*
 * get_relnatts
 *
 *        Returns the number of attributes for a given relation.
 */</comment>
<function><type><name>int</name></type>
<name>get_relnatts</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>relnatts</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidAttrNumber</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * get_rel_name
 *        Returns the name of a given relation.
 *
 * Returns a palloc'd copy of the string, or NULL if no such relation.
 *
 * NOTE: since relation name is not unique, be wary of code that uses this
 * for anything except preparing error messages.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_rel_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>reltup</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_rel_namespace
 *
 *        Returns the pg_namespace OID associated with a given relation.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_rel_namespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>relnamespace</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_rel_type_id
 *
 *        Returns the pg_type OID associated with a given relation.
 *
 * Note: not all pg_class entries have associated pg_type OIDs; so be
 * careful to check for InvalidOid result.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_rel_type_id</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>reltype</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_rel_relkind
 *
 *        Returns the relkind associated with a given relation.
 */</comment>
<function><type><name>char</name></type>
<name>get_rel_relkind</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><literal type="char">'\0'</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_rel_relispartition
 *
 *		Returns the relispartition flag associated with a given relation.
 */</comment>
<function><type><name>bool</name></type>
<name>get_rel_relispartition</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>relispartition</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_rel_tablespace
 *
 *        Returns the pg_tablespace OID associated with a given relation.
 *
 * Note: InvalidOid might mean either that we couldn't find the relation,
 * or that it is in the database's default tablespace.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_rel_tablespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_rel_persistence
 *
 *        Returns the relpersistence associated with a given relation.
 */</comment>
<function><type><name>char</name></type>
<name>get_rel_persistence</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>reltup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*                ---------- TRANSFORM CACHE ----------                         */</comment>

<function><type><name>Oid</name></type>
<name>get_transform_fromsql</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>langid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>trftypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>trftypes</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>TRFTYPELANG</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>, <argument><expr><name>langid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>funcid</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>funcid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_transform</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>trffromsql</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>funcid</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>get_transform_tosql</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>langid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>trftypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>trftypes</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>TRFTYPELANG</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>, <argument><expr><name>langid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>funcid</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>funcid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_transform</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>trftosql</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>funcid</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*                ---------- TYPE CACHE ----------                         */</comment>

<comment type="block">/*
 * get_typisdefined
 *
 *        Given the type OID, determine whether the type is defined
 *        (if not, it's only a shell).
 */</comment>
<function><type><name>bool</name></type>
<name>get_typisdefined</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typisdefined</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_typlen
 *
 *        Given the type OID, return the length of the type.
 */</comment>
<function><type><name>int16</name></type>
<name>get_typlen</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int16</name></type>        <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_typbyval
 *
 *        Given the type OID, determine whether the type is returned by value or
 *        not.  Returns true if by value, false if by reference.
 */</comment>
<function><type><name>bool</name></type>
<name>get_typbyval</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_typlenbyval
 *
 *        A two-fer: given the type OID, return both typlen and typbyval.
 *
 *        Since both pieces of info are needed to know how to copy a Datum,
 *        many places need both.  Might as well get them with one cache lookup
 *        instead of two.  Also, this routine raises an error instead of
 *        returning a bogus value when given a bad type OID.
 */</comment>
<function><type><name>void</name></type>
<name>get_typlenbyval</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>typbyval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>typtup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>typlen</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>typbyval</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_typlenbyvalalign
 *
 *        A three-fer: given the type OID, return typlen, typbyval, typalign.
 */</comment>
<function><type><name>void</name></type>
<name>get_typlenbyvalalign</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>typbyval</name></decl></parameter>,
                     <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>typalign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>typtup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>typlen</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>typbyval</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>typalign</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getTypeIOParam
 *        Given a pg_type row, select the type OID to pass to I/O functions
 *
 * Formerly, all I/O functions were passed pg_type.typelem as their second
 * parameter, but we now have a more complex rule about what to pass.
 * This knowledge is intended to be centralized here --- direct references
 * to typelem elsewhere in the code are wrong, if they are associated with
 * I/O calls and not with actual subscripting operations!  (But see
 * bootstrap.c's boot_get_type_io_data() if you need to change this.)
 *
 * As of PostgreSQL 8.1, output functions receive only the value itself
 * and not any auxiliary parameters, so the name of this routine is now
 * a bit of a misnomer ... it should be getTypeInputParam.
 */</comment>
<function><type><name>Oid</name></type>
<name>getTypeIOParam</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>typeTuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeStruct</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Array types get their typelem as parameter; everybody else gets their
     * own type OID as parameter.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typelem</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typelem</name></name></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_type_io_data
 *
 *        A six-fer:    given the type OID, return typlen, typbyval, typalign,
 *                    typdelim, typioparam, and IO function OID. The IO function
 *                    returned is controlled by IOFuncSelector
 */</comment>
<function><type><name>void</name></type>
<name>get_type_io_data</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>,
                 <parameter><decl><type><name>IOFuncSelector</name></type> <name>which_func</name></decl></parameter>,
                 <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>typlen</name></decl></parameter>,
                 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>typbyval</name></decl></parameter>,
                 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>typalign</name></decl></parameter>,
                 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>typdelim</name></decl></parameter>,
                 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typioparam</name></decl></parameter>,
                 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>typeTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeStruct</name></decl>;</decl_stmt>

    <comment type="block">/*
     * In bootstrap mode, pass it off to bootstrap.c.  This hack allows us to
     * use array_in and array_out during bootstrap.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>typinput</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>typoutput</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>boot_get_type_io_data</name><argument_list>(<argument><expr><name>typid</name></expr></argument>,
                              <argument><expr><name>typlen</name></expr></argument>,
                              <argument><expr><name>typbyval</name></expr></argument>,
                              <argument><expr><name>typalign</name></expr></argument>,
                              <argument><expr><name>typdelim</name></expr></argument>,
                              <argument><expr><name>typioparam</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>typinput</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>which_func</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>IOFunc_input</name></expr>:</case>
                <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>typinput</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>IOFunc_output</name></expr>:</case>
                <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>typoutput</name></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"binary I/O not supported during bootstrap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>typeStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>typlen</name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>typbyval</name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>typalign</name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>typdelim</name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typdelim</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>typioparam</name> <operator>=</operator> <call><name>getTypeIOParam</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>which_func</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>IOFunc_input</name></expr>:</case>
            <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typinput</name></name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>IOFunc_output</name></expr>:</case>
            <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typoutput</name></name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>IOFunc_receive</name></expr>:</case>
            <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typreceive</name></name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>IOFunc_send</name></expr>:</case>
            <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typsend</name></name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
<function><type><name>char</name></type>
<name>get_typalign</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><literal type="char">'i'</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>char</name></type>
<name>get_typstorage</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typstorage</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><literal type="char">'p'</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_typdefault
 *      Given a type OID, return the type's default value, if any.
 *
 *      The result is a palloc'd expression node tree, or NULL if there
 *      is no defined default for the datatype.
 *
 * NB: caller should be prepared to coerce result to correct datatype;
 * the returned expression tree might produce something of the wrong type.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>get_typdefault</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>typeTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isNull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * typdefault and typdefaultbin are potentially null, so don't try to
     * access 'em as struct fields. Must do it the hard way with
     * SysCacheGetAttr.
     */</comment>
    <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>,
                            <argument><expr><name>typeTuple</name></expr></argument>,
                            <argument><expr><name>Anum_pg_type_typdefaultbin</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We have an expression default */</comment>
        <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Perhaps we have a plain literal default */</comment>
        <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>,
                                <argument><expr><name>typeTuple</name></expr></argument>,
                                <argument><expr><name>Anum_pg_type_typdefault</name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>strDefaultVal</name></decl>;</decl_stmt>

            <comment type="block">/* Convert text datum to C string */</comment>
            <expr_stmt><expr><name>strDefaultVal</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Convert C string to a value of the given type */</comment>
            <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name><name>type</name><operator>-&gt;</operator><name>typinput</name></name></expr></argument>, <argument><expr><name>strDefaultVal</name></expr></argument>,
                                         <argument><expr><call><name>getTypeIOParam</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Build a Const node containing the value */</comment>
            <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>typid</name></expr></argument>,
                                      <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                      <argument><expr><name><name>type</name><operator>-&gt;</operator><name>typcollation</name></name></expr></argument>,
                                      <argument><expr><name><name>type</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
                                      <argument><expr><name>datum</name></expr></argument>,
                                      <argument><expr><name>false</name></expr></argument>,
                                      <argument><expr><name><name>type</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>strDefaultVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* No default */</comment>
            <expr_stmt><expr><name>expr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getBaseType
 *        If the given type is a domain, return its base type;
 *        otherwise return the type's own OID.
 */</comment>
<function><type><name>Oid</name></type>
<name>getBaseType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>typmod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getBaseTypeAndTypmod
 *        If the given type is a domain, return its base type and typmod;
 *        otherwise return the type's own OID, and leave *typmod unchanged.
 *
 * Note that the "applied typmod" should be -1 for every domain level
 * above the bottommost; therefore, if the passed-in typid is indeed
 * a domain, *typmod should be -1.
 */</comment>
<function><type><name>Oid</name></type>
<name>getBaseTypeAndTypmod</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * We loop to find the bottom base type in a stack of domains.
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typTup</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>typTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>typTup</name><operator>-&gt;</operator><name>typtype</name></name> <operator>!=</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Not a domain, so done */</comment>
            <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>typmod</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>typid</name> <operator>=</operator> <name><name>typTup</name><operator>-&gt;</operator><name>typbasetype</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>typmod</name> <operator>=</operator> <name><name>typTup</name><operator>-&gt;</operator><name>typtypmod</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>typid</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/*
 * get_typename
 *        Get type name for given type ID
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_typename</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>        <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_type</name></type>    <name>typeForm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>           <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>typeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>typeForm</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type> <name>get_typenamespace_typename</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
	<return>return <expr><call><name>TypidGetTypename</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_pgxc_nodeoid
 *        Obtain PGXC Node Oid for given node name
 *        Return Invalid Oid if object does not exist
 */</comment>
<function><type><name>Oid</name></type>
<name>get_pgxc_nodeoid_extend</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>clustername</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>PGXCNODENAME</name></expr></argument>,
                           <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>clustername</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_pgxc_nodename
 *        Get node name for given Oid
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_pgxc_nodename</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nodeid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>        <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_node</name></type>    <name>nodeForm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>           <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PGXCNODEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for node %u"</literal></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>nodeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_node</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

 <comment type="block">/*
 * get_pgxc_node_id
 *        Get node identifier for a given Oid
 */</comment>
<function><type><name>uint32</name></type>
<name>get_pgxc_node_id</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nodeid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_node</name></type>    <name>nodeForm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>nodeid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PGXCNODEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for node %u"</literal></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>nodeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_node</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>nodeForm</name><operator>-&gt;</operator><name>node_id</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_pgxc_nodetype
 *        Get node type for given Oid
 */</comment>
<function><type><name>char</name></type>
<name>get_pgxc_nodetype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nodeid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>        <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_node</name></type>    <name>nodeForm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>            <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PGXCNODEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for node %u"</literal></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>nodeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_node</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>nodeForm</name><operator>-&gt;</operator><name>node_type</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_pgxc_nodeport
 *        Get node port for given Oid
 */</comment>
<function><type><name>int</name></type>
<name>get_pgxc_nodeport</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nodeid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>        <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_node</name></type>    <name>nodeForm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PGXCNODEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for node %u"</literal></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>nodeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_node</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>nodeForm</name><operator>-&gt;</operator><name>node_port</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_pgxc_nodehost
 *        Get node host for given Oid
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_pgxc_nodehost</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nodeid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>        <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_node</name></type>    <name>nodeForm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>           <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PGXCNODEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for node %u"</literal></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>nodeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_node</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_host</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_pgxc_nodepreferred
 *        Determine if node is a preferred one
 */</comment>
<function><type><name>bool</name></type>
<name>is_pgxc_nodepreferred</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nodeid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>        <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_node</name></type>    <name>nodeForm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PGXCNODEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for node %u"</literal></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>nodeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_node</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>nodeForm</name><operator>-&gt;</operator><name>nodeis_preferred</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_pgxc_nodeprimary
 *        Determine if node is a primary one
 */</comment>
<function><type><name>bool</name></type>
<name>is_pgxc_nodeprimary</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nodeid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>        <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_node</name></type>    <name>nodeForm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PGXCNODEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for node %u"</literal></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>nodeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_node</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>nodeForm</name><operator>-&gt;</operator><name>nodeis_primary</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * get_pgxc_nodename
 *		Get node name for given identifier
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_pgxc_nodename_from_identifier</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pgxc_node</name></type>	<name>nodeForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>           <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PGXCNODEIDENTIFIER</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for identifier %d"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<expr_stmt><expr><name>nodeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_node</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * get_pgxc_groupoid
 *        Obtain PGXC Group Oid for given group name
 *        Return Invalid Oid if group does not exist
 */</comment>
<function><type><name>Oid</name></type>
<name>get_pgxc_groupoid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>groupname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>GetSysCacheOid1</name><argument_list>(<argument><expr><name>PGXCGROUPNAME</name></expr></argument>,
                           <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>groupname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_pgxc_groupmembers
 *        Obtain PGXC Group members for given group Oid
 *        Return number of members and their list
 *
 * Member list is returned as a palloc'd array
 */</comment>
<function><type><name>int</name></type>
<name>get_pgxc_groupmembers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupid</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>members</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>        <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_group</name></type>        <name>groupForm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nmembers</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PGXCGROUPOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>groupid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for group %u"</literal></expr></argument>, <argument><expr><name>groupid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>groupForm</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_group</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nmembers</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>groupForm</name><operator>-&gt;</operator><name>group_members</name><operator>.</operator><name>dim1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>members</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nmembers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>members</name></expr></argument>, <argument><expr><name><name>groupForm</name><operator>-&gt;</operator><name>group_members</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name>nmembers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>nmembers</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_pgxc_groupname</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>       <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_group</name></type>     <name>groupForm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PGXCGROUPOID</name></expr></argument>,
            <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>groupid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for group %u"</literal></expr></argument>, <argument><expr><name>groupid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>groupForm</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_group</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>groupForm</name><operator>-&gt;</operator><name>group_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * get_pgxc_classnodes
 *        Obtain PGXC class Datanode list for given relation Oid
 *        Return number of Datanodes and their list
 *
 * Node list is returned as a palloc'd array
 */</comment>
<function><type><name>int</name></type>
<name>get_pgxc_classnodes</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableid</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodes</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTuple</name></type>        <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_class</name></type>        <name>classForm</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>                <name>hasKeyValue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                 <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                 <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                 <name>keyvalueHotGroupNum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                 <name>keyvalueColdGroupNum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>                 <modifier>*</modifier></type><name>keyvalueHotGroup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>                 <modifier>*</modifier></type><name>keyvalueColdGroup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>                <name>coldgroup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>                <name>coldgroupisempty</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type>            <name>numnodes</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PGXCCLASSRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tableid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>tableid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <expr_stmt><expr><name>classForm</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>nodes</name>      <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAX_GROUP_NODE_NUMBER</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name>      <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>hasKeyValue</name> <operator>=</operator> <call><name>GatherRelationKeyValueGroup</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>pcrelid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keyvalueHotGroupNum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keyvalueHotGroup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keyvalueColdGroupNum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keyvalueColdGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>hasKeyValue</name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>keyvalueHotGroupNum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name>    <modifier>*</modifier></type><name>members</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int32</name></type>  <name>memnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>memnum</name> <operator>=</operator> <call><name>get_pgxc_groupmembers</name><argument_list>(<argument><expr><name><name>keyvalueHotGroup</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>*</operator><name>nodes</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>members</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>memnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>memnum</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            
            <if_stmt><if>if <condition>(<expr><name>keyvalueHotGroup</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>keyvalueHotGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>keyvalueColdGroupNum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name>    <modifier>*</modifier></type><name>members</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int32</name></type>  <name>memnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>memnum</name> <operator>=</operator> <call><name>get_pgxc_groupmembers</name><argument_list>(<argument><expr><name><name>keyvalueColdGroup</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>     
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>*</operator><name>nodes</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>members</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>memnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>memnum</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            
            <if_stmt><if>if <condition>(<expr><name>keyvalueColdGroup</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>keyvalueColdGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>


    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>*</operator><name>nodes</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>classForm</name><operator>-&gt;</operator><name>nodeoids</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>nodeoids</name><operator>.</operator><name>dim1</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name><name>classForm</name><operator>-&gt;</operator><name>nodeoids</name><operator>.</operator><name>dim1</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>coldgroup</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PGXCCLASSRELID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pgxc_class_cold_nodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>coldgroupisempty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><operator>!</operator><name>coldgroupisempty</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>oidvector</name> <modifier>*</modifier></type> <name>coldgroup_array</name>  <init>= <expr><operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>coldgroup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>*</operator><name>nodes</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>coldgroup_array</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>coldgroup_array</name><operator>-&gt;</operator><name>dim1</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name><name>coldgroup_array</name><operator>-&gt;</operator><name>dim1</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>offset</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>classForm</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>numnodes</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>classForm</name><operator>-&gt;</operator><name>nodeoids</name><operator>.</operator><name>dim1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>nodes</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numnodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>nodes</name></expr></argument>, <argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>nodeoids</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name>numnodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>numnodes</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * get_typavgwidth
 *
 *      Given a type OID and a typmod value (pass -1 if typmod is unknown),
 *      estimate the average width of values of the type.  This is used by
 *      the planner, which doesn't require absolutely correct results;
 *      it's OK (and expected) to guess if we don't know for sure.
 */</comment>
<function><type><name>int32</name></type>
<name>get_typavgwidth</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>typlen</name> <init>= <expr><call><name>get_typlen</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>maxwidth</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Easy if it's a fixed-width type
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>typlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>typlen</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * type_maximum_size knows the encoding of typmod for some datatypes;
     * don't duplicate that knowledge here.
     */</comment>
    <expr_stmt><expr><name>maxwidth</name> <operator>=</operator> <call><name>type_maximum_size</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>maxwidth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * For BPCHAR, the max width is also the only width.  Otherwise we
         * need to guess about the typical data width given the max. A sliding
         * scale for percentage of max width seems reasonable.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>typid</name> <operator>==</operator> <name>BPCHAROID</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>maxwidth</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>maxwidth</name> <operator>&lt;=</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>maxwidth</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* assume full width */</comment>
        <if_stmt><if>if <condition>(<expr><name>maxwidth</name> <operator>&lt;</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">32</literal> <operator>+</operator> <operator>(</operator><name>maxwidth</name> <operator>-</operator> <literal type="number">32</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* assume 50% */</comment>

        <comment type="block">/*
         * Beyond 1000, assume we're looking at something like
         * "varchar(10000)" where the limit isn't actually reached often, and
         * use a fixed estimate.
         */</comment>
        <return>return <expr><literal type="number">32</literal> <operator>+</operator> <operator>(</operator><literal type="number">1000</literal> <operator>-</operator> <literal type="number">32</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Oops, we have no idea ... wild guess time.
     */</comment>
    <return>return <expr><literal type="number">32</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_typtype
 *
 *        Given the type OID, find if it is a basic type, a complex type, etc.
 *        It returns the null char if the cache lookup fails...
 */</comment>
<function><type><name>char</name></type>
<name>get_typtype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typtype</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><literal type="char">'\0'</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * type_is_rowtype
 *
 *        Convenience function to determine whether a type OID represents
 *        a "rowtype" type --- either RECORD or a named composite type.
 */</comment>
<function><type><name>bool</name></type>
<name>type_is_rowtype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name>typid</name> <operator>==</operator> <name>RECORDOID</name> <operator>||</operator> <call><name>get_typtype</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * type_is_enum
 *      Returns true if the given type is an enum type.
 */</comment>
<function><type><name>bool</name></type>
<name>type_is_enum</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>get_typtype</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_ENUM</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * type_is_range
 *      Returns true if the given type is a range type.
 */</comment>
<function><type><name>bool</name></type>
<name>type_is_range</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>get_typtype</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_RANGE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_type_category_preferred
 *
 *        Given the type OID, fetch its category and preferred-type status.
 *        Throws error on failure.
 */</comment>
<function><type><name>void</name></type>
<name>get_type_category_preferred</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>typcategory</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>typispreferred</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>typtup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>typcategory</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typcategory</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>typispreferred</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typispreferred</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_typ_typrelid
 *
 *        Given the type OID, get the typrelid (InvalidOid if not a complex
 *        type).
 */</comment>
<function><type><name>Oid</name></type>
<name>get_typ_typrelid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typrelid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_element_type
 *
 *        Given the type OID, get the typelem (InvalidOid if not an array type).
 *
 * NB: this only considers varlena arrays to be true arrays; InvalidOid is
 * returned if the input is a fixed-length array type.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_element_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>typtup</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typelem</name></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_array_type
 *
 *        Given the type OID, get the corresponding "true" array type.
 *        Returns InvalidOid if no array type can be found.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_array_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>typarray</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_promoted_array_type
 *
 *        The "promoted" type is what you'd get from an ARRAY(SELECT ...)
 *        construct, that is, either the corresponding "true" array type
 *        if the input is a scalar type that has such an array type,
 *        or the same type if the input is already a "true" array type.
 *        Returns InvalidOid if neither rule is satisfied.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_promoted_array_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>array_type</name> <init>= <expr><call><name>get_array_type</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>array_type</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_element_type</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>typid</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_base_element_type
 *        Given the type OID, get the typelem, looking "through" any domain
 *        to its underlying array type.
 *
 * This is equivalent to get_element_type(getBaseType(typid)), but avoids
 * an extra cache lookup.  Note that it fails to provide any information
 * about the typmod of the array.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_base_element_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * We loop to find the bottom base type in a stack of domains.
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typTup</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>typTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>typTup</name><operator>-&gt;</operator><name>typtype</name></name> <operator>!=</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Not a domain, so stop descending */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

            <comment type="block">/* This test must match get_element_type */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>typTup</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typTup</name><operator>-&gt;</operator><name>typelem</name></name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>result</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>typid</name> <operator>=</operator> <name><name>typTup</name><operator>-&gt;</operator><name>typbasetype</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Like get_element_type, silently return InvalidOid for bogus input */</comment>
    <return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTypeInputInfo
 *
 *        Get info needed for converting values of a type to internal form
 */</comment>
<function><type><name>void</name></type>
<name>getTypeInputInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typInput</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typIOParam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>typeTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>pt</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pt</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pt</name><operator>-&gt;</operator><name>typisdefined</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is only a shell"</literal></expr></argument>,
                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>typinput</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no input function available for type %s"</literal></expr></argument>,
                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>typInput</name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>typinput</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>typIOParam</name> <operator>=</operator> <call><name>getTypeIOParam</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getTypeOutputInfo
 *
 *        Get info needed for printing values of a type
 */</comment>
<function><type><name>void</name></type>
<name>getTypeOutputInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typOutput</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>typIsVarlena</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>typeTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>pt</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pt</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pt</name><operator>-&gt;</operator><name>typisdefined</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is only a shell"</literal></expr></argument>,
                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>typoutput</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no output function available for type %s"</literal></expr></argument>,
                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>typOutput</name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>typoutput</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>typIsVarlena</name> <operator>=</operator> <operator>(</operator><operator>!</operator><name><name>pt</name><operator>-&gt;</operator><name>typbyval</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pt</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getTypeBinaryInputInfo
 *
 *        Get info needed for binary input of values of a type
 */</comment>
<function><type><name>void</name></type>
<name>getTypeBinaryInputInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typReceive</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typIOParam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>typeTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>pt</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pt</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pt</name><operator>-&gt;</operator><name>typisdefined</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is only a shell"</literal></expr></argument>,
                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>typreceive</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no binary input function available for type %s"</literal></expr></argument>,
                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>typReceive</name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>typreceive</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>typIOParam</name> <operator>=</operator> <call><name>getTypeIOParam</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getTypeBinaryOutputInfo
 *
 *        Get info needed for binary output of values of a type
 */</comment>
<function><type><name>void</name></type>
<name>getTypeBinaryOutputInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typSend</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>typIsVarlena</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>typeTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>pt</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pt</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pt</name><operator>-&gt;</operator><name>typisdefined</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is only a shell"</literal></expr></argument>,
                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>typsend</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no binary output function available for type %s"</literal></expr></argument>,
                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>typSend</name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>typsend</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>typIsVarlena</name> <operator>=</operator> <operator>(</operator><operator>!</operator><name><name>pt</name><operator>-&gt;</operator><name>typbyval</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pt</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_typmodin
 *
 *        Given the type OID, return the type's typmodin procedure, if any.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_typmodin</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typmodin</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
<comment type="block">/*
 * get_typmodout
 *
 *        Given the type OID, return the type's typmodout procedure, if any.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_typmodout</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typmodout</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* NOT_USED */</comment>

<comment type="block">/*
 * get_typcollation
 *
 *        Given the type OID, return the type's typcollation attribute.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_typcollation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typcollation</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * type_is_collatable
 *
 *        Return whether the type cares about collations
 */</comment>
<function><type><name>bool</name></type>
<name>type_is_collatable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_typcollation</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*                ---------- STATISTICS CACHE ----------                     */</comment>

<comment type="block">/*
 * get_attavgwidth
 *
 *      Given the table and attribute number of a column, get the average
 *      width of entries in the column.  Return zero if no data available.
 *
 * Currently this is only consulted for individual tables, not for inheritance
 * trees, so we don't need an "inh" parameter.
 *
 * Calling a hook at this point looks somewhat strange, but is required
 * because the optimizer calls this function without any other way for
 * plug-ins to control the result.
 */</comment>
<function><type><name>int32</name></type>
<name>get_attavgwidth</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>stawidth</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>get_attavgwidth_hook</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>stawidth</name> <operator>=</operator> <call>(<modifier>*</modifier><name>get_attavgwidth_hook</name>) <argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>stawidth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>stawidth</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>,
                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>stawidth</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>stawidth</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>stawidth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>stawidth</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_attstatsslot
 *
 *        Extract the contents of a "slot" of a pg_statistic tuple.
 *        Returns TRUE if requested slot type was found, else FALSE.
 *
 * Unlike other routines in this file, this takes a pointer to an
 * already-looked-up tuple in the pg_statistic cache.  We do this since
 * most callers will want to extract more than one value from the cache
 * entry, and we don't want to repeat the cache lookup unnecessarily.
 * Also, this API allows this routine to be used with statistics tuples
 * that have been provided by a stats hook and didn't really come from
 * pg_statistic.
 *
 * sslot: pointer to output area (typically, a local variable in the caller).
 * statstuple: pg_statistic tuple to be examined.
 * reqkind: STAKIND code for desired statistics slot kind.
 * reqop: STAOP value wanted, or InvalidOid if don't care.
 * flags: bitmask of ATTSTATSSLOT_VALUES and/or ATTSTATSSLOT_NUMBERS.
 *
 * If a matching slot is found, TRUE is returned, and *sslot is filled thus:
 * staop: receives the actual STAOP value.
 * valuetype: receives actual datatype of the elements of stavalues.
 * values: receives pointer to an array of the slot's stavalues.
 * nvalues: receives number of stavalues.
 * numbers: receives pointer to an array of the slot's stanumbers (as float4).
 * nnumbers: receives number of stanumbers.
 *
 * valuetype/values/nvalues are InvalidOid/NULL/0 if ATTSTATSSLOT_VALUES
 * wasn't specified.  Likewise, numbers/nnumbers are NULL/0 if
 * ATTSTATSSLOT_NUMBERS wasn't specified.
 *
 * If no matching slot is found, FALSE is returned, and *sslot is zeroed.
 *
 * The data referred to by the fields of sslot is locally palloc'd and
 * is independent of the original pg_statistic tuple.  When the caller
 * is done with it, call free_attstatsslot to release the palloc'd data.
 *
 * If it's desirable to call free_attstatsslot when get_attstatsslot might
 * not have been called, memset'ing sslot to zeroes will allow that.
 */</comment>
<function><type><name>bool</name></type>
<name>get_attstatsslot</name><parameter_list>(<parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier></type><name>sslot</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>statstuple</name></decl></parameter>,
                 <parameter><decl><type><name>int</name></type> <name>reqkind</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>reqop</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats</name> <init>= <expr><operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>statstuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>statarray</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>arrayelemtype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>narrayelem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>typeTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeForm</name></decl>;</decl_stmt>

    <comment type="block">/* initialize *sslot properly */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>sslot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttStatsSlot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>stakind1</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>==</operator> <name>reqkind</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name>reqop</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator> <operator>(</operator><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>staop1</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>==</operator> <name>reqop</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>STATISTIC_NUM_SLOTS</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* not there */</comment>

    <expr_stmt><expr><name><name>sslot</name><operator>-&gt;</operator><name>staop</name></name> <operator>=</operator> <operator>(</operator><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>staop1</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>ATTSTATSSLOT_VALUES</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>, <argument><expr><name>statstuple</name></expr></argument>,
                              <argument><expr><name>Anum_pg_statistic_stavalues1</name> <operator>+</operator> <name>i</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"stavalues is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Detoast the array if needed, and in any case make a copy that's
         * under control of this AttStatsSlot.
         */</comment>
        <expr_stmt><expr><name>statarray</name> <operator>=</operator> <call><name>DatumGetArrayTypePCopy</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Extract the actual array element type, and pass it back in case the
         * caller needs it.
         */</comment>
        <expr_stmt><expr><name><name>sslot</name><operator>-&gt;</operator><name>valuetype</name></name> <operator>=</operator> <name>arrayelemtype</name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>statarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Need info about element type */</comment>
        <expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>arrayelemtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>arrayelemtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>typeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Deconstruct array into Datum elements; NULLs not expected */</comment>
        <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>statarray</name></expr></argument>,
                          <argument><expr><name>arrayelemtype</name></expr></argument>,
                          <argument><expr><name><name>typeForm</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
                          <argument><expr><name><name>typeForm</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
                          <argument><expr><name><name>typeForm</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name><name>sslot</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sslot</name><operator>-&gt;</operator><name>nvalues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If the element type is pass-by-reference, we now have a bunch of
         * Datums that are pointers into the statarray, so we need to keep
         * that until free_attstatsslot.  Otherwise, all the useful info is in
         * sslot-&gt;values[], so we can free the array object immediately.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>typeForm</name><operator>-&gt;</operator><name>typbyval</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>sslot</name><operator>-&gt;</operator><name>values_arr</name></name> <operator>=</operator> <name>statarray</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>statarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>ATTSTATSSLOT_NUMBERS</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>, <argument><expr><name>statstuple</name></expr></argument>,
                              <argument><expr><name>Anum_pg_statistic_stanumbers1</name> <operator>+</operator> <name>i</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"stanumbers is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Detoast the array if needed, and in any case make a copy that's
         * under control of this AttStatsSlot.
         */</comment>
        <expr_stmt><expr><name>statarray</name> <operator>=</operator> <call><name>DatumGetArrayTypePCopy</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We expect the array to be a 1-D float4 array; verify that. We don't
         * need to use deconstruct_array() since the array data is just going
         * to look like a C array of float4 values.
         */</comment>
        <expr_stmt><expr><name>narrayelem</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>statarray</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>statarray</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name>narrayelem</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>statarray</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>statarray</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>FLOAT4OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"stanumbers is not a 1-D float4 array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Give caller a pointer directly into the statarray */</comment>
        <expr_stmt><expr><name><name>sslot</name><operator>-&gt;</operator><name>numbers</name></name> <operator>=</operator> <operator>(</operator><name>float4</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>statarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sslot</name><operator>-&gt;</operator><name>nnumbers</name></name> <operator>=</operator> <name>narrayelem</name></expr>;</expr_stmt>

        <comment type="block">/* We'll free the statarray in free_attstatsslot */</comment>
        <expr_stmt><expr><name><name>sslot</name><operator>-&gt;</operator><name>numbers_arr</name></name> <operator>=</operator> <name>statarray</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * free_attstatsslot
 *        Free data allocated by get_attstatsslot
 */</comment>
<function><type><name>void</name></type>
<name>free_attstatsslot</name><parameter_list>(<parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier></type><name>sslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* The values[] array was separately palloc'd by deconstruct_array */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sslot</name><operator>-&gt;</operator><name>values</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sslot</name><operator>-&gt;</operator><name>values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* The numbers[] array points into numbers_arr, do not pfree it */</comment>
    <comment type="block">/* Free the detoasted array objects, if any */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sslot</name><operator>-&gt;</operator><name>values_arr</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sslot</name><operator>-&gt;</operator><name>values_arr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>sslot</name><operator>-&gt;</operator><name>numbers_arr</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sslot</name><operator>-&gt;</operator><name>numbers_arr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*                ---------- PG_NAMESPACE CACHE ----------                 */</comment>

<comment type="block">/*
 * get_namespace_name
 *        Returns the name of a given namespace
 *
 * Returns a palloc'd copy of the string, or NULL if no such namespace.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_namespace_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nspid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>NAMESPACEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_namespace</name></type> <name>nsptup</name> <init>= <expr><operator>(</operator><name>Form_pg_namespace</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nsptup</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<comment type="block">/*
 * Routines to get info to encode/decode oids when sending between nodes
 */</comment>

<comment type="block">/*
 * get_namespaceid
 *      Given a namespace name, look up the namespace OID.
 *
 * Returns InvalidOid if there is no such namespace
 */</comment>
<function><type><name>Oid</name></type>
<name>get_namespaceid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>GetSysCacheOid</name><argument_list>(<argument><expr><name>NAMESPACENAME</name></expr></argument>,
                          <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_typ_name
 *
 *        Given the type OID, find the type name
 *        It returns palloc'd copy of the name or NULL if the cache lookup fails...
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_typ_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>,
                        <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>typtup</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_typ_namespace
 *
 *        Given the type OID, find the namespace
 *        It returns InvalidOid if the cache lookup fails...
 */</comment>
<function><type><name>Oid</name></type>
<name>get_typ_namespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>,
                        <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typnamespace</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_typname_typid
 *      Given a type name and namespace OID, look up the type OID.
 *
 * Returns InvalidOid if there is no such type
 */</comment>
<function><type><name>Oid</name></type>
<name>get_typname_typid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typnamespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>GetSysCacheOid</name><argument_list>(<argument><expr><name>TYPENAMENSP</name></expr></argument>,
                          <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typnamespace</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_funcid
 *      Given a function name, argument types and namespace OID, look up
 * the function OID.
 *
 * Returns InvalidOid if there is no such function
 */</comment>
<function><type><name>Oid</name></type>
<name>get_funcid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><name>oidvector</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>funcnsp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>GetSysCacheOid</name><argument_list>(<argument><expr><name>PROCNAMEARGSNSP</name></expr></argument>,
                          <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcnsp</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_opnamespace
 *      Given an opno, find the namespace
 *
 * Returns InvalidOid if there is no such operator
 */</comment>
<function><type><name>Oid</name></type>
<name>get_opnamespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>,
                        <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>                <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprnamespace</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_operid
 *      Given an operator name, argument types and namespace OID, look up
 * the operator OID.
 *
 * Returns InvalidOid if there is no such operator
 */</comment>
<function><type><name>Oid</name></type>
<name>get_operid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oprname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oprleft</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oprright</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oprnsp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>GetSysCacheOid</name><argument_list>(<argument><expr><name>OPERNAMENSP</name></expr></argument>,
                          <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oprleft</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oprright</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oprnsp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * get_namespace_name_or_temp
 *        As above, but if it is this backend's temporary namespace, return
 *        "pg_temp" instead.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_namespace_name_or_temp</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nspid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>isTempNamespace</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="string">"pg_temp"</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*                ---------- PG_RANGE CACHE ----------                 */</comment>

<comment type="block">/*
 * get_range_subtype
 *        Returns the subtype of a given range type
 *
 * Returns InvalidOid if the type is not a range type.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_range_subtype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>rangeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RANGETYPE</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>rangeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_range</name></type> <name>rngtup</name> <init>= <expr><operator>(</operator><name>Form_pg_range</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>rngtup</name><operator>-&gt;</operator><name>rngsubtype</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>Oid</name></type>
<name>get_interval_parent_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><name><name>reltup</name><operator>-&gt;</operator><name>relpartkind</name></name> <operator>==</operator> <name>RELPARTKIND_CHILD</name></expr> ?</condition><then> <expr><name><name>reltup</name><operator>-&gt;</operator><name>relparent</name></name></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>get_rel_filenode</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>bool</name></type> 
<name>get_rel_stat</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pages</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>tuples</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>all_visible_pages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if<condition>(<expr><name>pages</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>pages</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><name>tuples</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>tuples</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><name>all_visible_pages</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>all_visible_pages</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>relallvisible</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
