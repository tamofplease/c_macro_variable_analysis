<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/cache/plancache.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * plancache.c
 *      Plan cache management.
 *
 * The plan cache manager has two principal responsibilities: deciding when
 * to use a generic plan versus a custom (parameter-value-specific) plan,
 * and tracking whether cached plans need to be invalidated because of schema
 * changes in the objects they depend on.
 *
 * The logic for choosing generic or custom plans is in choose_custom_plan,
 * which see for comments.
 *
 * Cache invalidation is driven off sinval events.  Any CachedPlanSource
 * that matches the event is marked invalid, as is its generic CachedPlan
 * if it has one.  When (and if) the next demand for a cached plan occurs,
 * parse analysis and rewrite is repeated to build a new valid query tree,
 * and then planning is performed as normal.  We also force re-analysis and
 * re-planning if the active search_path is different from the previous time
 * or, if RLS is involved, if the user changes or the RLS environment changes.
 *
 * Note that if the sinval was a result of user DDL actions, parse analysis
 * could throw an error, for example if a column referenced by the query is
 * no longer present.  Another possibility is for the query's output tupdesc
 * to change (for instance "SELECT *" might expand differently than before).
 * The creator of a cached plan can specify whether it is allowable for the
 * query to change output tupdesc on replan --- if so, it's up to the
 * caller to notice changes and cope with them.
 *
 * Currently, we track exactly the dependencies of plans on relations and
 * user-defined functions.  On relcache invalidation events or pg_proc
 * syscache invalidation events, we invalidate just those plans that depend
 * on the particular object being modified.  (Note: this scheme assumes
 * that any table modification that requires replanning will generate a
 * relcache inval event.)  We also watch for inval events on certain other
 * system catalogs, such as pg_namespace; but for them, our response is
 * just to invalidate all plans.  We expect updates on those catalogs to
 * be infrequent enough that more-detailed tracking is not worth the effort.
 *
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *      src/backend/utils/cache/plancache.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/squeue.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/nodelock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pgxcship.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * We must skip "overhead" operations that involve database access when the
 * cached plan's subject statement is a transaction control command.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IsTransactionStmtPlan</name><parameter_list>(<parameter><type><name>plansource</name></type></parameter>)</parameter_list></cpp:macro>  \
    <cpp:value>((plansource)-&gt;raw_parse_tree &amp;&amp; \
     IsA((plansource)-&gt;raw_parse_tree-&gt;stmt, TransactionStmt))</cpp:value></cpp:define>

<comment type="block">/*
 * This is the head of the backend's list of "saved" CachedPlanSources (i.e.,
 * those that are in long-lived storage and are examined for sinval events).
 * We thread the structs manually instead of using List cells so that we can
 * guarantee to save a CachedPlanSource without error.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>CachedPlanSource</name> <modifier>*</modifier></type><name>first_saved_plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReleaseGenericPlan</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>RevalidateCachedQuery</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>,
                      <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CheckCachedPlan</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CachedPlan</name> <modifier>*</modifier></type><name>BuildCachedPlan</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qlist</name></decl></parameter>,
                <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>, <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>choose_custom_plan</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>,
                   <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>cached_plan_cost</name><parameter_list>(<parameter><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>include_planner</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>QueryListGetPrimaryStmt</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AcquireExecutorLocks</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt_list</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>acquire</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AcquirePlannerLocks</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt_list</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>acquire</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ScanQueryForLocks</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>acquire</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ScanQueryWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>acquire</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleDesc</name></type> <name>PlanCacheComputeResultDesc</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PlanCacheRelCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PlanCacheFuncCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PlanCacheSysCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * InitPlanCache: initialize module during InitPostgres.
 *
 * All we need to do is hook into inval.c's callback lists.
 */</comment>
<function><type><name>void</name></type>
<name>InitPlanCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>CacheRegisterRelcacheCallback</name><argument_list>(<argument><expr><name>PlanCacheRelCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>PlanCacheFuncCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>NAMESPACEOID</name></expr></argument>, <argument><expr><name>PlanCacheSysCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><name>PlanCacheSysCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>, <argument><expr><name>PlanCacheSysCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>FOREIGNSERVEROID</name></expr></argument>, <argument><expr><name>PlanCacheSysCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>FOREIGNDATAWRAPPEROID</name></expr></argument>, <argument><expr><name>PlanCacheSysCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CreateCachedPlan: initially create a plan cache entry.
 *
 * Creation of a cached plan is divided into two steps, CreateCachedPlan and
 * CompleteCachedPlan.  CreateCachedPlan should be called after running the
 * query through raw_parser, but before doing parse analysis and rewrite;
 * CompleteCachedPlan is called after that.  The reason for this arrangement
 * is that it can save one round of copying of the raw parse tree, since
 * the parser will normally scribble on the raw parse tree.  Callers would
 * otherwise need to make an extra copy of the parse tree to ensure they
 * still had a clean copy to present at plan cache creation time.
 *
 * All arguments presented to CreateCachedPlan are copied into a memory
 * context created as a child of the call-time CurrentMemoryContext, which
 * should be a reasonably short-lived working context that will go away in
 * event of an error.  This ensures that the cached plan data structure will
 * likewise disappear if an error occurs before we have fully constructed it.
 * Once constructed, the cached plan can be made longer-lived, if needed,
 * by calling SaveCachedPlan.
 *
 * raw_parse_tree: output of raw_parser(), or NULL if empty query
 * query_string: original query text
 * commandTag: compile-time-constant tag for query, or NULL if empty query
 */</comment>
<function><type><name>CachedPlanSource</name> <modifier>*</modifier></type>
<name>CreateCachedPlan</name><parameter_list>(<parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>raw_parse_tree</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
                 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>source_context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>query_string</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* required as of 8.4 */</comment>

    <comment type="block">/*
     * Make a dedicated memory context for the CachedPlanSource and its
     * permanent subsidiary data.  It's probably not going to be large, but
     * just in case, allow it to grow large.  Initially it's a child of the
     * caller's context (which we assume to be transient), so that it will be
     * cleaned up on error.
     */</comment>
    <expr_stmt><expr><name>source_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                           <argument><expr><literal type="string">"CachedPlanSource"</literal></expr></argument>,
                                           <argument><expr><name>ALLOCSET_START_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create and fill the CachedPlanSource struct within the new context.
     * Most fields are just left empty for the moment.
     */</comment>
    <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>source_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>plansource</name> <operator>=</operator> <operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CachedPlanSource</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>CACHEDPLANSOURCE_MAGIC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>raw_parse_tree</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>raw_parse_tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>=</operator> <name>commandTag</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>param_types</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>num_params</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>parserSetup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>cursor_options</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>fixed_result</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>resultDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name>source_context</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>stmt_name</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>stmt_name</name></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_list</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>invalItems</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>search_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>rewriteRoleId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>rewriteRowSecurity</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>dependsOnRLS</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_oneshot</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_complete</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_saved</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>generation</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>next_saved</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>generic_cost</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>total_custom_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>num_custom_plans</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>insert_into</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>plansource</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CreateOneShotCachedPlan: initially create a one-shot plan cache entry.
 *
 * This variant of CreateCachedPlan creates a plan cache entry that is meant
 * to be used only once.  No data copying occurs: all data structures remain
 * in the caller's memory context (which typically should get cleared after
 * completing execution).  The CachedPlanSource struct itself is also created
 * in that context.
 *
 * A one-shot plan cannot be saved or copied, since we make no effort to
 * preserve the raw parse tree unmodified.  There is also no support for
 * invalidation, so plan use must be completed in the current transaction,
 * and DDL that might invalidate the querytree_list must be avoided as well.
 *
 * raw_parse_tree: output of raw_parser(), or NULL if empty query
 * query_string: original query text
 * commandTag: compile-time-constant tag for query, or NULL if empty query
 */</comment>
<function><type><name>CachedPlanSource</name> <modifier>*</modifier></type>
<name>CreateOneShotCachedPlan</name><parameter_list>(<parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>raw_parse_tree</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>query_string</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* required as of 8.4 */</comment>

    <comment type="block">/*
     * Create and fill the CachedPlanSource struct within the caller's memory
     * context.  Most fields are just left empty for the moment.
     */</comment>
    <expr_stmt><expr><name>plansource</name> <operator>=</operator> <operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CachedPlanSource</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>CACHEDPLANSOURCE_MAGIC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>raw_parse_tree</name></name> <operator>=</operator> <name>raw_parse_tree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name> <operator>=</operator> <name>query_string</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>=</operator> <name>commandTag</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>param_types</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>num_params</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>parserSetup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>cursor_options</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>fixed_result</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>resultDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_list</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>invalItems</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>search_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>rewriteRoleId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>rewriteRowSecurity</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>dependsOnRLS</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_oneshot</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_complete</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_saved</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>generation</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>next_saved</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>generic_cost</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>total_custom_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>num_custom_plans</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <return>return <expr><name>plansource</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CompleteCachedPlan: second step of creating a plan cache entry.
 *
 * Pass in the analyzed-and-rewritten form of the query, as well as the
 * required subsidiary data about parameters and such.  All passed values will
 * be copied into the CachedPlanSource's memory, except as specified below.
 * After this is called, GetCachedPlan can be called to obtain a plan, and
 * optionally the CachedPlanSource can be saved using SaveCachedPlan.
 *
 * If querytree_context is not NULL, the querytree_list must be stored in that
 * context (but the other parameters need not be).  The querytree_list is not
 * copied, rather the given context is kept as the initial query_context of
 * the CachedPlanSource.  (It should have been created as a child of the
 * caller's working memory context, but it will now be reparented to belong
 * to the CachedPlanSource.)  The querytree_context is normally the context in
 * which the caller did raw parsing and parse analysis.  This approach saves
 * one tree copying step compared to passing NULL, but leaves lots of extra
 * cruft in the query_context, namely whatever extraneous stuff parse analysis
 * created, as well as whatever went unused from the raw parse tree.  Using
 * this option is a space-for-time tradeoff that is appropriate if the
 * CachedPlanSource is not expected to survive long.
 *
 * plancache.c cannot know how to copy the data referenced by parserSetupArg,
 * and it would often be inappropriate to do so anyway.  When using that
 * option, it is caller's responsibility that the referenced data remains
 * valid for as long as the CachedPlanSource exists.
 *
 * If the CachedPlanSource is a "oneshot" plan, then no querytree copying
 * occurs at all, and querytree_context is ignored; it is caller's
 * responsibility that the passed querytree_list is sufficiently long-lived.
 *
 * plansource: structure returned by CreateCachedPlan
 * querytree_list: analyzed-and-rewritten form of query (list of Query nodes)
 * querytree_context: memory context containing querytree_list,
 *                      or NULL to copy querytree_list into a fresh context
 * param_types: array of fixed parameter type OIDs, or NULL if none
 * num_params: number of fixed parameters
 * parserSetup: alternate method for handling query parameters
 * parserSetupArg: data to pass to parserSetup
 * cursor_options: options bitmask to pass to planner
 * fixed_result: TRUE to disallow future changes in query's result tupdesc
 */</comment>
<function><type><name>void</name></type>
<name>CompleteCachedPlan</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>,
                   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>querytree_list</name></decl></parameter>,
                   <parameter><decl><type><name>MemoryContext</name></type> <name>querytree_context</name></decl></parameter>,
                   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>param_types</name></decl></parameter>,
                   <parameter><decl><type><name>int</name></type> <name>num_params</name></decl></parameter>,
                   <parameter><decl><type><name>ParserSetupHook</name></type> <name>parserSetup</name></decl></parameter>,
                   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>parserSetupArg</name></decl></parameter>,
                   <parameter><decl><type><name>int</name></type> <name>cursor_options</name></decl></parameter>,
                   <parameter><decl><type><name>bool</name></type> <name>fixed_result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>source_context</name> <init>= <expr><name><name>plansource</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Assert caller is doing things in a sane order */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>CACHEDPLANSOURCE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>plansource</name><operator>-&gt;</operator><name>is_complete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If caller supplied a querytree_context, reparent it underneath the
     * CachedPlanSource's context; otherwise, create a suitable context and
     * copy the querytree_list into it.  But no data copying should be done
     * for one-shot plans; for those, assume the passed querytree_list is
     * sufficiently long-lived.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>is_oneshot</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>querytree_context</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>querytree_context</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name>querytree_context</name></expr></argument>, <argument><expr><name>source_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>querytree_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Again, it's a good bet the querytree_context can be small */</comment>
        <expr_stmt><expr><name>querytree_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>source_context</name></expr></argument>,
                                                  <argument><expr><literal type="string">"CachedPlanQuery"</literal></expr></argument>,
                                                  <argument><expr><name>ALLOCSET_START_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>querytree_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_context</name></name> <operator>=</operator> <name>querytree_context</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_list</name></name> <operator>=</operator> <name>querytree_list</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>plansource</name><operator>-&gt;</operator><name>is_oneshot</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsTransactionStmtPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Use the planner machinery to extract dependencies.  Data is saved
         * in query_context.  (We assume that not a lot of extra cruft is
         * created by this call.)  We can skip this for one-shot plans, and
         * transaction control commands have no such dependencies anyway.
         */</comment>
        <expr_stmt><expr><call><name>extract_query_dependencies</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>querytree_list</name></expr></argument>,
                                   <argument><expr><operator>&amp;</operator><name><name>plansource</name><operator>-&gt;</operator><name>relationOids</name></name></expr></argument>,
                                   <argument><expr><operator>&amp;</operator><name><name>plansource</name><operator>-&gt;</operator><name>invalItems</name></name></expr></argument>,
                                   <argument><expr><operator>&amp;</operator><name><name>plansource</name><operator>-&gt;</operator><name>dependsOnRLS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Update RLS info as well. */</comment>
        <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>rewriteRoleId</name></name> <operator>=</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>rewriteRowSecurity</name></name> <operator>=</operator> <name>row_security</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Also save the current search_path in the query_context.  (This
         * should not generate much extra cruft either, since almost certainly
         * the path is already valid.)    Again, we don't really need this for
         * one-shot plans; and we *must* skip this for transaction control
         * commands, because this could result in catalog accesses.
         */</comment>
        <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>search_path</name></name> <operator>=</operator> <call><name>GetOverrideSearchPath</name><argument_list>(<argument><expr><name>querytree_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Save the final parameter types (or other parameter specification data)
     * into the source_context, as well as our other parameters.  Also save
     * the result tuple descriptor.
     */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>source_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>num_params</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>param_types</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_params</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>param_types</name></name></expr></argument>, <argument><expr><name>param_types</name></expr></argument>, <argument><expr><name>num_params</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>param_types</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>num_params</name></name> <operator>=</operator> <name>num_params</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>parserSetup</name></name> <operator>=</operator> <name>parserSetup</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <name>parserSetupArg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>cursor_options</name></name> <operator>=</operator> <name>cursor_options</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>fixed_result</name></name> <operator>=</operator> <name>fixed_result</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>resultDesc</name></name> <operator>=</operator> <call><name>PlanCacheComputeResultDesc</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_complete</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SaveCachedPlan: save a cached plan permanently
 *
 * This function moves the cached plan underneath CacheMemoryContext (making
 * it live for the life of the backend, unless explicitly dropped), and adds
 * it to the list of cached plans that are checked for invalidation when an
 * sinval event occurs.
 *
 * This is guaranteed not to throw error, except for the caller-error case
 * of trying to save a one-shot plan.  Callers typically depend on that
 * since this is called just before or just after adding a pointer to the
 * CachedPlanSource to some permanent data structure of their own.  Up until
 * this is done, a CachedPlanSource is just transient data that will go away
 * automatically on transaction abort.
 */</comment>
<function><type><name>void</name></type>
<name>SaveCachedPlan</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Assert caller is doing things in a sane order */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>CACHEDPLANSOURCE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_complete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>plansource</name><operator>-&gt;</operator><name>is_saved</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* This seems worth a real test, though */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>is_oneshot</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot save one-shot cached plan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * In typical use, this function would be called before generating any
     * plans from the CachedPlanSource.  If there is a generic plan, moving it
     * into CacheMemoryContext would be pretty risky since it's unclear
     * whether the caller has taken suitable care with making references
     * long-lived.  Best thing to do seems to be to discard the plan.
     */</comment>
    <expr_stmt><expr><call><name>ReleaseGenericPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Reparent the source memory context under CacheMemoryContext so that it
     * will live indefinitely.  The query_context follows along since it's
     * already a child of the other one.
     */</comment>
    <expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Add the entry to the global list of cached plans.
     */</comment>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>next_saved</name></name> <operator>=</operator> <name>first_saved_plan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>first_saved_plan</name> <operator>=</operator> <name>plansource</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_saved</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * DropCachedPlan: destroy a cached plan.
 *
 * Actually this only destroys the CachedPlanSource: any referenced CachedPlan
 * is released, but not destroyed until its refcount goes to zero.  That
 * handles the situation where DropCachedPlan is called while the plan is
 * still in use.
 */</comment>
<function><type><name>void</name></type>
<name>DropCachedPlan</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>CACHEDPLANSOURCE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If it's been saved, remove it from the list */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>is_saved</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>first_saved_plan</name> <operator>==</operator> <name>plansource</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>first_saved_plan</name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>next_saved</name></name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>psrc</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>psrc</name> <operator>=</operator> <name>first_saved_plan</name></expr>;</init> <condition><expr><name>psrc</name></expr>;</condition> <incr><expr><name>psrc</name> <operator>=</operator> <name><name>psrc</name><operator>-&gt;</operator><name>next_saved</name></name></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>psrc</name><operator>-&gt;</operator><name>next_saved</name></name> <operator>==</operator> <name>plansource</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>psrc</name><operator>-&gt;</operator><name>next_saved</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>next_saved</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_saved</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Decrement generic CachePlan's refcount and drop if no longer needed */</comment>
    <expr_stmt><expr><call><name>ReleaseGenericPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Mark it no longer valid */</comment>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Remove the CachedPlanSource and all subsidiary data (including the
     * query_context if any).  But if it's a one-shot we can't free anything.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>plansource</name><operator>-&gt;</operator><name>is_oneshot</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReleaseGenericPlan: release a CachedPlanSource's generic plan, if any.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReleaseGenericPlan</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Be paranoid about the possibility that ReleaseCachedPlan fails */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <comment type="block">/* Release SharedQueue if still held */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsConnFromDatanode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>plan</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>pstmt</name> <operator>=</operator> <operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>pname</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>SharedQueueRelease</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>pname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>CACHEDPLAN_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseCachedPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RevalidateCachedQuery: ensure validity of analyzed-and-rewritten query tree.
 *
 * What we do here is re-acquire locks and redo parse analysis if necessary.
 * On return, the query_list is valid and we have sufficient locks to begin
 * planning.
 *
 * If any parse analysis activity is required, the caller's memory context is
 * used for that work.
 *
 * The result value is the transient analyzed-and-rewritten query tree if we
 * had to do re-analysis, and NIL otherwise.  (This is returned just to save
 * a tree copying step in a subsequent BuildCachedPlan call.)
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>RevalidateCachedQuery</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>,
                      <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>snapshot_set</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>rawtree</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>            <comment type="block">/* transient query-tree list */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>qlist</name></decl>;</decl_stmt>            <comment type="block">/* permanent query-tree list */</comment>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>resultDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>querytree_context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

    <comment type="block">/*
     * For one-shot plans, we do not support revalidation checking; it's
     * assumed the query is parsed, planned, and executed in one transaction,
     * so that no lock re-acquisition is necessary.  Also, there is never any
     * need to revalidate plans for transaction control commands (and we
     * mustn't risk any catalog accesses when handling those).
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>is_oneshot</name></name> <operator>||</operator> <call><name>IsTransactionStmtPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NIL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/*
     * In the raw_parse_tree is not available, there is no way the plan can be
     * revalidated and there must not be any need to do so. Trust the existing
     * plan
     *
     * XXX We should rather check this as an assertion, but currently
     * RemoteSubplan gets invalidated because of search_path changes as temp
     * namespace gets added in subsequent revalidation.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>raw_parse_tree</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NIL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If the query is currently valid, we should have a saved search_path ---
     * check to see if that matches the current environment.  If not, we want
     * to force replan.  We should also have a valid planUserId.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>search_path</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OverrideSearchPathMatchesCurrent</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>search_path</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Invalidate the querytree and generic plan */</comment>
            <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If the query rewrite phase had a possible RLS dependency, we must redo
     * it if either the role or the row_security setting has changed.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>&amp;&amp;</operator> <name><name>plansource</name><operator>-&gt;</operator><name>dependsOnRLS</name></name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>plansource</name><operator>-&gt;</operator><name>rewriteRoleId</name></name> <operator>!=</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call> <operator>||</operator>
         <name><name>plansource</name><operator>-&gt;</operator><name>rewriteRowSecurity</name></name> <operator>!=</operator> <name>row_security</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If the query is currently valid, acquire locks on the referenced
     * objects; then check again.  We need to do it this way to cover the race
     * condition that an invalidation message arrives before we get the locks.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>AcquirePlannerLocks</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_list</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * By now, if any invalidation has happened, the inval callback
         * functions will have marked the query invalid.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Successfully revalidated and locked the query. */</comment>
            <return>return <expr><name>NIL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Oops, the race case happened.  Release useless locks. */</comment>
        <expr_stmt><expr><call><name>AcquirePlannerLocks</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_list</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Discard the no-longer-useful query tree.  (Note: we don't want to do
     * this any earlier, else we'd not have been able to release locks
     * correctly in the race condition case.)
     */</comment>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_list</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>invalItems</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>search_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Free the query_context.  We don't really expect MemoryContextDelete to
     * fail, but just in case, make sure the CachedPlanSource is left in a
     * reasonably sane state.  (The generic plan won't get unlinked yet, but
     * that's acceptable.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>query_context</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>qcxt</name> <init>= <expr><name><name>plansource</name><operator>-&gt;</operator><name>query_context</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>qcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Drop the generic plan reference if any */</comment>
    <expr_stmt><expr><call><name>ReleaseGenericPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now re-do parse analysis and rewrite.  This not incidentally acquires
     * the locks we need to do planning safely.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_complete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If a snapshot is already set (the normal case), we can just use that
     * for parsing/planning.  But if it isn't, install one.  Note: no point in
     * checking whether parse analysis requires a snapshot; utility commands
     * don't have invalidatable plans, so we'd not get here for such a
     * command.
     */</comment>
    <expr_stmt><expr><name>snapshot_set</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>snapshot_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Run parse analysis and rule rewriting.  The parser tends to scribble on
     * its input, so we must copy the raw parse tree to prevent corruption of
     * the cache.
     */</comment>
    <expr_stmt><expr><name>rawtree</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>raw_parse_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rawtree</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>tlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>parserSetup</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite_params</name><argument_list>(<argument><expr><name>rawtree</name></expr></argument>,
                                              <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>,
                                              <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>parserSetup</name></name></expr></argument>,
                                              <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>parserSetupArg</name></name></expr></argument>,
                                              <argument><expr><name>queryEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite</name><argument_list>(<argument><expr><name>rawtree</name></expr></argument>,
                                       <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>,
                                       <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>param_types</name></name></expr></argument>,
                                       <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>num_params</name></name></expr></argument>,
                                       <argument><expr><name>queryEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Release snapshot if we got one */</comment>
    <if_stmt><if>if <condition>(<expr><name>snapshot_set</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check or update the result tupdesc.  XXX should we use a weaker
     * condition than equalTupleDescs() here?
     *
     * We assume the parameter types didn't change from the first time, so no
     * need to update that.
     */</comment>
    <expr_stmt><expr><name>resultDesc</name> <operator>=</operator> <call><name>PlanCacheComputeResultDesc</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>resultDesc</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>plansource</name><operator>-&gt;</operator><name>resultDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* OK, doesn't return tuples */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>resultDesc</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>plansource</name><operator>-&gt;</operator><name>resultDesc</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
             <operator>!</operator><call><name>equalTupleDescs</name><argument_list>(<argument><expr><name>resultDesc</name></expr></argument>, <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>resultDesc</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* can we give a better error message? */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>fixed_result</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cached plan must not change result type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>resultDesc</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>resultDesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>resultDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>resultDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>resultDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>resultDesc</name></name> <operator>=</operator> <name>resultDesc</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Allocate new query_context and copy the completed querytree into it.
     * It's transient until we complete the copying and dependency extraction.
     */</comment>
    <expr_stmt><expr><name>querytree_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                              <argument><expr><literal type="string">"CachedPlanQuery"</literal></expr></argument>,
                                              <argument><expr><name>ALLOCSET_START_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>querytree_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>qlist</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Use the planner machinery to extract dependencies.  Data is saved in
     * query_context.  (We assume that not a lot of extra cruft is created by
     * this call.)
     */</comment>
    <expr_stmt><expr><call><name>extract_query_dependencies</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qlist</name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name><name>plansource</name><operator>-&gt;</operator><name>relationOids</name></name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name><name>plansource</name><operator>-&gt;</operator><name>invalItems</name></name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name><name>plansource</name><operator>-&gt;</operator><name>dependsOnRLS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Update RLS info as well. */</comment>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>rewriteRoleId</name></name> <operator>=</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>rewriteRowSecurity</name></name> <operator>=</operator> <name>row_security</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Also save the current search_path in the query_context.  (This should
     * not generate much extra cruft either, since almost certainly the path
     * is already valid.)
     */</comment>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>search_path</name></name> <operator>=</operator> <call><name>GetOverrideSearchPath</name><argument_list>(<argument><expr><name>querytree_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now reparent the finished query_context and save the links */</comment>
    <expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name>querytree_context</name></expr></argument>, <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_context</name></name> <operator>=</operator> <name>querytree_context</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_list</name></name> <operator>=</operator> <name>qlist</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>insert_into</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <name>g_transform_insert_to_copy</name> <operator>&amp;&amp;</operator> <name>rawtree</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>rawtree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>, <argument><expr><name>InsertStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name>qlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>isMultiValues</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>hasUnshippableTriggers</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>insert_into</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Note: we do not reset generic_cost or total_custom_cost, although we
     * could choose to do so.  If the DDL or statistics change that prompted
     * the invalidation meant a significant change in the cost estimates, it
     * would be better to reset those variables and start fresh; but often it
     * doesn't, and we're better retaining our hard-won knowledge about the
     * relative costs.
     */</comment>

    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* Return transient copy of querytrees for possible use in planning */</comment>
    <return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CheckCachedPlan: see if the CachedPlanSource's generic plan is valid.
 *
 * Caller must have already called RevalidateCachedQuery to verify that the
 * querytree is up to date.
 *
 * On a "true" return, we have acquired the locks needed to run the plan.
 * (We must do this for the "true" result to be race-condition-free.)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CheckCachedPlan</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Assert that caller checked the querytree */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If there's no generic plan, just say "false" */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>plan</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>CACHEDPLAN_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Generic plans are never one-shot */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>plan</name><operator>-&gt;</operator><name>is_oneshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If plan isn't valid for current role, we can't use it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>&amp;&amp;</operator> <name><name>plan</name><operator>-&gt;</operator><name>dependsOnRole</name></name> <operator>&amp;&amp;</operator>
        <name><name>plan</name><operator>-&gt;</operator><name>planRoleId</name></name> <operator>!=</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If it appears valid, acquire locks and recheck; this is much the same
     * logic as in RevalidateCachedQuery, but for a plan.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>is_valid</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Plan must have positive refcount because it is referenced by
         * plansource; so no need to fear it disappears under us here.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>AcquireExecutorLocks</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If plan was transient, check to see if TransactionXmin has
         * advanced, and if so invalidate it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>&amp;&amp;</operator>
            <call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>saved_xmin</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>saved_xmin</name></name></expr></argument>, <argument><expr><name>TransactionXmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * By now, if any invalidation has happened, the inval callback
         * functions will have marked the plan invalid.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>is_valid</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Successfully revalidated and locked the query. */</comment>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Oops, the race case happened.  Release useless locks. */</comment>
        <expr_stmt><expr><call><name>AcquireExecutorLocks</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Plan has been invalidated, so unlink it from the parent and release it.
     */</comment>
    <expr_stmt><expr><call><name>ReleaseGenericPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * BuildCachedPlan: construct a new CachedPlan from a CachedPlanSource.
 *
 * qlist should be the result value from a previous RevalidateCachedQuery,
 * or it can be set to NIL if we need to re-copy the plansource's query_list.
 *
 * To build a generic, parameter-value-independent plan, pass NULL for
 * boundParams.  To build a custom plan, pass the actual parameter values via
 * boundParams.  For best effect, the PARAM_FLAG_CONST flag should be set on
 * each parameter value; otherwise the planner will treat the value as a
 * hint rather than a hard constant.
 *
 * Planning work is done in the caller's memory context.  The finished plan
 * is in a child memory context, which typically should get reparented
 * (unless this is a one-shot plan, in which case we don't copy the plan).
 */</comment>
<function><type><specifier>static</specifier> <name>CachedPlan</name> <modifier>*</modifier></type>
<name>BuildCachedPlan</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qlist</name></decl></parameter>,
                <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>, <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>plist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>snapshot_set</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_transient</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>plan_context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Normally the querytree should be valid already, but if it's not,
     * rebuild it.
     *
     * NOTE: GetCachedPlan should have called RevalidateCachedQuery first, so
     * we ought to be holding sufficient locks to prevent any invalidation.
     * However, if we're building a custom plan after having built and
     * rejected a generic plan, it's possible to reach here with is_valid
     * false due to an invalidation while making the generic plan.  In theory
     * the invalidation must be a false positive, perhaps a consequence of an
     * sinval reset event or the CLOBBER_CACHE_ALWAYS debug code.  But for
     * safety, let's treat it as real and redo the RevalidateCachedQuery call.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>qlist</name> <operator>=</operator> <call><name>RevalidateCachedQuery</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If we don't already have a copy of the querytree list that can be
     * scribbled on by the planner, make one.  For a one-shot plan, we assume
     * it's okay to scribble on the original query_list.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>qlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>plansource</name><operator>-&gt;</operator><name>is_oneshot</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>qlist</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>qlist</name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>query_list</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If a snapshot is already set (the normal case), we can just use that
     * for planning.  But if it isn't, and we need one, install one.
     */</comment>
    <expr_stmt><expr><name>snapshot_set</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
        <name><name>plansource</name><operator>-&gt;</operator><name>raw_parse_tree</name></name> <operator>&amp;&amp;</operator>
		<call><name>analyze_requires_snapshot</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>raw_parse_tree</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <name>g_snapshot_for_analyze</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>snapshot_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Generate the plan.
     */</comment>
    <expr_stmt><expr><name>plist</name> <operator>=</operator> <call><name>pg_plan_queries</name><argument_list>(<argument><expr><name>qlist</name></expr></argument>, <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>cursor_options</name></name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Release snapshot if we got one */</comment>
    <if_stmt><if>if <condition>(<expr><name>snapshot_set</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Normally we make a dedicated memory context for the CachedPlan and its
     * subsidiary data.  (It's probably not going to be large, but just in
     * case, allow it to grow large.  It's transient for the moment.)  But for
     * a one-shot plan, we just leave it in the caller's memory context.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>plansource</name><operator>-&gt;</operator><name>is_oneshot</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>plan_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                             <argument><expr><literal type="string">"CachedPlan"</literal></expr></argument>,
                                             <argument><expr><name>ALLOCSET_START_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Copy plan into the new context.
         */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>plan_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>plist</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>plist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>plan_context</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/*
     * If this plansource belongs to a named prepared statement, store the stmt
     * name for the Datanode queries.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator> <name><name>plansource</name><operator>-&gt;</operator><name>stmt_name</name></name> <operator>&amp;&amp;</operator>
            <name><name>plansource</name><operator>-&gt;</operator><name>stmt_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>         <name>n</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Scan the plans and set the statement field for all found RemoteQuery
         * nodes so they use Datanode statements
         */</comment>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plist</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>st</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>ps</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>st</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>ps</name> <operator>=</operator> <operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator><name>st</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>SetRemoteStatementName</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>, <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>stmt_name</name></name></expr></argument>,
                            <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>num_params</name></name></expr></argument>,
                            <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>param_types</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Create and fill the CachedPlan struct within the new context.
     */</comment>
    <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>CachedPlan</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CachedPlan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>CACHEDPLAN_MAGIC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>stmt_list</name></name> <operator>=</operator> <name>plist</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>stmt_list_backup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * CachedPlan is dependent on role either if RLS affected the rewrite
     * phase or if a role dependency was injected during planning.  And it's
     * transient if any plan is marked so.
     */</comment>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>planRoleId</name></name> <operator>=</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>dependsOnRole</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>dependsOnRLS</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>is_transient</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* Ignore utility statements */</comment>

        <if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>transientPlan</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>is_transient</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>dependsOnRole</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>dependsOnRole</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <if_stmt><if>if <condition>(<expr><name>is_transient</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>TransactionXmin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>saved_xmin</name></name> <operator>=</operator> <name>TransactionXmin</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>saved_xmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>refcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name>plan_context</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>is_oneshot</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>is_oneshot</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>is_saved</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* assign generation number to new plan */</comment>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>generation</name></name> <operator>=</operator> <operator>++</operator><operator>(</operator><name><name>plansource</name><operator>-&gt;</operator><name>generation</name></name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * choose_custom_plan: choose whether to use custom or generic plan
 *
 * This defines the policy followed by GetCachedPlan.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>choose_custom_plan</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>avg_custom_cost</name></decl>;</decl_stmt>

    <comment type="block">/* One-shot plans will always be considered custom */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>is_oneshot</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* has unshipptable triggers, always choose custom plan */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name></name> <operator>&amp;&amp;</operator> <name><name>plansource</name><operator>-&gt;</operator><name>gplan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>planstmt</name> <init>= <expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator><call><name>list_nth</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>planstmt</name><operator>-&gt;</operator><name>parseTree</name></name> <operator>&amp;&amp;</operator> <name><name>planstmt</name><operator>-&gt;</operator><name>parseTree</name><operator>-&gt;</operator><name>hasUnshippableTriggers</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>planstmt</name><operator>-&gt;</operator><name>planTree</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>planstmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>, <argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                
                <decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator><name><name>planstmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>int</name></type> <name>nremote_plans</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>remote_plans</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nremote_plans</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>rq</name> <init>= <expr><operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator><call><name>list_nth</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>remote_plans</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>DropRemoteDMLStatement</name><argument_list>(<argument><expr><name><name>rq</name><operator>-&gt;</operator><name>statement</name></name></expr></argument>, <argument><expr><name><name>rq</name><operator>-&gt;</operator><name>update_cursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>ReleaseGenericPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Otherwise, never any point in a custom plan if there's no parameters */</comment>
    <if_stmt><if>if <condition>(<expr><name>boundParams</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* ... nor for transaction control statements */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsTransactionStmtPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* See if caller wants to force the decision */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>cursor_options</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_GENERIC_PLAN</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>cursor_options</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_CUSTOM_PLAN</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Generate custom plans until we have done at least 5 (arbitrary) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>num_custom_plans</name></name> <operator>&lt;</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>avg_custom_cost</name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>total_custom_cost</name></name> <operator>/</operator> <name><name>plansource</name><operator>-&gt;</operator><name>num_custom_plans</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Prefer generic plan if it's less expensive than the average custom
     * plan.  (Because we include a charge for cost of planning in the
     * custom-plan costs, this means the generic plan only has to be less
     * expensive than the execution cost plus replan cost of the custom
     * plans.)
     *
     * Note that if generic_cost is -1 (indicating we've not yet determined
     * the generic plan cost), we'll always prefer generic at this point.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>generic_cost</name></name> <operator>&lt;</operator> <name>avg_custom_cost</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cached_plan_cost: calculate estimated cost of a plan
 *
 * If include_planner is true, also include the estimated cost of constructing
 * the plan.  (We must factor that into the cost of using a custom plan, but
 * we don't count it for a generic plan.)
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>cached_plan_cost</name><parameter_list>(<parameter><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>include_planner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plan-&gt;stmt_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* Ignore utility statements */</comment>

        <expr_stmt><expr><name>result</name> <operator>+=</operator> <name><name>plannedstmt</name><operator>-&gt;</operator><name>planTree</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>include_planner</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Currently we use a very crude estimate of planning effort based
             * on the number of relations in the finished plan's rangetable.
             * Join planning effort actually scales much worse than linearly
             * in the number of relations --- but only until the join collapse
             * limits kick in.  Also, while inheritance child relations surely
             * add to planning effort, they don't make the join situation
             * worse.  So the actual shape of the planning cost curve versus
             * number of relations isn't all that obvious.  It will take
             * considerable work to arrive at a less crude estimate, and for
             * now it's not clear that's worth doing.
             *
             * The other big difficulty here is that we don't have any very
             * good model of how planning cost compares to execution costs.
             * The current multiplier of 1000 * cpu_operator_cost is probably
             * on the low side, but we'll try this for awhile before making a
             * more aggressive correction.
             *
             * If we ever do write a more complicated estimator, it should
             * probably live in src/backend/optimizer/ not here.
             */</comment>
            <decl_stmt><decl><type><name>int</name></type>            <name>nrelations</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>result</name> <operator>+=</operator> <literal type="number">1000.0</literal> <operator>*</operator> <name>cpu_operator_cost</name> <operator>*</operator> <operator>(</operator><name>nrelations</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetCachedPlan: get a cached plan from a CachedPlanSource.
 *
 * This function hides the logic that decides whether to use a generic
 * plan or a custom plan for the given parameters: the caller does not know
 * which it will get.
 *
 * On return, the plan is valid and we have sufficient locks to begin
 * execution.
 *
 * On return, the refcount of the plan has been incremented; a later
 * ReleaseCachedPlan() call is expected.  The refcount has been reported
 * to the CurrentResourceOwner if useResOwner is true (note that that must
 * only be true if it's a "saved" CachedPlanSource).
 *
 * Note: if any replanning activity is required, the caller's memory context
 * is used for that work.
 */</comment>
<function><type><name>CachedPlan</name> <modifier>*</modifier></type>
<name>GetCachedPlan</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>,
              <parameter><decl><type><name>bool</name></type> <name>useResOwner</name></decl></parameter>, <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>qlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>customplan</name></decl>;</decl_stmt>

    <comment type="block">/* Assert caller is doing things in a sane order */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>CACHEDPLANSOURCE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_complete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* This seems worth a real test, though */</comment>
    <if_stmt><if>if <condition>(<expr><name>useResOwner</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>plansource</name><operator>-&gt;</operator><name>is_saved</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot apply ResourceOwner to non-saved cached plan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Make sure the querytree list is valid and we have parse-time locks */</comment>
    <expr_stmt><expr><name>qlist</name> <operator>=</operator> <call><name>RevalidateCachedQuery</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Decide whether to use a custom plan */</comment>
    <expr_stmt><expr><name>customplan</name> <operator>=</operator> <call><name>choose_custom_plan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>customplan</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>CheckCachedPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* We want a generic plan, and we already have a valid one */</comment>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>gplan</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>CACHEDPLAN_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Build a new generic plan */</comment>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>BuildCachedPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>, <argument><expr><name>qlist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Just make real sure plansource-&gt;gplan is clear */</comment>
            <expr_stmt><expr><call><name>ReleaseGenericPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Link the new generic plan into the plansource */</comment>
            <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name></name> <operator>=</operator> <name>plan</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>refcount</name></name><operator>++</operator></expr>;</expr_stmt>
            <comment type="block">/* Immediately reparent into appropriate context */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>is_saved</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* saved plans all live under CacheMemoryContext */</comment>
                <expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>is_saved</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* otherwise, it should be a sibling of the plansource */</comment>
                <expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
                                       <argument><expr><call><name>MemoryContextGetParent</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <comment type="block">/* Update generic_cost whenever we make a new generic plan */</comment>
            <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>generic_cost</name></name> <operator>=</operator> <call><name>cached_plan_cost</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If, based on the now-known value of generic_cost, we'd not have
             * chosen to use a generic plan, then forget it and make a custom
             * plan.  This is a bit of a wart but is necessary to avoid a
             * glitch in behavior when the custom plans are consistently big
             * winners; at some point we'll experiment with a generic plan and
             * find it's a loser, but we don't want to actually execute that
             * plan.
             */</comment>
            <expr_stmt><expr><name>customplan</name> <operator>=</operator> <call><name>choose_custom_plan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If we choose to plan again, we need to re-copy the query_list,
             * since the planner probably scribbled on it.  We can force
             * BuildCachedPlan to do that by passing NIL.
             */</comment>
            <expr_stmt><expr><name>qlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>customplan</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Build a custom plan */</comment>
        <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>BuildCachedPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>, <argument><expr><name>qlist</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Accumulate total costs of custom plans, but 'ware overflow */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>num_custom_plans</name></name> <operator>&lt;</operator> <name>INT_MAX</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>total_custom_cost</name></name> <operator>+=</operator> <call><name>cached_plan_cost</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>num_custom_plans</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>plan</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Flag the plan as in use by caller */</comment>
    <if_stmt><if>if <condition>(<expr><name>useResOwner</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResourceOwnerEnlargePlanCacheRefs</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>refcount</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>useResOwner</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResourceOwnerRememberPlanCacheRef</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Saved plans should be under CacheMemoryContext so they will not go away
     * until their reference count goes to zero.  In the generic-plan cases we
     * already took care of that, but for a custom plan, do it as soon as we
     * have created a reference-counted link.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>customplan</name> <operator>&amp;&amp;</operator> <name><name>plansource</name><operator>-&gt;</operator><name>is_saved</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>is_saved</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ReleaseCachedPlan: release active use of a cached plan.
 *
 * This decrements the reference count, and frees the plan if the count
 * has thereby gone to zero.  If useResOwner is true, it is assumed that
 * the reference count is managed by the CurrentResourceOwner.
 *
 * Note: useResOwner = false is used for releasing references that are in
 * persistent data structures, such as the parent CachedPlanSource or a
 * Portal.  Transient references should be protected by a resource owner.
 */</comment>
<function><type><name>void</name></type>
<name>ReleaseCachedPlan</name><parameter_list>(<parameter><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useResOwner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>CACHEDPLAN_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>useResOwner</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>is_saved</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ResourceOwnerForgetPlanCacheRef</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>refcount</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Mark it no longer valid */</comment>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* One-shot plans do not own their context, so we can't free them */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>plan</name><operator>-&gt;</operator><name>is_oneshot</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CachedPlanSetParentContext: move a CachedPlanSource to a new memory context
 *
 * This can only be applied to unsaved plans; once saved, a plan always
 * lives underneath CacheMemoryContext.
 */</comment>
<function><type><name>void</name></type>
<name>CachedPlanSetParentContext</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>,
                           <parameter><decl><type><name>MemoryContext</name></type> <name>newcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Assert caller is doing things in a sane order */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>CACHEDPLANSOURCE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_complete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* These seem worth real tests, though */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>is_saved</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot move a saved cached plan to another context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>is_oneshot</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot move a one-shot cached plan to another context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* OK, let the caller keep the plan where he wishes */</comment>
    <expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>newcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The query_context needs no special handling, since it's a child of
     * plansource-&gt;context.  But if there's a generic plan, it should be
     * maintained as a sibling of plansource-&gt;context.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>CACHEDPLAN_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>newcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CopyCachedPlan: make a copy of a CachedPlanSource
 *
 * This is a convenience routine that does the equivalent of
 * CreateCachedPlan + CompleteCachedPlan, using the data stored in the
 * input CachedPlanSource.  The result is therefore "unsaved" (regardless
 * of the state of the source), and we don't copy any generic plan either.
 * The result will be currently valid, or not, the same as the source.
 */</comment>
<function><type><name>CachedPlanSource</name> <modifier>*</modifier></type>
<name>CopyCachedPlan</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>newsource</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>source_context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>querytree_context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>CACHEDPLANSOURCE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_complete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * One-shot plans can't be copied, because we haven't taken care that
     * parsing/planning didn't scribble on the raw parse tree or querytrees.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>is_oneshot</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot copy a one-shot cached plan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>source_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                           <argument><expr><literal type="string">"CachedPlanSource"</literal></expr></argument>,
                                           <argument><expr><name>ALLOCSET_START_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>source_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>newsource</name> <operator>=</operator> <operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CachedPlanSource</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>CACHEDPLANSOURCE_MAGIC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>raw_parse_tree</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>raw_parse_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>query_string</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>commandTag</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>num_params</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>param_types</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>num_params</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newsource</name><operator>-&gt;</operator><name>param_types</name></name></expr></argument>, <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>param_types</name></name></expr></argument>,
               <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>num_params</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>param_types</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>num_params</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>num_params</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>parserSetup</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>parserSetup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>parserSetupArg</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>cursor_options</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>cursor_options</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>fixed_result</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>fixed_result</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>resultDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>resultDesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>resultDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>resultDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name>source_context</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>querytree_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>source_context</name></expr></argument>,
                                              <argument><expr><literal type="string">"CachedPlanQuery"</literal></expr></argument>,
                                              <argument><expr><name>ALLOCSET_START_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>querytree_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>query_list</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>relationOids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>invalItems</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>invalItems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>search_path</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>search_path</name></name> <operator>=</operator> <call><name>CopyOverrideSearchPath</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>search_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>query_context</name></name> <operator>=</operator> <name>querytree_context</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>rewriteRoleId</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>rewriteRoleId</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>rewriteRowSecurity</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>rewriteRowSecurity</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>dependsOnRLS</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>dependsOnRLS</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>gplan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>is_oneshot</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>is_complete</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>is_saved</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>generation</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>generation</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>next_saved</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* We may as well copy any acquired cost knowledge */</comment>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>generic_cost</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>generic_cost</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>total_custom_cost</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>total_custom_cost</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>num_custom_plans</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>num_custom_plans</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>newsource</name><operator>-&gt;</operator><name>insert_into</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>insert_into</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>newsource</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CachedPlanIsValid: test whether the rewritten querytree within a
 * CachedPlanSource is currently valid (that is, not marked as being in need
 * of revalidation).
 *
 * This result is only trustworthy (ie, free from race conditions) if
 * the caller has acquired locks on all the relations used in the plan.
 */</comment>
<function><type><name>bool</name></type>
<name>CachedPlanIsValid</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>CACHEDPLANSOURCE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CachedPlanGetTargetList: return tlist, if any, describing plan's output
 *
 * The result is guaranteed up-to-date.  However, it is local storage
 * within the cached plan, and may disappear next time the plan is updated.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>CachedPlanGetTargetList</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>,
                        <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>

    <comment type="block">/* Assert caller is doing things in a sane order */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>CACHEDPLANSOURCE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_complete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * No work needed if statement doesn't return tuples (we assume this
     * feature cannot be changed by an invalidation)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>resultDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Make sure the querytree list is valid and we have parse-time locks */</comment>
    <expr_stmt><expr><call><name>RevalidateCachedQuery</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get the primary statement and find out what it returns */</comment>
    <expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>QueryListGetPrimaryStmt</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>FetchStatementTargetList</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>pstmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * QueryListGetPrimaryStmt
 *        Get the "primary" stmt within a list, ie, the one marked canSetTag.
 *
 * Returns NULL if no such stmt.  If multiple queries within the list are
 * marked canSetTag, returns the first one.  Neither of these cases should
 * occur in present usages of this function.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>QueryListGetPrimaryStmt</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmts</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>stmt</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AcquireExecutorLocks: acquire locks needed for execution of a cached plan;
 * or release them if acquire is false.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AcquireExecutorLocks</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt_list</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>acquire</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>stmt_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>rt_index</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Ignore utility statements, except those (such as EXPLAIN) that
             * contain a parsed-but-not-planned query.  Note: it's okay to use
             * ScanQueryForLocks, even though the query hasn't been through
             * rule rewriting, because rewriting doesn't change the query
             * representation.
             */</comment>
            <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>UtilityContainsQuery</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>query</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ScanQueryForLocks</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>acquire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>rt_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>plannedstmt-&gt;rtable</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LOCKMODE</name></type>    <name>lockmode</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>rc</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>rt_index</name><operator>++</operator></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Acquire the appropriate type of lock on each relation OID. Note
             * that we don't actually try to open the rel, and hence will not
             * fail if it's been dropped entirely --- we'll just transiently
             * acquire a non-conflicting lock.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>list_member_int</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>resultRelations</name></name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <call><name>list_member_int</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>nonleafResultRelations</name></name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>RowExclusiveLock</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>get_plan_rowmark</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                     <call><name>RowMarkRequiresRowShareLock</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>markType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>RowShareLock</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>acquire</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * AcquirePlannerLocks: acquire locks needed for planning of a querytree list;
 * or release them if acquire is false.
 *
 * Note that we don't actually try to open the relations, and hence will not
 * fail if one has been dropped entirely --- we'll just transiently acquire
 * a non-conflicting lock.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AcquirePlannerLocks</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt_list</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>acquire</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Ignore utility statements, unless they contain a Query */</comment>
            <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>UtilityContainsQuery</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>query</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ScanQueryForLocks</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>acquire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ScanQueryForLocks</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>acquire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * ScanQueryForLocks: recursively scan one Query for AcquirePlannerLocks.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ScanQueryForLocks</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>acquire</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rt_index</name></decl>;</decl_stmt>

    <comment type="block">/* Shouldn't get called on utility commands */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * First, process RTEs of the current query level.
     */</comment>
    <expr_stmt><expr><name>rt_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parsetree-&gt;rtable</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LOCKMODE</name></type>    <name>lockmode</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rt_index</name><operator>++</operator></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>RTE_RELATION</name></expr>:</case>
                <comment type="block">/* Acquire or release the appropriate type of lock */</comment>
                <if_stmt><if>if <condition>(<expr><name>rt_index</name> <operator>==</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>RowExclusiveLock</name></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><call><name>get_parse_rowmark</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>RowShareLock</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>acquire</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <break>break;</break>

            <case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
                <comment type="block">/* Recurse into subquery-in-FROM */</comment>
                <expr_stmt><expr><call><name>ScanQueryForLocks</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>acquire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <default>default:</default>
                <comment type="block">/* ignore other types of RTEs */</comment>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block>

    <comment type="block">/* Recurse into subquery-in-WITH */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parsetree-&gt;cteList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>CommonTableExpr</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ScanQueryForLocks</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>acquire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Recurse into sublink subqueries, too.  But we already did the ones in
     * the rtable and cteList.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>ScanQueryWalker</name></expr></argument>,
                          <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>acquire</name></expr></argument>,
                          <argument><expr><name>QTW_IGNORE_RC_SUBQUERIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Walker to find sublink subqueries for ScanQueryForLocks
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ScanQueryWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>acquire</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sub</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Do what we came for */</comment>
        <expr_stmt><expr><call><name>ScanQueryForLocks</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name><name>sub</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>acquire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Fall through to process lefthand args of SubLink */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Do NOT recurse into Query nodes, because ScanQueryForLocks already
     * processed subselects of subselects for us.
     */</comment>
    <return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ScanQueryWalker</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>acquire</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PlanCacheComputeResultDesc: given a list of analyzed-and-rewritten Queries,
 * determine the result tupledesc it will produce.  Returns NULL if the
 * execution will not return tuples.
 *
 * Note: the result is created or copied into current memory context.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleDesc</name></type>
<name>PlanCacheComputeResultDesc</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt_list</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>ChoosePortalStrategy</name><argument_list>(<argument><expr><name>stmt_list</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <case>case <expr><name>PORTAL_DISTRIBUTED</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>PORTAL_ONE_SELECT</name></expr>:</case>
        <case>case <expr><name>PORTAL_ONE_MOD_WITH</name></expr>:</case>
            <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>stmt_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>ExecCleanTypeFromTL</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>

        <case>case <expr><name>PORTAL_ONE_RETURNING</name></expr>:</case>
            <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>QueryListGetPrimaryStmt</name><argument_list>(<argument><expr><name>stmt_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>ExecCleanTypeFromTL</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>

        <case>case <expr><name>PORTAL_UTIL_SELECT</name></expr>:</case>
            <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>stmt_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>UtilityTupleDescriptor</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</return>

        <case>case <expr><name>PORTAL_MULTI_QUERY</name></expr>:</case>
            <comment type="block">/* will not return tuples */</comment>
            <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PlanCacheRelCallback
 *        Relcache inval callback function
 *
 * Invalidate all plans mentioning the given rel, or all plans mentioning
 * any rel at all if relid == InvalidOid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PlanCacheRelCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>plansource</name> <operator>=</operator> <name>first_saved_plan</name></expr>;</init> <condition><expr><name>plansource</name></expr>;</condition> <incr><expr><name>plansource</name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>next_saved</name></name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>CACHEDPLANSOURCE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* No work if it's already invalidated */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Never invalidate transaction control commands */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsTransactionStmtPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Check the dependency list for the rewritten querytree.
         */</comment>
        <if_stmt><if>if <condition>(<expr><ternary><condition><expr><operator>(</operator><name>relid</name> <operator>==</operator> <name>InvalidOid</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>plansource</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>!=</operator> <name>NIL</name></expr> </then><else>:
            <expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>relationOids</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Invalidate the querytree and generic plan */</comment>
            <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * The generic plan, if any, could have more dependencies than the
         * querytree does, so we have to check it too.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name></name> <operator>&amp;&amp;</operator> <name><name>plansource</name><operator>-&gt;</operator><name>gplan</name><operator>-&gt;</operator><name>is_valid</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name><operator>-&gt;</operator><name>stmt_list_backup</name></name></expr>)</condition>
            <block>{<block_content>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plansource-&gt;gplan-&gt;stmt_list_backup</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* Ignore utility statements */</comment>
                    <if_stmt><if>if <condition>(<expr><ternary><condition><expr><operator>(</operator><name>relid</name> <operator>==</operator> <name>InvalidOid</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>!=</operator> <name>NIL</name></expr> </then><else>:
                        <expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>relationOids</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Invalidate the generic plan only */</comment>
                        <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        <break>break;</break>        <comment type="block">/* out of stmt_list scan */</comment>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plansource-&gt;gplan-&gt;stmt_list</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* Ignore utility statements */</comment>
                <if_stmt><if>if <condition>(<expr><ternary><condition><expr><operator>(</operator><name>relid</name> <operator>==</operator> <name>InvalidOid</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>!=</operator> <name>NIL</name></expr> </then><else>:
                    <expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>relationOids</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Invalidate the generic plan only */</comment>
                    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <break>break;</break>        <comment type="block">/* out of stmt_list scan */</comment>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * PlanCacheFuncCallback
 *        Syscache inval callback function for PROCOID cache
 *
 * Invalidate all plans mentioning the object with the specified hash value,
 * or all plans mentioning any member of this cache if hashvalue == 0.
 *
 * Note that the coding would support use for multiple caches, but right
 * now only user-defined functions are tracked this way.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PlanCacheFuncCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>plansource</name> <operator>=</operator> <name>first_saved_plan</name></expr>;</init> <condition><expr><name>plansource</name></expr>;</condition> <incr><expr><name>plansource</name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>next_saved</name></name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>CACHEDPLANSOURCE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* No work if it's already invalidated */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Never invalidate transaction control commands */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsTransactionStmtPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Check the dependency list for the rewritten querytree.
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plansource-&gt;invalItems</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PlanInvalItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>(</operator><name>PlanInvalItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>cacheId</name></name> <operator>!=</operator> <name>cacheid</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>hashvalue</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                <name><name>item</name><operator>-&gt;</operator><name>hashValue</name></name> <operator>==</operator> <name>hashvalue</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Invalidate the querytree and generic plan */</comment>
                <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <comment type="block">/*
         * The generic plan, if any, could have more dependencies than the
         * querytree does, so we have to check it too.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name></name> <operator>&amp;&amp;</operator> <name><name>plansource</name><operator>-&gt;</operator><name>gplan</name><operator>-&gt;</operator><name>is_valid</name></name></expr>)</condition>
        <block>{<block_content>
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plansource-&gt;gplan-&gt;stmt_list</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc3</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* Ignore utility statements */</comment>
                <macro><name>foreach</name><argument_list>(<argument>lc3</argument>, <argument>plannedstmt-&gt;invalItems</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>PlanInvalItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>(</operator><name>PlanInvalItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>cacheId</name></name> <operator>!=</operator> <name>cacheid</name></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name>hashvalue</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                        <name><name>item</name><operator>-&gt;</operator><name>hashValue</name></name> <operator>==</operator> <name>hashvalue</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Invalidate the generic plan only */</comment>
                        <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        <break>break;</break>    <comment type="block">/* out of invalItems scan */</comment>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name><operator>-&gt;</operator><name>is_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>        <comment type="block">/* out of stmt_list scan */</comment>
            </block_content>}</block>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * PlanCacheSysCallback
 *        Syscache inval callback function for other caches
 *
 * Just invalidate everything...
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PlanCacheSysCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ResetPlanCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ResetPlanCache: invalidate all cached plans.
 */</comment>
<function><type><name>void</name></type>
<name>ResetPlanCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>plansource</name> <operator>=</operator> <name>first_saved_plan</name></expr>;</init> <condition><expr><name>plansource</name></expr>;</condition> <incr><expr><name>plansource</name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>next_saved</name></name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>CACHEDPLANSOURCE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* No work if it's already invalidated */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * We *must not* mark transaction control statements as invalid,
         * particularly not ROLLBACK, because they may need to be executed in
         * aborted transactions when we can't revalidate them (cf bug #5269).
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsTransactionStmtPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * In general there is no point in invalidating utility statements
         * since they have no plans anyway.  So invalidate it only if it
         * contains at least one non-utility statement, or contains a utility
         * statement that contains a pre-analyzed query (which could have
         * dependencies.)
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plansource-&gt;query_list</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_UTILITY</name> <operator>||</operator>
                <call><name>UtilityContainsQuery</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* non-utility statement, so invalidate */</comment>
                <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <comment type="block">/* no need to look further */</comment>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></for>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>SetRemoteSubplan</name><parameter_list>(<parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>plan_string</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CachedPlan</name>            <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>         <name>plan_context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>         <name>oldcxt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteStmt</name>            <modifier>*</modifier></type><name>rstmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlannedStmt</name>        <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>IS_PGXC_DATANODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>raw_parse_tree</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_list</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Make dedicated query context to store cached plan. It is in current
     * memory context for now, later it will be reparented to
     * CachedMemoryContext. If it is in CachedMemoryContext initially we would
     * have to destroy it in case of error.
     */</comment>
    <expr_stmt><expr><name>plan_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                         <argument><expr><literal type="string">"CachedPlan"</literal></expr></argument>,
                                         <argument><expr><name>ALLOCSET_SMALL_MINSIZE</name></expr></argument>,
                                         <argument><expr><name>ALLOCSET_SMALL_INITSIZE</name></expr></argument>,
                                         <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>plan_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Restore query plan.
     *
     * A try-catch block to ensure that we don't leave behind a stale state
     * if nodeToString fails for whatever reason.
     *
     * XXX We should probably rewrite it someday by either passing a
     * context to nodeToString() or remembering this information somewhere
     * else which gets reset in case of errors. But for now, this seems
     * enough.
     */</comment>
    <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
	    <comment type="block">/*
	     * Check for shared-cache-inval messages before restoring query plan,
	     * avoid oid conversion and other operations to find old data.
	     */</comment>
        <expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>set_portable_input</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rstmt</name> <operator>=</operator> <operator>(</operator><name>RemoteStmt</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>plan_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>set_portable_input</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_portable_input</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>hasReturning</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>hasReturning</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>transientPlan</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="line">// ???</comment>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>planTree</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>planTree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>resultRelations</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>resultRelations</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>subplans</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>rewindPlanIDs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>invalItems</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>nParamExec</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>nParamExec</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>nParamRemote</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>nParamRemote</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>remoteparams</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>remoteparams</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>pname</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>stmt_name</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>distributionType</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>distributionKey</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>distributionNodes</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>distributionNodes</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>distributionRestrict</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>distributionRestrict</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>haspart_tobe_modify</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>haspart_tobe_modify</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>partrelindex</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>partrelindex</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>partpruning</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>partpruning</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>HeavyLockCheck</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>queryString</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>queryString</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>parseTree</name></name> <operator>=</operator> <name><name>rstmt</name><operator>-&gt;</operator><name>parseTree</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* register sigusr2 handler for remotesubplan */</comment>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>RemoteSubplanSigusr2Handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Set up SharedQueue if intermediate results need to be distributed
     * on multiple destination Datanodes.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsConnFromDatanode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>pname</name></name> <operator>&amp;&amp;</operator>
            <call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>distributionRestrict</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>with_params</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>numParallelWorkers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>rstmt</name><operator>-&gt;</operator><name>parallelWorkerSendTuple</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Gather</name> <modifier>*</modifier></type><name>gather_plan</name> <init>= <expr><operator>(</operator><name>Gather</name> <operator>*</operator><operator>)</operator><name><name>stmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>numParallelWorkers</name> <operator>=</operator> <name><name>gather_plan</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>paramPassDown</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>nParamRemote</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name><name>stmt</name><operator>-&gt;</operator><name>remoteparams</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>nParamRemote</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>paramkind</name> <operator>==</operator> <name>PARAM_EXEC</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>with_params</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
         
        <expr_stmt><expr><call><name>SharedQueueAcquire</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>pname</name></name></expr></argument>,
                           <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>distributionRestrict</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
                           <argument><expr><name><name>rstmt</name><operator>-&gt;</operator><name>parallelWorkerSendTuple</name></name></expr></argument>, <argument><expr><name>numParallelWorkers</name></expr></argument>, <argument><expr><name>with_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>distributed_query_analyze</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>StoreQueryAnalyzeInfo</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>pname</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>SharedQueueAcquire</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>pname</name></name></expr></argument>,
                           <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>distributionRestrict</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Create and fill the CachedPlan struct within the new context.
     */</comment>
    <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>CachedPlan</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CachedPlan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>CACHEDPLAN_MAGIC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>stmt_list</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>saved_xmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>refcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* will be referenced by plansource */</comment>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name>plan_context</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>dependsOnRole</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>is_saved</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name>plan_context</name></expr></argument>, <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>is_saved</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name>plan_context</name></expr></argument>,
                               <argument><expr><call><name>MemoryContextGetParent</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>is_saved</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>is_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>is_oneshot</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>stmt_list_backup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>plansource</name><operator>-&gt;</operator><name>gplan</name></name> <operator>=</operator> <name>plan</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
