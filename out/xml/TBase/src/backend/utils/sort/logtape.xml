<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/sort/logtape.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * logtape.c
 *      Management of "logical tapes" within temporary files.
 *
 * This module exists to support sorting via multiple merge passes (see
 * tuplesort.c).  Merging is an ideal algorithm for tape devices, but if
 * we implement it on disk by creating a separate file for each "tape",
 * there is an annoying problem: the peak space usage is at least twice
 * the volume of actual data to be sorted.  (This must be so because each
 * datum will appear in both the input and output tapes of the final
 * merge pass.  For seven-tape polyphase merge, which is otherwise a
 * pretty good algorithm, peak usage is more like 4x actual data volume.)
 *
 * We can work around this problem by recognizing that any one tape
 * dataset (with the possible exception of the final output) is written
 * and read exactly once in a perfectly sequential manner.  Therefore,
 * a datum once read will not be required again, and we can recycle its
 * space for use by the new tape dataset(s) being generated.  In this way,
 * the total space usage is essentially just the actual data volume, plus
 * insignificant bookkeeping and start/stop overhead.
 *
 * Few OSes allow arbitrary parts of a file to be released back to the OS,
 * so we have to implement this space-recycling ourselves within a single
 * logical file.  logtape.c exists to perform this bookkeeping and provide
 * the illusion of N independent tape devices to tuplesort.c.  Note that
 * logtape.c itself depends on buffile.c to provide a "logical file" of
 * larger size than the underlying OS may support.
 *
 * For simplicity, we allocate and release space in the underlying file
 * in BLCKSZ-size blocks.  Space allocation boils down to keeping track
 * of which blocks in the underlying file belong to which logical tape,
 * plus any blocks that are free (recycled and not yet reused).
 * The blocks in each logical tape form a chain, with a prev- and next-
 * pointer in each block.
 *
 * The initial write pass is guaranteed to fill the underlying file
 * perfectly sequentially, no matter how data is divided into logical tapes.
 * Once we begin merge passes, the access pattern becomes considerably
 * less predictable --- but the seeking involved should be comparable to
 * what would happen if we kept each logical tape in a separate file,
 * so there's no serious performance penalty paid to obtain the space
 * savings of recycling.  We try to localize the write accesses by always
 * writing to the lowest-numbered free block when we have a choice; it's
 * not clear this helps much, but it can't hurt.  (XXX perhaps a LIFO
 * policy for free blocks would be better?)
 *
 * To further make the I/Os more sequential, we can use a larger buffer
 * when reading, and read multiple blocks from the same tape in one go,
 * whenever the buffer becomes empty.  LogicalTapeAssignReadBufferSize()
 * can be used to set the size of the read buffer.
 *
 * To support the above policy of writing to the lowest free block,
 * ltsGetFreeBlock sorts the list of free block numbers into decreasing
 * order each time it is asked for a block and the list isn't currently
 * sorted.  This is an efficient way to handle it because we expect cycles
 * of releasing many blocks followed by re-using many blocks, due to
 * the larger read buffer.
 *
 * Since all the bookkeeping and buffer memory is allocated with palloc(),
 * and the underlying file(s) are made with OpenTemporaryFile, all resources
 * for a logical tape set are certain to be cleaned up even if processing
 * is aborted by ereport(ERROR).  To avoid confusion, the caller should take
 * care that all calls for a single LogicalTapeSet are made in the same
 * palloc context.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *      src/backend/utils/sort/logtape.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buffile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/logtape.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<comment type="block">/*
 * A TapeBlockTrailer is stored at the end of each BLCKSZ block.
 *
 * The first block of a tape has prev == -1.  The last block of a tape
 * stores the number of valid bytes on the block, inverted, in 'next'
 * Therefore next &lt; 0 indicates the last block.
 */</comment>
<typedef>typedef <type><struct>struct <name>TapeBlockTrailer</name>
<block>{
    <decl_stmt><decl><type><name>long</name></type>        <name>prev</name></decl>;</decl_stmt>            <comment type="block">/* previous block on this tape, or -1 on first
                                 * block */</comment>
    <decl_stmt><decl><type><name>long</name></type>        <name>next</name></decl>;</decl_stmt>            <comment type="block">/* next block on this tape, or # of valid
                                 * bytes on last block (if &lt; 0) */</comment>
}</block></struct></type> <name>TapeBlockTrailer</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TapeBlockPayloadSize</name></cpp:macro>  <cpp:value>(BLCKSZ - sizeof(TapeBlockTrailer))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TapeBlockGetTrailer</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>((TapeBlockTrailer *) ((char *) buf + TapeBlockPayloadSize))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TapeBlockIsLast</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(TapeBlockGetTrailer(buf)-&gt;next &lt; 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TapeBlockGetNBytes</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>(TapeBlockIsLast(buf) ? \
     (- TapeBlockGetTrailer(buf)-&gt;next) : TapeBlockPayloadSize)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TapeBlockSetNBytes</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>, <parameter><type><name>nbytes</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>(TapeBlockGetTrailer(buf)-&gt;next = -(nbytes))</cpp:value></cpp:define>


<comment type="block">/*
 * This data structure represents a single "logical tape" within the set
 * of logical tapes stored in the same file.
 *
 * While writing, we hold the current partially-written data block in the
 * buffer.  While reading, we can hold multiple blocks in the buffer.  Note
 * that we don't retain the trailers of a block when it's read into the
 * buffer.  The buffer therefore contains one large contiguous chunk of data
 * from the tape.
 */</comment>
<typedef>typedef <type><struct>struct <name>LogicalTape</name>
<block>{
    <decl_stmt><decl><type><name>bool</name></type>        <name>writing</name></decl>;</decl_stmt>        <comment type="block">/* T while in write phase */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>frozen</name></decl>;</decl_stmt>            <comment type="block">/* T if blocks should not be freed when read */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>dirty</name></decl>;</decl_stmt>            <comment type="block">/* does buffer need to be written? */</comment>

    <comment type="block">/*
     * Block numbers of the first, current, and next block of the tape.
     *
     * The "current" block number is only valid when writing, or reading from
     * a frozen tape.  (When reading from an unfrozen tape, we use a larger
     * read buffer that holds multiple blocks, so the "current" block is
     * ambiguous.)
     */</comment>
    <decl_stmt><decl><type><name>long</name></type>        <name>firstBlockNumber</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>curBlockNumber</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>nextBlockNumber</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Buffer for current data block(s).
     */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>            <comment type="block">/* physical buffer (separately palloc'd) */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>buffer_size</name></decl>;</decl_stmt>    <comment type="block">/* allocated size of the buffer */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>pos</name></decl>;</decl_stmt>            <comment type="block">/* next read/write position in buffer */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>nbytes</name></decl>;</decl_stmt>            <comment type="block">/* total # of valid bytes in buffer */</comment>
}</block></struct></type> <name>LogicalTape</name>;</typedef>

<comment type="block">/*
 * This data structure represents a set of related "logical tapes" sharing
 * space in a single underlying file.  (But that "file" may be multiple files
 * if needed to escape OS limits on file size; buffile.c handles that for us.)
 * The number of tapes is fixed at creation.
 */</comment>
<struct>struct <name>LogicalTapeSet</name>
<block>{
    <decl_stmt><decl><type><name>BufFile</name>    <modifier>*</modifier></type><name>pfile</name></decl>;</decl_stmt>            <comment type="block">/* underlying file for whole tape set */</comment>

    <comment type="block">/*
     * File size tracking.  nBlocksWritten is the size of the underlying file,
     * in BLCKSZ blocks.  nBlocksAllocated is the number of blocks allocated
     * by ltsGetFreeBlock(), and it is always greater than or equal to
     * nBlocksWritten.  Blocks between nBlocksAllocated and nBlocksWritten are
     * blocks that have been allocated for a tape, but have not been written
     * to the underlying file yet.
     */</comment>
    <decl_stmt><decl><type><name>long</name></type>        <name>nBlocksAllocated</name></decl>;</decl_stmt>    <comment type="block">/* # of blocks allocated */</comment>
    <decl_stmt><decl><type><name>long</name></type>        <name>nBlocksWritten</name></decl>;</decl_stmt> <comment type="block">/* # of blocks used in underlying file */</comment>

    <comment type="block">/*
     * We store the numbers of recycled-and-available blocks in freeBlocks[].
     * When there are no such blocks, we extend the underlying file.
     *
     * If forgetFreeSpace is true then any freed blocks are simply forgotten
     * rather than being remembered in freeBlocks[].  See notes for
     * LogicalTapeSetForgetFreeSpace().
     *
     * If blocksSorted is true then the block numbers in freeBlocks are in
     * *decreasing* order, so that removing the last entry gives us the lowest
     * free block.  We re-sort the blocks whenever a block is demanded; this
     * should be reasonably efficient given the expected usage pattern.
     */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>forgetFreeSpace</name></decl>;</decl_stmt>    <comment type="block">/* are we remembering free blocks? */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>blocksSorted</name></decl>;</decl_stmt>    <comment type="block">/* is freeBlocks[] currently in order? */</comment>
    <decl_stmt><decl><type><name>long</name>       <modifier>*</modifier></type><name>freeBlocks</name></decl>;</decl_stmt>        <comment type="block">/* resizable array */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>nFreeBlocks</name></decl>;</decl_stmt>    <comment type="block">/* # of currently free blocks */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>freeBlocksLen</name></decl>;</decl_stmt>    <comment type="block">/* current allocated length of freeBlocks[] */</comment>

    <comment type="block">/* The array of logical tapes. */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>nTapes</name></decl>;</decl_stmt>            <comment type="block">/* # of logical tapes in set */</comment>
    <decl_stmt><decl><type><name>LogicalTape</name></type> <name><name>tapes</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* has nTapes nentries */</comment>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ltsWriteBlock</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ltsReadBlock</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>long</name></type> <name>ltsGetFreeBlock</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ltsReleaseBlock</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>blocknum</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Write a block-sized buffer to the specified block of the underlying file.
 *
 * No need for an error return convention; we ereport() on any error.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ltsWriteBlock</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * BufFile does not support "holes", so if we're about to write a block
     * that's past the current end of file, fill the space between the current
     * end of file and the target block with zeros.
     *
     * This should happen rarely, otherwise you are not writing very
     * sequentially.  In current use, this only happens when the sort ends
     * writing a run, and switches to another tape.  The last block of the
     * previous tape isn't flushed to disk until the end of the sort, so you
     * get one-block hole, where the last block of the previous tape will
     * later go.
     */</comment>
    <while>while <condition>(<expr><name>blocknum</name> <operator>&gt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nBlocksWritten</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>zerobuf</name><index>[<expr><name>BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>zerobuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zerobuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ltsWriteBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name><name>lts</name><operator>-&gt;</operator><name>nBlocksWritten</name></name></expr></argument>, <argument><expr><name>zerobuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Write the requested block */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>BufFileSeekBlock</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>pfile</name></name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>pfile</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write block %ld of temporary file: %m"</literal></expr></argument>,
                        <argument><expr><name>blocknum</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Update nBlocksWritten, if we extended the file */</comment>
    <if_stmt><if>if <condition>(<expr><name>blocknum</name> <operator>==</operator> <name><name>lts</name><operator>-&gt;</operator><name>nBlocksWritten</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>nBlocksWritten</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read a block-sized buffer from the specified block of the underlying file.
 *
 * No need for an error return convention; we ereport() on any error.   This
 * module should never attempt to read a block it doesn't know is there.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ltsReadBlock</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>BufFileSeekBlock</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>pfile</name></name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>pfile</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read block %ld of temporary file: %m"</literal></expr></argument>,
                        <argument><expr><name>blocknum</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read as many blocks as we can into the per-tape buffer.
 *
 * Returns true if anything was read, 'false' on EOF.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ltsReadFillBuffer</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <do>do
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>thisbuf</name> <init>= <expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Fetch next block number */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1L</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* EOF */</comment>

        <comment type="block">/* Read the block */</comment>
        <expr_stmt><expr><call><name>ltsReadBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>thisbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lt</name><operator>-&gt;</operator><name>frozen</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ltsReleaseBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>+=</operator> <call><name>TapeBlockGetNBytes</name><argument_list>(<argument><expr><name>thisbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>TapeBlockIsLast</name><argument_list>(<argument><expr><name>thisbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt>
            <comment type="block">/* EOF */</comment>
            <break>break;</break>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name> <operator>=</operator> <call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name>thisbuf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* Advance to next block, if we have buffer space left */</comment>
    </block_content>}</block> while <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>-</operator> <name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>&gt;</operator> <name>BLCKSZ</name></expr>)</condition>;</do>

    <return>return <expr><operator>(</operator><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator for sorting freeBlocks[] into decreasing order.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>freeBlocks_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>long</name></type>        <name>ablk</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>long</name> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>bblk</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>long</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <comment type="block">/* can't just subtract because long might be wider than int */</comment>
    <if_stmt><if>if <condition>(<expr><name>ablk</name> <operator>&lt;</operator> <name>bblk</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>ablk</name> <operator>&gt;</operator> <name>bblk</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Select a currently unused block for writing to.
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>ltsGetFreeBlock</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * If there are multiple free blocks, we select the one appearing last in
     * freeBlocks[] (after sorting the array if needed).  If there are none,
     * assign the next block at the end of the file.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>lts</name><operator>-&gt;</operator><name>nFreeBlocks</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lts</name><operator>-&gt;</operator><name>blocksSorted</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>lts</name><operator>-&gt;</operator><name>freeBlocks</name></name></expr></argument>, <argument><expr><name><name>lts</name><operator>-&gt;</operator><name>nFreeBlocks</name></name></expr></argument>,
                  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>freeBlocks_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>blocksSorted</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocks</name><index>[<expr><operator>--</operator><name><name>lts</name><operator>-&gt;</operator><name>nFreeBlocks</name></name></expr>]</index></name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name><name>lts</name><operator>-&gt;</operator><name>nBlocksAllocated</name></name><operator>++</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return a block# to the freelist.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ltsReleaseBlock</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>blocknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>ndx</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Do nothing if we're no longer interested in remembering free space.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>lts</name><operator>-&gt;</operator><name>forgetFreeSpace</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Enlarge freeBlocks array if full.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>lts</name><operator>-&gt;</operator><name>nFreeBlocks</name></name> <operator>&gt;=</operator> <name><name>lts</name><operator>-&gt;</operator><name>freeBlocksLen</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocksLen</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocks</name></name> <operator>=</operator> <operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocks</name></name></expr></argument>,
                                            <argument><expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocksLen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Add blocknum to array, and mark the array unsorted if it's no longer in
     * decreasing order.
     */</comment>
    <expr_stmt><expr><name>ndx</name> <operator>=</operator> <name><name>lts</name><operator>-&gt;</operator><name>nFreeBlocks</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocks</name><index>[<expr><name>ndx</name></expr>]</index></name> <operator>=</operator> <name>blocknum</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ndx</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>lts</name><operator>-&gt;</operator><name>freeBlocks</name><index>[<expr><name>ndx</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name>blocknum</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>blocksSorted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a set of logical tapes in a temporary underlying file.
 *
 * Each tape is initialized in write state.
 */</comment>
<function><type><name>LogicalTapeSet</name> <modifier>*</modifier></type>
<name>LogicalTapeSetCreate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ntapes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Create top-level struct including per-tape LogicalTape structs.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ntapes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lts</name> <operator>=</operator> <operator>(</operator><name>LogicalTapeSet</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>LogicalTapeSet</name></expr></argument>, <argument><expr><name>tapes</name></expr></argument>)</argument_list></call> <operator>+</operator>
                                    <name>ntapes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LogicalTape</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>pfile</name></name> <operator>=</operator> <call><name>BufFileCreateTemp</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>nBlocksAllocated</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>nBlocksWritten</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>forgetFreeSpace</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>blocksSorted</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>    <comment type="block">/* a zero-length array is sorted ... */</comment>
    <expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocksLen</name></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>    <comment type="block">/* reasonable initial guess */</comment>
    <expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocks</name></name> <operator>=</operator> <operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocksLen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>nFreeBlocks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name> <operator>=</operator> <name>ntapes</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize per-tape structs.  Note we allocate the I/O buffer and the
     * first block for a tape only when it is first actually written to.  This
     * avoids wasting memory space when tuplesort.c overestimates the number
     * of tapes needed.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntapes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>frozen</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>dirty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>lts</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Close a logical tape set and release all resources.
 */</comment>
<function><type><name>void</name></type>
<name>LogicalTapeSetClose</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>pfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Mark a logical tape set as not needing management of free space anymore.
 *
 * This should be called if the caller does not intend to write any more data
 * into the tape set, but is reading from un-frozen tapes.  Since no more
 * writes are planned, remembering free blocks is no longer useful.  Setting
 * this flag lets us avoid wasting time and space in ltsReleaseBlock(), which
 * is not designed to handle large numbers of free blocks.
 */</comment>
<function><type><name>void</name></type>
<name>LogicalTapeSetForgetFreeSpace</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>forgetFreeSpace</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write to a logical tape.
 *
 * There are no error returns; we ereport() on failure.
 */</comment>
<function><type><name>void</name></type>
<name>LogicalTapeWrite</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>,
                 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>nthistime</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tapenum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tapenum</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>tapenum</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Allocate data buffer and first block on first write */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>=</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>=</operator> <call><name>ltsGetFreeBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>prev</name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>==</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>&gt;=</operator> <name>TapeBlockPayloadSize</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Buffer full, dump it out */</comment>
            <decl_stmt><decl><type><name>long</name></type>        <name>nextBlockNumber</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lt</name><operator>-&gt;</operator><name>dirty</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Hmm, went directly from reading to writing? */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid logtape state: should be dirty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * First allocate the next block, so that we can store it in the
             * 'next' pointer of this block.
             */</comment>
            <expr_stmt><expr><name>nextBlockNumber</name> <operator>=</operator> <call><name>ltsGetFreeBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* set the next-pointer and dump the current block. */</comment>
            <expr_stmt><expr><call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name> <operator>=</operator> <name>nextBlockNumber</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ltsWriteBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* initialize the prev-pointer of the next block */</comment>
            <expr_stmt><expr><call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>prev</name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>=</operator> <name>nextBlockNumber</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>nthistime</name> <operator>=</operator> <name>TapeBlockPayloadSize</name> <operator>-</operator> <name><name>lt</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nthistime</name> <operator>&gt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nthistime</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nthistime</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name><name>lt</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>nthistime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>dirty</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>+=</operator> <name>nthistime</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>&lt;</operator> <name><name>lt</name><operator>-&gt;</operator><name>pos</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <name>nthistime</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> <operator>-=</operator> <name>nthistime</name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Rewind logical tape and switch from writing to reading.
 *
 * The tape must currently be in writing state, or "frozen" in read state.
 *
 * 'buffer_size' specifies how much memory to use for the read buffer.
 * Regardless of the argument, the actual amount of memory used is between
 * BLCKSZ and MaxAllocSize, and is a multiple of BLCKSZ.  The given value is
 * rounded down and truncated to fit those constraints, if necessary.  If the
 * tape is frozen, the 'buffer_size' argument is ignored, and a small BLCKSZ
 * byte buffer is used.
 */</comment>
<function><type><name>void</name></type>
<name>LogicalTapeRewindForRead</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buffer_size</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tapenum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tapenum</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>tapenum</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Round and cap buffer_size if needed.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>frozen</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>buffer_size</name> <operator>=</operator> <name>BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* need at least one block */</comment>
        <if_stmt><if>if <condition>(<expr><name>buffer_size</name> <operator>&lt;</operator> <name>BLCKSZ</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>buffer_size</name> <operator>=</operator> <name>BLCKSZ</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * palloc() larger than MaxAllocSize would fail (a multi-gigabyte
         * buffer is unlikely to be helpful, anyway)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>buffer_size</name> <operator>&gt;</operator> <name>MaxAllocSize</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>buffer_size</name> <operator>=</operator> <name>MaxAllocSize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* round down to BLCKSZ boundary */</comment>
        <expr_stmt><expr><name>buffer_size</name> <operator>-=</operator> <name>buffer_size</name> <operator>%</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Completion of a write phase.  Flush last partial data block, and
         * rewind for normal (destructive) read.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>dirty</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>TapeBlockSetNBytes</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ltsWriteBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * This is only OK if tape is frozen; we rewind for (another) read
         * pass.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>frozen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Allocate a read buffer (unless the tape is empty) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1L</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>buffer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>=</operator> <name>buffer_size</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Read the first block, or reset if tape is empty */</comment>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ltsReadFillBuffer</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Rewind logical tape and switch from reading to writing.
 *
 * NOTE: we assume the caller has read the tape to the end; otherwise
 * untouched data will not have been freed. We could add more code to free
 * any unread blocks, but in current usage of this module it'd be useless
 * code.
 */</comment>
<function><type><name>void</name></type>
<name>LogicalTapeRewindForWrite</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tapenum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tapenum</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>tapenum</name></expr>]</index></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>lt</name><operator>-&gt;</operator><name>frozen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>dirty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read from a logical tape.
 *
 * Early EOF is indicated by return value less than #bytes requested.
 */</comment>
<function><type><name>size_t</name></type>
<name>LogicalTapeRead</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>,
                <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>nread</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>nthistime</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tapenum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tapenum</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>tapenum</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>&gt;=</operator> <name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Try to load more data into buffer. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ltsReadFillBuffer</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>            <comment type="block">/* EOF */</comment>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>nthistime</name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>-</operator> <name><name>lt</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nthistime</name> <operator>&gt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nthistime</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nthistime</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name><name>lt</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name>nthistime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>+=</operator> <name>nthistime</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <name>nthistime</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> <operator>-=</operator> <name>nthistime</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nread</name> <operator>+=</operator> <name>nthistime</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>nread</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * "Freeze" the contents of a tape so that it can be read multiple times
 * and/or read backwards.  Once a tape is frozen, its contents will not
 * be released until the LogicalTapeSet is destroyed.  This is expected
 * to be used only for the final output pass of a merge.
 *
 * This *must* be called just at the end of a write pass, before the
 * tape is rewound (after rewind is too late!).  It performs a rewind
 * and switch to read mode "for free".  An immediately following rewind-
 * for-read call is OK but not necessary.
 */</comment>
<function><type><name>void</name></type>
<name>LogicalTapeFreeze</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tapenum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tapenum</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>tapenum</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Completion of a write phase.  Flush last partial data block, and rewind
     * for nondestructive read.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>dirty</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>TapeBlockSetNBytes</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ltsWriteBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>frozen</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/*
     * The seek and backspace functions assume a single block read buffer.
     * That's OK with current usage.  A larger buffer is helpful to make the
     * read pattern of the backing file look more sequential to the OS, when
     * we're reading from multiple tapes.  But at the end of a sort, when a
     * tape is frozen, we only read from a single tape anyway.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>||</operator> <name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>=</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Read the first block, or reset if tape is empty */</comment>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1L</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>ltsReadBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>TapeBlockIsLast</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name> <operator>=</operator> <call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <call><name>TapeBlockGetNBytes</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Backspace the tape a given number of bytes.  (We also support a more
 * general seek interface, see below.)
 *
 * *Only* a frozen-for-read tape can be backed up; we don't support
 * random access during write, and an unfrozen read tape may have
 * already discarded the desired data!
 *
 * Returns the number of bytes backed up.  It can be less than the
 * requested amount, if there isn't that much data before the current
 * position.  The tape is positioned to the beginning of the tape in
 * that case.
 */</comment>
<function><type><name>size_t</name></type>
<name>LogicalTapeBackspace</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>seekpos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tapenum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tapenum</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>tapenum</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>frozen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>==</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Easy case for seek within current block.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name><name>lt</name><operator>-&gt;</operator><name>pos</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>size</name></expr>;</expr_stmt>
        <return>return <expr><name>size</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Not-so-easy case, have to walk back the chain of blocks.  This
     * implementation would be pretty inefficient for long seeks, but we
     * really aren't doing that (a seek over one tuple is typical).
     */</comment>
    <expr_stmt><expr><name>seekpos</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name><name>lt</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt> <comment type="block">/* part within this block */</comment>
    <while>while <condition>(<expr><name>size</name> <operator>&gt;</operator> <name>seekpos</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type>        <name>prev</name> <init>= <expr><call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>prev</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>prev</name> <operator>==</operator> <operator>-</operator><literal type="number">1L</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Tried to back up beyond the beginning of tape. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>!=</operator> <name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of tape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <return>return <expr><name>seekpos</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ltsReadBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name> <operator>!=</operator> <name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"broken tape, next of block %ld is %ld, expected %ld"</literal></expr></argument>,
                 <argument><expr><name>prev</name></expr></argument>,
                 <argument><expr><call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr></argument>,
                 <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <name>TapeBlockPayloadSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name> <operator>=</operator> <call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>seekpos</name> <operator>+=</operator> <name>TapeBlockPayloadSize</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * 'seekpos' can now be greater than 'size', because it points to the
     * beginning the target block.  The difference is the position within the
     * page.
     */</comment>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>seekpos</name> <operator>-</operator> <name>size</name></expr>;</expr_stmt>
    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Seek to an arbitrary position in a logical tape.
 *
 * *Only* a frozen-for-read tape can be seeked.
 *
 * Must be called with a block/offset previously returned by
 * LogicalTapeTell().
 */</comment>
<function><type><name>void</name></type>
<name>LogicalTapeSeek</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>,
                <parameter><decl><type><name>long</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tapenum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tapenum</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>tapenum</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>frozen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&lt;=</operator> <name>TapeBlockPayloadSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>==</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>blocknum</name> <operator>!=</operator> <name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ltsReadBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>=</operator> <name>blocknum</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <name>TapeBlockPayloadSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name> <operator>=</operator> <call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tape seek position"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Obtain current position in a form suitable for a later LogicalTapeSeek.
 *
 * NOTE: it'd be OK to do this during write phase with intention of using
 * the position for a seek after freezing.  Not clear if anyone needs that.
 */</comment>
<function><type><name>void</name></type>
<name>LogicalTapeTell</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>,
                <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>blocknum</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tapenum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tapenum</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>tapenum</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* With a larger buffer, 'pos' wouldn't be the same as offset within page */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>==</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>blocknum</name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>offset</name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Obtain total disk space currently used by a LogicalTapeSet, in blocks.
 */</comment>
<function><type><name>long</name></type>
<name>LogicalTapeSetBlocks</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>lts</name><operator>-&gt;</operator><name>nBlocksAllocated</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
