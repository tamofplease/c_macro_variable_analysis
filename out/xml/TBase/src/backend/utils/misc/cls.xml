<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/misc/cls.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_mls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tuptable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lockdefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/palloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/cls.h"</cpp:file></cpp:include>

<comment type="block">/*
 * cls column value in every row
 */</comment>
<typedef>typedef <type><struct>struct <name>ClsItem</name>
<block>{
    <decl_stmt><decl><type><name>int16</name></type> <name>polid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type> <name>labelid</name></decl>;</decl_stmt>
}</block></struct></type><name>ClsItem</name>;</typedef>

<comment type="block">/*
 * stands for one label
 */</comment>
<typedef>typedef <type><struct>struct <name>tagClsLabel</name>
<block>{
    <decl_stmt><decl><type><name>int16</name></type>  <name>levelid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type> <name>compartmentlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type> <name>grouptree</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type> <name>unionset</name></decl>;</decl_stmt>
}</block></struct></type><name>ClsLabel</name>;</typedef>

<comment type="block">/*
 * every user has one of this global variable 
 */</comment>
<typedef>typedef <type><struct>struct <name>tagClsUserAuthority</name>
<block>{
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type> <name>polid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type> <name>privilege</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type> <name>max_read_label</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type> <name>max_write_label</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type> <name>min_write_label</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type> <name>default_read_label</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type> <name>default_write_label</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type> <name>default_row_label</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ClsLabel</name> <modifier>*</modifier></type> <name>def_read_label_stru</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ClsLabel</name> <modifier>*</modifier></type> <name>def_write_label_stru</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ClsLabel</name> <modifier>*</modifier></type> <name>def_row_label_stru</name></decl>;</decl_stmt>
}</block></struct></type><name>ClsUserAuthority</name>;</typedef>

<typedef>typedef <type><struct>struct <name>tagClsGroupInfo</name>
<block>{
    <decl_stmt><decl><type><name>int</name></type>     <name>childid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>parentid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>    <name>valid</name></decl>;</decl_stmt>
}</block></struct></type><name>ClsGroupInfo</name>;</typedef>

<comment type="block">/* every user has one of this global variable */</comment>
<decl_stmt><decl><type><name>ClsUserAuthority</name></type> <name>g_user_cls_priv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>g_command_tag_enum</name> <init>= <expr><name>CLS_CMD_UNKNOWN</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* only the parent of root node could be invalid node, other has only one parent */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLS_GROUP_INVALID_NODE</name></cpp:macro>              <cpp:value>-1</cpp:value></cpp:define>
<comment type="block">/* zero mean invalid */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLS_INVALID_POLICY_ID</name></cpp:macro>               <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLS_ARRAY_NUM</name><parameter_list>(<parameter><type><name>CLS_ARRAY</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>(ARR_DIMS(CLS_ARRAY)[0])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLS_ARRAY_DAT</name><parameter_list>(<parameter><type><name>CLS_ARRAY</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>((ClsItem *) ARR_DATA_PTR(CLS_ARRAY))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLS_ARRAY_N_SIZE</name><parameter_list>(<parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro>         <cpp:value>(ARR_OVERHEAD_NONULLS(1) + ((N) * sizeof(ClsItem)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLS_ARRAY_SIZE</name><parameter_list>(<parameter><type><name>CLS_ARRAY</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>ARR_SIZE(CLS_ARRAY)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DatumGetClsItemP</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>        <cpp:value>((ClsItem *) DatumGetPointer(X))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_GETARG_CLSITEM_P</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>     <cpp:value>DatumGetClsItemP(PG_GETARG_DATUM(n))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_RETURN_CLSITEM_P</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>     <cpp:value>PG_RETURN_POINTER(x)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLS_MAX_POLICY_ID_STRING_LEN</name></cpp:macro>    <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLS_MAX_LABEL_ID_STRING_LEN</name></cpp:macro>     <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLS_DELIMETER_STRING_LEN</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLS_MAX_CLS_ITEM_STRING_LEN</name></cpp:macro>     <cpp:value>(CLS_MAX_POLICY_ID_STRING_LEN+CLS_DELIMETER_STRING_LEN+CLS_MAX_LABEL_ID_STRING_LEN)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLS_TDCLSCOL_CHANGE_TO_ATTNUM</name><parameter_list>(<parameter><type><name>_tdclscol</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((_tdclscol)-1)</cpp:value></cpp:define>

<comment type="block">/* check current user was in the same policy with '_polid' */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLS_AUTH_CHECK_IN_POLICY</name><parameter_list>(<parameter><type><name>_polid</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((g_user_cls_priv.polid == (_polid)) &amp;&amp; (CLS_INVALID_POLICY_ID != (_polid)))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cls_parse_clsitem_and_assign</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>ClsItem</name> <modifier>*</modifier></type> <name>clstiem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int16</name></type> <name>cls_check_table_has_cls_policy</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ClsLabel</name> <modifier>*</modifier></type> <name>cls_get_label</name><parameter_list>(<parameter><decl><type><name>int16</name></type> <name>polid</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>labelid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ClsExprStruct</name> <modifier>*</modifier></type> <name>cls_create_func_expr</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>cls_check_write</name><parameter_list>(<parameter><decl><type><name>ClsItem</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>cls_check_read</name><parameter_list>(<parameter><decl><type><name>ClsItem</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>cls_parse_compartment</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>compartment_datum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>cls_parse_group</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>group_datum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>list_compare_int</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type> <name>list1</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type> <name>list2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>cls_group_node_match_child_and_parent</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>polid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>childid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>parentid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>cls_get_clscol_from_pg_attribute</name><parameter_list>(<parameter><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>attrs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>array_datum_convert_to_int2_list</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>cls_group_compare</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>polid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type> <name>rowgrouplist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type> <name>usergrouplist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>cls_compartment_compare</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type> <name>rowcompartmentlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type> <name>usercompartmentlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Datum</name></type> <name>clsitemin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Datum</name></type> <name>clsitemout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MARK</name><argument_list>(<argument><expr><literal type="string">"utility"</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * pre-condition : list1 and list2 are unique lists, and elements are sorted.
 * return 1, expect list2 has a bigger set than list1, 
 * return 0, list1 and list2 are same,
 * else -1.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>list_compare_int</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type> <name>list1</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type> <name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell2</name></decl>;</decl_stmt>
    
    <comment type="block">/* no care list2 is null or not */</comment>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>list1</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* here, list1 is not null */</comment>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>list2</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* now list1 and list2 are not null */</comment>

    <comment type="block">/* if list1 has more elements, there is no suspense, list2 does not have a bigger set */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* compare elements one by one */</comment>
    <for>for <control>(<init><expr><operator>(</operator><name>cell1</name><operator>)</operator> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><name>cell2</name><operator>)</operator> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr>;</init>        
         <condition><expr><operator>(</operator><name>cell1</name><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>cell2</name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>;</condition>                
         <incr/>)</control>
    <block>{<block_content>
        <comment type="block">/* the front ones are the same, both step to the next */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>(</operator><name>cell1</name><operator>)</operator> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>cell1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><name>cell2</name><operator>)</operator> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* else step list2 to next element until list2 end */</comment>
        <expr_stmt><expr><operator>(</operator><name>cell2</name><operator>)</operator> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* if list1 is to the end, means list2 is not smaller than list2 */</comment>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>cell1</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>cell2</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* list2 is also to the end, they are just same */</comment>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* while, list2 has more elements */</comment>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
         
    <comment type="block">/* else list2 dose not have all elements in list1 */</comment>         
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>array_datum_convert_to_int2_list</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type> <name>array</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>dims</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>       <name>element</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name>     <modifier>*</modifier></type> <name>elements</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>      <modifier>*</modifier></type> <name>list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>array</name> <operator>=</operator> <operator>(</operator><name>ArrayType</name> <operator>*</operator><operator>)</operator><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* mark this part is empty, return NULL */</comment>
    <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>!=</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>dims</name>     <operator>=</operator>  <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
    <expr_stmt><expr><name>elements</name> <operator>=</operator>  <operator>(</operator><name>int16</name><operator>*</operator><operator>)</operator><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dims</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>element</name> <operator>=</operator> <name><name>elements</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>list_append_unique_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    </block_content>}</block></for>
    
    <return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * check attr if cls column exists
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cls_get_clscol_from_pg_attribute</name><parameter_list>(<parameter><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>attrs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>clscol</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>CLSITEM_OID</name> <operator>==</operator> <name><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>clscol</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    
    <return>return <expr><name>clscol</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cls_parse_clsitem_and_assign</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>ClsItem</name> <modifier>*</modifier></type> <name>clstiem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">//elog(LOG, "[neoqguo]cls_parse_clsitem_and_assign get str arg:%s", str);</comment>
    
    <expr_stmt><expr><call><name>sscanf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%hd:%hd"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>clstiem</name><operator>-&gt;</operator><name>polid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>clstiem</name><operator>-&gt;</operator><name>labelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>cls_get_group_info</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>polid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>groupid</name></decl></parameter>, <parameter><decl><type><name>ClsGroupInfo</name> <modifier>*</modifier></type> <name>group_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_cls_group</name></type> <name>group_form</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_cls_group_polid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>polid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_cls_group_groupid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>groupid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ClsGroupRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>PgClsGroupPolidGroupidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>group_form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_cls_group</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>group_info</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>group_info</name><operator>-&gt;</operator><name>childid</name></name>  <operator>=</operator> <name><name>group_form</name><operator>-&gt;</operator><name>groupid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>group_info</name><operator>-&gt;</operator><name>parentid</name></name> <operator>=</operator> <name><name>group_form</name><operator>-&gt;</operator><name>parentid</name></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>HeapTupleHasNulls</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call> 
                <operator>&amp;&amp;</operator> <call><name>att_isnull</name><argument_list>(<argument><expr><name>Anum_pg_cls_group_longname</name></expr></argument>, <argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_bits</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>group_info</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>group_info</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MARK</name><argument_list>(<argument><expr><literal type="string">"algorithm"</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * check relationship between child and parent, means parent is the upper node of child.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>cls_group_node_match_child_and_parent</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>polid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>childid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>parentid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>    <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>current_nodeid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ClsGroupInfo</name></type> <name>nodeinfo</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>current_nodeid</name> <operator>=</operator> <name>childid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name>            <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <call><name>cls_get_group_info</name><argument_list>(<argument><expr><name>polid</name></expr></argument>, <argument><expr><name>current_nodeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodeinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>   
            <if_stmt><if>if <condition>(<expr><name><name>nodeinfo</name><operator>.</operator><name>parentid</name></name> <operator>==</operator> <name>parentid</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>nodeinfo</name><operator>.</operator><name>valid</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* get the parentid, but it was invalid, so returns fail*/</comment>
                    <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <break>break;</break>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>CLS_GROUP_INVALID_NODE</name> <operator>==</operator> <name><name>nodeinfo</name><operator>.</operator><name>parentid</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* already up to the root, fails */</comment>
                <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* step to upper node */</comment>
            <expr_stmt><expr><name>current_nodeid</name> <operator>=</operator> <name><name>nodeinfo</name><operator>.</operator><name>parentid</name></name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* groupid not found, fails */</comment>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></for>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * expect user comparelist covering all elements in row comparelist.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>cls_compartment_compare</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type> <name>rowcompartmentlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type> <name>usercompartmentlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>list_compare_int</name><argument_list>(<argument><expr><name>rowcompartmentlist</name></expr></argument>, <argument><expr><name>usercompartmentlist</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * expect user grouplist has at least one element is 'NOT UNDER' the element in rowgrouplist.
 * NodeA is NOT UNDER NodeB means NodeA equal to NodeB OR NodeA is parent node of NodeB. 
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>cls_group_compare</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>polid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type> <name>rowgrouplist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type> <name>usergrouplist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type>  <name>rowcell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type>  <name>usercell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>rowgroupid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>usergroupid</name></decl>;</decl_stmt>

    <comment type="block">/* there is no group in row label, just skip */</comment>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>rowgrouplist</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* here, row is not null, if user was null, fails */</comment>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>usergrouplist</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* here, both row and user are not null, go to pk */</comment>
    <macro><name>foreach</name><argument_list>(<argument>rowcell</argument>, <argument>rowgrouplist</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>rowgroupid</name> <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>rowcell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>usercell</argument>, <argument>usergrouplist</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>usergroupid</name> <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>usercell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>rowgroupid</name> <operator>==</operator> <name>usergroupid</name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            
            <if_stmt><if>if <condition>(<expr><call><name>cls_group_node_match_child_and_parent</name><argument_list>(<argument><expr><name>polid</name></expr></argument>, <argument><expr><name>rowgroupid</name></expr></argument>, <argument><expr><name>usergroupid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MARK</name><argument_list>(<argument><expr><literal type="string">"cls action check"</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * check if table was binding cls policy, return _cls attnum if exists, else InvalidAttrNumber.
 */</comment>
<function><type><specifier>static</specifier> <name>int16</name></type> <name>cls_check_table_has_cls_policy</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>       <name>attnum</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* skip system tables */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IS_SYSTEM_REL</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>InvalidAttrNumber</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_cls_table_relid</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                    <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ClsTableRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, 
                              <argument><expr><name>PgClsTablePolidRelidIndexId</name></expr></argument>, 
                              <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, 
                              <argument><expr><literal type="number">1</literal></expr></argument>, 
                              <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    
    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_cls_table</name></type> <name>form_cls_table</name> <init>= <expr><operator>(</operator><name>Form_pg_cls_table</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <name><name>form_cls_table</name><operator>-&gt;</operator><name>enable</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>form_cls_table</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>attnum</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * go through the parse routine and get the clause node tree.
 */</comment>
<function><type><specifier>static</specifier> <name>ClsExprStruct</name> <modifier>*</modifier></type> <name>cls_create_func_expr</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_SQL_LEN</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>    
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parsestate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>parse_sql</name><index>[<expr><name>PARSE_SQL_LEN</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>qual</name>                     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>parsetree_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>parsetree_item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type> <name>rte</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ClsExprStruct</name> <modifier>*</modifier></type> <name>cls_struct</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>   <name>tempctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>   <name>oldcxt</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>tempctx</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
                                       <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tempctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>cls_struct</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ClsExprStruct</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>cls_struct</name><operator>-&gt;</operator><name>mctx</name></name> <operator>=</operator> <name>tempctx</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>parsestate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rte</name>        <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>parsestate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>parsestate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>parse_sql</name></expr></argument>, <argument><expr><name>PARSE_SQL_LEN</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM %s WHERE pg_cls_check(_cls)"</literal></expr></argument>,
                                        <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>parse_sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <macro><name>foreach</name><argument_list>(<argument>parsetree_item</argument>, <argument>parsetree_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>parsetree</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>parsetree</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>parsetree_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>n</name>    <operator>=</operator> <operator>(</operator><name>SelectStmt</name> <operator>*</operator><operator>)</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>parsestate</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>, <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>parsestate</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>cls_struct</name><operator>-&gt;</operator><name>rd_cls_expr</name></name> <operator>=</operator> <name>qual</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>cls_struct</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * parse
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>cls_parse_compartment</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>compartment_datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>array_datum_convert_to_int2_list</name><argument_list>(<argument><expr><name>compartment_datum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>cls_parse_group</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>group_datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>array_datum_convert_to_int2_list</name><argument_list>(<argument><expr><name>group_datum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get clslabel according to policy id and label id.
 */</comment>
<function><type><specifier>static</specifier> <name>ClsLabel</name> <modifier>*</modifier></type> <name>cls_get_label</name><parameter_list>(<parameter><decl><type><name>int16</name></type> <name>polid</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>labelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_null</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>       <name>compartment_datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>       <name>group_datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ClsLabel</name>  <modifier>*</modifier></type> <name>clslabel</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>clslabel</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ClsLabel</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>CLSLABELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>polid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>labelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_cls_label</name></type> <name>label_tup</name> <init>= <expr><operator>(</operator><name>Form_pg_cls_label</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* get level */</comment>
        <expr_stmt><expr><name><name>clslabel</name><operator>-&gt;</operator><name>levelid</name></name> <operator>=</operator> <name><name>label_tup</name><operator>-&gt;</operator><name>levelid</name></name></expr>;</expr_stmt>

        <comment type="block">/* get compartment if exists */</comment>
        <expr_stmt><expr><name>compartment_datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CLSLABELOID</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>Anum_pg_cls_label_compartmentid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>is_null</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>clslabel</name><operator>-&gt;</operator><name>compartmentlist</name></name> <operator>=</operator> <call><name>cls_parse_compartment</name><argument_list>(<argument><expr><name>compartment_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* get group if exists */</comment>
        <expr_stmt><expr><name>group_datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CLSLABELOID</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>Anum_pg_cls_label_groupid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>is_null</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>clslabel</name><operator>-&gt;</operator><name>grouptree</name></name> <operator>=</operator> <call><name>cls_parse_group</name><argument_list>(<argument><expr><name>group_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>tp</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>clslabel</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>clslabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cls checking in WRITE action procedure.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>  <name>cls_check_write</name><parameter_list>(<parameter><decl><type><name>ClsItem</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ClsLabel</name> <modifier>*</modifier></type> <name>rowclslabel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ClsLabel</name> <modifier>*</modifier></type> <name>userclslabel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>      <name>polid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>      <name>labelid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>polid</name>   <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>polid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>labelid</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>labelid</name></name></expr>;</expr_stmt>    
    
    <comment type="block">/* diffrent policy, return false directly */</comment>
    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>CLS_AUTH_CHECK_IN_POLICY</name><argument_list>(<argument><expr><name>polid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* the same label means the same authority */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>g_user_cls_priv</name><operator>.</operator><name>default_write_label</name></name> <operator>==</operator> <name>labelid</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* get cls label of datarow */</comment>
    <expr_stmt><expr><name>rowclslabel</name> <operator>=</operator> <call><name>cls_get_label</name><argument_list>(<argument><expr><name>polid</name></expr></argument>, <argument><expr><name>labelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>rowclslabel</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* get cls label of user */</comment>
    <expr_stmt><expr><name>userclslabel</name> <operator>=</operator> <name><name>g_user_cls_priv</name><operator>.</operator><name>def_write_label_stru</name></name></expr>;</expr_stmt>

    <comment type="block">/* STEP1. compare level */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>userclslabel</name><operator>-&gt;</operator><name>levelid</name></name> <operator>&lt;</operator> <name><name>rowclslabel</name><operator>-&gt;</operator><name>levelid</name></name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* STEP2.compare group and compartment if exists */</comment>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>rowclslabel</name><operator>-&gt;</operator><name>grouptree</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*STEP 2.1.1 */</comment>
        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>cls_group_compare</name><argument_list>(<argument><expr><name>polid</name></expr></argument>, <argument><expr><name><name>rowclslabel</name><operator>-&gt;</operator><name>grouptree</name></name></expr></argument>, <argument><expr><name><name>userclslabel</name><operator>-&gt;</operator><name>grouptree</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* STEP2.1.2 compare compartment with READ authority if exists */</comment>
        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>cls_compartment_compare</name><argument_list>(<argument><expr><name><name>rowclslabel</name><operator>-&gt;</operator><name>compartmentlist</name></name></expr></argument>, <argument><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>def_read_label_stru</name><operator>-&gt;</operator><name>compartmentlist</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* STEP2.2.1 compare compartment with WRITE authority if exists */</comment>
        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>cls_compartment_compare</name><argument_list>(<argument><expr><name><name>rowclslabel</name><operator>-&gt;</operator><name>compartmentlist</name></name></expr></argument>, <argument><expr><name><name>userclslabel</name><operator>-&gt;</operator><name>compartmentlist</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cls checking in READ action procedure.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>  <name>cls_check_read</name><parameter_list>(<parameter><decl><type><name>ClsItem</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ClsLabel</name> <modifier>*</modifier></type> <name>rowclslabel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ClsLabel</name> <modifier>*</modifier></type> <name>userclslabel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>      <name>polid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>      <name>labelid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>polid</name>   <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>polid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>labelid</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>labelid</name></name></expr>;</expr_stmt>    

    <comment type="block">/* diffrent policy, return false directly */</comment>
    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>CLS_AUTH_CHECK_IN_POLICY</name><argument_list>(<argument><expr><name>polid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* the same label means the same authority */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>g_user_cls_priv</name><operator>.</operator><name>default_read_label</name></name> <operator>==</operator> <name>labelid</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get cls label of datarow */</comment>
    <expr_stmt><expr><name>rowclslabel</name> <operator>=</operator> <call><name>cls_get_label</name><argument_list>(<argument><expr><name>polid</name></expr></argument>, <argument><expr><name>labelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>rowclslabel</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* get cls label of user */</comment>
    <expr_stmt><expr><name>userclslabel</name> <operator>=</operator> <name><name>g_user_cls_priv</name><operator>.</operator><name>def_read_label_stru</name></name></expr>;</expr_stmt>

    <comment type="block">/* STEP1.compare level */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>userclslabel</name><operator>-&gt;</operator><name>levelid</name></name> <operator>&lt;</operator> <name><name>rowclslabel</name><operator>-&gt;</operator><name>levelid</name></name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* STEP2.compare group if exists */</comment>
    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>cls_group_compare</name><argument_list>(<argument><expr><name>polid</name></expr></argument>, <argument><expr><name><name>rowclslabel</name><operator>-&gt;</operator><name>grouptree</name></name></expr></argument>, <argument><expr><name><name>userclslabel</name><operator>-&gt;</operator><name>grouptree</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* STEP3.compare compartment if exists */</comment>
    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>cls_compartment_compare</name><argument_list>(<argument><expr><name><name>rowclslabel</name><operator>-&gt;</operator><name>compartmentlist</name></name></expr></argument>, <argument><expr><name><name>userclslabel</name><operator>-&gt;</operator><name>compartmentlist</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* pass all */</comment> 
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MARK</name><argument_list>(<argument><expr><literal type="string">"external api"</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * this is the enterance of cls check process, all cls work strategies work and judge here, 
 * the result would make a direct effect on the visiblity of current tuple
 */</comment>
<function><type><name>Datum</name></type> <name>pg_cls_check</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ClsItem</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>     <name>ret</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>ClsItem</name><operator>*</operator><operator>)</operator><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>CLS_AUTH_CHECK_IN_POLICY</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>polid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>CLS_CMD_READ</name> <operator>==</operator> <name>g_command_tag_enum</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>cls_check_read</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>CLS_CMD_WRITE</name> <operator>==</operator> <name>g_command_tag_enum</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>cls_check_write</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<comment type="block">/*        
        else if (CLS_CMD_ROW == g_command_tag_enum)
        {
            
        }
*/</comment>      
        <comment type="block">/* TODO: we just output the datum value, later there would be policies algorithm */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[neoqguo]pg_cls_check is ready, get value:%d:%d"</literal></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>polid</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>labelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>clsitemin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ClsItem</name>    <modifier>*</modifier></type><name>clsitem</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>clsitem</name> <operator>=</operator> <operator>(</operator><name>ClsItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ClsItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cls_parse_clsitem_and_assign</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>clsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>PG_RETURN_CLSITEM_P</name><argument_list>(<argument><expr><name>clsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>clsitemout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ClsItem</name>    <modifier>*</modifier></type><name>clsitem</name> <init>= <expr><call><name>PG_GETARG_CLSITEM_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>CLS_MAX_CLS_ITEM_STRING_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>CLS_MAX_CLS_ITEM_STRING_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%d:%d"</literal></expr></argument>, <argument><expr><name><name>clsitem</name><operator>-&gt;</operator><name>polid</name></name></expr></argument>, <argument><expr><name><name>clsitem</name><operator>-&gt;</operator><name>labelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * rows inserted with row label of current user
 */</comment>
<function><type><name>void</name></type> <name>mls_update_cls_with_current_user</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>     <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>      <name>cls_col_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ClsItem</name><modifier>*</modifier></type> <name>clsitem</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>cls_col_id</name> <operator>=</operator> <call><name>cls_get_clscol_from_pg_attribute</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>attrs</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>InvalidAttrNumber</name> <operator>==</operator> <name>cls_col_id</name></expr>)</condition>
    <block>{<block_content>
        <return>return ;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* user dose not have cls policy, use the default value. */</comment>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>g_user_cls_priv</name><operator>.</operator><name>def_row_label_stru</name></name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* maybe copy data from another relation or inner results, do not change the original _cls value */</comment>
    <if_stmt><if>if <condition>(<expr><name>CLS_CMD_ROW</name> <operator>!=</operator> <name>g_command_tag_enum</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* if tts_values is not ready, to deform it */</comment>
    <if_stmt><if>if <condition>(<expr><name>cls_col_id</name> <operator>&gt;</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>cls_col_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>clsitem</name> <operator>=</operator> <operator>(</operator><name>ClsItem</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>cls_col_id</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    
    <comment type="block">/* user's policy:label is the same as default value, just return. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>g_user_cls_priv</name><operator>.</operator><name>polid</name></name> <operator>==</operator> <name><name>clsitem</name><operator>-&gt;</operator><name>polid</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>g_user_cls_priv</name><operator>.</operator><name>default_row_label</name></name> <operator>==</operator> <name><name>clsitem</name><operator>-&gt;</operator><name>labelid</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* update tts_values with user */</comment>
    <expr_stmt><expr><name><name>clsitem</name><operator>-&gt;</operator><name>polid</name></name>   <operator>=</operator> <name><name>g_user_cls_priv</name><operator>.</operator><name>polid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>clsitem</name><operator>-&gt;</operator><name>labelid</name></name> <operator>=</operator> <name><name>g_user_cls_priv</name><operator>.</operator><name>default_row_label</name></name></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>


<comment type="block">/*
 * just like switch memory context, to mark current action type, type see ClsCmdType.
 */</comment>
<function><type><name>int</name></type> <name>mls_command_tag_switch_to</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>oldtag</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>oldtag</name> <operator>=</operator> <name>g_command_tag_enum</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>g_command_tag_enum</name> <operator>=</operator> <name>tag</name></expr>;</expr_stmt>
    
    <return>return <expr><name>oldtag</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * a new round for query, set to init type.
 */</comment> 
<function><type><name>void</name></type> <name>mls_reset_command_tag</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>g_command_tag_enum</name> <operator>=</operator> <name>CLS_CMD_READ</name></expr>;</expr_stmt>
    
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * assign user clsitem infos, hold all memory allocated in "user clsitem info" memory context.
 * skip if system users.
 */</comment>
<function><type><name>void</name></type> <name>mls_assign_user_clsitem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>   
    <decl_stmt><decl><type><name>int16</name></type>         <name>polid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type>   <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type>   <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>     <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>      <name>rel</name></decl>;</decl_stmt>       

    <comment type="block">/* skip system users */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IS_SYSTEM_REL</name><argument_list>(<argument><expr><call><name>GetAuthenticatedUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>g_user_cls_priv</name><operator>.</operator><name>mctx</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>mctx</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                              <argument><expr><literal type="string">"user clsitem info"</literal></expr></argument>,
                              <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* delete memory context to free all the labels */</comment>
        <expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* STEP 1. get the label values of current user */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_cls_user_userid</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                    <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>GetAuthenticatedUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ClsUserRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, 
                              <argument><expr><name>PgClsUserPolidUseridIndexId</name></expr></argument>, 
                              <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, 
                              <argument><expr><literal type="number">1</literal></expr></argument>, 
                              <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_cls_user</name></type> <name>form_cls_user</name> <init>= <expr><operator>(</operator><name>Form_pg_cls_user</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>polid</name></name>               <operator>=</operator> <name><name>form_cls_user</name><operator>-&gt;</operator><name>polid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>privilege</name></name>           <operator>=</operator> <name><name>form_cls_user</name><operator>-&gt;</operator><name>privilege</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>max_read_label</name></name>      <operator>=</operator> <name><name>form_cls_user</name><operator>-&gt;</operator><name>max_read_label</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>max_write_label</name></name>     <operator>=</operator> <name><name>form_cls_user</name><operator>-&gt;</operator><name>max_write_label</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>min_write_label</name></name>     <operator>=</operator> <name><name>form_cls_user</name><operator>-&gt;</operator><name>min_write_label</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>default_read_label</name></name>  <operator>=</operator> <name><name>form_cls_user</name><operator>-&gt;</operator><name>default_read_label</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>default_write_label</name></name> <operator>=</operator> <name><name>form_cls_user</name><operator>-&gt;</operator><name>default_write_label</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>default_row_label</name></name>   <operator>=</operator> <name><name>form_cls_user</name><operator>-&gt;</operator><name>default_row_label</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* STEP 2. get the label structs */</comment>
    
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>polid</name> <operator>=</operator> <name><name>g_user_cls_priv</name><operator>.</operator><name>polid</name></name></expr>;</expr_stmt>
    <comment type="block">/* 
     * get and to cache each label, if the label is same as before, just use the it 
     */</comment>

    <comment type="block">/* 2.1 for read label */</comment>
    <expr_stmt><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>def_read_label_stru</name></name> <operator>=</operator> <call><name>cls_get_label</name><argument_list>(<argument><expr><name>polid</name></expr></argument>, <argument><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>default_read_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* 2.2 for write label */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>g_user_cls_priv</name><operator>.</operator><name>default_write_label</name></name> <operator>==</operator> <name><name>g_user_cls_priv</name><operator>.</operator><name>default_read_label</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>def_write_label_stru</name></name> <operator>=</operator> <name><name>g_user_cls_priv</name><operator>.</operator><name>def_read_label_stru</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>def_write_label_stru</name></name> <operator>=</operator> <call><name>cls_get_label</name><argument_list>(<argument><expr><name>polid</name></expr></argument>, <argument><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>default_write_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* 2.3 for row label */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>g_user_cls_priv</name><operator>.</operator><name>default_row_label</name></name> <operator>==</operator> <name><name>g_user_cls_priv</name><operator>.</operator><name>default_read_label</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>def_row_label_stru</name></name> <operator>=</operator> <name><name>g_user_cls_priv</name><operator>.</operator><name>def_read_label_stru</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>g_user_cls_priv</name><operator>.</operator><name>default_row_label</name></name> <operator>==</operator> <name><name>g_user_cls_priv</name><operator>.</operator><name>default_write_label</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>def_row_label_stru</name></name> <operator>=</operator> <name><name>g_user_cls_priv</name><operator>.</operator><name>def_write_label_stru</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>def_row_label_stru</name></name> <operator>=</operator> <call><name>cls_get_label</name><argument_list>(<argument><expr><name>polid</name></expr></argument>, <argument><expr><name><name>g_user_cls_priv</name><operator>.</operator><name>default_row_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return ;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>mls_create_cls_check_expr</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type> <name>attnum</name></decl>;</decl_stmt>

    <comment type="block">/* skip other relation except tables and orignal partition tables */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>RELKIND_RELATION</name> <operator>!=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name><operator>)</operator>
       <operator>&amp;&amp;</operator><operator>(</operator><name>RELKIND_PARTITIONED_TABLE</name> <operator>!=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* policy is bound on parent relation */</comment>
    <expr_stmt><expr><name>relid</name>  <operator>=</operator> <call><name>mls_get_parent_oid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* skip system table */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IS_SYSTEM_REL</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>cls_check_table_has_cls_policy</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>InvalidAttrNumber</name> <operator>!=</operator> <name>attnum</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cls_struct</name></name>         <operator>=</operator> <call><name>cls_create_func_expr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cls_struct</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cls_struct</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * in procedure of copy to, filter hidden rows.
 */</comment>
<function><type><name>bool</name></type> <name>mls_cls_check_row_validation_in_cp</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ClsItem</name> <modifier>*</modifier></type> <name>clsitem</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>clsitem</name> <operator>=</operator> <operator>(</operator><name>ClsItem</name> <operator>*</operator><operator>)</operator><name>datum</name></expr>;</expr_stmt>

    <return>return <expr><call><name>cls_check_read</name><argument_list>(<argument><expr><name>clsitem</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * only mls_admin could alter _cls
 */</comment>
<function><type><name>bool</name></type> <name>mls_cls_column_drop_check</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"_cls"</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * only mls_admin could alter _cls, and type is clsitem
 */</comment>
<function><type><name>bool</name></type> <name>mls_cls_column_add_check</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>colname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><literal type="string">"_cls"</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"keywords _cls is reserverd"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>CLSITEM_OID</name> <operator>!=</operator> <name>typoid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type for _cls column should be clsitem"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * to alter cls column is forbidded. 
 */</comment>
<function><type><name>bool</name></type> <name>cls_check_table_col_has_policy</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>CLSITEM_OID</name> <operator>==</operator> <call><name>get_atttype</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"mls_admin could not do this"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check table has policy
 */</comment>
<function><type><name>bool</name></type> <name>cls_check_table_has_policy</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type>       <name>attnum</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>cls_check_table_has_cls_policy</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check user whether has policy
 */</comment>
<function><type><name>bool</name></type> <name>cls_check_user_has_policy</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>   <name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
	            <argument><expr><name>Anum_pg_cls_user_userid</name></expr></argument>,
	            <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
	            <argument><expr><name>F_OIDEQ</name></expr></argument>,
	            <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ClsUserRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
	                          <argument><expr><name>PgClsUserPolidUseridIndexId</name></expr></argument>,
	                          <argument><expr><name>true</name></expr></argument>,
	                          <argument><expr><name>NULL</name></expr></argument>,
	                          <argument><expr><literal type="number">1</literal></expr></argument>,
	                          <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_cls_user</name></type> <name>form_cls_user</name> <init>= <expr><operator>(</operator><name>Form_pg_cls_user</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>form_cls_user</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
