<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/misc/mls.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogreader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_audit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_mls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"contrib/pgcrypto/pgp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/schemacmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tuptable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/primnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buf_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lockdefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrprotos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapshot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcrypt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcryptcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcryptmisc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcryptmap.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datamask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls_extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxcnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>




<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
<decl_stmt><decl><type><name>bool</name></type> <name>g_enable_cls</name>               <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>g_enable_data_mask</name>         <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>g_enable_transparent_crypt</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>g_enable_crypt_debug</name>       <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>bool</name></type> <name>g_enable_cls</name>               <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>g_enable_data_mask</name>         <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>g_enable_transparent_crypt</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>g_enable_crypt_debug</name>       <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>g_rel_crypt_hash_size</name> <init>= <expr><literal type="number">2048</literal></expr></init></decl>;</decl_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MLS_QUERY_STRING_PRUNE_DELIMETER</name></cpp:macro> <cpp:value>'('</cpp:value></cpp:define>


<function_decl><type><name>Datum</name></type> <name>pg_execute_query_on_all_nodes</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Datum</name></type> <name>pg_get_table_oid_by_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Datum</name></type> <name>pg_get_role_oid_by_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Datum</name></type> <name>pg_get_function_oid_by_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Datum</name></type> <name>pg_get_schema_oid_by_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Datum</name></type> <name>pg_get_tablespace_oid_by_tablename</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Datum</name></type> <name>pg_get_tablespace_name_by_tablename</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Datum</name></type> <name>pg_get_current_database_oid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Datum</name></type> <name>pg_trsprt_crypt_support_datatype</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>List</name> <modifier>*</modifier></type> <name>FunctionGetOidsByNameString</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type> <name>func_name</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>bool</name></type> <name>g_is_mls_user</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>  <name>g_mls_acl_table_oid</name>     <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>  <name>g_mls_acl_namespace_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MARK</name><argument_list>(<argument><expr><literal type="string">"sys function"</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * this is a special function, called by cls user or audit user, to modify cls or audit system tables directly,
 * and would keep the transaction consistence and relcache fresh.
 */</comment>
<function><type><name>Datum</name></type> <name>pg_execute_query_on_all_nodes</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>query_str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>     <modifier>*</modifier></type><name>co_oids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>     <modifier>*</modifier></type><name>dn_oids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>num_dnodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>num_coords</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>     <name>authenticate_userid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>authenticate_userid</name> <operator>=</operator> <call><name>GetAuthenticatedUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_mls_user</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>DEFAULT_ROLE_AUDIT_SYS_USERID</name> <operator>!=</operator> <name>authenticate_userid</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied, function only could be called by cls user or audit user"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>query_str</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>query_str</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"input query is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PgxcNodeGetOids</name><argument_list>(<argument><expr><operator>&amp;</operator><name>co_oids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_oids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_coords</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_dnodes</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pgxc_execute_on_nodes</name><argument_list>(<argument><expr><name>num_coords</name></expr></argument>, <argument><expr><name>co_oids</name></expr></argument>, <argument><expr><name>query_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgxc_execute_on_nodes</name><argument_list>(<argument><expr><name>num_dnodes</name></expr></argument>, <argument><expr><name>dn_oids</name></expr></argument>, <argument><expr><name>query_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * there are basic functions, get object id with name, 
 * cause oid on nodes maybe different, so get the oid locally.
 */</comment>
<function><type><name>Datum</name></type> <name>pg_get_table_oid_by_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>tablename</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>tableoid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tableoid</name> <operator>=</operator> <call><name>convert_table_name</name><argument_list>(<argument><expr><name>tablename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>tableoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>pg_get_role_oid_by_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Name</name></type>        <name>rolename</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>roleoid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>roleoid</name> <operator>=</operator> <call><name>get_role_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>rolename</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>roleoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>pg_get_function_oid_by_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Name</name></type>        <name>funcname</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>funcoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type>      <name>funcnamelist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type>      <name>funcoidlist</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>funcnamelist</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>funcoidlist</name>  <operator>=</operator> <call><name>FunctionGetOidsByNameString</name><argument_list>(<argument><expr><name>funcnamelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>funcoid</name>      <operator>=</operator> <call><name>list_nth_oid</name><argument_list>(<argument><expr><name>funcoidlist</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>pg_get_schema_oid_by_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>schemaoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Name</name></type>        <name>nspname</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>schemaoid</name>  <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>schemaoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>pg_get_tablespace_oid_by_tablename</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>              <name>relid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>              <name>spcoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>      <name>reltup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type>  <name>tablename</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>tablename</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>relid</name>     <operator>=</operator> <call><name>convert_table_name</name><argument_list>(<argument><expr><name>tablename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>relform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name><name>relform</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>spcoid</name> <operator>=</operator> <name>DEFAULTTABLESPACE_OID</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>spcoid</name> <operator>=</operator> <name><name>relform</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>spcoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>pg_get_tablespace_name_by_tablename</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>              <name>relid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>              <name>spcoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Name</name></type>          <name>spcname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>      <name>reltup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type>  <name>tablename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_tablespace</name></type> <name>spcform</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>tablename</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get relid of table string line */</comment>
    <expr_stmt><expr><name>relid</name>     <operator>=</operator> <call><name>convert_table_name</name><argument_list>(<argument><expr><name>tablename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get spaceoid of relid */</comment>
    <expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>relform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name><name>relform</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>spcoid</name> <operator>=</operator> <name>DEFAULTTABLESPACE_OID</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>spcoid</name> <operator>=</operator> <name><name>relform</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* alloc result set */</comment>
    <expr_stmt><expr><name>spcname</name> <operator>=</operator> <operator>(</operator><name>Name</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>spcname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get spcname of spaceoid */</comment>
    <expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TABLESPACEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>spcoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for tablespace %u"</literal></expr></argument>, <argument><expr><name>spcoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>spcform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_tablespace</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><name>spcname</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>spcform</name><operator>-&gt;</operator><name>spcname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* here we go */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_NAME</name><argument_list>(<argument><expr><name>spcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>pg_get_current_database_oid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>pg_trsprt_crypt_support_datatype</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type> <name>datatype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>support</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>datatype</name> <operator>=</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>support</name> <operator>=</operator> <call><name>mls_support_data_type</name><argument_list>(<argument><expr><name>datatype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>support</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MARK</name><argument_list>(<argument><expr><literal type="string">"mls permission control"</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * check relid having mls policy bound. 
 * at the same time, schema_bound means wether the schema where relid belongs is bound mls policy,
 * under this condition, the output arg is usefull, one relation could be dropped directly whose schema is crypted,
 * cause, the relation would be crypted when created again, 
 * so there is no corner for somebody who wants to escape relfile crypto by a 'fake' with the same relname.
 */</comment>
<function><type><name>bool</name></type> <name>mls_check_relation_permission</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type> <name>schema_bound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>  <name>parent_oid</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_SYSTEM_REL</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>schema_bound</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>schema_bound</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name>parent_oid</name> <operator>=</operator> <call><name>mls_get_parent_oid_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><call><name>datamask_check_table_has_datamask</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>)</argument_list></call> <operator>||</operator>
		        <call><name>datamask_check_table_has_datamask</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>trsprt_crypt_check_table_has_crypt</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>,  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>schema_bound</name></expr></argument>)</argument_list></call> <operator>||</operator>
		        <call><name>trsprt_crypt_check_table_has_crypt</name><argument_list>(<argument><expr><name>relid</name></expr></argument>,  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>schema_bound</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>cls_check_table_has_policy</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <call><name>cls_check_table_has_policy</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        	<return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>mls_check_schema_permission</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>schemaoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>relid_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>relOid</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name> <operator>!=</operator> <call><name>mls_check_schema_crypted</name><argument_list>(<argument><expr><name>schemaoid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>found</name>      <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>relid_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>relid_list</name> <operator>=</operator> <call><name>mls_get_relid_list_in_schema</name><argument_list>(<argument><expr><name>schemaoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NIL</name> <operator>!=</operator> <name>relid_list</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>relid_list</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>relOid</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>mls_check_relation_permission</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <name>found</name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>found</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>mls_check_column_permission</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>  <name>parent_oid</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_SYSTEM_REL</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>parent_oid</name> <operator>=</operator> <call><name>mls_get_parent_oid_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>dmask_check_table_col_has_dmask</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call> <operator>||</operator>
		        <call><name>dmask_check_table_col_has_dmask</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>trsprt_crypt_chk_tbl_col_has_crypt</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call> <operator>||</operator>
		        <call><name>trsprt_crypt_chk_tbl_col_has_crypt</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>cls_check_table_col_has_policy</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call> <operator>||</operator>
		        <call><name>cls_check_table_col_has_policy</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>        
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>bool</name></type> <name>mls_check_role_permission</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>datamask_check_user_in_white_list</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>mls_user</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>DEFAULT_ROLE_MLS_SYS_USERID</name> <operator>==</operator> <call><name>GetAuthenticatedUserId</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pooler connection option contains MLS_CONN_OPTION, so, if exists, skip md5 authentication.
 */</comment>
<function><type><name>bool</name></type> <name>mls_check_inner_conn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>cmd_option</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>cmd_option</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>cmd_option</name></expr></argument>, <argument><expr><name>MLS_CONN_OPTION</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MARK</name><argument_list>(<argument><expr><literal type="string">"queue"</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>pack</name> <name>(</name><name>4</name><name>)</name></cpp:pragma>
<typedef>typedef <type><struct>struct <name>QueueData</name> 
<block>{
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>head</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>tail</name></decl>;</decl_stmt>

    <comment type="block">/* protect above members */</comment>
    <comment type="line">//slock_t      lock;</comment>
    <decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>lock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>          <name>length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>          <name>element_size</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>void</name>     <modifier>*</modifier></type>   <name>data</name></decl>;</decl_stmt>
}</block></struct></type><name>QueueData</name>;</typedef>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>pack</name> <name>(</name><name>)</name></cpp:pragma> 

<typedef>typedef <type><name>QueueData</name> <modifier>*</modifier></type> <name>Queue</name>;</typedef>

<typedef>typedef <type><struct>struct <name>BufEncryptElement</name>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>buf_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>algo_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>slot_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey</name></decl>;</decl_stmt> 
}</block></struct></type><name>BufEncryptElement</name>;</typedef>

<typedef>typedef <type><struct>struct <name>BufCryptedElement</name>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>buf_id</name></decl>;</decl_stmt>         <comment type="block">/* orignal buf id */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>slot_id</name></decl>;</decl_stmt>        <comment type="block">/* crypted slot id */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>error_code</name></decl>;</decl_stmt>     <comment type="block">/* if error_code is not zero, use buf_id to get buftowrite */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
}</block></struct></type><name>BufCryptedElement</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>QueueInit</name><parameter_list>(<parameter><decl><type><name>Queue</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elementcnt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elmentsz</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>QueuePutSingle</name><parameter_list>(<parameter><decl><type><name>Queue</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>element</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>QueueGetSingle</name><parameter_list>(<parameter><decl><type><name>Queue</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>element</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>QueueGetLength</name><parameter_list>(<parameter><decl><type><name>Queue</name></type> <name>q</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>QueueIsFull</name><parameter_list>(<parameter><decl><type><name>Queue</name></type> <name>q</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>QueueInit</name><parameter_list>(<parameter><decl><type><name>Queue</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elementcnt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elmentsz</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>length</name></name>       <operator>=</operator> <name>elementcnt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>element_size</name></name> <operator>=</operator> <name>elmentsz</name></expr>;</expr_stmt> 
        <expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>head</name></name>         <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>tail</name></name>         <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <comment type="line">//SpinLockInit(&amp;q-&gt;lock);</comment>
        <expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name>         <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>data</name><operator>)</operator></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>QueuePutSingle</name><parameter_list>(<parameter><decl><type><name>Queue</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>element</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">//SpinLockAcquire(&amp;q-&gt;lock);</comment>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>q</name><operator>-&gt;</operator><name>tail</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>q</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <name><name>q</name><operator>-&gt;</operator><name>head</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">//SpinLockRelease(&amp;q-&gt;lock);</comment>
        <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>q</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>q</name><operator>-&gt;</operator><name>tail</name></name> <operator>*</operator> <name><name>q</name><operator>-&gt;</operator><name>element_size</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>element</name></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>element_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <operator>(</operator><name><name>q</name><operator>-&gt;</operator><name>tail</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>q</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>  
    
    <comment type="line">//SpinLockRelease(&amp;q-&gt;lock);</comment>
    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>QueueGetSingle</name><parameter_list>(<parameter><decl><type><name>Queue</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>element</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">//SpinLockAcquire(&amp;q-&gt;lock);</comment>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name><name>q</name><operator>-&gt;</operator><name>tail</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">//SpinLockRelease(&amp;q-&gt;lock);</comment>
        <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>                
    </block_content>}</block></if></if_stmt>            

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>element</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>q</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>q</name><operator>-&gt;</operator><name>head</name></name> <operator>*</operator> <name><name>q</name><operator>-&gt;</operator><name>element_size</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>element_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>         

    <expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <operator>(</operator><name><name>q</name><operator>-&gt;</operator><name>head</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>q</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>  

    <comment type="line">//SpinLockRelease(&amp;q-&gt;lock);</comment>
    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>QueueGetLength</name><parameter_list>(<parameter><decl><type><name>Queue</name></type> <name>q</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
    
    <comment type="line">//SpinLockAcquire(&amp;q-&gt;lock);</comment>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name><name>q</name><operator>-&gt;</operator><name>tail</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">//SpinLockRelease(&amp;q-&gt;lock);</comment>
        <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>                
    </block_content>}</block></if></if_stmt>            
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    if (q-&gt;head &lt; q-&gt;tail)
    {
        len = q-&gt;tail - q-&gt;head;
    }
    else
    {
        len = q-&gt;tail - q-&gt;head + q-&gt;length;    
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name><name>q</name><operator>-&gt;</operator><name>tail</name></name> <operator>-</operator> <name><name>q</name><operator>-&gt;</operator><name>head</name></name> <operator>+</operator> <name><name>q</name><operator>-&gt;</operator><name>length</name></name><operator>)</operator> <operator>%</operator> <name><name>q</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>

    <comment type="line">//SpinLockRelease(&amp;q-&gt;lock);</comment>
    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>QueueIsFull</name><parameter_list>(<parameter><decl><type><name>Queue</name></type> <name>q</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">//SpinLockAcquire(&amp;(q-&gt;lock));</comment>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>q</name><operator>-&gt;</operator><name>tail</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>q</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <name><name>q</name><operator>-&gt;</operator><name>head</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">//SpinLockRelease(&amp;(q-&gt;lock));</comment>
        <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//SpinLockRelease(&amp;(q-&gt;lock));</comment>
    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MARK</name><argument_list>(<argument><expr><literal type="string">"crypt buffer parellel"</literal></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/* slot id queue should be a littel more, in case encrypt and crypted queue are full */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRYPT_SLOT_QUEUE_CNT_MULTI_FACTOR</name></cpp:macro>    <cpp:value>3</cpp:value></cpp:define>
<comment type="block">/* every crypting slot has 2 blocks */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRYPT_ONE_BUF_NEED_TEMP_MULTI_FACTOR</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/* hold all infos of crypt workers */</comment>
<typedef>typedef <type><struct>struct <name>tagArgsForEncryptWorker</name>
<block>{
    <decl_stmt><decl><type><name>Queue</name></type>         <name>encrypt_queue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Queue</name></type>         <name>crypted_queue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Queue</name></type>         <name>slot_queue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>         <modifier>*</modifier></type><name>slot_pool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>crypted_cnt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>           <name>worker_id</name></decl>;</decl_stmt>
}</block></struct></type><name>ArgsForEncryptWorker</name>;</typedef>
<decl_stmt><decl><type><name>ArgsForEncryptWorker</name> <modifier>*</modifier><modifier>*</modifier></type><name>g_crypt_worker_info</name></decl>;</decl_stmt>

<comment type="block">/* number of default crypt workers and crypt queue */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>g_checkpoint_crypt_worker</name>       <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>g_checkpoint_crypt_queue_length</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>g_crypt_parellel_main_running</name>   <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>mls_get_crypt_worker_id</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>mls_get_crypt_block</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>pool</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>mls_crypt_worker</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>input</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>mls_start_crypt_parellel_workers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
 * split the pool by offset
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>mls_get_crypt_block</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>pool</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>idx</name> <operator>&lt;</operator> <name>g_checkpoint_crypt_queue_length</name><operator>*</operator><name>CRYPT_SLOT_QUEUE_CNT_MULTI_FACTOR</name> <operator>-</operator> <literal type="number">1</literal></expr> )</condition>
    <block>{<block_content>
        <return>return <expr><name>pool</name> <operator>+</operator> <name>idx</name> <operator>*</operator> <name>BLCKSZ</name> <operator>*</operator> <name>CRYPT_ONE_BUF_NEED_TEMP_MULTI_FACTOR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * crypt worker main
 */</comment>
<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>mls_crypt_worker</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>input</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ArgsForEncryptWorker</name><modifier>*</modifier></type> <name>arg</name></decl>;</decl_stmt>       
    <decl_stmt><decl><type><name>char</name>                <modifier>*</modifier></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>                <modifier>*</modifier></type> <name>slot_pool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>                <modifier>*</modifier></type> <name>buf_need_encrypt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>                <modifier>*</modifier></type> <name>page_new</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BufferDesc</name>          <modifier>*</modifier></type> <name>bufdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                   <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Queue</name></type>                 <name>encrypt_queue</name></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>Queue</name></type>                 <name>crypted_queue</name></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>BufEncryptElement</name></type>     <name>encrypt_element</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BufCryptedElement</name></type>     <name>crypted_element</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                   <name>localcnt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                   <name>workerid</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>ArgsForEncryptWorker</name> <operator>*</operator><operator>)</operator> <name>input</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>encrypt_queue</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>encrypt_queue</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>crypted_queue</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>crypted_queue</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>slot_pool</name>     <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>slot_pool</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>workerid</name>      <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>worker_id</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>localcnt</name>      <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>crypted_cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>need_mprotect</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>g_crypt_parellel_main_running</name></expr>)</condition>
        <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* 1. get one buf for encrypt */</comment>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>QueueGetLength</name><argument_list>(<argument><expr><name>encrypt_queue</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* if there is no job go to sleep */</comment>
            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">100000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>QueueGetSingle</name><argument_list>(<argument><expr><name>encrypt_queue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>encrypt_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>localcnt</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>localcnt</name><operator>%</operator><literal type="number">1000</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>crypted_cnt</name></name> <operator>+=</operator> <name>localcnt</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* 2. transform to buf and encrypt it */</comment>
        <expr_stmt><expr><name>bufdesc</name>  <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name><name>encrypt_element</name><operator>.</operator><name>buf_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>buf</name>      <operator>=</operator> <call><name>BufHdrGetBlockFunc</name><argument_list>(<argument><expr><name>bufdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* 2.1 offset pool for crypting buf */</comment>
        <expr_stmt><expr><name>page_new</name>         <operator>=</operator> <call><name>mls_get_crypt_block</name><argument_list>(<argument><expr><name>slot_pool</name></expr></argument>, <argument><expr><name><name>encrypt_element</name><operator>.</operator><name>slot_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>buf_need_encrypt</name> <operator>=</operator> <name>page_new</name> <operator>+</operator> <name>BLCKSZ</name></expr>;</expr_stmt>

        <comment type="block">/* 2.2 do the encrypt */</comment>
        <expr_stmt><expr><name>need_mprotect</name> <operator>=</operator> <name>enable_buffer_mprotect</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name><name>encrypt_element</name><operator>.</operator><name>buf_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>need_mprotect</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>BufDisableMemoryProtection</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>ret</name>      <operator>=</operator> <call><name>rel_crypt_page_encrypting_parellel</name><argument_list>(<argument><expr><name><name>encrypt_element</name><operator>.</operator><name>algo_id</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_need_encrypt</name></expr></argument>, <argument><expr><name>page_new</name></expr></argument>, <argument><expr><name><name>encrypt_element</name><operator>.</operator><name>cryptkey</name></name></expr></argument>, <argument><expr><name>workerid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>need_mprotect</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>BufEnableMemoryProtection</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* 3. put it to crypted queue */</comment>
        <while>while <condition>(<expr><call><name>QueueIsFull</name><argument_list>(<argument><expr><name>crypted_queue</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">//sleep</comment>
            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">10000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><name><name>crypted_element</name><operator>.</operator><name>buf_id</name></name>     <operator>=</operator> <name><name>encrypt_element</name><operator>.</operator><name>buf_id</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>crypted_element</name><operator>.</operator><name>slot_id</name></name>    <operator>=</operator> <name><name>encrypt_element</name><operator>.</operator><name>slot_id</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>crypted_element</name><operator>.</operator><name>status</name></name>     <operator>=</operator> <name><name>encrypt_element</name><operator>.</operator><name>status</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>crypted_element</name><operator>.</operator><name>error_code</name></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>        
        
        <expr_stmt><expr><call><name>QueuePutSingle</name><argument_list>(<argument><expr><name>crypted_queue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>crypted_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * free slot for worker
 */</comment>
<function><type><name>void</name></type> <name>mls_crypt_worker_free_slot</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slot_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ArgsForEncryptWorker</name> <modifier>*</modifier></type> <name>args</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>g_crypt_worker_info</name><index>[<expr><name>worker_id</name></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>QueuePutSingle</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>slot_queue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slot_id</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* should never happen */</comment>
        <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MUST get an 'free' worker whose queue length is shortest.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>mls_get_crypt_worker_id</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>worker_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>ret_worker_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArgsForEncryptWorker</name> <modifier>*</modifier></type> <name>args</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ret_worker_id</name> <operator>=</operator> <name>worker_id</name></expr>;</expr_stmt>
    
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>g_crypt_worker_info</name><index>[<expr><name>ret_worker_id</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>QueueIsFull</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>encrypt_queue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>worker_id</name> <operator>=</operator> <operator>(</operator><name>ret_worker_id</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>%</operator><name>g_checkpoint_crypt_worker</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name>ret_worker_id</name> <operator>=</operator> <operator>(</operator><name>ret_worker_id</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>%</operator><name>g_checkpoint_crypt_worker</name></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
    </block_content>}</block></for>
    
    <return>return <expr><name>ret_worker_id</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * look for crypted buffers and write them out.
 * collect buffers from all workers.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type> <name>mls_get_crypted_buflist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type> <name>buf_id_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArgsForEncryptWorker</name> <modifier>*</modifier></type> <name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BufCryptedElement</name></type>      <name>element</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>                 <modifier>*</modifier></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BufferDesc</name>           <modifier>*</modifier></type> <name>bufdesc</name></decl>;</decl_stmt>
    
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>g_checkpoint_crypt_worker</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>g_crypt_worker_info</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>QueueGetLength</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>crypted_queue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>QueueGetSingle</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>crypted_queue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>CRYPT_RET_SUCCESS</name> <operator>==</operator> <name><name>element</name><operator>.</operator><name>error_code</name></name></expr>)</condition>
            <block>{<block_content>   
                <comment type="block">/* offset slot_id to crypted block, hold the slot_id and free after smgrwrite */</comment>
                <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>mls_get_crypt_block</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>slot_pool</name></name></expr></argument>, <argument><expr><name><name>element</name><operator>.</operator><name>slot_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <expr_stmt><expr><name>buf_id_list</name> <operator>=</operator> <call><name>SyncBufidListAppend</name><argument_list>(<argument><expr><name>buf_id_list</name></expr></argument>, <argument><expr><name><name>element</name><operator>.</operator><name>buf_id</name></name></expr></argument>, <argument><expr><name><name>element</name><operator>.</operator><name>status</name></name></expr></argument>, <argument><expr><name><name>element</name><operator>.</operator><name>slot_id</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* error happens in crypting, so use orignal ones, and algo_id in page should be INVALID(TRANSP_CRYPT_INVALID_ALGORITHM_ID) */</comment>
                <expr_stmt><expr><name>bufdesc</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name><name>element</name><operator>.</operator><name>buf_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>buf</name>     <operator>=</operator> <call><name>BufHdrGetBlockFunc</name><argument_list>(<argument><expr><name>bufdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <expr_stmt><expr><name>buf_id_list</name> <operator>=</operator> <call><name>SyncBufidListAppend</name><argument_list>(<argument><expr><name>buf_id_list</name></expr></argument>, <argument><expr><name><name>element</name><operator>.</operator><name>buf_id</name></name></expr></argument>, <argument><expr><name><name>element</name><operator>.</operator><name>status</name></name></expr></argument>, <argument><expr><name><name>element</name><operator>.</operator><name>slot_id</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CHECKPOINT:buf:%d encrypt error:%d, use orignal one, algo_id:%d in buf"</literal></expr></argument>, 
                    <argument><expr><name><name>element</name><operator>.</operator><name>buf_id</name></name></expr></argument>, <argument><expr><name><name>element</name><operator>.</operator><name>error_code</name></name></expr></argument>, <argument><expr><call><name>PageGetAlgorithmId</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name> <operator>==</operator> <call><name>PageGetAlgorithmId</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></for>

    <return>return <expr><name>buf_id_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * judge if there was buffer in encrypt process.
 */</comment>
<function><type><name>bool</name></type> <name>mls_encrypt_queue_is_empty</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArgsForEncryptWorker</name> <modifier>*</modifier></type> <name>args</name></decl>;</decl_stmt>
    
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>g_checkpoint_crypt_worker</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>g_crypt_worker_info</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>QueueIsFull</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>slot_queue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* 
 * put buf_id into encrypt queue 
 */</comment>
<function><type><name>List</name><modifier>*</modifier></type> <name>mls_encrypt_buf_parellel</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type> <name>buf_id_list</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>algo_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buf_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>                  <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                   <name>worker_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                   <name>slot_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArgsForEncryptWorker</name><modifier>*</modifier></type> <name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BufEncryptElement</name></type>     <name>element</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <name>int16</name></type>          <name>algo_id_keep</name>  <init>= <expr><name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>CryptKeyInfo</name></type>   <name>cryptkey_keep</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* 1. find one crypt worker */</comment>
    <expr_stmt><expr><name>worker_id</name> <operator>=</operator> <call><name>mls_get_crypt_worker_id</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>g_crypt_worker_info</name><index>[<expr><name>worker_id</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* 2. get slot for crypting */</comment>
    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>QueueGetSingle</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>slot_queue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slot_id</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* slot is sufficient, should not happen */</comment>
        <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* 3. get cryptkey */</comment>
    <if_stmt><if>if <condition>(<expr><name>algo_id</name> <operator>==</operator> <name>algo_id_keep</name> <operator>&amp;&amp;</operator> <name>cryptkey_keep</name></expr>)</condition>
    <block>{<block_content>
        <empty_stmt>;</empty_stmt> 
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>   
        <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>crypt_key_info_hash_lookup</name><argument_list>(<argument><expr><name>algo_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cryptkey_keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>found</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"algo_id:%d dose not exist, mls_encrypt_buf_parellel"</literal></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* cache it for next time using the same crypt key info */</comment>
        <expr_stmt><expr><name>algo_id_keep</name> <operator>=</operator> <name>algo_id</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <expr_stmt><expr><name><name>element</name><operator>.</operator><name>buf_id</name></name>   <operator>=</operator> <name>buf_id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>element</name><operator>.</operator><name>algo_id</name></name>  <operator>=</operator> <name>algo_id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>element</name><operator>.</operator><name>slot_id</name></name>  <operator>=</operator> <name>slot_id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>element</name><operator>.</operator><name>status</name></name>   <operator>=</operator> <name>status</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>element</name><operator>.</operator><name>cryptkey</name></name> <operator>=</operator> <name>cryptkey_keep</name></expr>;</expr_stmt>

    <comment type="block">/* 4. put it into queue */</comment> 
    <while>while <condition>(<expr><name>false</name> <operator>==</operator> <call><name>QueuePutSingle</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>encrypt_queue</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>element</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* do wait 100ms as ISO procedure, in fact, it would go through after getting workerid */</comment>
        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">100000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* 5. again, to fetch more crypted buf if exists */</comment>
    <expr_stmt><expr><name>buf_id_list</name> <operator>=</operator> <call><name>mls_get_crypted_buflist</name><argument_list>(<argument><expr><name>buf_id_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><name>buf_id_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create workers for crypting in parellel in checkpoint_main
 */</comment>
<function><type><name>void</name></type> <name>mls_start_crypt_parellel_workers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONTEXT_NAME_LEN</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>int</name></type> <name>slot_idx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArgsForEncryptWorker</name> <modifier>*</modifier></type> <name>args</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_crypt_parellel_main_running</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>g_crypt_parellel_main_running</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* hold all infos of workers */</comment>
    <expr_stmt><expr><name>g_crypt_worker_info</name> <operator>=</operator> <operator>(</operator><name>ArgsForEncryptWorker</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArgsForEncryptWorker</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>g_checkpoint_crypt_worker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_check</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>rel_crypt_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* every worker has its own resource */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>g_checkpoint_crypt_worker</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArgsForEncryptWorker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>worker_id</name></name>     <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>crypted_cnt</name></name>   <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>encrypt_queue</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufEncryptElement</name></expr></argument>)</argument_list></sizeof><operator>*</operator> <name>g_checkpoint_crypt_queue_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>QueueInit</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>encrypt_queue</name></name></expr></argument>, <argument><expr><name>g_checkpoint_crypt_queue_length</name></expr></argument>,   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufEncryptElement</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>crypted_queue</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufCryptedElement</name></expr></argument>)</argument_list></sizeof><operator>*</operator> <name>g_checkpoint_crypt_queue_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>QueueInit</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>crypted_queue</name></name></expr></argument>, <argument><expr><name>g_checkpoint_crypt_queue_length</name></expr></argument>,   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufCryptedElement</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>slot_queue</name></name>    <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator> <name>g_checkpoint_crypt_queue_length</name> <operator>*</operator> <name>CRYPT_SLOT_QUEUE_CNT_MULTI_FACTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>QueueInit</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>slot_queue</name></name></expr></argument>,    <argument><expr><name>g_checkpoint_crypt_queue_length</name><operator>*</operator><name>CRYPT_SLOT_QUEUE_CNT_MULTI_FACTOR</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>slot_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slot_idx</name> <operator>&lt;</operator> <name>g_checkpoint_crypt_queue_length</name><operator>*</operator><name>CRYPT_SLOT_QUEUE_CNT_MULTI_FACTOR</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>slot_idx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* init slot queue id */</comment>
            <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>QueuePutSingle</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>slot_queue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slot_idx</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * alloc a continuous huge memory for crypting, then split them by slot_id.
         * every slot has 'CRYPT_ONE_BUF_NEED_TEMP_MULTI_FACTOR' = 2 block.
         * prepare 'CRYPT_SLOT_QUEUE_CNT_MULTI_FACTOR' = 3 times slots for use, in case encrypt and crypted queue are full at the same time. 
         */</comment>
        <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>slot_pool</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name> 
                                  <operator>*</operator><name>CRYPT_SLOT_QUEUE_CNT_MULTI_FACTOR</name>
                                  <operator>*</operator><name>CRYPT_ONE_BUF_NEED_TEMP_MULTI_FACTOR</name>
                                  <operator>*</operator><name>g_checkpoint_crypt_queue_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>CreateThread</name><argument_list>(<argument><expr><name>mls_crypt_worker</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>args</name></expr></argument>, <argument><expr><name>MT_THR_DETACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* pause 1 second, in case too many output leads to side effect to disc load */</comment>
            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <comment type="block">/* failed to create thread, exit */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not start encrypt worker:%d, checkpointer exits, try it later, ret:%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* track the infos */</comment>
        <expr_stmt><expr><name><name>g_crypt_worker_info</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>mls_crypt_parellel_main_exit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>g_crypt_parellel_main_running</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>

<function><type><name>uint32</name></type> <name>mls_crypt_parle_get_queue_capacity</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>g_checkpoint_crypt_queue_length</name><operator>*</operator><name>g_checkpoint_crypt_worker</name><operator>*</operator><literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type> <name>SyncBufidListAppend</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type> <name>buf_id_list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buf_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slot_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>bufToWrite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SyncBufIdInfo</name>  <modifier>*</modifier></type> <name>node</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SyncBufIdInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>buf_id</name></name>        <operator>=</operator> <name>buf_id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>slot_id</name></name>       <operator>=</operator> <name>slot_id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>worker_id</name></name>     <operator>=</operator> <name>worker_id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>status</name></name>        <operator>=</operator> <name>status</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>encrypted_buf</name></name> <operator>=</operator> <name>bufToWrite</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>buf_id_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>buf_id_list</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>buf_id_list</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>mls_log_crypt_worker_detail</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>   
    <decl_stmt><decl><type><name>StringInfoData</name></type>    <name>ds</name></decl>;</decl_stmt>
    
    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>g_checkpoint_crypt_worker</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>, <argument><expr><literal type="string">"id:%d-bufs:%lu, "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>g_crypt_worker_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>crypted_cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"detail for workers:%s"</literal></expr></argument>, <argument><expr><name><name>ds</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>ds</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MARK</name><argument_list>(<argument><expr><literal type="string">"datamask"</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type> <name>mls_check_datamask_need_passby</name><parameter_list>(<parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type> <name>scanstate</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type> <name>parent_oid</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>relid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>skip_data_mask_check</name></name> <operator>=</operator> <name>DATA_MASK_SKIP_ALL_TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>parent_oid</name> <operator>=</operator> <call><name>mls_get_parent_oid_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>datamask_check_table_has_datamask</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>dmask_chk_usr_and_col_in_whit_list</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>skip_data_mask_check</name></name> <operator>=</operator> <name>DATA_MASK_SKIP_ALL_FALSE</name></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>skip_data_mask_check</name></name> <operator>=</operator> <name>DATA_MASK_SKIP_ALL_TRUE</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * cls and audit add several system tables, we manage them in this sample way.
 */</comment>
<function><type><name>int</name></type> <name>transfer_rel_kind_ext</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>init_extension_table_oids</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>relid</name> <operator>==</operator> <name>g_mls_acl_namespace_oid</name> <operator>||</operator>
       <name>relid</name> <operator>==</operator> <name>g_mls_acl_table_oid</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>RELKIND_MLS_SYS_TABLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <switch>switch <condition>(<expr><name>relid</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>ClsCompartmentRelationId</name></expr>:</case>
        <case>case <expr><name>ClsGroupRelationId</name></expr>:</case>
        <case>case <expr><name>ClsLabelRelationId</name></expr>:</case>
        <case>case <expr><name>ClsLevelRelationId</name></expr>:</case>
        <case>case <expr><name>ClsPolicyRelationId</name></expr>:</case>
        <case>case <expr><name>ClsTableRelationId</name></expr>:</case>
        <case>case <expr><name>ClsUserRelationId</name></expr>:</case>
        <case>case <expr><name>DataMaskMapRelationId</name></expr>:</case>
        <case>case <expr><name>DataMaskUserRelationId</name></expr>:</case>    
        <case>case <expr><name>TransparentCryptPolicyMapRelationId</name></expr>:</case>
        <case>case <expr><name>TransparentCryptPolicyAlgorithmId</name></expr>:</case>
        <case>case <expr><name>TransparentCryptPolicyTablespaceRelationId</name></expr>:</case>
        <case>case <expr><name>TransparentCryptPolicySchemaRelationId</name></expr>:</case>
            <return>return <expr><name>RELKIND_MLS_SYS_TABLE</name></expr>;</return>
            <break>break;</break>
        <case>case <expr><name>PgAuditObjDefOptsRelationId</name></expr>:</case>
        <case>case <expr><name>PgAuditObjConfRelationId</name></expr>:</case>
        <case>case <expr><name>PgAuditStmtConfRelationId</name></expr>:</case>
        <case>case <expr><name>PgAuditUserConfRelationId</name></expr>:</case>
        <case>case <expr><name>PgAuditFgaConfRelationId</name></expr>:</case>
            <return>return <expr><name>RELKIND_AUDIT_SYS_TABLE</name></expr>;</return>
            <break>break;</break>
        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name>relid</name> <operator>&lt;</operator> <name>FirstNormalObjectId</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>RELKIND_SYS_TABLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>RELKIND_NORMAL_TABLE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * while, we define three role kind to extend orginal role kind, 
 * cls user in charge of security, audit user in charge audit event.
 */</comment>
<function><type><name>int</name></type> <name>transfer_rol_kind_ext</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>rolid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>ROLE_MLS_USER</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>DEFAULT_ROLE_AUDIT_SYS_USERID</name> <operator>==</operator> <name>rolid</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>ROLE_AUDIT_USER</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>ROLE_NORMAL_USER</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>is_mls_or_audit_user</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>DEFAULT_ROLE_MLS_SYS_USERID</name> <operator>==</operator> <call><name>GetAuthenticatedUserId</name><argument_list>()</argument_list></call><operator>)</operator> 
        <operator>||</operator> <operator>(</operator><name>DEFAULT_ROLE_AUDIT_SYS_USERID</name> <operator>==</operator> <call><name>GetAuthenticatedUserId</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type> <name>mls_get_parent_oid</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>mls_get_parent_oid_by_relid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>mls_check_schema_crypted</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>schemaoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>          <name>algoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>     <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scandesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>     <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type>  <name><name>entry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>algoid</name> <operator>=</operator> <name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>schemaoid</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TransparentCryptPolicySchemaRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_transparent_crypt_policy_schema_schemaoid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>schemaoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple</name>    <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We assume that there can be at most one matching tuple */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>algoid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_transparent_crypt_policy_schema</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>algorithm_id</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>algoid</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>mls_check_tablespc_crypted</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tablespcoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>          <name>algoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>     <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scandesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>     <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type>  <name><name>entry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>algoid</name> <operator>=</operator> <name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TransparentCryptPolicyTablespaceRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_transparent_crypt_policy_spc_spcoid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tablespcoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple</name>    <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We assume that there can be at most one matching tuple */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>algoid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_transparent_crypt_policy_tablespace</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>algorithm_id</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>algoid</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>InsertTrsprtCryptPolicyMapTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pg_transp_crypt_map_desc</name></decl></parameter>,
                                                    <parameter><decl><type><name>Oid</name></type> <name>relnamespace</name></decl></parameter>,
                                                    <parameter><decl><type><name>Oid</name></type>    <name>reltablespace</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>        <name>rel_crypt_map</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type>   <name>rd_rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>        <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>algoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>             <name>spaceoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>            <name><name>values</name><index>[<expr><name>Natts_pg_transparent_crypt_policy_map</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name><name>nulls</name><index>[<expr><name>Natts_pg_transparent_crypt_policy_map</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NameData</name></type>        <name>schemaname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NameData</name></type>        <name>spcname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CatalogIndexState</name></type> <name>indstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>            <name>relkind</name></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>relnamespace</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>reltablespace</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>spaceoid</name> <operator>=</operator> <name>DEFAULTTABLESPACE_OID</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>spaceoid</name> <operator>=</operator> <name>reltablespace</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>relkind</name> <operator>=</operator> <name><name>pg_transp_crypt_map_desc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>RELKIND_VIEW</name> <operator>==</operator> <name>relkind</name> <operator>||</operator> <name>RELKIND_SEQUENCE</name> <operator>==</operator> <name>relkind</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* skip recording view and seq */</comment>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>algoid</name> <operator>=</operator> <call><name>mls_check_schema_crypted</name><argument_list>(<argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name> <operator>==</operator> <name>algoid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>algoid</name> <operator>=</operator> <call><name>mls_check_tablespc_crypted</name><argument_list>(<argument><expr><name>spaceoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name> <operator>==</operator> <name>algoid</name></expr>)</condition>
        <block>{<block_content>
            <return>return ;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rd_rel</name> <operator>=</operator> <name><name>pg_transp_crypt_map_desc</name><operator>-&gt;</operator><name>rd_rel</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetSchemaNameByOid</name><argument_list>(<argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>spcname</name></expr></argument>)</argument_list></call></expr></argument>,    <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>spcname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>spaceoid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    
    <comment type="block">/*
     * open pg_transparent_crypt_policy_map and its indexes.
     */</comment>
    <expr_stmt><expr><name>rel_crypt_map</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TransparentCryptPolicyMapRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>indstate</name>      <operator>=</operator> <call><name>CatalogOpenIndexes</name><argument_list>(<argument><expr><name>rel_crypt_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/* make a tuple and insert */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_transparent_crypt_policy_map_relid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>      <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>pg_transp_crypt_map_desc</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_transparent_crypt_policy_map_attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>     <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>REL_FILE_CRYPT_ATTR_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_transparent_crypt_policy_map_algorithm</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>  <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>algoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_transparent_crypt_policy_map_spcoid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>     <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>spaceoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_transparent_crypt_policy_map_schemaoid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>  <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_transparent_crypt_policy_map_spcname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>    <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_transparent_crypt_policy_map_nspname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>    <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schemaname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_transparent_crypt_policy_map_tblname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>    <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel_crypt_map</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* finally insert the new tuple, update the indexes, and clean up */</comment>
    <expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>rel_crypt_map</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* close relation */</comment>
    <expr_stmt><expr><call><name>CatalogCloseIndexes</name><argument_list>(<argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel_crypt_map</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * return parent oid if exists, or return itself
 */</comment>
<function><type><name>Oid</name></type> <name>mls_get_parent_oid_by_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>      <name>parent_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>      <name>tbl_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tbl_tp</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_SYSTEM_REL</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>  
        <expr_stmt><expr><name>tbl_oid</name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* convert index oid to relation oid */</comment>
            <if_stmt><if>if <condition>(<expr><name>RELKIND_INDEX</name> <operator>==</operator> <name><name>reltup</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>tbl_oid</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>tbl_tp</name>  <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tbl_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>g_allow_force_ddl</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>tbl_tp</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>InvalidOid</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>reltup</name>  <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator><call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tbl_tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <comment type="block">/* partition internal */</comment>
            <if_stmt><if>if <condition>(<expr><name>RELPARTKIND_CHILD</name> <operator>==</operator> <name><name>reltup</name><operator>-&gt;</operator><name>relpartkind</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* if child, return parent */</comment>
                <expr_stmt><expr><name>parent_oid</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>relparent</name></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else 
            <block>{<block_content>
                <comment type="block">/*
                 * 1. RELPARTKIND_PARENT == reltup-&gt;relpartkind
                 * 2. (true == rel-&gt;rd_rel-&gt;relispartition)
                 * 3. (RELKIND_PARTITIONED_TABLE == rel-&gt;rd_rel-&gt;relkind)
                 * 4. normal relation
                 * return itself
                 */</comment>
                <expr_stmt><expr><name>parent_oid</name> <operator>=</operator> <name>tbl_oid</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tbl_tp</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tbl_tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>parent_oid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * focus on datatype supported currently, if new datatype added, this is the enterance function on critical path
 */</comment>
<function><type><name>bool</name></type> <name>mls_support_data_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <switch>switch<condition>(<expr><name>typid</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
        <case>case <expr><name>FLOAT4OID</name></expr>:</case>
        <case>case <expr><name>FLOAT8OID</name></expr>:</case>
        <case>case <expr><name>NUMERICOID</name></expr>:</case>
        <case>case <expr><name>INT2OID</name></expr>:</case>
        <case>case <expr><name>INT4OID</name></expr>:</case>
        <case>case <expr><name>INT8OID</name></expr>:</case>
            
        <case>case <expr><name>BPCHAROID</name></expr>:</case>     <comment type="block">/* char */</comment>
        <case>case <expr><name>VARCHAR2OID</name></expr>:</case>        
        <case>case <expr><name>VARCHAROID</name></expr>:</case>
        <case>case <expr><name>TEXTOID</name></expr>:</case>
        <case>case <expr><name>BYTEAOID</name></expr>:</case>
        
            <return>return <expr><name>true</name></expr>;</return>
            <break>break;</break>
        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 * all relative row level control feature entrance, such as datamask, cls, transparent crypt.
 */</comment>
<function><type><name>void</name></type> <name>MlsExecCheck</name><parameter_list>(<parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type> <name>parent_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>g_enable_cls</name> <operator>||</operator> <name>g_enable_data_mask</name> <operator>||</operator> <name>g_enable_transparent_crypt</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>node</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ss_currentRelation</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ss_currentRelation</name><operator>-&gt;</operator><name>rd_att</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* 
                     * entrance: transparent crypt 
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>g_enable_transparent_crypt</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ss_currentRelation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>transp_crypt</name></name></expr> )</condition>
                       <comment type="line">//     || (TransparentCryptPolicyAlgorithmId == RelationGetRelid(node-&gt;ss_currentRelation)))</comment>
                        <block>{<block_content>
                            <expr_stmt><expr><name>parent_oid</name> <operator>=</operator> <call><name>mls_get_parent_oid</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss_currentRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>trsprt_crypt_dcrpt_all_col_vale</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>parent_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/* 
                     * entrance: datamask 
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>g_enable_data_mask</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ss_currentRelation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdatamask</name></name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if<condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ss_currentMaskDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>parent_oid</name> <operator>=</operator> <call><name>mls_get_parent_oid</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss_currentRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ss_currentMaskDesc</name></name> <operator>=</operator> <call><name>init_datamask_desc</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>,
                                                                              <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>attrs</name></name></expr></argument>,
                                                                              <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss_currentRelation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdatamask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

                            <comment type="block">/* 
                             * skip_data_mask_check is assigned in execinitnode, 
                             * so concurrent changing to datamask has not effect on current select 
                             */</comment>
                            <if_stmt><if>if <condition>(<expr><name>DATA_MASK_SKIP_ALL_TRUE</name> <operator>!=</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>skip_data_mask_check</name></name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>datamask_exchange_all_cols_value</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * return children part list if exist, including interval and original partitions
 * NOTE, the parent relation is not included in returning list, so if this is a normal relation, NIL is returned.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type> <name>FetchAllParitionList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>     <name>relkind</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>    <modifier>*</modifier></type><name>children</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* in case the relation has already been eliminated */</comment>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>rel</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NIL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* this is interval partition */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>RelationGetAllPartitions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>relkind</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr> ;</expr_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* treat partition tables */</comment>
    <if_stmt><if>if <condition>(<expr><name>NIL</name> <operator>==</operator> <name>children</name> <operator>&amp;&amp;</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>==</operator> <name>relkind</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>children</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * this function cover two kinds of partition, interval and original partition
 */</comment>
<function><type><name>void</name></type> <name>CacheInvalidateRelcacheAllPatition</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>    <modifier>*</modifier></type><name>children</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>FetchAllParitionList</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>NIL</name> <operator>!=</operator> <name>children</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type>    <name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>         <name>partoid</name></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>children</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>partoid</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MlsRegisterRelcacheInvalidation</name><argument_list>(<argument><expr><name>databaseid</name></expr></argument>, <argument><expr><name>partoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * hide sensitive info from query string.
 *
 * we cut off from the first '(', cause, infos like password must appear in (clause_stmt).
 *
 * new querystring is allocateing from errorcontext, which would be reset for every query, 
 * so need to worry about memory leak.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>mls_query_string_prune</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>querystring</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_memctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type>        <name>string_prune</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type>        <name>string_delimeter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>           <name>string_len</name></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>querystring</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>string_delimeter</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>querystring</name></expr></argument>, <argument><expr><name>MLS_QUERY_STRING_PRUNE_DELIMETER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>string_delimeter</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>querystring</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>string_len</name> <operator>=</operator> <name>string_delimeter</name> <operator>-</operator> <name>querystring</name></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>old_memctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>string_prune</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>string_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_memctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>string_prune</name></expr></argument>, <argument><expr><name>querystring</name></expr></argument>, <argument><expr><name>string_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>string_prune</name><index>[<expr><name>string_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <return>return <expr><name>string_prune</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>MlsShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>   
    <expr_stmt><expr><call><name>cyprt_key_info_hash_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rel_cyprt_hash_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* for vfd access */</comment>
    <expr_stmt><expr><call><name>MlsInitFileAccess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>crypt_key_info_load_mapfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"start rel crypt load mapfile"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rel_crypt_load_mapfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"end rel crypt load mapfile"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* after vfd access, rollback all init actions */</comment>
    <expr_stmt><expr><call><name>MlsCleanFileAccess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        
    <return>return;</return>
</block_content>}</block></function>

<function><type><name>Size</name></type> <name>MlsShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>rel_crypt_hash_shmem_size</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>crypt_key_info_hash_shmem_size</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>init_extension_table_oids</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_mls_acl_table_oid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type> <name>nsid</name></decl> ;</decl_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nsid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>MLS_EXTENSION_NAMESPACE_NAME</name></expr></argument>,<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>g_mls_acl_table_oid</name>     <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>MLS_RELATION_ACL_NAME</name></expr></argument>,<argument><expr><name>nsid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>g_mls_acl_namespace_oid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>MLS_SCHEMA_ACL_NAME</name></expr></argument>,<argument><expr><name>nsid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check if current user has mls permission for target_relid
 */</comment>
<function><type><name>bool</name></type> <name>check_user_has_acl_for_relation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>target_relid</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type> <name>nsid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>index_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>table</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name>    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>user_has_acl</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nsid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>MLS_EXTENSION_NAMESPACE_NAME</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
       <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>MLS_RELATION_ACL_NAME</name></expr></argument>, <argument><expr><name>nsid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>index_list</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>index_list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name>index_list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>,
                <argument><expr><literal type="number">1</literal></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>,
                <argument><expr><literal type="number">2</literal></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><name>target_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Scan in the table  */</comment>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>index_beginscan</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name>GetLocalTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>,<argument><expr><name>skey</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>index_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TupleDesc</name> <name>tup_desc</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name> <name>tuple_isnull</name></type>  <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call>   <operator>==</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>tup_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple_isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>target_relid</name>  <operator>==</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>tup_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple_isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>user_has_acl</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>index_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>user_has_acl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check if current user has mls permission for target_namespace
 */</comment>
<function><type><name>bool</name></type> <name>check_user_has_acl_for_namespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>target_namespace</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type> <name>nsid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>index_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>table</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name>    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>user_has_acl</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nsid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>MLS_EXTENSION_NAMESPACE_NAME</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
       <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>MLS_SCHEMA_ACL_NAME</name></expr></argument>, <argument><expr><name>nsid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>index_list</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>index_list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name>index_list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>,
                <argument><expr><literal type="number">1</literal></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>,
                <argument><expr><literal type="number">2</literal></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><name>target_namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Scan in the table  */</comment>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>index_beginscan</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name>GetLocalTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>,<argument><expr><name>skey</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>index_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TupleDesc</name> <name>tup_desc</name></type>  <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name> <name>tuple_isnull</name></type>  <name>PG_USED_FOR_ASSERTS_ONLY</name>  <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call>   <operator>==</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>tup_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple_isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>target_namespace</name>  <operator>==</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>tup_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple_isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>user_has_acl</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>index_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>user_has_acl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check if user has the permission for the mls object
 */</comment>
<function><type><name>void</name></type> <name>CheckMlsTableUserAcl</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>target_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>num_attr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_relation</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>check_tbase_mls_extension</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>is_mls_root_user</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return ;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>relid</name> <operator>==</operator> <name>g_mls_acl_table_oid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>num_attr</name> <operator>=</operator> <name>Anum_pg_mls_relation_acl_relid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>is_relation</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>relid</name> <operator>==</operator> <name>g_mls_acl_namespace_oid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>num_attr</name> <operator>=</operator> <name>Anum_pg_mls_schema_acl_relid</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <switch>switch <condition>(<expr><name>relid</name></expr>)</condition> <block>{<block_content>
            <case>case <expr><name>DataMaskMapRelationId</name></expr>:</case>
                <expr_stmt><expr><name>num_attr</name> <operator>=</operator> <name>Anum_pg_data_mask_map_relid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>is_relation</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>DataMaskUserRelationId</name></expr>:</case>
                <expr_stmt><expr><name>num_attr</name> <operator>=</operator> <name>Anum_pg_data_mask_user_relid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>is_relation</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>TransparentCryptPolicyMapRelationId</name></expr>:</case>
                <expr_stmt><expr><name>num_attr</name> <operator>=</operator> <name>Anum_pg_transparent_crypt_policy_map_relid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>is_relation</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>TransparentCryptPolicySchemaRelationId</name></expr>:</case>
                <expr_stmt><expr><name>num_attr</name> <operator>=</operator> <name>Anum_pg_transparent_crypt_policy_schema_schemaoid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>is_relation</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <return>return ;</return>
        </block_content>}</block></switch>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>target_oid</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,<argument><expr><name>num_attr</name></expr></argument>,<argument><expr><name>tupdesc</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>target_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Extract oid from mls tuple failed "</literal></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Oid is not valid"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>is_relation</name></expr>)</condition>
    <block>{<block_content>
       <decl_stmt><decl><type><name>Relation</name></type> <name>target_relation</name></decl>;</decl_stmt>

       <if_stmt><if>if<condition>(<expr><call><name>check_user_has_acl_for_relation</name><argument_list>(<argument><expr><name>target_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
           <return>return ;</return></block_content></block></if></if_stmt>
    
       <expr_stmt><expr><name>target_relation</name> <operator>=</operator> <call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>target_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>target_relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
           <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                   <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                           <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find relation with oid %u"</literal></expr></argument>,
                                  <argument><expr><name>target_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

       <expr_stmt><expr><name>target_oid</name> <operator>=</operator> <call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>target_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>check_user_has_acl_for_namespace</name><argument_list>(<argument><expr><name>target_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
       <return>return ;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"No mls permission"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"No mls permission for table or schema."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check if tbase_mls extension is installed
 */</comment>
<function><type><name>void</name></type> <name>check_tbase_mls_extension</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type> <name>extOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>extOid</name> <operator>=</operator> <call><name>get_extension_oid</name><argument_list>(<argument><expr><name>MLS_EXTENSION_NAME</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>extOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"This operation is not allowed until the extension \"%s\" is installed."</literal></expr></argument>,
                               <argument><expr><name>MLS_EXTENSION_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

</unit>
