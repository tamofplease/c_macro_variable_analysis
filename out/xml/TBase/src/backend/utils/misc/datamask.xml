<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/misc/datamask.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogreader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_audit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_mls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"contrib/pgcrypto/pgp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tuptable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/primnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lockdefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrprotos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapshot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcrypt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcryptcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcryptmisc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcryptmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datamask.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxcnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MARK</name><argument_list>(<argument><expr><literal type="string">"datamask"</literal></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/*just test stub */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATAMASK_TEST_TEXT_STUB</name></cpp:macro>     <cpp:value>"XXXX"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATAMASK_TEST_INT8_STUB</name></cpp:macro>     <cpp:value>PG_INT8_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATAMASK_TEST_INT16_STUB</name></cpp:macro>    <cpp:value>PG_INT16_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATAMASK_TEST_INT32_STUB</name></cpp:macro>    <cpp:value>PG_INT32_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATAMASK_TEST_INT64_STUB</name></cpp:macro>    <cpp:value>PG_INT64_MAX</cpp:value></cpp:define>


<comment type="block">/*
 * value of option in pg_data_mask_map, indentify kinds of data mask.
 */</comment>
<enum>enum
<block>{
    <decl><name>DATAMASK_KIND_INVALID</name>       <init>= <expr><literal type="number">0</literal></expr></init></decl>,
    <decl><name>DATAMASK_KIND_VALUE</name>         <init>= <expr><literal type="number">1</literal></expr></init></decl>,    <comment type="block">/* exchange value with datamask */</comment>
    <decl><name>DATAMASK_KIND_STR_PREFIX</name>    <init>= <expr><literal type="number">2</literal></expr></init></decl>,    <comment type="block">/* to mask several characters in string, the 'several' is indendified by datamask */</comment>
    <decl><name>DATAMASK_KIND_DEFAULT_VAL</name>   <init>= <expr><literal type="number">3</literal></expr></init></decl>,    <comment type="block">/* datamask use default value kept in pg_data_mask_map.defaultval */</comment>
    <decl><name>DATAMASK_KIND_STR_POSTFIX</name>   <init>= <expr><literal type="number">4</literal></expr></init></decl>,    <comment type="block">/* same as DATAMASK_KIND_STR_PREFIX, except treating string from end to begin */</comment>
    <decl><name>DATAMASK_KIND_FUNC_PROCESS</name>  <init>= <expr><literal type="number">5</literal></expr></init></decl>,    <comment type="block">/* value treate by identified function */</comment>
    <decl><name>DATAMASK_KIND_BUTT</name></decl>
}</block>;</enum>

<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>datamask_exchange_one_col_value</name><parameter_list>(<parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>inputval</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>, <parameter><decl><type><name>DataMaskAttScan</name> <modifier>*</modifier></type><name>mask</name></decl></parameter>,
                                             <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>datumvalid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>datamask_attr_mask_is_valid</name><parameter_list>(<parameter><decl><type><name>Datamask</name>   <modifier>*</modifier></type><name>datamask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>transfer_str_prefix</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type> <name>text_str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask_bit_count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>transfer_str_postfix</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type> <name>text_str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask_bit_count</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * relative to input_str, to alloc a new memory, and exchange serveral chars from end to begin
 * and returns up to max('mask_bit_count', strlen(input_str) characters
 * if input_str is null, a string of 'X' with 'mask_bit_count' length would be returned
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>transfer_str_postfix</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type> <name>text_str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask_bit_count</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type>  <name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type>  <name>input_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>input_str_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>character_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>character_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>dst_loop</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>input_loop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>char_len</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type>    <name>mask_len</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name>   <modifier>*</modifier></type><name>mask_char</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name>mask_char</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* perform conversion */</comment>
        <expr_stmt><expr><name>mask_char</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_do_encoding_conversion</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"X"</literal></expr></argument>,
                             <argument><expr><literal type="number">1</literal></expr></argument>,
                             <argument><expr><name>PG_SQL_ASCII</name></expr></argument>,
                             <argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mask_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>mask_char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* string mask must be valid */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mask_bit_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>text_str</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>input_str</name>     <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>text_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>input_str_len</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>text_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>character_len</name> <operator>=</operator> <call><name>pg_mbstrlen_with_len</name><argument_list>(<argument><expr><name>input_str</name></expr></argument>,<argument><expr><name>input_str_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>character_len</name> <operator>&gt;</operator> <name>mask_bit_count</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* assume mini encoding byte to be 1,to avoid repalloc or calculation */</comment>
	    <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>input_str_len</name> <operator>+</operator> <operator>(</operator><name>mask_len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>mask_bit_count</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <while>while<condition>(<expr><name>input_loop</name> <operator>&lt;</operator> <name>input_str_len</name></expr>)</condition>
	    <block>{<block_content>
	    	<expr_stmt><expr><name>char_len</name> <operator>=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>input_str</name> <operator>+</operator> <name>input_loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<if_stmt><if>if<condition>(<expr><name>character_len</name> <operator>-</operator> <name>character_idx</name> <operator>&lt;=</operator> <name>mask_bit_count</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>dst_loop</name></expr></argument>,<argument><expr><name>mask_char</name></expr></argument>,<argument><expr><operator>(</operator><name>uint</name><operator>)</operator><name>mask_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>dst_loop</name> <operator>+=</operator> <name>mask_len</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>dst_loop</name></expr></argument>,<argument><expr><name>input_str</name> <operator>+</operator> <name>input_loop</name></expr></argument>,<argument><expr><operator>(</operator><name>uint</name><operator>)</operator><name>char_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>dst_loop</name> <operator>+=</operator> <name>char_len</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>input_loop</name> <operator>+=</operator> <name>char_len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>character_idx</name><operator>++</operator></expr>;</expr_stmt>
	    </block_content>}</block></while>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>mask_len</name> <operator>*</operator> <name>mask_bit_count</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<for>for<control>(<init><expr><name>character_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>character_idx</name> <operator>&lt;</operator> <name>mask_bit_count</name></expr>;</condition><incr><expr><name>character_idx</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>dst_loop</name></expr></argument>,<argument><expr><name>mask_char</name></expr></argument>,<argument><expr><operator>(</operator><name>uint</name><operator>)</operator><name>mask_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dst_loop</name> <operator>+=</operator> <name>mask_len</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>str</name><index>[<expr><name>dst_loop</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * exactly same as transfer_str_postfix, except the direction of exchanging string
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>transfer_str_prefix</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type> <name>text_str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask_bit_count</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type>  <name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type>  <name>input_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>input_str_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>character_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>character_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>dst_loop</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>input_loop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>char_len</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type>    <name>mask_len</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name>   <modifier>*</modifier></type><name>mask_char</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name>mask_char</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* perform conversion */</comment>
        <expr_stmt><expr><name>mask_char</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_do_encoding_conversion</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"X"</literal></expr></argument>,
                             <argument><expr><literal type="number">1</literal></expr></argument>,
                             <argument><expr><name>PG_SQL_ASCII</name></expr></argument>,
                             <argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mask_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>mask_char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mask_char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* string mask must be valid */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mask_bit_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>text_str</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>input_str</name>     <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>text_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>input_str_len</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>text_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>character_len</name> <operator>=</operator> <call><name>pg_mbstrlen_with_len</name><argument_list>(<argument><expr><name>input_str</name></expr></argument>,<argument><expr><name>input_str_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>character_len</name> <operator>&gt;</operator> <name>mask_bit_count</name></expr>)</condition>
	<block>{<block_content>
	    <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>input_str_len</name> <operator>+</operator> <operator>(</operator><name>mask_len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>mask_bit_count</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <while>while<condition>(<expr><name>input_loop</name> <operator>&lt;</operator> <name>input_str_len</name></expr>)</condition>
	    <block>{<block_content>
	    	<expr_stmt><expr><name>char_len</name> <operator>=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>input_str</name> <operator>+</operator> <name>input_loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<if_stmt><if>if<condition>(<expr><name>character_idx</name> <operator>&lt;</operator> <name>mask_bit_count</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>dst_loop</name></expr></argument>,<argument><expr><name>mask_char</name></expr></argument>,<argument><expr><operator>(</operator><name>uint</name><operator>)</operator><name>mask_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>dst_loop</name> <operator>+=</operator> <name>mask_len</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>dst_loop</name></expr></argument>,<argument><expr><name>input_str</name> <operator>+</operator> <name>input_loop</name></expr></argument>,<argument><expr><operator>(</operator><name>uint</name><operator>)</operator><name>char_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>dst_loop</name> <operator>+=</operator> <name>char_len</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>input_loop</name> <operator>+=</operator> <name>char_len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>character_idx</name><operator>++</operator></expr>;</expr_stmt>
	    </block_content>}</block></while>	    
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>mask_len</name> <operator>*</operator> <name>mask_bit_count</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<for>for<control>(<init><expr><name>character_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>character_idx</name> <operator>&lt;</operator> <name>mask_bit_count</name></expr>;</condition><incr><expr><name>character_idx</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>dst_loop</name></expr></argument>,<argument><expr><name>mask_char</name></expr></argument>,<argument><expr><operator>(</operator><name>uint</name><operator>)</operator><name>mask_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dst_loop</name> <operator>+=</operator> <name>mask_len</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	
	<expr_stmt><expr><name><name>str</name><index>[<expr><name>dst_loop</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
 
    <return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>dmask_chk_usr_and_col_in_whit_list</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_data_mask_user_relid</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                    <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_data_mask_user_userid</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                    <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>userid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_data_mask_user_attnum</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                    <argument><expr><name>F_INT2EQ</name></expr></argument>,
                    <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DataMaskUserRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, 
                              <argument><expr><name>PgDataMaskUserIndexId</name></expr></argument>, 
                              <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, 
                              <argument><expr><literal type="number">3</literal></expr></argument>, 
                              <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_data_mask_user</name></type> <name>form_pg_datamask_user</name> <init>= <expr><operator>(</operator><name>Form_pg_data_mask_user</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <name><name>form_pg_datamask_user</name><operator>-&gt;</operator><name>enable</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * return list of user name in white list
 * 
 * allocating in current memory context, so remember to free it.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type> <name>datamask_get_user_in_white_list</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type> <name>retlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>rtup</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DataMaskUserRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, 
                              <argument><expr><name>InvalidOid</name></expr></argument>, 
                              <argument><expr><name>false</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, 
                              <argument><expr><literal type="number">0</literal></expr></argument>, 
                              <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_data_mask_user</name></type> <name>form_pg_datamask_user</name> <init>= <expr><operator>(</operator><name>Form_pg_data_mask_user</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <name><name>form_pg_datamask_user</name><operator>-&gt;</operator><name>enable</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>rtup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>form_pg_datamask_user</name><operator>-&gt;</operator><name>userid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>rtup</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Name</name></type> <name>username</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NameData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>username</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>form_pg_datamask_user</name><operator>-&gt;</operator><name>username</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NameData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>retlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>retlist</name></expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>rtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>retlist</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>datamask_check_user_in_white_list</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>g_enable_data_mask</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_data_mask_user_userid</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                    <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>userid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DataMaskUserRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, 
                              <argument><expr><name>PgDataMaskUserIndexId</name></expr></argument>, 
                              <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, 
                              <argument><expr><literal type="number">1</literal></expr></argument>, 
                              <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_data_mask_user</name></type> <name>form_pg_datamask_user</name> <init>= <expr><operator>(</operator><name>Form_pg_data_mask_user</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <name><name>form_pg_datamask_user</name><operator>-&gt;</operator><name>enable</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *  exchange one column once, while, only several basic type supported, 
 *      such as integer(int2\int4\int8),varchar,text 
 *  the col 'datamask' of pg_data_mask_map, that would be more flexible.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type> <name>datamask_exchange_one_col_value</name><parameter_list>(<parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>inputval</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>, <parameter><decl><type><name>DataMaskAttScan</name> <modifier>*</modifier></type><name>mask</name></decl></parameter>,
                                             <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>datumvalid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>unknown_option_kind</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>unsupport_data_type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>option</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>typmod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>string_len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>option</name> <operator>=</operator> <name>DATAMASK_KIND_INVALID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>unknown_option_kind</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>unsupport_data_type</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mask</name><operator>-&gt;</operator><name>enable</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>datumvalid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <return>return <expr><name>value</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>mls_support_data_type</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>datumvalid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>option</name> <operator>=</operator> <name><name>mask</name><operator>-&gt;</operator><name>option</name></name></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name>option</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>DATAMASK_KIND_VALUE</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>INT4OID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator> <name>INT2OID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator> <name>INT8OID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>mask</name><operator>-&gt;</operator><name>datamask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>unsupport_data_type</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><name>DATAMASK_KIND_STR_PREFIX</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>VARCHAROID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name>
                    <operator>||</operator> <name>TEXTOID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name>
                    <operator>||</operator> <name>VARCHAR2OID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name>
                    <operator>||</operator> <name>BPCHAROID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>ret_str</name> <operator>=</operator> <call><name>transfer_str_prefix</name><argument_list>(<argument><expr><ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><name>inputval</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
                                                  <argument><expr><name><name>mask</name><operator>-&gt;</operator><name>datamask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>ret_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>unsupport_data_type</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><name>DATAMASK_KIND_STR_POSTFIX</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>VARCHAROID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name>
                    <operator>||</operator> <name>TEXTOID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name>
                    <operator>||</operator> <name>VARCHAR2OID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name>
                    <operator>||</operator> <name>BPCHAROID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>ret_str</name> <operator>=</operator> <call><name>transfer_str_postfix</name><argument_list>(<argument><expr><ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><name>inputval</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
                                                   <argument><expr><name><name>mask</name><operator>-&gt;</operator><name>datamask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>ret_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>unsupport_data_type</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><name>DATAMASK_KIND_DEFAULT_VAL</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>TIMESTAMPOID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mask</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>,
                                              <argument><expr><name><name>mask</name><operator>-&gt;</operator><name>defaultval</name></name></expr></argument>,
                                              <argument><expr><name>TIMESTAMPOID</name></expr></argument>,
                                              <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* the typmod of timestamp is -1 */</comment>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>FLOAT4OID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mask</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>,
                                              <argument><expr><name><name>mask</name><operator>-&gt;</operator><name>defaultval</name></name></expr></argument>,
                                              <argument><expr><name>TIMESTAMPOID</name></expr></argument>,
                                              <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* the typmod of float4 is -1 */</comment>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>FLOAT8OID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mask</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>,
                                              <argument><expr><name><name>mask</name><operator>-&gt;</operator><name>defaultval</name></name></expr></argument>,
                                              <argument><expr><name>TIMESTAMPOID</name></expr></argument>,
                                              <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* the typmod of float8 is -1 */</comment>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>BPCHAROID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>string_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>mask</name><operator>-&gt;</operator><name>defaultval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>string_len</name> <operator>&gt;</operator> <operator>(</operator><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>-</operator> <name>VARHDRSZ</name><operator>)</operator></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>typmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>typmod</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mask</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>,
                                              <argument><expr><name><name>mask</name><operator>-&gt;</operator><name>defaultval</name></name></expr></argument>,
                                              <argument><expr><name>BPCHAROID</name></expr></argument>,
                                              <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>VARCHAR2OID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mask</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>,
                                              <argument><expr><name><name>mask</name><operator>-&gt;</operator><name>defaultval</name></name></expr></argument>,
                                              <argument><expr><name>VARCHAR2OID</name></expr></argument>,
                                              <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* the typmod of varchar2 is -1 */</comment>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>NUMERICOID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mask</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>,
                                              <argument><expr><name><name>mask</name><operator>-&gt;</operator><name>defaultval</name></name></expr></argument>,
                                              <argument><expr><name>NUMERICOID</name></expr></argument>,
                                              <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* the typmod of numeric is -1 */</comment>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>VARCHAROID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mask</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>,
                                              <argument><expr><name><name>mask</name><operator>-&gt;</operator><name>defaultval</name></name></expr></argument>,
                                              <argument><expr><name>VARCHAROID</name></expr></argument>,
                                              <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* the typmod of varchar is -1 */</comment>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>TEXTOID</name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mask</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>,
                                              <argument><expr><name><name>mask</name><operator>-&gt;</operator><name>defaultval</name></name></expr></argument>,
                                              <argument><expr><name>TEXTOID</name></expr></argument>,
                                              <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* the text of varchar is -1 */</comment>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>unsupport_data_type</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <break>break;</break>
            </block_content>}</block>
            <default>default:</default>
                <expr_stmt><expr><name>unknown_option_kind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>unsupport_data_type</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>unknown_option_kind</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"datamask:unsupported type, typeid:%d for option:%d"</literal></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>unsupport_data_type</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"datamask:unsupported type, typeid:%d for option:%d"</literal></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>datamask_scan_key_contain_mask</name><parameter_list>(<parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datamask</name>   <modifier>*</modifier></type><name>datamask</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>ScanKeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>NumScanKeys</name></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>IndexScanState</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>IndexOnlyScanState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ss_currentRelation</name></name> <operator>&amp;&amp;</operator>
		<name><name>node</name><operator>-&gt;</operator><name>ss_currentRelation</name><operator>-&gt;</operator><name>rd_att</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>datamask</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss_currentRelation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdatamask</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>IndexScanState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>state</name>  <init>= <expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>ScanKeys</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>iss_ScanKeys</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>NumScanKeys</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>iss_NumScanKeys</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>IndexOnlyScanState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>state</name>  <init>= <expr><operator>(</operator><name>IndexOnlyScanState</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>ScanKeys</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ioss_ScanKeys</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>NumScanKeys</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ioss_NumScanKeys</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumScanKeys</name></expr> ;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><call><name>datamask_attr_mask_is_valid</name><argument_list>(<argument><expr><name>datamask</name></expr></argument>, <argument><expr><name><name>ScanKeys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 *  one col needs data masking when the corresponding mask_array is valid
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>datamask_attr_mask_is_valid</name><parameter_list>(<parameter><decl><type><name>Datamask</name> <modifier>*</modifier></type><name>datamask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>datamask</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name><name>datamask</name><operator>-&gt;</operator><name>mask_array</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fill_att_mask_func</name><parameter_list>(<parameter><decl><type><name>DataMaskAttScan</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attypid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type> <name>functionId</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>option</name></name> <operator>!=</operator> <name>DATAMASK_KIND_DEFAULT_VAL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return ;</return></block_content></block></if></if_stmt>

    <switch>switch<condition>(<expr><name>attypid</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
            <expr_stmt><expr><name>functionId</name> <operator>=</operator> <name>TIMESTAMP_IN_OID</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>FLOAT4OID</name></expr>:</case>
            <expr_stmt><expr><name>functionId</name> <operator>=</operator> <name>FLOAT4_IN_OID</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>FLOAT8OID</name></expr>:</case>
            <expr_stmt><expr><name>functionId</name> <operator>=</operator> <name>FLOAT8_IN_OID</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>BPCHAROID</name></expr>:</case>
            <expr_stmt><expr><name>functionId</name> <operator>=</operator> <name>BPCHAR_IN_OID</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>VARCHAR2OID</name></expr>:</case>
            <expr_stmt><expr><name>functionId</name> <operator>=</operator> <name>VARCHAR2_IN_OID</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>NUMERICOID</name></expr>:</case>
            <expr_stmt><expr><name>functionId</name> <operator>=</operator> <name>NUMERIC_IN_OID</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>VARCHAROID</name></expr>:</case>
            <expr_stmt><expr><name>functionId</name> <operator>=</operator> <name>VARCHAR_IN_OID</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>TEXTOID</name></expr>:</case>
            <expr_stmt><expr><name>functionId</name> <operator>=</operator> <name>TEXT_IN_OID</name></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"type not supported."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fill_att_mask_info</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl></parameter>, <parameter><decl><type><name>DataMaskAttScan</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>enable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>mls_support_data_type</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return ;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_data_mask_map_relid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
                <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_data_mask_map_attnum</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
                <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DataMaskMapRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
                              <argument><expr><name>PgDataMaskMapIndexId</name></expr></argument>,
                              <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><literal type="number">2</literal></expr></argument>,
                              <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_data_mask_map</name></type> <name>form_pg_datamask</name> <init>= <expr><operator>(</operator><name>Form_pg_data_mask_map</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>enable</name></name>     <operator>=</operator> <name><name>form_pg_datamask</name><operator>-&gt;</operator><name>enable</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>datamask</name></name>   <operator>=</operator> <name><name>form_pg_datamask</name><operator>-&gt;</operator><name>datamask</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>defaultval</name></name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>form_pg_datamask</name><operator>-&gt;</operator><name>defaultval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>option</name></name>     <operator>=</operator> <name><name>form_pg_datamask</name><operator>-&gt;</operator><name>option</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>fill_att_mask_func</name><argument_list>(<argument><expr><name>info</name></expr></argument>,<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>DataMaskState</name> <modifier>*</modifier></type><name>init_datamask_desc</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>attrs</name></decl></parameter>, <parameter><decl><type><name>Datamask</name> <modifier>*</modifier></type><name>datamask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DataMaskAttScan</name> <modifier>*</modifier></type><name>att_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataMaskState</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>attno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>natts</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>datamask</name><operator>-&gt;</operator><name>attmasknum</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DataMaskState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>desc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>maskinfo</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DataMaskAttScan</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>maskinfo</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>att_info</name> <operator>=</operator> <operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>maskinfo</name><index>[<expr><name>attno</name></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>datamask_attr_mask_is_valid</name><argument_list>(<argument><expr><name>datamask</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>att_info</name><operator>-&gt;</operator><name>enable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><call><name>dmask_chk_usr_and_col_in_whit_list</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>attrs</name><index>[<expr><name>attno</name></expr>]</index></name><operator>-&gt;</operator><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>att_info</name><operator>-&gt;</operator><name>enable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>att_info</name><operator>-&gt;</operator><name>enable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fill_att_mask_info</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>attrs</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>, <argument><expr><name>att_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>desc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * after tuple deform to slot, exchange the col values with those defined by user or defaults.
 */</comment>
<function><type><name>void</name></type> <name>datamask_exchange_all_cols_value</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_exchange_slot_tts_tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>datumvalid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>natts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>   <name>tupleDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>      <modifier>*</modifier></type><name>tuple_values</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>tuple_isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>      <modifier>*</modifier></type><name>slot_values</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>slot_isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datamask</name>   <modifier>*</modifier></type><name>datamask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>new_tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>      <name>old_memctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>att</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanState</name>       <modifier>*</modifier></type><name>scanstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataMaskAttScan</name> <modifier>*</modifier></type><name>maskState</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>scanstate</name>   <operator>=</operator> <operator>(</operator><name>ScanState</name> <operator>*</operator><operator>)</operator><name>node</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tupleDesc</name>   <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>maskState</name>   <operator>=</operator> <name><name>scanstate</name><operator>-&gt;</operator><name>ss_currentMaskDesc</name><operator>-&gt;</operator><name>maskinfo</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>datamask</name>    <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>tdatamask</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>natts</name>       <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>slot_values</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>slot_isnull</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>att</name>         <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>need_exchange_slot_tts_tuple</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>datamask</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>need_exchange_slot_tts_tuple</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>old_memctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mls_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>need_exchange_slot_tts_tuple</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>tuple_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tuple_isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>tuple_values</name></expr></argument>, <argument><expr><name>tuple_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        </block_content>}</block></if></if_stmt>

        <for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>datamask_attr_mask_is_valid</name><argument_list>(<argument><expr><name>datamask</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>thisatt</name> <init>= <expr><name><name>att</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>datumvalid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>need_exchange_slot_tts_tuple</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>slot_values</name><index>[<expr><name>attnum</name></expr>]</index></name>  <operator>=</operator> <call><name>datamask_exchange_one_col_value</name><argument_list>(
                            <argument><expr><name>thisatt</name></expr></argument>,
                            <argument><expr><name><name>tuple_values</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>,
                            <argument><expr><name><name>tuple_isnull</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name><name>maskState</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>datumvalid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* tuple_values are null, so try slot_values */</comment>
                    <expr_stmt><expr><name><name>slot_values</name><index>[<expr><name>attnum</name></expr>]</index></name>  <operator>=</operator> <call><name>datamask_exchange_one_col_value</name><argument_list>(
                            <argument><expr><name>thisatt</name></expr></argument>,
                            <argument><expr><name><name>slot_values</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>,
                            <argument><expr><name><name>slot_isnull</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name><name>maskState</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>datumvalid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name><name>slot_isnull</name><index>[<expr><name>attnum</name></expr>]</index></name>  <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                <comment type="block">/* 
                 * if datum is invalid, slot_values is invalid either, keep orginal value in tuple_value
                 * it seems a little bored
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>need_exchange_slot_tts_tuple</name> <operator>&amp;&amp;</operator> <name>datumvalid</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>tuple_values</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <name><name>slot_values</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>tuple_isnull</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <name><name>slot_isnull</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>need_exchange_slot_tts_tuple</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* do not forget to set shardid */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>RelationIsSharded</name><argument_list>(<argument><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss_currentRelation</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_form_tuple_plain</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>tuple_values</name></expr></argument>, <argument><expr><name>tuple_isnull</name></expr></argument>, <argument><expr><call><name>RelationGetDisKey</name><argument_list>(<argument><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss_currentRelation</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                  <argument><expr><call><name>RelationGetSecDisKey</name><argument_list>(<argument><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss_currentRelation</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss_currentRelation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>tuple_values</name></expr></argument>, <argument><expr><name>tuple_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* remember to do this copy manually */</comment>
            <expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_self</name></name>       <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name>   <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_xc_node_id</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name><operator>-&gt;</operator><name>t_xc_node_id</name></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFree</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name>      <operator>=</operator> <name>new_tuple</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFree</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <comment type="block">/* fresh tts_values in slot */</comment>
            <expr_stmt><expr><call><name>slot_deform_tuple_extern</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>slot</name></expr></argument>, <argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tuple_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tuple_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_memctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * a little quick check whether this table binding a datamask.
 */</comment>
<function><type><name>bool</name></type> <name>datamask_check_table_has_datamask</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>hasdatamask</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_data_mask_map_relid</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
                    <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DataMaskMapRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
                              <argument><expr><name>PgDataMaskMapIndexId</name></expr></argument>,
                              <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><literal type="number">1</literal></expr></argument>,
                              <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>hasdatamask</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_data_mask_map</name></type> <name>form_data_mask_map</name> <init>= <expr><operator>(</operator><name>Form_pg_data_mask_map</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <name><name>form_data_mask_map</name><operator>-&gt;</operator><name>enable</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>hasdatamask</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>hasdatamask</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * here, we already known this table coupled with datamask, so check attributes one by one to mark.
 */</comment>
<function><type><name>bool</name></type> <name>dmask_check_table_col_has_dmask</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>hasdatamask</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>g_enable_data_mask</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_data_mask_map_relid</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
                    <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_data_mask_map_attnum</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
                    <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DataMaskMapRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
                              <argument><expr><name>PgDataMaskMapIndexId</name></expr></argument>,
                              <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><literal type="number">2</literal></expr></argument>,
                              <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>hasdatamask</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_data_mask_map</name></type> <name>form_pg_datamask</name> <init>= <expr><operator>(</operator><name>Form_pg_data_mask_map</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <name><name>form_pg_datamask</name><operator>-&gt;</operator><name>enable</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>hasdatamask</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>hasdatamask</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datamask</name> <modifier>*</modifier></type> <name>datamask_alloc_datamask_struct</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>attmasknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datamask</name> <modifier>*</modifier></type> <name>datamask</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>datamask</name> <operator>=</operator> <operator>(</operator><name>Datamask</name> <operator>*</operator> <operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datamask</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>datamask</name><operator>-&gt;</operator><name>attmasknum</name></name> <operator>=</operator> <name>attmasknum</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>datamask</name><operator>-&gt;</operator><name>mask_array</name></name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>attmasknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>datamask</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * to make up tupdescfree.
 */</comment>
<function><type><name>void</name></type> <name>datamask_free_datamask_struct</name><parameter_list>(<parameter><decl><type><name>Datamask</name> <modifier>*</modifier></type><name>datamask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>datamask</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>datamask</name><operator>-&gt;</operator><name>mask_array</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>datamask</name><operator>-&gt;</operator><name>mask_array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datamask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return ;</return>
</block_content>}</block></function>

<comment type="block">/*
 * we place datamask in tupledesc
 */</comment>
<function><type><name>void</name></type> <name>dmask_assgin_relat_tupledesc_fld</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>         <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>natts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datamask</name><modifier>*</modifier></type>   <name>datamask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>parent_oid</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>g_enable_data_mask</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_SYSTEM_REL</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>parent_oid</name> <operator>=</operator> <call><name>mls_get_parent_oid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* quick check wether this table has col with datamask */</comment>
        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>datamask_check_table_has_datamask</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdatamask</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>datamask_free_datamask_struct</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdatamask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdatamask</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>datamask</name> <operator>=</operator> <operator>(</operator><name>Datamask</name> <operator>*</operator> <operator>)</operator><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datamask</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>datamask</name><operator>-&gt;</operator><name>attmasknum</name></name> <operator>=</operator> <name>natts</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>datamask</name><operator>-&gt;</operator><name>mask_array</name></name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>*</operator><operator>)</operator><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* skip the dropped column */</comment>
            <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>datamask</name><operator>-&gt;</operator><name>mask_array</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <call><name>dmask_check_table_col_has_dmask</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>, <argument><expr><name>attnum</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        
        <expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdatamask</name></name> <operator>=</operator> <name>datamask</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdatamask</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * to make up tupledesccopy.
 */</comment> 
<function><type><name>void</name></type> <name>datamask_alloc_and_copy</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>g_enable_data_mask</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/*skip system table*/</comment>
    <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>attrs</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_SYSTEM_REL</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>attrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>dst</name><operator>-&gt;</operator><name>tdatamask</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>datamask_free_datamask_struct</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>tdatamask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>tdatamask</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>tdatamask</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>tdatamask</name><operator>-&gt;</operator><name>attmasknum</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>tdatamask</name></name> <operator>=</operator> <call><name>datamask_alloc_datamask_struct</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>tdatamask</name><operator>-&gt;</operator><name>attmasknum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>tdatamask</name><operator>-&gt;</operator><name>mask_array</name></name></expr></argument>,
                            <argument><expr><name><name>src</name><operator>-&gt;</operator><name>tdatamask</name><operator>-&gt;</operator><name>mask_array</name></name></expr></argument>,
                            <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>src</name><operator>-&gt;</operator><name>tdatamask</name><operator>-&gt;</operator><name>attmasknum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * to make up the equal judgement of tupledesc.
 */</comment> 
<function><type><name>bool</name></type> <name>datamask_check_datamask_equal</name><parameter_list>(<parameter><decl><type><name>Datamask</name> <modifier>*</modifier></type> <name>dm1</name></decl></parameter>, <parameter><decl><type><name>Datamask</name> <modifier>*</modifier></type> <name>dm2</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>g_enable_data_mask</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>dm1</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>dm2</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>dm1</name> <operator>&amp;&amp;</operator> <name>dm2</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>dm1</name> <operator>==</operator> <name>dm2</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>dm1</name><operator>-&gt;</operator><name>attmasknum</name></name> <operator>!=</operator> <name><name>dm2</name><operator>-&gt;</operator><name>attmasknum</name></name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>memcpy</name><argument_list>(<argument><expr><name><name>dm1</name><operator>-&gt;</operator><name>mask_array</name></name></expr></argument>, <argument><expr><name><name>dm2</name><operator>-&gt;</operator><name>mask_array</name></name></expr></argument>, <argument><expr><name><name>dm1</name><operator>-&gt;</operator><name>attmasknum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>dmask_exchg_all_cols_value_copy</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>, <parameter><decl><type><name>Datum</name>   <modifier>*</modifier></type><name>tuple_values</name></decl></parameter>, <parameter><decl><type><name>bool</name><modifier>*</modifier></type><name>tuple_isnull</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>         <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>natts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datamask</name>   <modifier>*</modifier></type><name>datamask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>       <name>datum_ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>datumvalid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>att</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataMaskState</name> <modifier>*</modifier></type><name>maskstate</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>natts</name>    <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>att</name>      <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>datamask</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>tdatamask</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>maskstate</name> <operator>=</operator> <call><name>init_datamask_desc</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>att</name></expr></argument>, <argument><expr><name>datamask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>datamask_attr_mask_is_valid</name><argument_list>(<argument><expr><name>datamask</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>thisatt</name> <init>= <expr><name><name>att</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>datumvalid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>datum_ret</name> <operator>=</operator> <call><name>datamask_exchange_one_col_value</name><argument_list>(
                    <argument><expr><name>thisatt</name></expr></argument>,
                    <argument><expr><name><name>tuple_values</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>,
                    <argument><expr><name><name>tuple_isnull</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name><name>maskstate</name><operator>-&gt;</operator><name>maskinfo</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>datumvalid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>datumvalid</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>tuple_values</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <name>datum_ret</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>tuple_isnull</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>datamask_check_column_in_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ParseState</name>   <modifier>*</modifier></type> <name>parsestate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Var</name>          <modifier>*</modifier></type> <name>var</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name><modifier>*</modifier></type> <name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>           <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>           <name>is_legaluser</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>         <modifier>*</modifier></type> <name>attrname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>parent_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>
    <comment type="line">//ListCell     * cell;</comment>
    <decl_stmt><decl><type><name>TargetEntry</name>  <modifier>*</modifier></type> <name>targetentry</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>parsestate</name> <operator>=</operator> <operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>context</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>var</name>        <operator>=</operator> <operator>(</operator><name>Var</name><operator>*</operator><operator>)</operator><name>node</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>parsestate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>GetRTEByRangeTablePosn</name><argument_list>(<argument><expr><name>parsestate</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>rte</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>RTE_SUBQUERY</name> <operator>==</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>targetentry</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name><operator>*</operator><operator>)</operator><call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>InvalidOid</name> <operator>!=</operator> <name><name>targetentry</name><operator>-&gt;</operator><name>resorigtbl</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>InvalidAttrNumber</name> <operator>!=</operator> <name><name>targetentry</name><operator>-&gt;</operator><name>resorigcol</name></name><operator>)</operator></expr>)</condition>
                    <block>{<block_content>   
                        <expr_stmt><expr><name>parent_oid</name>  <operator>=</operator> <call><name>mls_get_parent_oid_by_relid</name><argument_list>(<argument><expr><name><name>targetentry</name><operator>-&gt;</operator><name>resorigtbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>found</name>       <operator>=</operator> <call><name>dmask_check_table_col_has_dmask</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>, <argument><expr><name><name>targetentry</name><operator>-&gt;</operator><name>resorigcol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>is_legaluser</name> <operator>=</operator> <call><name>dmask_chk_usr_and_col_in_whit_list</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>, <argument><expr><call><name>GetAuthenticatedUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_legaluser</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>attrname</name> <operator>=</operator> <call><name>get_relid_attribute_name</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>, <argument><expr><name><name>targetentry</name><operator>-&gt;</operator><name>resorigcol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>attrname</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"column(attrname:%s) with datamask policy is forbidden in expression"</literal></expr></argument>, <argument><expr><name>attrname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if>
                                <else>else
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"column(attrnum:%d) with datamask policy is forbidden in expression"</literal></expr></argument>, <argument><expr><name><name>targetentry</name><operator>-&gt;</operator><name>resorigcol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></else></if_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>         
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>RTE_RELATION</name> <operator>==</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>relid</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
                    
                    <expr_stmt><expr><name>parent_oid</name> <operator>=</operator> <call><name>mls_get_parent_oid_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>found</name>      <operator>=</operator> <call><name>dmask_check_table_col_has_dmask</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>is_legaluser</name> <operator>=</operator> <call><name>dmask_chk_usr_and_col_in_whit_list</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>, <argument><expr><call><name>GetAuthenticatedUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_legaluser</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>attrname</name> <operator>=</operator> <call><name>get_rte_attribute_name</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>attrname</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"column(attrname:%s) with datamask policy is forbidden in expression"</literal></expr></argument>, <argument><expr><name>attrname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"column(attrnum:%d) with datamask policy is forbidden in expression"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name><modifier>*</modifier></type> <name>te</name></decl>;</decl_stmt>
        
        <expr_stmt><expr><name>te</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name><operator>*</operator><operator>)</operator><name>node</name></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>parsestate</name> <operator>=</operator> <operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>context</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>parsestate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>relid</name>      <operator>=</operator> <name><name>parsestate</name><operator>-&gt;</operator><name>p_target_relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr>;</expr_stmt>
            
            <expr_stmt><expr><name>parent_oid</name> <operator>=</operator> <call><name>mls_get_parent_oid_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>found</name>      <operator>=</operator> <call><name>dmask_check_table_col_has_dmask</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>is_legaluser</name> <operator>=</operator> <call><name>dmask_chk_usr_and_col_in_whit_list</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>, <argument><expr><call><name>GetAuthenticatedUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_legaluser</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>te</name><operator>-&gt;</operator><name>resname</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"column(attrname:%s) with datamask policy is forbidden in expression"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"column(attrnum:%d) with datamask policy is forbidden in expression"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>datamask_check_column_in_expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
