<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/misc/relcrypt.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 * relcrypt.c
 *
 *
 * Portions Copyright (c) 2018, Tbase Global Development Group
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *    src/backend/utils/misc/relcrypt.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogreader.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_audit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_mls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"contrib/pgcrypto/pgp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"contrib/sm/sm4.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrprotos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapshot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner_private.h"</cpp:file></cpp:include>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls.h"</cpp:file></cpp:include>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcrypt.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcryptmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcryptcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcryptmisc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relcryptaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/relcryptcommand.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/relcryptstorage.h"</cpp:file></cpp:include>


<function_decl><type><name>void</name></type> <name>print_page_header</name><parameter_list>(<parameter><decl><type><name>PageHeader</name></type> <name>header</name></decl></parameter>)</parameter_list>;</function_decl>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MARK</name><argument_list>(<argument><expr><literal type="string">"crypt key info"</literal></expr></argument>)</argument_list></call></expr></cpp:if>

<typedef>typedef <type><struct>struct <name>tagCryptKeyUdf</name>
<block>{
    <decl_stmt><decl><type><name>Oid</name></type>     <name>encrypt_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>     <name>decrypt_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>encrypt_prosrc_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>encrypt_probin_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>decrypt_prosrc_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>decrypt_probin_offset</name></decl>;</decl_stmt>
}</block></struct></type><name>CryptKeyUdf</name>;</typedef>

<typedef>typedef <type><struct>struct <name>tagCryptKeyNonSym</name>
<block>{
    <decl_stmt><decl><type><name>int</name></type>     <name>encrypt_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>decrypt_offset</name></decl>;</decl_stmt>
}</block></struct></type><name>CryptKeyNonSym</name>;</typedef>



<comment type="line">//#if MARK("for process execept backend, such checkpoint")</comment>
<typedef>typedef <function_decl><type><name>text</name><modifier>*</modifier></type> (<modifier>*</modifier><name>CryptUdfCallbackFunc</name>) <parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>text</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<comment type="line">//static HTAB *g_crypt_udf_local_hash = NULL;</comment>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type> <name>g_crypt_check_array</name>         <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<typedef>typedef <type><struct>struct <name>tagCryptUdfLocalHashEntry</name>
<block>{
    <decl_stmt><decl><type><name>Oid</name></type>                  <name>funcoid</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
    <decl_stmt><decl><type><name>PGFunction</name></type>           <name>udf_func</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>CryptUdfCallbackFunc</name></type> <name>udf_func</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type><name>CryptUdfLocalHashEntry</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRYPT_OPTION_VALID</name><parameter_list>(<parameter><type><name>_option</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(CRYPT_KEY_INFO_OPTION_SYMKEY == (_option) \
                                    || CRYPT_KEY_INFO_OPTION_ANYKEY == (_option)\
                                    || CRYPT_KEY_INFO_OPTION_UDF == (_option)\
                                    || CRYPT_KEY_INFO_OPTION_SM4 == (option))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGE_ENCRYPT_LEN</name></cpp:macro>                        <cpp:value>(BLCKSZ - sizeof(PageHeaderData))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECRYPT_CONTEXT_LENGTH_VALID</name><parameter_list>(<parameter><type><name>_len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(INVALID_CONTEXT_LENGTH != (_len))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>crypt_key_info_udf_get_prosrc_probin</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>prosrc_ret</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>probin_ret</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CryptKeyInfo</name></type> <name>crypt_key_info_alloc_and_fill</name><parameter_list>(<parameter><decl><type><name>AlgoId</name></type> <name>algo_id</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="line">//static text * crypt_key_info_get_dearmor_key(char* key);</comment>
<function_decl><type><specifier>static</specifier> <name>CryptKeyInfo</name></type> <name>crypt_key_info_fill_struct_inner</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>htup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupledesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>crypt_key_info_load_by_algoid</name><parameter_list>(<parameter><decl><type><name>int16</name></type> <name>algo_id</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><specifier>static</specifier> <name>CryptKeyInfo</name></type> <name>crypt_key_info_fill_struct_inner</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>htup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupledesc</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Form_pg_transparent_crypt_policy_algorithm</name></type> <name>form_transp_crypt_algo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>    <name>attr_isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>   <name>passwd_datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>   <name>option_args_datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>   <name>pubkey_datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>   <name>privatekey_datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>  <modifier>*</modifier></type> <name>textval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>option</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>form_transp_crypt_algo</name> <operator>=</operator> <operator>(</operator><name>Form_pg_transparent_crypt_policy_algorithm</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>option</name> <operator>=</operator> <name><name>form_transp_crypt_algo</name><operator>-&gt;</operator><name>option</name></name></expr>;</expr_stmt>

    <comment type="block">/* first, alloc */</comment>
    <expr_stmt><expr><name>cryptkey</name> <operator>=</operator> <call><name>crypt_key_info_alloc</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>algo_id</name></name>     <operator>=</operator> <name><name>form_transp_crypt_algo</name><operator>-&gt;</operator><name>algorithm_id</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>option</name></name>      <operator>=</operator> <name>option</name></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>CRYPT_OPTION_VALID</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>passwd_datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>htup</name></expr></argument>,
                                   <argument><expr><name>Anum_pg_transparent_crypt_policy_algorithm_passwd</name></expr></argument>,
                                   <argument><expr><name>tupledesc</name></expr></argument>,
                                   <argument><expr><operator>&amp;</operator><name>attr_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>attr_isnull</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>textval</name> <operator>=</operator> <call><name>DatumGetTextPCopy</name><argument_list>(<argument><expr><name>passwd_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>textval</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>CRYPT_KEY_INFO_MAX_PASSWORD_LEN</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>password</name></name></expr></argument>, <argument><expr><name>textval</name></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>textval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"password is over length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <comment type="line">//default_private_key_dearmor_bytea = transparent_crypt_get_dearmor_key(transparent_crypt_get_private_key(), memcxt);</comment>
               
            <comment type="line">//transp_crypt-&gt;password = decrypt_internal(1, 1, transp_crypt-&gt;password, default_private_key_dearmor_bytea, NULL, NULL);</comment>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>option_args_datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>htup</name></expr></argument>,
                                   <argument><expr><name>Anum_pg_transparent_crypt_policy_algorithm_option_args</name></expr></argument>,
                                   <argument><expr><name>tupledesc</name></expr></argument>,
                                   <argument><expr><operator>&amp;</operator><name>attr_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>attr_isnull</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>textval</name> <operator>=</operator> <call><name>DatumGetTextPCopy</name><argument_list>(<argument><expr><name>option_args_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>textval</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>CRYPT_KEY_INFO_MAX_OPT_ARGS_LEN</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>, <argument><expr><name>textval</name></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>textval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"option args string is over length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>CRYPT_KEY_INFO_OPTION_UDF</name> <operator>==</operator> <name>option</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_oid</name></name> <operator>=</operator> <name><name>form_transp_crypt_algo</name><operator>-&gt;</operator><name>encrypt_oid</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_oid</name></name> <operator>=</operator> <name><name>form_transp_crypt_algo</name><operator>-&gt;</operator><name>decrypt_oid</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>CRYPT_KEY_INFO_OPTION_ANYKEY</name> <operator>==</operator> <name>option</name> <operator>||</operator> <name>CRYPT_KEY_INFO_OPTION_UDF</name> <operator>==</operator> <name>option</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>pubkey_datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>htup</name></expr></argument>,
                                           <argument><expr><name>Anum_pg_transparent_crypt_policy_algorithm_pubkey</name></expr></argument>,
                                           <argument><expr><name>tupledesc</name></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name>attr_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>attr_isnull</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>textval</name> <operator>=</operator> <call><name>DatumGetTextPCopy</name><argument_list>(<argument><expr><name>pubkey_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>textval</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>CRYPT_KEY_INFO_MAX_PUBKEY_LEN</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>publickey</name></name></expr></argument>, <argument><expr><name>textval</name></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>textval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"public key is over length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>privatekey_datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>htup</name></expr></argument>,
                                           <argument><expr><name>Anum_pg_transparent_crypt_policy_algorithm_prikey</name></expr></argument>,
                                           <argument><expr><name>tupledesc</name></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name>attr_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>attr_isnull</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>textval</name> <operator>=</operator> <call><name>DatumGetTextPCopy</name><argument_list>(<argument><expr><name>privatekey_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>textval</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>CRYPT_KEY_INFO_MAX_PRIKEY_LEN</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>privatekey</name></name></expr></argument>, <argument><expr><name>textval</name></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>textval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"private key is over length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* accumulate size */</comment>
        <expr_stmt><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keysize</name></name> <operator>=</operator> <call><name>crypt_key_info_cal_key_size</name><argument_list>(<argument><expr><name>cryptkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid option:%d in pg_transparent_crypt_policy_algorithm"</literal></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>cryptkey</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CryptKeyInfo</name></type> <name>crypt_key_info_alloc_and_fill</name><parameter_list>(<parameter><decl><type><name>AlgoId</name></type> <name>algo_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                        <argument><expr><name>Anum_pg_transparent_crypt_policy_algorithm_id</name></expr></argument>,
                        <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                        <argument><expr><name>F_OIDEQ</name></expr></argument>,
                        <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rel</name>  <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TransparentCryptPolicyAlgorithmId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, 
                              <argument><expr><name>PgTransparentCryptPolicyAlgorithmIndexId</name></expr></argument>, 
                              <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, 
                              <argument><expr><literal type="number">1</literal></expr></argument>, 
                              <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>cryptkey</name> <operator>=</operator> <call><name>crypt_key_info_fill_struct_inner</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>cryptkey</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>crypt_key_info_udf_get_prosrc_probin</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>prosrc_ret</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>probin_ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>procedureTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>prosrcdatum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>probindatum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type>      <name>prosrc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type>      <name>probin</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>procedureTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>prosrcdatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, 
                                  <argument><expr><name>procedureTuple</name></expr></argument>,
                                  <argument><expr><name>Anum_pg_proc_prosrc</name></expr></argument>, 
                                  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>isnull</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>prosrc</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>prosrcdatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>prosrc_ret</name></expr></argument>, <argument><expr><name>prosrc</name></expr></argument>, <argument><expr><call><name>strnlen</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>, <argument><expr><name>CRYPT_KEY_INFO_PROC_SRC_LEN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"prosrc of funcionid:%d is NULL"</literal></expr></argument>, <argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>probindatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, 
                                  <argument><expr><name>procedureTuple</name></expr></argument>,
                                  <argument><expr><name>Anum_pg_proc_probin</name></expr></argument>, 
                                  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>isnull</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>probin</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>probindatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>probin_ret</name></expr></argument>, <argument><expr><name>probin</name></expr></argument>, <argument><expr><call><name>strnlen</name><argument_list>(<argument><expr><name>probin</name></expr></argument>, <argument><expr><name>CRYPT_KEY_INFO_PROC_BIN_LEN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>probin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"probin of funcionid:%d is NULL"</literal></expr></argument>, <argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>


<comment type="block">/*
 * load crypt key into shmem hash by algoid, so it will check wether the algo_id already exists
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>crypt_key_info_load_by_algoid</name><parameter_list>(<parameter><decl><type><name>int16</name></type> <name>algo_id</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>              <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CryptKeyInfo</name></type>      <name>cryptkey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CryptKeyInfoUDF</name> <modifier>*</modifier></type> <name>udf</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/*
     * FIRST, look up in shmem hash
     */</comment>
    <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>crypt_key_info_hash_lookup</name><argument_list>(<argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <name>found</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* 
     * THEN, not found, prepare cryptkeyinfo
     */</comment>

    <comment type="block">/* special treat for default inner algo */</comment>
    <if_stmt><if>if <condition>(<expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name> <operator>==</operator> <name>algo_id</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>useLocalXid</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>                
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, crypt_key_info_load_by_algoid, algo_id:%d, useLocalXid:%d"</literal></expr></argument>, 
                    <argument><expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name></expr></argument>, <argument><expr><name>useLocalXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>crypt_key_info_load_default_key</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"default algo should be loaded durning postmaster startup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>cryptkey</name> <operator>=</operator> <call><name>crypt_key_info_alloc_and_fill</name><argument_list>(<argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>cryptkey</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* special treat for udf */</comment>
        <if_stmt><if>if <condition>(<expr><name>CRYPT_KEY_INFO_OPTION_UDF</name> <operator>==</operator> <name><name>cryptkey</name><operator>-&gt;</operator><name>option</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>udf</name> <operator>=</operator> <name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name></name></expr>;</expr_stmt>
                <comment type="block">/*collect func callback */</comment>
                <expr_stmt><expr><call><name>crypt_key_info_udf_get_prosrc_probin</name><argument_list>(<argument><expr><name><name>udf</name><operator>-&gt;</operator><name>encrypt_oid</name></name></expr></argument>, 
                                                     <argument><expr><name><name>udf</name><operator>-&gt;</operator><name>encrypt_prosrc</name></name></expr></argument>, <argument><expr><name><name>udf</name><operator>-&gt;</operator><name>encrypt_probin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>udf</name><operator>-&gt;</operator><name>encrypt_func</name></name> <operator>=</operator> <call><name>load_external_function</name><argument_list>(<argument><expr><name><name>udf</name><operator>-&gt;</operator><name>encrypt_probin</name></name></expr></argument>, 
                                                            <argument><expr><name><name>udf</name><operator>-&gt;</operator><name>encrypt_prosrc</name></name></expr></argument>,
                                                            <argument><expr><name>true</name></expr></argument>, 
                                                            <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>crypt_key_info_udf_get_prosrc_probin</name><argument_list>(<argument><expr><name><name>udf</name><operator>-&gt;</operator><name>decrypt_oid</name></name></expr></argument>, 
                                                     <argument><expr><name><name>udf</name><operator>-&gt;</operator><name>decrypt_prosrc</name></name></expr></argument>, <argument><expr><name><name>udf</name><operator>-&gt;</operator><name>decrypt_probin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>udf</name><operator>-&gt;</operator><name>decrypt_func</name></name> <operator>=</operator> <call><name>load_external_function</name><argument_list>(<argument><expr><name><name>udf</name><operator>-&gt;</operator><name>decrypt_probin</name></name></expr></argument>, 
                                                            <argument><expr><name><name>udf</name><operator>-&gt;</operator><name>decrypt_prosrc</name></name></expr></argument>,
                                                            <argument><expr><name>true</name></expr></argument>, 
                                                            <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"get invalid cryptkey-&gt;udf return"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* others skip */</comment>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * LAST, insert into shmem hash for next round lookup.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>                
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, crypt_key_info_load_by_algoid, algo_id:%d, option:%d, size:%d, option_args:%s"</literal></expr></argument>, 
                <argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>algo_id</name></name></expr></argument>, <argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keysize</name></name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>crypt_key_info_hash_insert</name><argument_list>(<argument><expr><name>cryptkey</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>crypt_key_info_free</name><argument_list>(<argument><expr><name>cryptkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"get invalid cryptkey return"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return ;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>crypt_key_info_load_by_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>heaptuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupledesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cryptkey</name> <operator>=</operator> <call><name>crypt_key_info_fill_struct_inner</name><argument_list>(<argument><expr><name>heaptuple</name></expr></argument>, <argument><expr><name>tupledesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>                
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CRYPT_KEY_INSERT, crypt_key_info_load_by_tuple, algo_id:%d, option:%d, size:%d, option_args:%s"</literal></expr></argument>, 
            <argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>algo_id</name></name></expr></argument>, <argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>keysize</name></name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>option_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>crypt_key_info_hash_insert</name><argument_list>(<argument><expr><name>cryptkey</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>crypt_key_info_free</name><argument_list>(<argument><expr><name>cryptkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return;</return>
</block_content>}</block></function>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="line">//MARK("for udf crypt")</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRTPT_UDF_LOCAL_HASH_SIZE</name></cpp:macro>               <cpp:value>(256)</cpp:value></cpp:define>

static int crypt_udf_local_hash_cmp (const void *key1, const void *key2, Size keysize);
static PGFunction  crypt_udf_lookup(Oid func_id, const char * probin, const char * prosrc);
static CryptUdfLocalHashEntry *  crypt_udf_local_hash_lookup(Oid fn_oid);
static void crypt_udf_local_hash_insert(Oid fn_oid, PGFunction udf_func);


static int crypt_udf_local_hash_cmp (const void *key1, const void *key2, Size keysize)
{
    const Oid *tagPtr1 = key1, *tagPtr2 = key2;

    if (*tagPtr1 == *tagPtr2)
    {
        return 0;
    }
    
    return 1;
}

static PGFunction  crypt_udf_lookup(Oid func_id, const char * probin, const char * prosrc)
{
    CryptUdfLocalHashEntry * entry;
    PGFunction     udf_func;
    
    entry = crypt_udf_local_hash_lookup(func_id);
    if (NULL != entry)
    {
        return entry-&gt;udf_func;
    }

    udf_func = (PGFunction)load_external_function(probin, 
                                                        prosrc,
                                                        true, 
                                                        NULL);

    crypt_udf_local_hash_insert(func_id, udf_func);

    return udf_func;
}

static CryptUdfLocalHashEntry *  crypt_udf_local_hash_lookup(Oid fn_oid)
{
    CryptUdfLocalHashEntry *entry = NULL;

    if (NULL == g_crypt_udf_local_hash)
    {
        return entry;
    }

    entry = (CryptUdfLocalHashEntry *)hash_search(g_crypt_udf_local_hash,
                                                &amp;fn_oid,
                                                HASH_FIND, 
                                                NULL);

    return entry;
}

static void crypt_udf_local_hash_insert(Oid fn_oid, PGFunction udf_func)
{
    CryptUdfLocalHashEntry *entry;
    bool                    found = false;

    <comment type="block">/* Create the hash table if it doesn't exist yet */</comment>
    if (g_crypt_udf_local_hash == NULL)
    {
        HASHCTL        hash_ctl;

        MemSet(&amp;hash_ctl, 0, sizeof(hash_ctl));
        hash_ctl.keysize   = sizeof(Oid);
        hash_ctl.entrysize = sizeof(CryptUdfLocalHashEntry);
        hash_ctl.match     = crypt_udf_local_hash_cmp;
        g_crypt_udf_local_hash = hash_create("mls udf local hash",
                                CRTPT_UDF_LOCAL_HASH_SIZE,
                                &amp;hash_ctl,
                                HASH_ELEM | HASH_BLOBS| HASH_COMPARE);
    }

    entry = (CryptUdfLocalHashEntry * )hash_search(g_crypt_udf_local_hash,
                                        &amp;fn_oid,
                                        HASH_ENTER,
                                        &amp;found);
    if (false == found)
    {
        <comment type="block">/* OID is already filled in */</comment>
        entry-&gt;udf_func = udf_func;
    }
    
    return;
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MARK</name><argument_list>(<argument><expr><literal type="string">"rel crypt"</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rel_crypt_create</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>AlgoId</name></type> <name>algo_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wal_write</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rel_crypt_create_one_relation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>algo_id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>rel_crypt_get_table_oid</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type> <name>encrypt_procedure_inner</name><parameter_list>(<parameter><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey_local</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type> <name>text_src</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>page_new_output</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>crypt_check</name><parameter_list>(<parameter><decl><type><name>int16</name></type> <name>algo_id</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type> <name>text_src</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type> <name>text_crypted</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>workerid</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type> <name>rel_crypt_create</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>AlgoId</name></type> <name>algo_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wal_write</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>     <name>found</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>rel_crypt_hash_lookup</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <name>found</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if rnode is not found, it would be insert into relcrypt hash, while, we check algo_id is ready. */</comment>
    <expr_stmt><expr><call><name>crypt_key_info_load_by_algoid</name><argument_list>(<argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_debug</name></expr>)</condition>                
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"REL_CRYPT_INSERT, rel_crypt_create, relfilenode:%d:%d:%d, algo_id:%d"</literal></expr></argument>, 
                        <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>-&gt;</operator><name>relNode</name></name></expr></argument>,
                        <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>rel_crypt_hash_insert</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name>wal_write</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="line">//elog(DEBUG, "pid:%d create relfilenode:%d:%d:%d", getpid(), rnode-&gt;spcNode, rnode-&gt;dbNode, rnode-&gt;relNode);</comment>

    <return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>rel_crypt_struct_init</name><parameter_list>(<parameter><decl><type><name>RelCrypt</name></type> <name>relcrypt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>relcrypt</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>relcrypt</name><operator>-&gt;</operator><name>algo_id</name></name> <operator>=</operator> <name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check relation having crypt policy and return algoid if exists
 */</comment>
<function><type><specifier>static</specifier> <name>int16</name></type>  <name>rel_crypt_get_relation_algoid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">//RelCrypt     relcrypt;</comment>
    <decl_stmt><decl><type><name>SysScanDesc</name></type>  <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type>  <name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>     <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>         <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>        <name>algo_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>          <name>parent_oid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>parent_oid</name> <operator>=</operator> <call><name>mls_get_parent_oid_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>TransparentCryptPolicyAlgorithmId</name> <operator>==</operator> <name>parent_oid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"rel crypt for algo table shoule be loaded when postmaster start up"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>CRYPT_DEFAULT_INNER_ALGO_ID</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_SYSTEM_REL</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>    
        <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                        <argument><expr><name>Anum_pg_transparent_crypt_policy_map_relid</name></expr></argument>,
                        <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                        <argument><expr><name>F_OIDEQ</name></expr></argument>,
                        <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                        <argument><expr><name>Anum_pg_transparent_crypt_policy_map_attnum</name></expr></argument>,
                        <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                        <argument><expr><name>F_INT2EQ</name></expr></argument>,
                        <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>REL_FILE_CRYPT_ATTR_NUM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>TransparentCryptPolicyMapRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, 
                                  <argument><expr><name>PgTransparentCryptPolicyMapIndexId</name></expr></argument>, 
                                  <argument><expr><name>true</name></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument>, 
                                  <argument><expr><literal type="number">2</literal></expr></argument>, 
                                  <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Form_pg_transparent_crypt_policy_map</name></type> <name>form_trans_crypt</name> <init>= <expr><operator>(</operator><name>Form_pg_transparent_crypt_policy_map</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>algo_id</name> <operator>=</operator> <name><name>form_trans_crypt</name><operator>-&gt;</operator><name>algorithm_id</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>found</name>   <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>algo_id</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <return>return <expr><name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type> <name>rel_crypt_get_table_oid</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>RELKIND_INDEX</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><call><name>IndexGetRelation</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>       
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>RELKIND_RELATION</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check heap table having crypt, and insert index rnode into shmem hash.
 */</comment>
<function><type><name>void</name></type> <name>rel_crypt_index_check_policy</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>heap_oid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>indexrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>    <name>algo_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>      <name>table_oid</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IS_SYSTEM_REL</name><argument_list>(<argument><expr><name>heap_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* try locking this relation to keep consistency in case dropping concurrently */</comment>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>heap_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>rel</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get table oid */</comment>
    <expr_stmt><expr><name>table_oid</name> <operator>=</operator> <call><name>rel_crypt_get_table_oid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>table_oid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* looking up wether crypt was binding or not */</comment>
    <expr_stmt><expr><name>algo_id</name> <operator>=</operator> <call><name>rel_crypt_get_relation_algoid</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>TRANSP_CRYPT_ALGO_ID_IS_VALID</name><argument_list>(<argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>rel_crypt_create</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>indexrel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>   
        <comment type="block">/* 
         * also, need to check its heap wether bound.
         * for example, an internal partition table was created, then, the schema was bound with cryptition,
         * later, new parition was add, we should make sure new partition and its indexes crypted.
         * in this scene, parent oid was not bound with crypt, so need to check the table of index.
         */</comment>
        <decl_stmt><decl><type><name>RelCryptEntry</name></type> <name>relcrypt</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <call><name>rel_crypt_hash_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>relcrypt</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>rel_crypt_create</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>indexrel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>relcrypt</name><operator>.</operator><name>algo_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>rel_crypt_relat_chk_plcy_wth_rnode</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>       <name>algo_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>relid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>table_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>form_pg_class</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IS_SYSTEM_REL</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* try locking this relation to keep consistency in case dropping concurrently */</comment>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>rel</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get table oid */</comment>
    <expr_stmt><expr><name>table_oid</name> <operator>=</operator> <call><name>rel_crypt_get_table_oid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>table_oid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* looking up wether crypt was binding or not */</comment>
    <expr_stmt><expr><name>algo_id</name> <operator>=</operator> <call><name>rel_crypt_get_relation_algoid</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>TRANSP_CRYPT_ALGO_ID_IS_VALID</name><argument_list>(<argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>form_pg_class</name>  <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator><call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name>   <operator>=</operator> <name>databaseid</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name><name>form_pg_class</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name>  <operator>=</operator> <name>DEFAULTTABLESPACE_OID</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name>  <operator>=</operator> <name><name>form_pg_class</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name>  <operator>=</operator> <name><name>form_pg_class</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>rel_crypt_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * this relid maybe the oid of index, so get table oid
 */</comment>
<function><type><name>void</name></type> <name>rel_crypt_relation_check_policy</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>    <name>algo_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>      <name>table_oid</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IS_SYSTEM_REL</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* try locking this relation to keep consistency in case dropping concurrently */</comment>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>rel</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get table oid */</comment>
    <expr_stmt><expr><name>table_oid</name> <operator>=</operator> <call><name>rel_crypt_get_table_oid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>table_oid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* looking up wether crypt was binding or not */</comment>
    <expr_stmt><expr><name>algo_id</name> <operator>=</operator> <call><name>rel_crypt_get_relation_algoid</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>TRANSP_CRYPT_ALGO_ID_IS_VALID</name><argument_list>(<argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>rel_crypt_create_direct</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * to bind table itself and its children if exist with algo_id, 
 * so rnode would be inserted into relcrypt shmem hash.
 * while, if api binding just a partition(not the parent), we do this upto parent level
 * NOTE:
 * 1. caller must be sure that relid is not system table
 * 2. share invalid message should be sent seperately
 */</comment>
<function><type><name>void</name></type> <name>rel_crypt_create_direct</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>algo_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>parent_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>child_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>     <modifier>*</modifier></type>  <name>children</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type>    <name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>relkind</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>relkind</name> <operator>=</operator> <call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>RELKIND_VIEW</name> <operator>==</operator> <name>relkind</name> <operator>||</operator> <name>RELKIND_SEQUENCE</name> <operator>==</operator> <name>relkind</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* skip recording view and seq */</comment>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>parent_oid</name> <operator>=</operator> <call><name>mls_get_parent_oid_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    
    <comment type="block">/* 1. treat itself */</comment>
    <expr_stmt><expr><call><name>rel_crypt_create_one_relation</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* 2. treat children */</comment>
    <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>FetchAllParitionList</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>children</argument>)</argument_list></macro>
    <block>{<block_content>    
        <expr_stmt><expr><name>child_oid</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>rel_crypt_create_one_relation</name><argument_list>(<argument><expr><name>child_oid</name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * insert relation into relcrypt shmem hash, and insert all its indexes if exist
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rel_crypt_create_one_relation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>algo_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>    <modifier>*</modifier></type><name>index_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name><modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>rel</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* this should not happen */</comment>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>rel_crypt_create</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* treat indexes */</comment>
    <expr_stmt><expr><name>index_list</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>index_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>indexOid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>indexDesc</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>indexOid</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>indexDesc</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>rel_crypt_create</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>indexDesc</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexDesc</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return;</return>
</block_content>}</block></function>

<function><type><name>Page</name></type> <name>rel_crypt_page_encrypt</name><parameter_list>(<parameter><decl><type><name>RelCrypt</name></type> <name>relcrypt</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>     <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AlgoId</name></type>  <name>algo_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>   <modifier>*</modifier></type><name>encryptpage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type><name>need_encrypt_text</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>Page</name></type>  <name>page_new</name>          <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>algo_id</name> <operator>=</operator> <name><name>relcrypt</name><operator>-&gt;</operator><name>algo_id</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * We allocate the copy space once and use it over on each subsequent
     * call.  The point of palloc'ing here, rather than having a static char
     * array, is first to ensure adequate alignment for the checksumming code
     * and second to avoid wasting space in processes that never call this.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>need_encrypt_text</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>need_encrypt_text</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><operator>(</operator><name>VARHDRSZ</name> <operator>+</operator> <name>PAGE_ENCRYPT_LEN</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>page_new</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>page_new</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PageSetAlgorithmId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <return>return <expr><name>page</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>page_new</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>need_encrypt_text</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>VARHDRSZ</name> <operator>+</operator> <name>PAGE_ENCRYPT_LEN</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>need_encrypt_text</name></expr></argument>, <argument><expr><operator>(</operator><name>VARHDRSZ</name> <operator>+</operator> <name>PAGE_ENCRYPT_LEN</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>need_encrypt_text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>page</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PageHeaderData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>, <argument><expr><name>PAGE_ENCRYPT_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* run encrypt algorithm */</comment>
    <expr_stmt><expr><name>encryptpage</name> <operator>=</operator> <call><name>encrypt_procedure</name><argument_list>(<argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name>need_encrypt_text</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>page_new</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PageHeaderData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>encryptpage</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* aes128/192/256 has compression, so, the return data is a standard text, it contains length */</comment>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>encryptpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>PAGE_ENCRYPT_LEN</name></expr>)</condition>
        <block>{<block_content>   
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>page_new</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>page</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PageHeaderData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>page_new</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PageHeaderData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>encryptpage</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PageSetAlgorithmId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PageSetAlgorithmId</name><argument_list>(<argument><expr><name>page_new</name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>crypt_free</name><argument_list>(<argument><expr><name>encryptpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <return>return <expr><name>page_new</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* 
         * crypt has no return, so, no length judge, page_new conntains the crypted context except the pageheader
         * such as guomi, sm4, we consider the length of crypted context is (blcksz - sizeof(PageHeaderData)) as default.
         */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>page_new</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>page</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PageHeaderData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageSetAlgorithmId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageSetAlgorithmId</name><argument_list>(<argument><expr><name>page_new</name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* encryptpage is NULL, no free */</comment>

        <return>return <expr><name>page_new</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
    
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"relfilenode:%d:%d:%d with algo_id:%d oversize"</literal></expr></argument>, 
                        <argument><expr><name><name>relcrypt</name><operator>-&gt;</operator><name>relfilenode</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
                        <argument><expr><name><name>relcrypt</name><operator>-&gt;</operator><name>relfilenode</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
                        <argument><expr><name><name>relcrypt</name><operator>-&gt;</operator><name>relfilenode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                        <argument><expr><name><name>relcrypt</name><operator>-&gt;</operator><name>algo_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
    <expr_stmt><expr><call><name>PageSetAlgorithmId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
    
    <expr_stmt><expr><call><name>crypt_free</name><argument_list>(<argument><expr><name>encryptpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><name>page</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * parellel crypt in workers
 * there is a difference between aes128 and guomi(sm4) in encrypt_procedure_inner 
 */</comment>
<function><type><name>int</name></type> <name>rel_crypt_page_encrypting_parellel</name><parameter_list>(<parameter><decl><type><name>int16</name></type> <name>algo_id</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buf_need_encrypt_input</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>page_new_output</name></decl></parameter>, <parameter><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>workerid</name></decl></parameter>)</parameter_list>
<block>{<block_content>     
    <decl_stmt><decl><type><name>int</name></type>     <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>   <modifier>*</modifier></type><name>encryptpage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>   <modifier>*</modifier></type><name>buf_need_encrypt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>page_new</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>page_new</name>         <operator>=</operator> <name>page_new_output</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>page_new</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* copy the page context except pageheader, and make a standard text struct */</comment>
    <expr_stmt><expr><name>buf_need_encrypt</name> <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><name>buf_need_encrypt_input</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>buf_need_encrypt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>VARHDRSZ</name> <operator>+</operator> <name>PAGE_ENCRYPT_LEN</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>buf_need_encrypt</name></expr></argument>, <argument><expr><operator>(</operator><name>VARHDRSZ</name> <operator>+</operator> <name>PAGE_ENCRYPT_LEN</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>buf_need_encrypt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>page</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PageHeaderData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>, <argument><expr><name>PAGE_ENCRYPT_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* run encrypt algorithm */</comment>
    <expr_stmt><expr><name>encryptpage</name> <operator>=</operator> <call><name>encrypt_procedure_inner</name><argument_list>(<argument><expr><name>cryptkey</name></expr></argument>, <argument><expr><name>buf_need_encrypt</name></expr></argument>, <argument><expr><name>page_new</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PageHeaderData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>encryptpage</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_check</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>crypt_check</name><argument_list>(<argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name>buf_need_encrypt</name></expr></argument>, <argument><expr><name>encryptpage</name></expr></argument>, <argument><expr><name>INVALID_CONTEXT_LENGTH</name></expr></argument>, <argument><expr><name>workerid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* aes128/192/256 would return a copy of crypted page context, so, copy it to dst page */</comment>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>encryptpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>PAGE_ENCRYPT_LEN</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>page_new</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>page</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PageHeaderData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>page_new</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PageHeaderData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>encryptpage</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PageSetAlgorithmId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PageSetAlgorithmId</name><argument_list>(<argument><expr><name>page_new</name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>crypt_free</name><argument_list>(<argument><expr><name>encryptpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <return>return <expr><name>CRYPT_RET_SUCCESS</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* 
         * crypt has no return, so, no length judge, page_new conntains the crypted context except the pageheader
         * such as guomi, sm4, we consider the length of crypted context is (blcksz - sizeof(PageHeaderData)) as default.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>g_enable_crypt_check</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>crypt_check</name><argument_list>(<argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name>buf_need_encrypt</name></expr></argument>, <argument><expr><operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><operator>(</operator><name>page_new</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PageHeaderData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>, <argument><expr><name>BLCKSZ</name><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>PageHeaderData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>workerid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>page_new</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>page</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PageHeaderData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* page_new is assigned in encrypt_procedure_inner except page header */</comment>    
        <expr_stmt><expr><call><name>PageSetAlgorithmId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageSetAlgorithmId</name><argument_list>(<argument><expr><name>page_new</name></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* encryptpage is NULL, no free */</comment>

        <return>return <expr><name>CRYPT_RET_SUCCESS</name></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PageSetAlgorithmId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  

    <expr_stmt><expr><call><name>crypt_free</name><argument_list>(<argument><expr><name>encryptpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><name>CRYPT_RET_OVERSIZE</name></expr>;</return>  
</block_content>}</block></function>


<function><type><name>void</name></type> <name>print_page_header</name><parameter_list>(<parameter><decl><type><name>PageHeader</name></type> <name>header</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"----print pagehead begin----\n"</literal>
              <literal type="string">"pd_lsn(xlogid:%u xrecoff:%u), pd_checksum:%u, pd_flags:%u, pd_shard:%d, "</literal>
              <literal type="string">"pd_lower:%u, pd_upper:%u, pd_special:%u, pd_pagesize_version:%u, pd_algorithm_id:%d, "</literal>
              <literal type="string">"pd_prune_ts:"</literal><name>INT64_FORMAT</name> <literal type="string">", pd_prune_xid:%u "</literal>
              <literal type="string">"----print pagehead end----\n"</literal></expr></argument>,
        <argument><expr><name><name>header</name><operator>-&gt;</operator><name>pd_lsn</name><operator>.</operator><name>xlogid</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>pd_lsn</name><operator>.</operator><name>xrecoff</name></name></expr></argument>,
        <argument><expr><name><name>header</name><operator>-&gt;</operator><name>pd_checksum</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>pd_flags</name></name></expr></argument>,
        <argument><expr><name><name>header</name><operator>-&gt;</operator><name>pd_shard</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>pd_lower</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>pd_upper</name></name></expr></argument>,
        <argument><expr><name><name>header</name><operator>-&gt;</operator><name>pd_special</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>pd_pagesize_version</name></name></expr></argument>, 
        <argument><expr><name><name>header</name><operator>-&gt;</operator><name>pd_algorithm_id</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>pd_prune_ts</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>pd_prune_xid</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>rel_crypt_page_decrypt</name><parameter_list>(<parameter><decl><type><name>RelCrypt</name></type> <name>relcrypt</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int16</name></type>   <name>algo_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>  <modifier>*</modifier></type><name>cryptedpage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>  <modifier>*</modifier></type><name>decryptpage</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>algo_id</name> <operator>=</operator> <call><name>PageGetAlgorithmId</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>cryptedpage</name> <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>page</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PageHeaderData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* run decrypt algorithm, context length for page decrypt is default:(BLCKSZ - sizeof(PageHeaderData)), this is used for guomi(sm4) */</comment>
    <expr_stmt><expr><name>decryptpage</name> <operator>=</operator> <call><name>decrypt_procedure</name><argument_list>(<argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name>cryptedpage</name></expr></argument>, <argument><expr><name>BLCKSZ</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PageHeaderData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>decryptpage</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* just exchange data region */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>page</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PageHeaderData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>decryptpage</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>decryptpage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* remember to free */</comment>
        <comment type="line">//crypt_free(decryptpage);</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* guomi(sm4) decrypts and rewrites orignal page, no return, so no need to copy */</comment>
    </block_content>}</block></else></if_stmt>

    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * do the encrypt action
 * this function support several scenarios.
 * 1. sym/non-sym/udf crypt function.
 * 2. page_new_output is no use in sym/non-sym crypt.
 * 3. in crypt, such as guomi(sm4), page_new_output will be supplied for page crypt, and NULL for column crypt.
 * 4. column crypt will alloc memory in this function, to compatible with parellel crypt, 
 *    use malloc, and the memory would release with process quit.
 */</comment>
<function><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type> <name>encrypt_procedure_inner</name><parameter_list>(<parameter><decl><type><name>CryptKeyInfo</name></type> <name>cryptkey_local</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type> <name>text_src</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>page_new_output</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type> <name>text_ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type> <name>password</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type> <name>option_args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type> <name>pubkey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>  <name>option</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>    <name>datum_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>datum_ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>page_new_inner</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
 
    <expr_stmt><expr><name>option</name> <operator>=</operator> <name><name>cryptkey_local</name><operator>-&gt;</operator><name>option</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>CRYPT_KEY_INFO_OPTION_SYMKEY</name> <operator>==</operator> <name>option</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>password</name>    <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey_local</name><operator>-&gt;</operator><name>password</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>option_args</name> <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey_local</name><operator>-&gt;</operator><name>option_args</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>text_ret</name>    <operator>=</operator> <call><name>encrypt_internal</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>text_src</name></expr></argument>, <argument><expr><name>password</name></expr></argument>, <argument><expr><name>option_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>CRYPT_KEY_INFO_OPTION_ANYKEY</name> <operator>==</operator> <name>option</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>pubkey</name>      <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey_local</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>publickey</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>text_ret</name>    <operator>=</operator> <call><name>encrypt_internal</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>text_src</name></expr></argument>, <argument><expr><name>pubkey</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>CRYPT_KEY_INFO_OPTION_SM4</name> <operator>==</operator> <name>option</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">//sm4_context ctx;</comment>
        <comment type="line">//password    = (text*)(cryptkey_local-&gt;password);</comment>
        <comment type="line">//sm4_setkey_enc(&amp;ctx, (unsigned char *)VARDATA_ANY(password));</comment>
        <if_stmt><if>if <condition>(<expr><name>page_new_output</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* for page encrypt */</comment>
            <comment type="block">/* 
             * arg1: sm4context
             * arg2: encrypt action = 1
             * arg3: length of context to encrypt
             * arg4: context to encrypt
             * arg5: encrypt result
             */</comment>
            <expr_stmt><expr><call><name>sm4_crypt_ecb</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cryptkey_local</name><operator>-&gt;</operator><name>sm4_ctx_encrypt</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>text_src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>text_src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>page_new_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>text_ret</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* for column encrypt */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>text_src</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>BLCKSZ</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PageHeaderData</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"the column to crypt is oversize"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>datum_len</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>text_src</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>datum_ptr</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>datum_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>datum_ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>datum_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>datum_ptr</name></expr></argument>, <argument><expr><name>datum_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>sm4_crypt_ecb</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cryptkey_local</name><operator>-&gt;</operator><name>sm4_ctx_encrypt</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>text_src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>text_src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>datum_ptr</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name>text_ret</name> <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><name>datum_ptr</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>CRYPT_KEY_INFO_OPTION_UDF</name> <operator>==</operator> <name>option</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>pubkey</name>      <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey_local</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>publickey</name></name><operator>)</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>page_new_output</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* function 'DirectFunctionCall3Coll' force to make a return, otherwise, will make an error, so return value is necessary. */</comment>
            <expr_stmt><expr><call><name>DirectFunctionCall3Coll</name><argument_list>(<argument><expr><name><name>cryptkey_local</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_func</name></name></expr></argument>, 
                                            <argument><expr><name>InvalidOid</name></expr></argument>,
                                            <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>text_src</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>pubkey</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>page_new_output</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* src and dst buffer are sent to udf crypt func */</comment>
            <expr_stmt><expr><name>text_ret</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* for column crypt */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>text_src</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>BLCKSZ</name> <operator>-</operator> <name>VARHDRSZ</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"the column to crypt is oversize"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>page_new_inner</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>page_new_inner</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>page_new_inner</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>page_new_inner</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>DirectFunctionCall3Coll</name><argument_list>(<argument><expr><name><name>cryptkey_local</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>encrypt_func</name></name></expr></argument>, 
                                                <argument><expr><name>InvalidOid</name></expr></argument>,
                                                <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>text_src</name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>pubkey</name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>page_new_inner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>text_ret</name> <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><name>page_new_inner</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>        
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>text_ret</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown option value:%d in encrypt_procedure"</literal></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <return>return <expr><name>text_ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>crypt_mem_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>s2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>s1</name><operator>+</operator><name>i</name><operator>)</operator> <operator>!=</operator> <operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>s2</name><operator>+</operator><name>i</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>crypt_check</name><parameter_list>(<parameter><decl><type><name>int16</name></type> <name>algo_id</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type> <name>text_src</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type> <name>text_crypted</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>workerid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type> <name>text_ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>text_crypt_copy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>INVALID_CONTEXT_LENGTH</name> <operator>==</operator> <name>length</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>text_ret</name> <operator>=</operator> <call><name>decrypt_procedure</name><argument_list>(<argument><expr><name>algo_id</name></expr></argument>, <argument><expr><name>text_crypted</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>crypt_mem_cmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>text_src</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>text_ret</name></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>text_src</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>text_crypt_copy</name> <operator>=</operator> <name><name>g_crypt_check_array</name><index>[<expr><name>workerid</name></expr>]</index></name></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>text_crypt_copy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>text_crypt_copy</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>text_crypted</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>decrypt_procedure</name><argument_list>(<argument><expr><name>algo_id</name></expr></argument>, <argument><expr><operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><name>text_crypt_copy</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>crypt_mem_cmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>text_src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>text_crypt_copy</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>rel_crypt_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>g_crypt_check_array</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>g_checkpoint_crypt_worker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition><expr><name>i</name> <operator>&lt;</operator> <name>g_checkpoint_crypt_worker</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_crypt_check_array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MARK</name><argument_list>(<argument><expr><literal type="string">"column crypt"</literal></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRANSP_CRYPT_INVALID_CACHEOFF</name></cpp:macro>       <cpp:value>-1</cpp:value></cpp:define>  <comment type="block">/* relative to attcacheoff -1 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRANSP_CRYPT_ENABLED</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>             <cpp:value>(NULL != (X))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transparent_crypt_check_and_fill_table_col_crypto</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>TranspCrypt</name> <modifier>*</modifier></type> <name>transp_crypt</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>memcxt</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr_ext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type> <name>has_plain_to_compress</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transparent_crypt_init_element</name><parameter_list>(<parameter><decl><type><name>TranspCrypt</name> <modifier>*</modifier></type> <name>transp_crypt</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="line">//static void transparent_crypt_assign_policy_algo_key(TranspCrypt * transp_crypt, MemoryContext memcxt, int attnum);</comment>
<comment type="line">//static bytea * transparent_crypt_get_dearmor_key(char* key, MemoryContext memcxt);</comment>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>transparent_crypt_encrypt_datum</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>TranspCrypt</name> <modifier>*</modifier></type> <name>transp_crypt</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type> <name>transparent_crypt_datum_get_text</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transparent_crypt_attr_plain_storage_to_compress_storage</name><parameter_list>(<parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>transparent_crypt_text_get_datum</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transparent_crypt_assign_tupledesc_field_inner</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type>    <name>tupledesc</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>memctx</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * a little quicker check whether this table was binding a crypt.
 * mix is true, no matter relcrypt or column crypt bound, will return yes,
 * otherwise, only column has crypt policy would return yes.
 */</comment>
<function><type><name>bool</name></type> <name>trsprt_crypt_check_table_has_crypt</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>mix</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type> <name>schema_bound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>hascrypt</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_transparent_crypt_policy_map_relid</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                    <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TransparentCryptPolicyMapRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, 
                              <argument><expr><name>PgTransparentCryptPolicyMapIndexId</name></expr></argument>, 
                              <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, 
                              <argument><expr><literal type="number">1</literal></expr></argument>, 
                              <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>hascrypt</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_transparent_crypt_policy_map</name></type> <name>form_pol_map</name> <init>= <expr><operator>(</operator><name>Form_pg_transparent_crypt_policy_map</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>mix</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>hascrypt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>schema_bound</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* check if schema is bound crypto */</comment>
                <if_stmt><if>if <condition>(<expr><name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name> <operator>!=</operator> <call><name>mls_check_schema_crypted</name><argument_list>(<argument><expr><name><name>form_pol_map</name><operator>-&gt;</operator><name>schemaoid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>schema_bound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>schema_bound</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>REL_FILE_CRYPT_ATTR_NUM</name> <operator>!=</operator> <name><name>form_pol_map</name><operator>-&gt;</operator><name>attnum</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>hascrypt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>hascrypt</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>transparent_crypt_init_element</name><parameter_list>(<parameter><decl><type><name>TranspCrypt</name> <modifier>*</modifier></type> <name>transp_crypt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>transp_crypt</name><operator>-&gt;</operator><name>algo_id</name></name>       <operator>=</operator> <name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>    
    transp_crypt-&gt;option        = 0;
    transp_crypt-&gt;password      = NULL;
    transp_crypt-&gt;pubkey        = NULL;
    transp_crypt-&gt;privatekey    = NULL;
    transp_crypt-&gt;option_args   = NULL;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * here, we already known this table coupled with crypto, so check attributes one by one and mark them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>transparent_crypt_check_and_fill_table_col_crypto</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, 
                                                                    <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, 
                                                                    <parameter><decl><type><name>TranspCrypt</name> <modifier>*</modifier></type> <name>transp_crypt</name></decl></parameter>, 
                                                                    <parameter><decl><type><name>MemoryContext</name></type> <name>memcxt</name></decl></parameter>, 
                                                                    <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl></parameter>,
                                                                    <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr_ext</name></decl></parameter>,
                                                                    <parameter><decl><type><name>bool</name> <modifier>*</modifier></type> <name>has_plain_to_compress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>unsupport_data_type</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>memcxt</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>found</name>               <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>unsupport_data_type</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_transparent_crypt_policy_map_relid</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                    <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_transparent_crypt_policy_map_attnum</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                    <argument><expr><name>F_INT2EQ</name></expr></argument>,
                    <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TransparentCryptPolicyMapRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, 
                              <argument><expr><name>PgTransparentCryptPolicyMapIndexId</name></expr></argument>, 
                              <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, 
                              <argument><expr><literal type="number">2</literal></expr></argument>, 
                              <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* attribute is bound with crypt policy, then check type is supported or not */</comment>
        <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <call><name>mls_support_data_type</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Form_pg_transparent_crypt_policy_map</name></type> <name>form_trans_crypt</name> 
                    <init>= <expr><operator>(</operator><name>Form_pg_transparent_crypt_policy_map</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">//if (true == form_trans_crypt-&gt;enable)</comment>
            <block>{<block_content>
                <expr_stmt><expr><name><name>transp_crypt</name><operator>-&gt;</operator><name>algo_id</name></name> <operator>=</operator> <name><name>form_trans_crypt</name><operator>-&gt;</operator><name>algorithm_id</name></name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>crypt_key_info_load_by_algoid</name><argument_list>(<argument><expr><name><name>transp_crypt</name><operator>-&gt;</operator><name>algo_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> 

                <comment type="block">/* 
                 * backup attribute infos for these firm length datatype, such int2/4/8, 
                 * to mark the modify of storage type.
                 * while, this treating method is not perfect in one case, to make an example as follows,
                 * we change attcacheoff to '-1' directly, in fact, the first variable length col, 
                 * its attcacheoff could be valid.
                 * we omit this case.
                 */</comment>
                <expr_stmt><expr><call><name>transparent_crypt_attr_plain_storage_to_compress_storage</name><argument_list>(<argument><expr><name>attr_ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>has_plain_to_compress</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>unsupport_data_type</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>transparent_crypt_init_element</name><argument_list>(<argument><expr><name>transp_crypt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <name>unsupport_data_type</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"transparent crypt:unsupport type, typid:%d"</literal></expr></argument>, 
            <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return ;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>trsprt_crypt_chk_tbl_col_has_crypt</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>found</name>               <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_transparent_crypt_policy_map_relid</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                    <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_transparent_crypt_policy_map_attnum</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                    <argument><expr><name>F_INT2EQ</name></expr></argument>,
                    <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TransparentCryptPolicyMapRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, 
                              <argument><expr><name>PgTransparentCryptPolicyMapIndexId</name></expr></argument>, 
                              <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, 
                              <argument><expr><literal type="number">2</literal></expr></argument>, 
                              <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>trsprt_crypt_chk_tbl_has_col_crypt</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>found</name>               <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_transparent_crypt_policy_map_relid</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                    <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TransparentCryptPolicyMapRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, 
                              <argument><expr><name>PgTransparentCryptPolicyMapIndexId</name></expr></argument>, 
                              <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, 
                              <argument><expr><literal type="number">1</literal></expr></argument>, 
                              <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_transparent_crypt_policy_map</name></type> <name>form</name> <init>= <expr><operator>(</operator><name>Form_pg_transparent_crypt_policy_map</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>form</name><operator>-&gt;</operator><name>attnum</name></name> <operator>&gt;</operator> <name>InvalidAttrNumber</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 *  decrypt one column when 'SELECT' value, while, only several basic type supported, 
 *      such as varchar,text 
 */</comment>
<function><type><name>Datum</name></type> <name>trsprt_crypt_decrypt_one_col_value</name><parameter_list>(<parameter><decl><type><name>TranspCrypt</name><modifier>*</modifier></type><name>transp_crypt</name></decl></parameter>,
                                                        <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl></parameter>, 
                                                        <parameter><decl><type><name>Datum</name></type> <name>inputval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>   <name>datum_ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type>  <name>datum_text</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name> <operator>!=</operator> <name><name>transp_crypt</name><operator>-&gt;</operator><name>algo_id</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>datum_text</name> <operator>=</operator> <call><name>decrypt_procedure</name><argument_list>(<argument><expr><name><name>transp_crypt</name><operator>-&gt;</operator><name>algo_id</name></name></expr></argument>, <argument><expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><name>inputval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INVALID_CONTEXT_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <if_stmt><if>if <condition>(<expr><name>datum_text</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>datum_ret</name> <operator>=</operator> <call><name>transparent_crypt_text_get_datum</name><argument_list>(<argument><expr><name>datum_text</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
	        <expr_stmt><expr><name>datum_ret</name> <operator>=</operator> <call><name>transparent_crypt_text_get_datum</name><argument_list>(<argument><expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><name>inputval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <return>return <expr><name>datum_ret</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"get an invalid transp_crypt-&gt;algo_id:%d"</literal></expr></argument>, <argument><expr><name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>   
</block_content>}</block></function>

<function><type><name>void</name></type> <name>transparent_crypt_copy_attrs</name><parameter_list>(<parameter><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type> <name>dst_attrs</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type> <name>src_attrs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dst_attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>src_attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * assign transp_crypt in tupledesc
 * check the table(relid) has transparent crypt policy or not,
 * if so, assign passwd or keys, then create an copy of attrs in case of those 'attbyval' columns
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>transparent_crypt_assign_tupledesc_field_inner</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type>    <name>tupledesc</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>memctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>               <name>has_plain_to_compress</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>natts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>loop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>      <name>old_memctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>attrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>attrs_ext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TranspCrypt</name>       <modifier>*</modifier></type><name>transp_crypt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>                <name>parent_oid</name></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_SYSTEM_REL</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>parent_oid</name> <operator>=</operator> <call><name>mls_get_parent_oid_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* quick check wether this table has col with crypt */</comment>
        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>trsprt_crypt_check_table_has_crypt</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        	<expr_stmt><expr><call><name>trsprt_crypt_free_strut_in_tupdesc</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><name><name>tupledesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>tupledesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>old_memctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>memctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* build transp_crypt */</comment>
        <expr_stmt><expr><name>transp_crypt</name> <operator>=</operator> <operator>(</operator><name>TranspCrypt</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TranspCrypt</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* build attrs_ext */</comment>
        <expr_stmt><expr><name>attrs_ext</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Form_pg_attribute</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>loop</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>loop</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>attrs_ext</name><index>[<expr><name>loop</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FormData_pg_attribute</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>attrs</name> <operator>=</operator> <name><name>tupledesc</name><operator>-&gt;</operator><name>attrs</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>transparent_crypt_copy_attrs</name><argument_list>(<argument><expr><name>attrs_ext</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>, <argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>has_plain_to_compress</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <comment type="block">/* check col one by one */</comment>
        <for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* skip the droped column */</comment>
            <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name><name>tupledesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>transparent_crypt_check_and_fill_table_col_crypto</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>, 
                                                            <argument><expr><name>attnum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, 
                                                            <argument><expr><operator>&amp;</operator><name><name>transp_crypt</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>, 
                                                            <argument><expr><name>memctx</name></expr></argument>, 
                                                            <argument><expr><name><name>attrs</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>,
                                                            <argument><expr><name><name>attrs_ext</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>,
                                                            <argument><expr><operator>&amp;</operator><name>has_plain_to_compress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* 
                 * if there was one attribute storage changing from plain to compress, 
                 * later, the following attributes could not be fetched by cacheoff, 
                 * so we mark the attrcacheoff of following ones to invalid 
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>has_plain_to_compress</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>attrs_ext</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attcacheoff</name> <operator>=</operator> <name>TRANSP_CRYPT_INVALID_CACHEOFF</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_memctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name><name>tupledesc</name><operator>-&gt;</operator><name>transp_crypt</name></name> <operator>=</operator> <name>transp_crypt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tupledesc</name><operator>-&gt;</operator><name>attrs_ext</name></name>    <operator>=</operator> <name>attrs_ext</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>tupledesc</name><operator>-&gt;</operator><name>transp_crypt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tupledesc</name><operator>-&gt;</operator><name>attrs_ext</name></name>    <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tupledesc</name><operator>-&gt;</operator><name>use_attrs_ext</name></name><operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * we place transp_crypt in tupledesc
 */</comment>
<function><type><name>void</name></type> <name>trsprt_crypt_asign_rela_tuldsc_fld</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>g_enable_transparent_crypt</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>transparent_crypt_assign_tupledesc_field_inner</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>    
</block_content>}</block></function>

<comment type="block">/*
 * to make up tupdescfree.
 */</comment> 
<function><type><name>void</name></type> <name>trsprt_crypt_free_strut_in_tupdesc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupledesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>                 <name>loop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TranspCrypt</name>        <modifier>*</modifier></type><name>transp_crypt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name>  <modifier>*</modifier></type><name>attrs_ext</name></decl>;</decl_stmt>

    <comment type="block">/* treat transp_crypt */</comment>
    <expr_stmt><expr><name>transp_crypt</name> <operator>=</operator> <name><name>tupledesc</name><operator>-&gt;</operator><name>transp_crypt</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>transp_crypt</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>transp_crypt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>tupledesc</name><operator>-&gt;</operator><name>transp_crypt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* treat attrs_ext */</comment>
    <expr_stmt><expr><name>attrs_ext</name> <operator>=</operator> <name><name>tupledesc</name><operator>-&gt;</operator><name>attrs_ext</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>attrs_ext</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>loop</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>loop</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>attrs_ext</name><index>[<expr><name>loop</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>attrs_ext</name><index>[<expr><name>loop</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attrs_ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>tupledesc</name><operator>-&gt;</operator><name>attrs_ext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <return>return ;</return>
</block_content>}</block></function>



<comment type="block">/* 
 * after tuple deform to slot, exchange the col values with decrypt result.
 */</comment>
<function><type><name>void</name></type> <name>trsprt_crypt_dcrpt_all_col_vale</name><parameter_list>(<parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>                <name>need_exchange_slot_tts_tuple</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                    <name>attnum</name>      <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>            <name>tupleDesc</name>   <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>               <modifier>*</modifier></type><name>tuple_values</name><init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>               <modifier>*</modifier></type><name>tuple_isnull</name><init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>               <modifier>*</modifier></type><name>slot_values</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>               <modifier>*</modifier></type><name>slot_isnull</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TranspCrypt</name>        <modifier>*</modifier></type><name>transp_crypt</name><init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>transp_crypt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name>  <modifier>*</modifier></type><name>att</name>         <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                 <name>numberOfAttributes</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>           <name>new_tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>       <name>old_memctx</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>transp_crypt</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>old_memctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mls_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>need_exchange_slot_tts_tuple</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>need_exchange_slot_tts_tuple</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>tuple_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tuple_isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>TRANSP_CRYPT_ATTRS_EXT_ENABLE</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>tuple_values</name></expr></argument>, <argument><expr><name>tuple_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>TRANSP_CRYPT_ATTRS_EXT_DISABLE</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>numberOfAttributes</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* skip null col */</comment>
            <if_stmt><if>if <condition>(<expr><name>need_exchange_slot_tts_tuple</name> <operator>&amp;&amp;</operator> <name><name>tuple_isnull</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><name>need_exchange_slot_tts_tuple</name> <operator>&amp;&amp;</operator> <name><name>slot_isnull</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            
            <if_stmt><if>if <condition>(<expr><name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name> <operator>!=</operator> <name><name>transp_crypt</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>.</operator><name>algo_id</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>need_exchange_slot_tts_tuple</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>slot_values</name><index>[<expr><name>attnum</name></expr>]</index></name>  <operator>=</operator> <call><name>trsprt_crypt_decrypt_one_col_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>transp_crypt</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>,
                                                                            <argument><expr><name><name>att</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>, 
                                                                            <argument><expr><name><name>tuple_values</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* tuple_values are null, so try slot_values */</comment>
                    <expr_stmt><expr><name><name>slot_values</name><index>[<expr><name>attnum</name></expr>]</index></name>  <operator>=</operator> <call><name>trsprt_crypt_decrypt_one_col_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>transp_crypt</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>,
                                                                            <argument><expr><name><name>att</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>, 
                                                                            <argument><expr><name><name>slot_values</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <comment type="block">/* 
                 * if datum is invalid, slot_values is invalid either, keep orginal value in tuple_value
                 * it seems a little bored
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>need_exchange_slot_tts_tuple</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>tuple_values</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <name><name>slot_values</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>need_exchange_slot_tts_tuple</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* do not forget to fill shardid */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>RelationIsSharded</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss_currentRelation</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_form_tuple_plain</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>tuple_values</name></expr></argument>, <argument><expr><name>tuple_isnull</name></expr></argument>, <argument><expr><call><name>RelationGetDisKey</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss_currentRelation</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                   <argument><expr><call><name>RelationGetSecDisKey</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss_currentRelation</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss_currentRelation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>tuple_values</name></expr></argument>, <argument><expr><name>tuple_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* remember to do this copy manually */</comment>
            <expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_self</name></name>       <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name>   <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_xc_node_id</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name><operator>-&gt;</operator><name>t_xc_node_id</name></name></expr>;</expr_stmt>

            <comment type="block">/* after forming a new tuple, the orginal could be free if needed */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFree</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>            
            
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name> <operator>=</operator> <name>new_tuple</name></expr>;</expr_stmt>
            
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFree</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tuple_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tuple_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_memctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>trsprt_crypt_dcrpt_all_col_vale_cp</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
                                                            <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>                    <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TranspCrypt</name>        <modifier>*</modifier></type><name>transp_crypt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name>  <modifier>*</modifier></type><name>attrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                 <name>numberOfAttributes</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>transp_crypt</name>       <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>transp_crypt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>numberOfAttributes</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>attrs</name>              <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>transp_crypt</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">//old_memctx = MemoryContextSwitchTo(slot-&gt;tts_mcxt);</comment>

        <expr_stmt><expr><call><name>TRANSP_CRYPT_ATTRS_EXT_ENABLE</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TRANSP_CRYPT_ATTRS_EXT_DISABLE</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>numberOfAttributes</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* skip null col */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            
            <if_stmt><if>if <condition>(<expr><name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name> <operator>!=</operator> <name><name>transp_crypt</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>.</operator><name>algo_id</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>values</name><index>[<expr><name>attnum</name></expr>]</index></name>  <operator>=</operator> <call><name>trsprt_crypt_decrypt_one_col_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>transp_crypt</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>,
                                                                            <argument><expr><name><name>attrs</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>, 
                                                                            <argument><expr><name><name>values</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <comment type="line">//MemoryContextSwitchTo(old_memctx);</comment>
    </block_content>}</block></if></if_stmt>
    
    <return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>transparent_crypt_attr_plain_storage_to_compress_storage</name><parameter_list>(<parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name>        <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name>      <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>attcacheoff</name></name>   <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>attstorage</name></name>    <operator>=</operator> <literal type="char">'x'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>attalign</name></name>      <operator>=</operator> <literal type="char">'i'</literal></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type> <name>transparent_crypt_text_get_datum</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>     <name>typid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type>  <name>datum_text</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>   <name>datum_ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>    <name><name>datum_str</name><index>[<expr><literal type="number">70</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>typid</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><name>typid</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>VARCHAR2OID</name></expr>:</case>
        <case>case <expr><name>VARCHAROID</name></expr>:</case>
        <case>case <expr><name>TEXTOID</name></expr>:</case>
        <case>case <expr><name>BPCHAROID</name></expr>:</case>
        <case>case <expr><name>BYTEAOID</name></expr>:</case>
            <expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>INT2OID</name></expr>:</case>
        <case>case <expr><name>INT4OID</name></expr>:</case>
        <case>case <expr><name>INT8OID</name></expr>:</case>
        <case>case <expr><name>FLOAT4OID</name></expr>:</case>
        <case>case <expr><name>FLOAT8OID</name></expr>:</case>
        <case>case <expr><name>NUMERICOID</name></expr>:</case>
        <case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type>    <name>typinput</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type> <name>typioparam</name></decl>;</decl_stmt>
                
                <expr_stmt><expr><name>datum_text</name> <operator>=</operator> <call><name>DatumGetTextP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  

                <expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typinput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>datum_str</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>datum_text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>datum_text</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>datum_ret</name> <operator>=</operator> <call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>typinput</name></expr></argument>, <argument><expr><name>datum_str</name></expr></argument>,
                                            <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>datum_ret</name></expr>;</return>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
                if (INT2OID == typid)
                {
                    datum_ret = Int16GetDatum(atoi(VARDATA_ANY(datum_text)));
                    return datum_ret;
                }
                else if (INT4OID == typid)
                {
                    datum_ret = Int32GetDatum(atoi(VARDATA_ANY(datum_text)));
                    return datum_ret;
                }
                else if (INT8OID == typid)
                {
                    datum_ret = Int64GetDatum(atoll(VARDATA_ANY(datum_text)));
                    return datum_ret;
                }
                else if (FLOAT4OID == typid)
                {
                    datum_ret = DirectFunctionCall1(float4in, VARDATA_ANY(datum_text));
                    return datum_ret;
                }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                
            </block_content>}</block>
            <break>break;</break>
        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>
    
    <comment type="block">/* keep compiler quite */</comment>
    <return>return <expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get text struct of datum, if datum is in plain storage, that should be converted to compress
 */</comment>
<function><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type> <name>transparent_crypt_datum_get_text</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRANSPARENT_CRYPT_DIGITAL_MAX_LEN</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
    
    <decl_stmt><decl><type><name>Oid</name></type> <name>typid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>typid</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><name>typid</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>VARCHAR2OID</name></expr>:</case>
        <case>case <expr><name>VARCHAROID</name></expr>:</case>
        <case>case <expr><name>TEXTOID</name></expr>:</case>
        <case>case <expr><name>BPCHAROID</name></expr>:</case>
        <case>case <expr><name>BYTEAOID</name></expr>:</case>
            <return>return <expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
            <break>break;</break>
            
        <case>case <expr><name>INT2OID</name></expr>:</case>
        <case>case <expr><name>INT4OID</name></expr>:</case>
        <case>case <expr><name>INT8OID</name></expr>:</case>
        <case>case <expr><name>FLOAT4OID</name></expr>:</case>
        <case>case <expr><name>FLOAT8OID</name></expr>:</case>
        <case>case <expr><name>NUMERICOID</name></expr>:</case>
        <case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name></type>   <name><name>digital_str</name><index>[<expr><name>TRANSPARENT_CRYPT_DIGITAL_MAX_LEN</name></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>    <name>len</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type> <name>datum_text</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>       <name>typoutput</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>   <name>typisvarlen</name></decl>;</decl_stmt>
                
                <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>digital_str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRANSPARENT_CRYPT_DIGITAL_MAX_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>digital_str</name></expr></argument>, <argument><expr><name>TRANSPARENT_CRYPT_DIGITAL_MAX_LEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, 
                                    <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strnlen</name><argument_list>(<argument><expr><name>digital_str</name></expr></argument>, <argument><expr><name>TRANSPARENT_CRYPT_DIGITAL_MAX_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

                <expr_stmt><expr><name>datum_text</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>VARHDRSZ</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>datum_text</name></expr></argument>, <argument><expr><name>VARHDRSZ</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>datum_text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>digital_str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <return>return <expr><name>datum_text</name></expr>;</return>
            </block_content>}</block>
            <break>break;</break>    
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"datatype:%d dose not be supported by transparent crypt"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* keep compiler quite */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * the caller must sure that algo_id was valid 
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type> <name>transparent_crypt_encrypt_datum</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>TranspCrypt</name> <modifier>*</modifier></type> <name>transp_crypt</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type>        <name>datum_text</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>transp_crypt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>datum_text</name> <operator>=</operator> <call><name>transparent_crypt_datum_get_text</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>datum_text</name> <operator>=</operator> <call><name>encrypt_procedure</name><argument_list>(<argument><expr><name><name>transp_crypt</name><operator>-&gt;</operator><name>algo_id</name></name></expr></argument>, <argument><expr><name>datum_text</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
    <return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>datum_text</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>HeapTuple</name></type> <name>transparent_crypt_encrypt_columns</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>memctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>                    <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>            <name>tupleDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>               <modifier>*</modifier></type><name>tuple_values</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>               <modifier>*</modifier></type><name>tuple_isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                 <name>numberOfAttributes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TranspCrypt</name>        <modifier>*</modifier></type><name>transp_crypt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name>  <modifier>*</modifier></type><name>attrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>           <name>heaptup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>       <name>old_memctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleHeader</name></type>     <name>tupheader</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>numberOfAttributes</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>transp_crypt</name>       <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>transp_crypt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>attrs</name>              <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>old_memctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>memctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple_isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>  <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">//TRANSP_CRYPT_ATTRS_EXT_ENABLE(tupleDesc);</comment>
    <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>tuple_values</name></expr></argument>, <argument><expr><name>tuple_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">//TRANSP_CRYPT_ATTRS_EXT_DISABLE(tupleDesc);</comment>
    
    <for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>numberOfAttributes</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* skip null col */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tuple_isnull</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name> <operator>!=</operator> <name><name>transp_crypt</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>.</operator><name>algo_id</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>tuple_values</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <call><name>transparent_crypt_encrypt_datum</name><argument_list>(<argument><expr><name><name>tuple_values</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>, 
                                                                    <argument><expr><operator>&amp;</operator><name><name>transp_crypt</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>, 
                                                                    <argument><expr><name><name>attrs</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    
    <expr_stmt><expr><call><name>TRANSP_CRYPT_ATTRS_EXT_ENABLE</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>RelationIsSharded</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>heaptup</name> <operator>=</operator> <call><name>heap_form_tuple_plain</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>tuple_values</name></expr></argument>, <argument><expr><name>tuple_isnull</name></expr></argument>, <argument><expr><call><name>RelationGetDisKey</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>RelationGetSecDisKey</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>heaptup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>tuple_values</name></expr></argument>, <argument><expr><name>tuple_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>TRANSP_CRYPT_ATTRS_EXT_DISABLE</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tupheader</name> <operator>=</operator> <name><name>heaptup</name><operator>-&gt;</operator><name>t_data</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>heaptup</name><operator>-&gt;</operator><name>t_self</name></name>       <operator>=</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>heaptup</name><operator>-&gt;</operator><name>t_tableOid</name></name>   <operator>=</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>heaptup</name><operator>-&gt;</operator><name>t_xc_node_id</name></name> <operator>=</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_xc_node_id</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>tupheader</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_memctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><name>heaptup</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MARK</name><argument_list>(<argument><expr><literal type="string">"extern"</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>text</name> <modifier>*</modifier></type> <name>encrypt_procedure</name><parameter_list>(<parameter><decl><type><name>AlgoId</name></type> <name>algo_id</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type> <name>text_src</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>page_new_output</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type> <name>text_ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>   <name>found</name></decl>;</decl_stmt>
    <comment type="block">/* accelerate looking for */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int16</name></type>        <name>algo_id_keep</name>  <init>= <expr><name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>CryptKeyInfo</name></type> <name>cryptkey_keep</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>algo_id</name> <operator>==</operator> <name>algo_id_keep</name> <operator>&amp;&amp;</operator> <name>cryptkey_keep</name></expr>)</condition>
    <block>{<block_content>
        <empty_stmt>;</empty_stmt> 
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>   
        <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>crypt_key_info_hash_lookup</name><argument_list>(<argument><expr><name>algo_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cryptkey_keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>found</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"algo_id:%d dose not exist"</literal></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* cache it for next time using the same crypt key info */</comment>
        <expr_stmt><expr><name>algo_id_keep</name>  <operator>=</operator> <name>algo_id</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>text_ret</name> <operator>=</operator> <call><name>encrypt_procedure_inner</name><argument_list>(<argument><expr><name>cryptkey_keep</name></expr></argument>, <argument><expr><name>text_src</name></expr></argument>, <argument><expr><name>page_new_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>    
    if (g_enable_crypt_check)
    {
        if (text_ret)
        {
            crypt_check(algo_id, text_src, text_ret, INVALID_CONTEXT_LENGTH);
        }
        else if (page_new_output)
        {
            crypt_check(algo_id, text_src, (text*)page_new_output, BLCKSZ - sizeof(PageHeaderData));
        }
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>text_ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>text</name> <modifier>*</modifier></type> <name>decrypt_procedure</name><parameter_list>(<parameter><decl><type><name>AlgoId</name></type> <name>algo_id</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type> <name>text_src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>context_length</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type> <name>text_ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type> <name>password</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type> <name>privatekey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>   <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>  <name>option</name></decl>;</decl_stmt>
    
    <comment type="block">/* accelerate looking for */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int16</name></type>        <name>algo_id_keep</name> <init>= <expr><name>TRANSP_CRYPT_INVALID_ALGORITHM_ID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>CryptKeyInfo</name></type> <name>cryptkey</name>     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>algo_id</name> <operator>==</operator> <name>algo_id_keep</name> <operator>&amp;&amp;</operator> <name>cryptkey</name></expr>)</condition>
    <block>{<block_content>
        <empty_stmt>;</empty_stmt> 
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>   
        <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>crypt_key_info_hash_lookup</name><argument_list>(<argument><expr><name>algo_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cryptkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>found</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"algo_id:%d dose not exist"</literal></expr></argument>, <argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* cache it for next time using the same crypt key info */</comment>
        <expr_stmt><expr><name>algo_id_keep</name> <operator>=</operator> <name>algo_id</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <expr_stmt><expr><name>option</name> <operator>=</operator> <name><name>cryptkey</name><operator>-&gt;</operator><name>option</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>CRYPT_KEY_INFO_OPTION_SYMKEY</name> <operator>==</operator> <name>option</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>password</name>    <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>password</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>text_ret</name>    <operator>=</operator> <call><name>decrypt_internal</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>text_src</name></expr></argument>, <argument><expr><name>password</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>CRYPT_KEY_INFO_OPTION_ANYKEY</name> <operator>==</operator> <name>option</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>privatekey</name>  <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>privatekey</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>text_ret</name>    <operator>=</operator> <call><name>decrypt_internal</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>text_src</name></expr></argument>, <argument><expr><name>privatekey</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>CRYPT_KEY_INFO_OPTION_SM4</name> <operator>==</operator> <name>option</name></expr>)</condition>
    <block>{<block_content>

        <if_stmt><if>if <condition>(<expr><call><name>DECRYPT_CONTEXT_LENGTH_VALID</name><argument_list>(<argument><expr><name>context_length</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* for page decrypt */</comment>
            <comment type="block">/* 
             * arg1: sm4context
             * arg2: decrypt action = 0
             * arg3: length of context to decrypt
             * arg4: context to encrypt, not (text*) type
             * arg5: encrypt result, not (text*) type
             */</comment>
            <expr_stmt><expr><call><name>sm4_crypt_ecb</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>sm4_ctx_decrypt</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>context_length</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>text_src</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>text_src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name>text_ret</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* for column decrypt */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>ctx_len</name></decl>;</decl_stmt>
            
            <expr_stmt><expr><name>ctx_len</name>  <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>text_src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>sm4_crypt_ecb</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>sm4_ctx_decrypt</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ctx_len</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>text_src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>text_src</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name>text_ret</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>CRYPT_KEY_INFO_OPTION_UDF</name> <operator>==</operator> <name>option</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>privatekey</name>  <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cryptkey</name><operator>-&gt;</operator><name>keypair</name><operator>-&gt;</operator><name>privatekey</name></name><operator>)</operator></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>DirectFunctionCall3Coll</name><argument_list>(<argument><expr><name><name>cryptkey</name><operator>-&gt;</operator><name>udf</name><operator>-&gt;</operator><name>decrypt_func</name></name></expr></argument>, 
                                            <argument><expr><name>InvalidOid</name></expr></argument>,
                                            <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>text_src</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>privatekey</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>text_src</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>text_ret</name>    <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>text_ret</name>    <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown option value:%d in decrypt_procedure"</literal></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <return>return <expr><name>text_ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check object having crypt policy or not, if the schema had policy, the policies also should be deleted.
 */</comment>
<function><type><name>void</name></type> <name>DeleteCryptPolicy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>oldtup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>schema_bound</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IS_SYSTEM_REL</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <call><name>mls_check_relation_permission</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schema_bound</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <name>schema_bound</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * if schema is crypted, crypt policies in TransparentCryptPolicyMapRelationId should be delete cascade.
             */</comment>
            <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                        <argument><expr><name>Anum_pg_transparent_crypt_policy_map_relid</name></expr></argument>,
                        <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                        <argument><expr><name>F_OIDEQ</name></expr></argument>,
                        <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TransparentCryptPolicyMapRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, 
                                      <argument><expr><name>PgTransparentCryptPolicyMapIndexId</name></expr></argument>, 
                                      <argument><expr><name>true</name></expr></argument>,
                                      <argument><expr><name>NULL</name></expr></argument>, 
                                      <argument><expr><literal type="number">1</literal></expr></argument>, 
                                      <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * delete all policies of the relation.   
             */</comment>
            <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
            
            <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>        
    </block_content>}</block></if></if_stmt>    

    <return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>RenameCryptRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myrelid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newrelname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>Natts_pg_transparent_crypt_policy_map</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>replaces</name><index>[<expr><name>Natts_pg_transparent_crypt_policy_map</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>Natts_pg_transparent_crypt_policy_map</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>oldtup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>newtup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>schema_bound</name></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>IS_SYSTEM_REL</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <call><name>mls_check_relation_permission</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schema_bound</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <name>schema_bound</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * if schema is crypted, tables could be renamed, 
             * and the copies in TransparentCryptPolicyMapRelationId should also be updated.
             */</comment>
            <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                        <argument><expr><name>Anum_pg_transparent_crypt_policy_map_relid</name></expr></argument>,
                        <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                        <argument><expr><name>F_OIDEQ</name></expr></argument>,
                        <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TransparentCryptPolicyMapRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, 
                                      <argument><expr><name>PgTransparentCryptPolicyMapIndexId</name></expr></argument>, 
                                      <argument><expr><name>true</name></expr></argument>,
                                      <argument><expr><name>NULL</name></expr></argument>, 
                                      <argument><expr><literal type="number">1</literal></expr></argument>, 
                                      <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <comment type="block">/* Everything ok, form a new tuple. */</comment>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_transparent_crypt_policy_map_tblname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>   <operator>=</operator> <call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>newrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_transparent_crypt_policy_map_tblname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <comment type="block">/*
             * update all policies of the relation.   
             */</comment>
            <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
            
            <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>        
    </block_content>}</block></if></if_stmt>    
    
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * if table is altered schema, the copies in TransparentCryptPolicyMapRelationId should also be updated.
 */</comment>
<function><type><name>void</name></type> <name>AlterCryptdTableNamespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myrelid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newschemaoid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newschemaname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>Natts_pg_transparent_crypt_policy_map</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>replaces</name><index>[<expr><name>Natts_pg_transparent_crypt_policy_map</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>Natts_pg_transparent_crypt_policy_map</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>oldtup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>newtup</name></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>IS_SYSTEM_REL</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>NULL</name> <operator>==</operator> <name>newschemaname</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <call><name>mls_check_relation_permission</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_transparent_crypt_policy_map_relid</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                    <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TransparentCryptPolicyMapRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, 
                                  <argument><expr><name>PgTransparentCryptPolicyMapIndexId</name></expr></argument>, 
                                  <argument><expr><name>true</name></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument>, 
                                  <argument><expr><literal type="number">1</literal></expr></argument>, 
                                  <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Everything ok, form a new tuple. */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_transparent_crypt_policy_map_schemaoid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>   <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>newschemaoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_transparent_crypt_policy_map_schemaoid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_transparent_crypt_policy_map_nspname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>     <operator>=</operator> <call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>newschemaname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_transparent_crypt_policy_map_nspname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>   <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <comment type="block">/*
         * update all policies of the relation.   
         */</comment>
        <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        
        <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>    
    
    <return>return;</return>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
