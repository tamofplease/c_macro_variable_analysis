<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/time/snapmgr.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * snapmgr.c
 *        PostgreSQL snapshot manager
 *
 * We keep track of snapshots in two ways: those "registered" by resowner.c,
 * and the "active snapshot" stack.  All snapshots in either of them live in
 * persistent memory.  When a snapshot is no longer in any of these lists
 * (tracked by separate refcounts on each snapshot), its memory can be freed.
 *
 * The FirstXactSnapshot, if any, is treated a bit specially: we increment its
 * regd_count and list it in RegisteredSnapshots, but this reference is not
 * tracked by a resource owner. We used to use the TopTransactionResourceOwner
 * to track this snapshot reference, but that introduces logical circularity
 * and thus makes it impossible to clean up in a sane fashion.  It's better to
 * handle this reference as an internally-tracked registration, so that this
 * module is entirely lower-level than ResourceOwners.
 *
 * Likewise, any snapshots that have been exported by pg_export_snapshot
 * have regd_count = 1 and are listed in RegisteredSnapshots, but are not
 * tracked by any resource owner.
 *
 * Likewise, the CatalogSnapshot is listed in RegisteredSnapshots when it
 * is valid, but is not tracked by any resource owner.
 *
 * The same is true for historic snapshots used during logical decoding,
 * their lifetime is managed separately (as they live longer than one xact.c
 * transaction).
 *
 * These arrangements let us reset MyPgXact-&gt;xmin when there are no snapshots
 * referenced by this transaction, and advance it when the one with oldest
 * Xmin is no longer referenced.  For simplicity however, only registered
 * snapshots not active snapshots participate in tracking which one is oldest;
 * we don't try to change MyPgXact-&gt;xmin except when the active-snapshot
 * stack is empty.
 *
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *      src/backend/utils/time/snapmgr.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/pairingheap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinvaladt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * GUC parameters
 */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>old_snapshot_threshold</name></decl>;</decl_stmt> <comment type="block">/* number of minutes, -1 disables */</comment>

<comment type="block">/*
 * Structure for dealing with old_snapshot_threshold implementation.
 */</comment>
<typedef>typedef <type><struct>struct <name>OldSnapshotControlData</name>
<block>{
    <comment type="block">/*
     * Variables for old snapshot handling are shared among processes and are
     * only allowed to move forward.
     */</comment>
    <decl_stmt><decl><type><name>slock_t</name></type>        <name>mutex_current</name></decl>;</decl_stmt>    <comment type="block">/* protect current_timestamp */</comment>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>current_timestamp</name></decl>;</decl_stmt>    <comment type="block">/* latest snapshot timestamp */</comment>
    <decl_stmt><decl><type><name>slock_t</name></type>        <name>mutex_latest_xmin</name></decl>;</decl_stmt>    <comment type="block">/* protect latest_xmin and next_map_update */</comment>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>latest_xmin</name></decl>;</decl_stmt>    <comment type="block">/* latest snapshot xmin */</comment>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>next_map_update</name></decl>;</decl_stmt>    <comment type="block">/* latest snapshot valid up to */</comment>
    <decl_stmt><decl><type><name>slock_t</name></type>        <name>mutex_threshold</name></decl>;</decl_stmt>    <comment type="block">/* protect threshold fields */</comment>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>threshold_timestamp</name></decl>;</decl_stmt>    <comment type="block">/* earlier snapshot is old */</comment>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>threshold_xid</name></decl>;</decl_stmt>    <comment type="block">/* earlier xid may be gone */</comment>

    <comment type="block">/*
     * Keep one xid per minute for old snapshot error handling.
     *
     * Use a circular buffer with a head offset, a count of entries currently
     * used, and a timestamp corresponding to the xid at the head offset.  A
     * count_used value of zero means that there are no times stored; a
     * count_used value of OLD_SNAPSHOT_TIME_MAP_ENTRIES means that the buffer
     * is full and the head must be advanced to add new entries.  Use
     * timestamps aligned to minute boundaries, since that seems less
     * surprising than aligning based on the first usage timestamp.  The
     * latest bucket is effectively stored within latest_xmin.  The circular
     * buffer is updated when we get a new xmin value that doesn't fall into
     * the same interval.
     *
     * It is OK if the xid for a given time slot is from earlier than
     * calculated by adding the number of minutes corresponding to the
     * (possibly wrapped) distance from the head offset to the time of the
     * head entry, since that just results in the vacuuming of old tuples
     * being slightly less aggressive.  It would not be OK for it to be off in
     * the other direction, since it might result in vacuuming tuples that are
     * still expected to be there.
     *
     * Use of an SLRU was considered but not chosen because it is more
     * heavyweight than is needed for this, and would probably not be any less
     * code to implement.
     *
     * Persistence is not needed.
     */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>head_offset</name></decl>;</decl_stmt>    <comment type="block">/* subscript of oldest tracked time */</comment>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>head_timestamp</name></decl>;</decl_stmt> <comment type="block">/* time corresponding to head xid */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>count_used</name></decl>;</decl_stmt>        <comment type="block">/* how many slots are in use */</comment>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name><name>xid_by_minute</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>OldSnapshotControlData</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>OldSnapshotControlData</name> <modifier>*</modifier></type><name>oldSnapshotControl</name></decl>;</decl_stmt>


<comment type="block">/*
 * CurrentSnapshot points to the only snapshot taken in transaction-snapshot
 * mode, and to the latest one taken in a read-committed transaction.
 * SecondarySnapshot is a snapshot that's always up-to-date as of the current
 * instant, even in transaction-snapshot mode.  It should only be used for
 * special-purpose code (say, RI checking.)  CatalogSnapshot points to an
 * MVCC snapshot intended to be used for catalog scans; we must invalidate it
 * whenever a system catalog change occurs.
 *
 * These SnapshotData structs are static to simplify memory allocation
 * (see the hack in GetSnapshotData to avoid repeated malloc/free).
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SnapshotData</name></type> <name>CurrentSnapshotData</name> <init>= <expr><block>{<expr><name>HeapTupleSatisfiesMVCC</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SnapshotData</name></type> <name>SecondarySnapshotData</name> <init>= <expr><block>{<expr><name>HeapTupleSatisfiesMVCC</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SnapshotData</name></type> <name>CatalogSnapshotData</name> <init>= <expr><block>{<expr><name>HeapTupleSatisfiesMVCC</name></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Pointers to valid snapshots */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Snapshot</name></type> <name>CurrentSnapshot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Snapshot</name></type> <name>SecondarySnapshot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Snapshot</name></type> <name>CatalogSnapshot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Snapshot</name></type> <name>HistoricSnapshot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * These are updated by GetSnapshotData.  We initialize them this way
 * for the convenience of TransactionIdIsInProgress: even in bootstrap
 * mode, we don't want it to say that BootstrapTransactionId is in progress.
 *
 * RecentGlobalXmin and RecentGlobalDataXmin are initialized to
 * InvalidTransactionId, to ensure that no one tries to use a stale
 * value. Readers should ensure that it has been set to something else
 * before using it.
 */</comment>
<decl_stmt><decl><type><name>TransactionId</name></type> <name>TransactionXmin</name> <init>= <expr><name>FirstNormalTransactionId</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TransactionId</name></type> <name>RecentXmin</name> <init>= <expr><name>FirstNormalTransactionId</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TransactionId</name></type> <name>RecentGlobalXmin</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TransactionId</name></type> <name>RecentGlobalDataXmin</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GlobalTimestamp</name></type> <name>RecentCommitTs</name> <init>= <expr><name>InvalidGlobalTimestamp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GlobalTimestamp</name></type> <name>RecentDataTs</name> <init>= <expr><name>InvalidGlobalTimestamp</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>     <name>vacuum_delta</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>vacuum_debug_print</name></decl>;</decl_stmt>


<comment type="block">/* (table, ctid) =&gt; (cmin, cmax) mapping during timetravel */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>tuplecid_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Elements of the active snapshot stack.
 *
 * Each element here accounts for exactly one active_count on SnapshotData.
 *
 * NB: the code assumes that elements in this list are in non-increasing
 * order of as_level; also, the list must be NULL-terminated.
 */</comment>
<typedef>typedef <type><struct>struct <name>ActiveSnapshotElt</name>
<block>{
    <decl_stmt><decl><type><name>Snapshot</name></type>    <name>as_snap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>as_level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SnapshotStatus</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>ActiveSnapshotElt</name></name> <modifier>*</modifier></type><name>as_next</name></decl>;</decl_stmt>
}</block></struct></type> <name>ActiveSnapshotElt</name>;</typedef>

<comment type="block">/* Top of the stack of active snapshots */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ActiveSnapshotElt</name> <modifier>*</modifier></type><name>ActiveSnapshot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Bottom of the stack of active snapshots */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ActiveSnapshotElt</name> <modifier>*</modifier></type><name>OldestActiveSnapshot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Currently registered Snapshots.  Ordered in a heap by xmin, so that we can
 * quickly find the one with lowest xmin, to advance our MyPgXact-&gt;xmin.
 */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>xmin_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
         <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>pairingheap</name></type> <name>RegisteredSnapshots</name> <init>= <expr><block>{<expr><operator>&amp;</operator><name>xmin_cmp</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* first GetTransactionSnapshot call in a transaction? */</comment>
<decl_stmt><decl><type><name>bool</name></type>        <name>FirstSnapshotSet</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Remember the serializable transaction snapshot, if any.  We cannot trust
 * FirstSnapshotSet in combination with IsolationUsesXactSnapshot(), because
 * GUC may be reset before us, changing the value of IsolationUsesXactSnapshot.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Snapshot</name></type> <name>FirstXactSnapshot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Define pathname of exported-snapshot files */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNAPSHOT_EXPORT_DIR</name></cpp:macro> <cpp:value>"pg_snapshots"</cpp:value></cpp:define>

<comment type="block">/* Structure holding info about exported snapshot. */</comment>
<typedef>typedef <type><struct>struct <name>ExportedSnapshot</name>
<block>{
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>snapfile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Snapshot</name></type>    <name>snapshot</name></decl>;</decl_stmt>
}</block></struct></type> <name>ExportedSnapshot</name>;</typedef>

<comment type="block">/* Current xact's exported snapshots (a list of ExportedSnapshot structs) */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>exportedSnapshots</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Prototypes for local functions */</comment>
<function_decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>AlignTimestampToMinuteBoundary</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>ts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Snapshot</name></type> <name>CopySnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FreeSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SnapshotResetXmin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Snapshot fields to be serialized.
 *
 * Only these fields need to be sent to the cooperating backend; the
 * remaining ones can (and must) be set by the receiver upon restore.
 */</comment>
<typedef>typedef <type><struct>struct <name>SerializedSnapshotData</name>
<block>{

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>GlobalTimestamp</name></type> <name>start_ts</name></decl>;</decl_stmt>        <comment type="block">/* global timestamp at which the statement/transaction starts */</comment>
    <decl_stmt><decl><type><name>bool</name></type>            <name>local</name></decl>;</decl_stmt>            <comment type="block">/* local snapshot */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>prepare_xcnt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>prepare_subxcnt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>prepare_xmin</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xmin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xmax</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>xcnt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>subxcnt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>suboverflowed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>takenDuringRecovery</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CommandId</name></type>    <name>curcid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>whenTaken</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>lsn</name></decl>;</decl_stmt>
}</block></struct></type> <name>SerializedSnapshotData</name>;</typedef>

<function><type><name>Size</name></type>
<name>SnapMgrShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>OldSnapshotControlData</name></expr></argument>, <argument><expr><name>xid_by_minute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>old_snapshot_threshold</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                       <argument><expr><name>OLD_SNAPSHOT_TIME_MAP_ENTRIES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize for managing old snapshot detection.
 */</comment>
<function><type><name>void</name></type>
<name>SnapMgrInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Create or attach to the OldSnapshotControlData structure.
     */</comment>
    <expr_stmt><expr><name>oldSnapshotControl</name> <operator>=</operator> <operator>(</operator><specifier>volatile</specifier> <name>OldSnapshotControlData</name> <operator>*</operator><operator>)</operator>
        <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"OldSnapshotControlData"</literal></expr></argument>,
                        <argument><expr><call><name>SnapMgrShmemSize</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>mutex_current</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>current_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>mutex_latest_xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>latest_xmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>next_map_update</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>mutex_threshold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>threshold_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>threshold_xid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>count_used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GetTransactionSnapshot
 *        Get the appropriate snapshot for a new query in a transaction.
 *
 * Note that the return value may point at static storage that will be modified
 * by future calls and by CommandCounterIncrement().  Callers should call
 * RegisterSnapshot or PushActiveSnapshot on the returned snap if it is to be
 * used very long.
 */</comment>
<function><type><name>Snapshot</name></type>
<name>GetTransactionSnapshot_shard</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>need_shardmap</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>latest</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
     * Return historic snapshot if doing logical decoding. We'll never need a
     * non-historic transaction snapshot in this (sub-)transaction, so there's
     * no need to be careful to set one up for later calls to
     * GetTransactionSnapshot().
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HistoricSnapshotActive</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>FirstSnapshotSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HistoricSnapshot</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* First call in transaction? */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>FirstSnapshotSet</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Don't allow catalog snapshot to be older than xact snapshot.  Must
         * do this first to allow the empty-heap Assert to succeed.
         */</comment>
        <expr_stmt><expr><call><name>InvalidateCatalogSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pairingheap_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>FirstXactSnapshot</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                 <argument><expr><literal type="string">"cannot take query snapshot during a parallel operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * In transaction-snapshot mode, the first snapshot must live until
         * end of xact regardless of what the caller does with it, so we must
         * make a copy of it rather than returning CurrentSnapshotData
         * directly.  Furthermore, if we're running in serializable mode,
         * predicate.c needs to wrap the snapshot fetch in its own processing.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* First, create the snapshot in CurrentSnapshotData */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>IsolationIsSerializable</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>CurrentSnapshot</name> <operator>=</operator> <call><name>GetSerializableTransactionSnapshot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>CurrentSnapshotData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>CurrentSnapshot</name> <operator>=</operator> <call><name>GetSnapshotData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>CurrentSnapshotData</name></expr></argument>, <argument><expr><name>latest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <comment type="block">/* Make a saved copy */</comment>
            <expr_stmt><expr><name>CurrentSnapshot</name> <operator>=</operator> <call><name>CopySnapshot</name><argument_list>(<argument><expr><name>CurrentSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>FirstXactSnapshot</name> <operator>=</operator> <name>CurrentSnapshot</name></expr>;</expr_stmt>
            <comment type="block">/* Mark it as "registered" in FirstXactSnapshot */</comment>
            <expr_stmt><expr><name><name>FirstXactSnapshot</name><operator>-&gt;</operator><name>regd_count</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pairingheap_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>FirstXactSnapshot</name><operator>-&gt;</operator><name>ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>CurrentSnapshot</name> <operator>=</operator> <call><name>GetSnapshotData_shard</name><argument_list>(<argument><expr><operator>&amp;</operator><name>CurrentSnapshotData</name></expr></argument>, <argument><expr><name>latest</name></expr></argument>, <argument><expr><name>need_shardmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>FirstSnapshotSet</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <return>return <expr><name>CurrentSnapshot</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <comment type="block">/*
         * Consider this test case taken from portals.sql
         *
         * CREATE TABLE cursor (a int, b int) distribute by replication;
         * INSERT INTO cursor VALUES (10);
         * BEGIN;
         * SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
         * DECLARE c1 NO SCROLL CURSOR FOR SELECT * FROM cursor FOR UPDATE;
         * INSERT INTO cursor VALUES (2);
         * FETCH ALL FROM c1;
         * would result in
         * ERROR:  attempted to lock invisible tuple
         * because FETCH would be sent as a select to the remote nodes
         * with command id 0, whereas the command id would be 2
         * in the current snapshot.
         * (1 sent by Coordinator due to declare cursor &amp;
         *  2 because of the insert inside the transaction)
         * The command id should therefore be updated in the
         * current snapshot.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsConnFromDatanode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>SnapshotSetCommandId</name><argument_list>(<argument><expr><call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><name>CurrentSnapshot</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Don't allow catalog snapshot to be older than xact snapshot. */</comment>
    <expr_stmt><expr><call><name>InvalidateCatalogSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>CurrentSnapshot</name> <operator>=</operator> <call><name>GetSnapshotData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>CurrentSnapshotData</name></expr></argument>, <argument><expr><name>latest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>CurrentSnapshot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetLatestSnapshot
 *        Get a snapshot that is up-to-date as of the current instant,
 *        even if we are executing in transaction-snapshot mode.
 */</comment>
<function><type><name>Snapshot</name></type>
<name>GetLatestSnapshot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * We might be able to relax this, but nothing that could otherwise work
     * needs it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
             <argument><expr><literal type="string">"cannot update SecondarySnapshot during a parallel operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * So far there are no cases requiring support for GetLatestSnapshot()
     * during logical decoding, but it wouldn't be hard to add if required.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>HistoricSnapshotActive</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If first call in transaction, go ahead and set the xact snapshot */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>FirstSnapshotSet</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>SecondarySnapshot</name> <operator>=</operator> <call><name>GetSnapshotData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SecondarySnapshotData</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>SecondarySnapshot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetOldestSnapshot
 *
 *        Get the transaction's oldest known snapshot, as judged by the LSN.
 *        Will return NULL if there are no active or registered snapshots.
 */</comment>
<function><type><name>Snapshot</name></type>
<name>GetOldestSnapshot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Snapshot</name></type>    <name>OldestRegisteredSnapshot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>RegisteredLSN</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pairingheap_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>OldestRegisteredSnapshot</name> <operator>=</operator> <call><name>pairingheap_container</name><argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>, <argument><expr><name>ph_node</name></expr></argument>,
                                                         <argument><expr><call><name>pairingheap_first</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>RegisteredLSN</name> <operator>=</operator> <name><name>OldestRegisteredSnapshot</name><operator>-&gt;</operator><name>lsn</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>OldestActiveSnapshot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>ActiveLSN</name> <init>= <expr><name><name>OldestActiveSnapshot</name><operator>-&gt;</operator><name>as_snap</name><operator>-&gt;</operator><name>lsn</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>RegisteredLSN</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>RegisteredLSN</name> <operator>&gt;</operator> <name>ActiveLSN</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name><name>OldestActiveSnapshot</name><operator>-&gt;</operator><name>as_snap</name></name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>OldestRegisteredSnapshot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetCatalogSnapshot
 *        Get a snapshot that is sufficiently up-to-date for scan of the
 *        system catalog with the specified OID.
 */</comment>
<function><type><name>Snapshot</name></type>
<name>GetCatalogSnapshot</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Return historic snapshot while we're doing logical decoding, so we can
     * see the appropriate state of the catalog.
     *
     * This is the primary reason for needing to reset the system caches after
     * finishing decoding.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HistoricSnapshotActive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>HistoricSnapshot</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>GetNonHistoricCatalogSnapshot</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetNonHistoricCatalogSnapshot
 *        Get a snapshot that is sufficiently up-to-date for scan of the system
 *        catalog with the specified OID, even while historic snapshots are set
 *        up.
 */</comment>
<function><type><name>Snapshot</name></type>
<name>GetNonHistoricCatalogSnapshot</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * If the caller is trying to scan a relation that has no syscache, no
     * catcache invalidations will be sent when it is updated.  For a few key
     * relations, snapshot invalidations are sent instead.  If we're trying to
     * scan a relation for which neither catcache nor snapshot invalidations
     * are sent, we must refresh the snapshot every time.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>CatalogSnapshot</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>RelationInvalidatesSnapshotsOnly</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>RelationHasSysCache</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>InvalidateCatalogSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>CatalogSnapshot</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Get new snapshot. */</comment>
        <expr_stmt><expr><name>CatalogSnapshot</name> <operator>=</operator> <call><name>GetSnapshotData_shard</name><argument_list>(<argument><expr><operator>&amp;</operator><name>CatalogSnapshotData</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Make sure the catalog snapshot will be accounted for in decisions
         * about advancing PGXACT-&gt;xmin.  We could apply RegisterSnapshot, but
         * that would result in making a physical copy, which is overkill; and
         * it would also create a dependency on some resource owner, which we
         * do not want for reasons explained at the head of this file. Instead
         * just shove the CatalogSnapshot into the pairing heap manually. This
         * has to be reversed in InvalidateCatalogSnapshot, of course.
         *
         * NB: it had better be impossible for this to throw error, since the
         * CatalogSnapshot pointer is already valid.
         */</comment>
        <expr_stmt><expr><call><name>pairingheap_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>CatalogSnapshot</name><operator>-&gt;</operator><name>ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>CatalogSnapshot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * InvalidateCatalogSnapshot
 *        Mark the current catalog snapshot, if any, as invalid
 *
 * We could change this API to allow the caller to provide more fine-grained
 * invalidation details, so that a change to relation A wouldn't prevent us
 * from using our cached snapshot to scan relation B, but so far there's no
 * evidence that the CPU cycles we spent tracking such fine details would be
 * well-spent.
 */</comment>
<function><type><name>void</name></type>
<name>InvalidateCatalogSnapshot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>CatalogSnapshot</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pairingheap_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>CatalogSnapshot</name><operator>-&gt;</operator><name>ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>CatalogSnapshot</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SnapshotResetXmin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * InvalidateCatalogSnapshotConditionally
 *        Drop catalog snapshot if it's the only one we have
 *
 * This is called when we are about to wait for client input, so we don't
 * want to continue holding the catalog snapshot if it might mean that the
 * global xmin horizon can't advance.  However, if there are other snapshots
 * still active or registered, the catalog snapshot isn't likely to be the
 * oldest one, so we might as well keep it.
 */</comment>
<function><type><name>void</name></type>
<name>InvalidateCatalogSnapshotConditionally</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>CatalogSnapshot</name> <operator>&amp;&amp;</operator>
        <name>ActiveSnapshot</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
        <call><name>pairingheap_is_singular</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>InvalidateCatalogSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SnapshotSetCommandId
 *        Propagate CommandCounterIncrement into the static snapshots, if set
 */</comment>
<function><type><name>void</name></type>
<name>SnapshotSetCommandId</name><parameter_list>(<parameter><decl><type><name>CommandId</name></type> <name>curcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>FirstSnapshotSet</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>CurrentSnapshot</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>curcid</name></name> <operator>=</operator> <name>curcid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>SecondarySnapshot</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>SecondarySnapshot</name><operator>-&gt;</operator><name>curcid</name></name> <operator>=</operator> <name>curcid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Should we do the same with CatalogSnapshot? */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * SetTransactionSnapshot
 *        Set the transaction's snapshot from an imported MVCC snapshot.
 *
 * Note that this is very closely tied to GetTransactionSnapshot --- it
 * must take care of all the same considerations as the first-snapshot case
 * in GetTransactionSnapshot.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetTransactionSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>sourcesnap</name></decl></parameter>, <parameter><decl><type><name>VirtualTransactionId</name> <modifier>*</modifier></type><name>sourcevxid</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>sourcepid</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>sourceproc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Caller should have checked this already */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>FirstSnapshotSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Better do this to ensure following Assert succeeds. */</comment>
    <expr_stmt><expr><call><name>InvalidateCatalogSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pairingheap_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>FirstXactSnapshot</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>HistoricSnapshotActive</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Even though we are not going to use the snapshot it computes, we must
     * call GetSnapshotData, for two reasons: (1) to be sure that
     * CurrentSnapshotData's XID arrays have been allocated, and (2) to update
     * RecentXmin and RecentGlobalXmin.  (We could alternatively include those
     * two variables in exported snapshot files, but it seems better to have
     * snapshot importers compute reasonably up-to-date values for them.)
     */</comment>
    <expr_stmt><expr><name>CurrentSnapshot</name> <operator>=</operator> <call><name>GetSnapshotData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>CurrentSnapshotData</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now copy appropriate fields from the source snapshot.
     */</comment>
    <expr_stmt><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name><name>sourcesnap</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name><name>sourcesnap</name><operator>-&gt;</operator><name>xmax</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>=</operator> <name><name>sourcesnap</name><operator>-&gt;</operator><name>xcnt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sourcesnap</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>&lt;=</operator> <call><name>GetMaxSnapshotXidCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>, <argument><expr><name><name>sourcesnap</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>,
           <argument><expr><name><name>sourcesnap</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>=</operator> <name><name>sourcesnap</name><operator>-&gt;</operator><name>subxcnt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sourcesnap</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>&lt;=</operator> <call><name>GetMaxSnapshotSubxidCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>subxip</name></name></expr></argument>, <argument><expr><name><name>sourcesnap</name><operator>-&gt;</operator><name>subxip</name></name></expr></argument>,
           <argument><expr><name><name>sourcesnap</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>suboverflowed</name></name> <operator>=</operator> <name><name>sourcesnap</name><operator>-&gt;</operator><name>suboverflowed</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>takenDuringRecovery</name></name> <operator>=</operator> <name><name>sourcesnap</name><operator>-&gt;</operator><name>takenDuringRecovery</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>start_ts</name></name> <operator>=</operator> <name><name>sourcesnap</name><operator>-&gt;</operator><name>start_ts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>local</name></name>    <operator>=</operator> <name><name>sourcesnap</name><operator>-&gt;</operator><name>local</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>prepare_xcnt</name></name> <operator>=</operator> <name><name>sourcesnap</name><operator>-&gt;</operator><name>prepare_xcnt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name> <operator>=</operator> <name><name>sourcesnap</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>prepare_xmin</name></name> <operator>=</operator> <name><name>sourcesnap</name><operator>-&gt;</operator><name>prepare_xmin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>prepare_xip</name></name></expr></argument>, <argument><expr><name><name>sourcesnap</name><operator>-&gt;</operator><name>prepare_xip</name></name></expr></argument>,
           <argument><expr><name><name>sourcesnap</name><operator>-&gt;</operator><name>prepare_xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>prepare_subxip</name></name></expr></argument>, <argument><expr><name><name>sourcesnap</name><operator>-&gt;</operator><name>prepare_subxip</name></name></expr></argument>,
           <argument><expr><name><name>sourcesnap</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>prepare_xip_ts</name></name></expr></argument>, <argument><expr><name><name>sourcesnap</name><operator>-&gt;</operator><name>prepare_xip_ts</name></name></expr></argument>,
           <argument><expr><name><name>sourcesnap</name><operator>-&gt;</operator><name>prepare_xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>prepare_subxip_ts</name></name></expr></argument>, <argument><expr><name><name>sourcesnap</name><operator>-&gt;</operator><name>prepare_subxip_ts</name></name></expr></argument>,
           <argument><expr><name><name>sourcesnap</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    
    <comment type="block">/* NB: curcid should NOT be copied, it's a local matter */</comment>

    <comment type="block">/*
     * Now we have to fix what GetSnapshotData did with MyPgXact-&gt;xmin and
     * TransactionXmin.  There is a race condition: to make sure we are not
     * causing the global xmin to go backwards, we have to test that the
     * source transaction is still running, and that has to be done
     * atomically. So let procarray.c do it.
     *
     * Note: in serializable mode, predicate.c will do this a second time. It
     * doesn't seem worth contorting the logic here to avoid two calls,
     * especially since it's not clear that predicate.c *must* do this.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>sourceproc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ProcArrayInstallRestoredXmin</name><argument_list>(<argument><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name>sourceproc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not import the requested snapshot"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The source transaction is not running anymore."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ProcArrayInstallImportedXmin</name><argument_list>(<argument><expr><name><name>CurrentSnapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name>sourcevxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not import the requested snapshot"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The source process with pid %d is not running anymore."</literal></expr></argument>,
                           <argument><expr><name>sourcepid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * In transaction-snapshot mode, the first snapshot must live until end of
     * xact, so we must make a copy of it.  Furthermore, if we're running in
     * serializable mode, predicate.c needs to do its own processing.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IsolationIsSerializable</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>SetSerializableTransactionSnapshot</name><argument_list>(<argument><expr><name>CurrentSnapshot</name></expr></argument>, <argument><expr><name>sourcevxid</name></expr></argument>,
                                               <argument><expr><name>sourcepid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Make a saved copy */</comment>
        <expr_stmt><expr><name>CurrentSnapshot</name> <operator>=</operator> <call><name>CopySnapshot</name><argument_list>(<argument><expr><name>CurrentSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>FirstXactSnapshot</name> <operator>=</operator> <name>CurrentSnapshot</name></expr>;</expr_stmt>
        <comment type="block">/* Mark it as "registered" in FirstXactSnapshot */</comment>
        <expr_stmt><expr><name><name>FirstXactSnapshot</name><operator>-&gt;</operator><name>regd_count</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pairingheap_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>FirstXactSnapshot</name><operator>-&gt;</operator><name>ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>FirstSnapshotSet</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CopySnapshot
 *        Copy the given snapshot.
 *
 * The copy is palloc'd in TopTransactionContext and has initial refcounts set
 * to 0.  The returned snapshot has the copied flag set.
 */</comment>
<function><type><specifier>static</specifier> <name>Snapshot</name></type>
<name>CopySnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Snapshot</name></type>    <name>newsnap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>subxipoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Size</name></type>        <name>preparexipoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>preparetsoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>preparesubxipoff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/*keep gcc quiet */</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>preparesubtsoff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/*keep gcc quiet */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>snapshot</name> <operator>!=</operator> <name>InvalidSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We allocate any XID arrays needed in the same palloc block. */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <name>subxipoff</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
        <name><name>snapshot</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><name>preparexipoff</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>preparetsoff</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>preparesubxipoff</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name>preparesubtsoff</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


    <expr_stmt><expr><name>newsnap</name> <operator>=</operator> <operator>(</operator><name>Snapshot</name><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newsnap</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>regd_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>active_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>copied</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* setup XID array */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>xip</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>newsnap</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newsnap</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>,
               <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>xip</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Setup subXID array. Don't bother to copy it if it had overflowed,
     * though, because it's not used anywhere in that case. Except if it's a
     * snapshot taken during recovery; all the top-level XIDs are in subxip as
     * well in that case, so we mustn't lose them.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>(</operator><operator>!</operator><name><name>snapshot</name><operator>-&gt;</operator><name>suboverflowed</name></name> <operator>||</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>takenDuringRecovery</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>subxip</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newsnap</name> <operator>+</operator> <name>subxipoff</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newsnap</name><operator>-&gt;</operator><name>subxip</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxip</name></name></expr></argument>,
               <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>subxip</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <name><name>newsnap</name><operator>-&gt;</operator><name>groupsize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>groupsize</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>groupsize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SnapshotGetShardTable</name><argument_list>(<argument><expr><name>newsnap</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>Bitmapset</name> <operator>*</operator><operator>)</operator><name><name>newsnap</name><operator>-&gt;</operator><name>sg_filler</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>SnapshotGetShardTable</name><argument_list>(<argument><expr><name>newsnap</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SnapshotGetShardTable</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SHARD_TABLE_BITMAP_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>groupsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SnapshotGetShardTable</name><argument_list>(<argument><expr><name>newsnap</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>prepare_xip</name></name> <operator>=</operator>    <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newsnap</name> <operator>+</operator> <name>preparexipoff</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newsnap</name><operator>-&gt;</operator><name>prepare_xip</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xip</name></name></expr></argument>,
             <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>prepare_xip_ts</name></name> <operator>=</operator>  <operator>(</operator><name>GlobalTimestamp</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newsnap</name> <operator>+</operator> <name>preparetsoff</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newsnap</name><operator>-&gt;</operator><name>prepare_xip_ts</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xip_ts</name></name></expr></argument>,
             <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>prepare_xip</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>prepare_xip_ts</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    
    <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>(</operator><operator>!</operator><name><name>snapshot</name><operator>-&gt;</operator><name>suboverflowed</name></name> <operator>||</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>takenDuringRecovery</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>

        <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>prepare_subxip</name></name> <operator>=</operator>    <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newsnap</name> <operator>+</operator> <name>preparesubxipoff</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newsnap</name><operator>-&gt;</operator><name>prepare_subxip</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxip</name></name></expr></argument>,
             <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>prepare_subxip_ts</name></name> <operator>=</operator>    <operator>(</operator><name>GlobalTimestamp</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newsnap</name> <operator>+</operator> <name>preparesubtsoff</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newsnap</name><operator>-&gt;</operator><name>prepare_subxip_ts</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxip_ts</name></name></expr></argument>,
             <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>prepare_subxip</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>prepare_subxip_ts</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


    <return>return <expr><name>newsnap</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FreeSnapshot
 *        Free the memory associated with a snapshot.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreeSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>regd_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>active_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>copied</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PushActiveSnapshot
 *        Set the given snapshot as the current active snapshot
 *
 * If the passed snapshot is a statically-allocated one, or it is possibly
 * subject to a future command counter update, create a new long-lived copy
 * with active refcount=1.  Otherwise, only increment the refcount.
 */</comment>
<function><type><name>void</name></type>
<name>PushActiveSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ActiveSnapshotElt</name> <modifier>*</modifier></type><name>newactive</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>snap</name> <operator>==</operator> <name>InvalidSnapshot</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>snap</name> <operator>!=</operator> <name>InvalidSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"push active snapshot local %d start ts "</literal><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>local</name></name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>newactive</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ActiveSnapshotElt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Checking SecondarySnapshot is probably useless here, but it seems
     * better to be sure.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>snap</name> <operator>==</operator> <name>CurrentSnapshot</name> <operator>||</operator> <name>snap</name> <operator>==</operator> <name>SecondarySnapshot</name> <operator>||</operator> <operator>!</operator><name><name>snap</name><operator>-&gt;</operator><name>copied</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>newactive</name><operator>-&gt;</operator><name>as_snap</name></name> <operator>=</operator> <call><name>CopySnapshot</name><argument_list>(<argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>newactive</name><operator>-&gt;</operator><name>as_snap</name></name> <operator>=</operator> <name>snap</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>newactive</name><operator>-&gt;</operator><name>as_next</name></name> <operator>=</operator> <name>ActiveSnapshot</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newactive</name><operator>-&gt;</operator><name>as_level</name></name> <operator>=</operator> <call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newactive</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>S_DEFAULT</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>newactive</name><operator>-&gt;</operator><name>as_snap</name><operator>-&gt;</operator><name>active_count</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>ActiveSnapshot</name> <operator>=</operator> <name>newactive</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>OldestActiveSnapshot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>OldestActiveSnapshot</name> <operator>=</operator> <name>ActiveSnapshot</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PushCopiedSnapshot
 *        As above, except forcibly copy the presented snapshot.
 *
 * This should be used when the ActiveSnapshot has to be modifiable, for
 * example if the caller intends to call UpdateActiveSnapshotCommandId.
 * The new snapshot will be released when popped from the stack.
 */</comment>
<function><type><name>void</name></type>
<name>PushCopiedSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>CopySnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * UpdateActiveSnapshotCommandId
 *
 * Update the current CID of the active snapshot.  This can only be applied
 * to a snapshot that is not referenced elsewhere.
 */</comment>
<function><type><name>void</name></type>
<name>UpdateActiveSnapshotCommandId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CommandId</name></type>    <name>save_curcid</name></decl>,
                <decl><type ref="prev"/><name>curcid</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ActiveSnapshot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_snap</name><operator>-&gt;</operator><name>active_count</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_snap</name><operator>-&gt;</operator><name>regd_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Don't allow modification of the active snapshot during parallel
     * operation.  We share the snapshot to worker backends at the beginning
     * of parallel operation, so any change to the snapshot can lead to
     * inconsistencies.  We have other defenses against
     * CommandCounterIncrement, but there are a few places that call this
     * directly, so we put an additional guard here.
     */</comment>
    <expr_stmt><expr><name>save_curcid</name> <operator>=</operator> <name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_snap</name><operator>-&gt;</operator><name>curcid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>curcid</name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>save_curcid</name> <operator>!=</operator> <name>curcid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot modify commandid in active snapshot during a parallel operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_snap</name><operator>-&gt;</operator><name>curcid</name></name> <operator>=</operator> <name>curcid</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>    
    <comment type="block">/*
     * Set flag so that updated command ID is sent to the datanodes before the
     * next query. This ensures that the effects of previous statements are
     * visible to the subsequent statements
     */</comment>
    <expr_stmt><expr><call><name>SetSendCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>UpdateActiveSnapshotStatus</name><parameter_list>(<parameter><decl><type><name>SnapshotStatus</name></type> <name>new_status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ActiveSnapshot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>new_status</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>SnapshotStatus</name></type>
<name>GetActiveSnapshotStatus</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ActiveSnapshot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>status</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>GetActiveSnapshotLevel</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ActiveSnapshot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_level</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SetActiveSnapshotLevel</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ActiveSnapshot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PopActiveSnapshot
 *
 * Remove the topmost snapshot from the active snapshot stack, decrementing the
 * reference count, and free it if this was the last reference.
 */</comment>
<function><type><name>void</name></type>
<name>PopActiveSnapshot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ActiveSnapshotElt</name> <modifier>*</modifier></type><name>newstack</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>newstack</name> <operator>=</operator> <name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_next</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_snap</name><operator>-&gt;</operator><name>active_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_snap</name><operator>-&gt;</operator><name>active_count</name></name><operator>--</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_snap</name><operator>-&gt;</operator><name>active_count</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_snap</name><operator>-&gt;</operator><name>regd_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FreeSnapshot</name><argument_list>(<argument><expr><name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_snap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ActiveSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ActiveSnapshot</name> <operator>=</operator> <name>newstack</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ActiveSnapshot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>OldestActiveSnapshot</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>SnapshotResetXmin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GetActiveSnapshot
 *        Return the topmost snapshot in the Active stack.
 */</comment>
<function><type><name>Snapshot</name></type>
<name>GetActiveSnapshot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/*
     * Check if topmost snapshot is null or not,
     * if it is, a new one will be taken from GTM.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ActiveSnapshot</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ActiveSnapshot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_snap</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ActiveSnapshotSet
 *        Return whether there is at least one snapshot in the Active stack
 */</comment>
<function><type><name>bool</name></type>
<name>ActiveSnapshotSet</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>ActiveSnapshot</name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RegisterSnapshot
 *        Register a snapshot as being in use by the current resource owner
 *
 * If InvalidSnapshot is passed, it is not registered.
 */</comment>
<function><type><name>Snapshot</name></type>
<name>RegisterSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>==</operator> <name>InvalidSnapshot</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>InvalidSnapshot</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>RegisterSnapshotOnOwner</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RegisterSnapshotOnOwner
 *        As above, but use the specified resource owner
 */</comment>
<function><type><name>Snapshot</name></type>
<name>RegisterSnapshotOnOwner</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Snapshot</name></type>    <name>snap</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>==</operator> <name>InvalidSnapshot</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>InvalidSnapshot</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Static snapshot?  Create a persistent copy */</comment>
    <expr_stmt><expr><name>snap</name> <operator>=</operator> <ternary><condition><expr><name><name>snapshot</name><operator>-&gt;</operator><name>copied</name></name></expr> ?</condition><then> <expr><name>snapshot</name></expr> </then><else>: <expr><call><name>CopySnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* and tell resowner.c about it */</comment>
    <expr_stmt><expr><call><name>ResourceOwnerEnlargeSnapshots</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>regd_count</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ResourceOwnerRememberSnapshot</name><argument_list>(<argument><expr><name>owner</name></expr></argument>, <argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>snap</name><operator>-&gt;</operator><name>regd_count</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pairingheap_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>snap</name><operator>-&gt;</operator><name>ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>snap</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * UnregisterSnapshot
 *
 * Decrement the reference count of a snapshot, remove the corresponding
 * reference from CurrentResourceOwner, and free the snapshot if no more
 * references remain.
 */</comment>
<function><type><name>void</name></type>
<name>UnregisterSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>UnregisterSnapshotFromOwner</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * UnregisterSnapshotFromOwner
 *        As above, but use the specified resource owner
 */</comment>
<function><type><name>void</name></type>
<name>UnregisterSnapshotFromOwner</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>regd_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>pairingheap_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* 
     * The Portal's resource may be set to null during prepare or commit transaction.
     * Check it before trying to release it.
     */</comment>
    <if_stmt><if>if<condition>(<expr><name>owner</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResourceOwnerForgetSnapshot</name><argument_list>(<argument><expr><name>owner</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>regd_count</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>regd_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pairingheap_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>snapshot</name><operator>-&gt;</operator><name>ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>regd_count</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>active_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>FreeSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SnapshotResetXmin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Comparison function for RegisteredSnapshots heap.  Snapshots are ordered
 * by xmin, so that the snapshot with smallest xmin is at the top.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>xmin_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>SnapshotData</name> <modifier>*</modifier></type><name>asnap</name> <init>= <expr><call><name>pairingheap_const_container</name><argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>, <argument><expr><name>ph_node</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>SnapshotData</name> <modifier>*</modifier></type><name>bsnap</name> <init>= <expr><call><name>pairingheap_const_container</name><argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>, <argument><expr><name>ph_node</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>asnap</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name><name>bsnap</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name><name>asnap</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name><name>bsnap</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SnapshotResetXmin
 *
 * If there are no more snapshots, we can reset our PGXACT-&gt;xmin to InvalidXid.
 * Note we can do this without locking because we assume that storing an Xid
 * is atomic.
 *
 * Even if there are some remaining snapshots, we may be able to advance our
 * PGXACT-&gt;xmin to some degree.  This typically happens when a portal is
 * dropped.  For efficiency, we only consider recomputing PGXACT-&gt;xmin when
 * the active snapshot stack is empty; this allows us not to need to track
 * which active snapshot is oldest.
 *
 * Note: it's tempting to use GetOldestSnapshot() here so that we can include
 * active snapshots in the calculation.  However, that compares by LSN not
 * xmin so it's not entirely clear that it's the same thing.  Also, we'd be
 * critically dependent on the assumption that the bottommost active snapshot
 * stack entry has the oldest xmin.  (Current uses of GetOldestSnapshot() are
 * not actually critical, but this would be.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SnapshotResetXmin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Snapshot</name></type>    <name>minSnapshot</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>ActiveSnapshot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>pairingheap_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>minSnapshot</name> <operator>=</operator> <call><name>pairingheap_container</name><argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>, <argument><expr><name>ph_node</name></expr></argument>,
                                        <argument><expr><call><name>pairingheap_first</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name><name>minSnapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name><name>minSnapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtSubCommit_Snapshot
 */</comment>
<function><type><name>void</name></type>
<name>AtSubCommit_Snapshot</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ActiveSnapshotElt</name> <modifier>*</modifier></type><name>active</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Relabel the active snapshots set in this subtransaction as though they
     * are owned by the parent subxact.
     */</comment>
    <for>for <control>(<init><expr><name>active</name> <operator>=</operator> <name>ActiveSnapshot</name></expr>;</init> <condition><expr><name>active</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>active</name> <operator>=</operator> <name><name>active</name><operator>-&gt;</operator><name>as_next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>active</name><operator>-&gt;</operator><name>as_level</name></name> <operator>&lt;</operator> <name>level</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>active</name><operator>-&gt;</operator><name>as_level</name></name> <operator>=</operator> <name>level</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * AtSubAbort_Snapshot
 *        Clean up snapshots after a subtransaction abort
 */</comment>
<function><type><name>void</name></type>
<name>AtSubAbort_Snapshot</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Forget the active snapshots set by this subtransaction */</comment>
    <while>while <condition>(<expr><name>ActiveSnapshot</name> <operator>&amp;&amp;</operator> <name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_level</name></name> <operator>&gt;=</operator> <name>level</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ActiveSnapshotElt</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_next</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * Decrement the snapshot's active count.  If it's still registered or
         * marked as active by an outer subtransaction, we can't free it yet.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_snap</name><operator>-&gt;</operator><name>active_count</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_snap</name><operator>-&gt;</operator><name>active_count</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_snap</name><operator>-&gt;</operator><name>active_count</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_snap</name><operator>-&gt;</operator><name>regd_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FreeSnapshot</name><argument_list>(<argument><expr><name><name>ActiveSnapshot</name><operator>-&gt;</operator><name>as_snap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* and free the stack element */</comment>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ActiveSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>ActiveSnapshot</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ActiveSnapshot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>OldestActiveSnapshot</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>SnapshotResetXmin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtEOXact_Snapshot
 *        Snapshot manager's cleanup function for end of transaction
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_Snapshot</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>resetXmin</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
     * In transaction-snapshot mode we must release our privately-managed
     * reference to the transaction snapshot.  We must remove it from
     * RegisteredSnapshots to keep the check below happy.  But we don't bother
     * to do FreeSnapshot, for two reasons: the memory will go away with
     * TopTransactionContext anyway, and if someone has left the snapshot
     * stacked as active, we don't want the code below to be chasing through a
     * dangling pointer.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>FirstXactSnapshot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>FirstXactSnapshot</name><operator>-&gt;</operator><name>regd_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>pairingheap_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pairingheap_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>FirstXactSnapshot</name><operator>-&gt;</operator><name>ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>FirstXactSnapshot</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If we exported any snapshots, clean them up.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>exportedSnapshots</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Get rid of the files.  Unlink failure is only a WARNING because (1)
         * it's too late to abort the transaction, and (2) leaving a leaked
         * file around has little real consequence anyway.
         *
         * We also also need to remove the snapshots from RegisteredSnapshots
         * to prevent a warning below.
         *
         * As with the FirstXactSnapshot, we don't need to free resources of
         * the snapshot iself as it will go away with the memory context.
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>exportedSnapshots</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ExportedSnapshot</name> <modifier>*</modifier></type><name>esnap</name> <init>= <expr><operator>(</operator><name>ExportedSnapshot</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name><name>esnap</name><operator>-&gt;</operator><name>snapfile</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"could not unlink file \"%s\": %m"</literal></expr></argument>,
                     <argument><expr><name><name>esnap</name><operator>-&gt;</operator><name>snapfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>pairingheap_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name><name>esnap</name><operator>-&gt;</operator><name>snapshot</name><operator>-&gt;</operator><name>ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><name>exportedSnapshots</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Drop catalog snapshot if any */</comment>
    <expr_stmt><expr><call><name>InvalidateCatalogSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* On commit, complain about leftover snapshots */</comment>
    <if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ActiveSnapshotElt</name> <modifier>*</modifier></type><name>active</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pairingheap_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"registered snapshots seem to remain after cleanup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* complain about unpopped active snapshots */</comment>
		<for>for <control>(<init><expr><name>active</name> <operator>=</operator> <name>ActiveSnapshot</name></expr>;</init> <condition><expr><name>active</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>active</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>S_FOR_CTAS</name></expr>;</condition> <incr><expr><name>active</name> <operator>=</operator> <name><name>active</name><operator>-&gt;</operator><name>as_next</name></name></expr></incr>)</control>
		<block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"snapshot %p still active"</literal></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

		<comment type="block">/* Resources to clean up, pop all active snapshots */</comment>
		<while>while <condition>(<expr><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * And reset our state.  We don't need to free the memory explicitly --
     * it'll go away with TopTransactionContext.
     */</comment>
    <expr_stmt><expr><name>ActiveSnapshot</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>OldestActiveSnapshot</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pairingheap_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>CurrentSnapshot</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>SecondarySnapshot</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>FirstSnapshotSet</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * During normal commit processing, we call ProcArrayEndTransaction() to
     * reset the PgXact-&gt;xmin. That call happens prior to the call to
     * AtEOXact_Snapshot(), so we need not touch xmin here at all.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>resetXmin</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SnapshotResetXmin</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>resetXmin</name> <operator>||</operator> <name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExportSnapshot
 *        Export the snapshot to a file so that other backends can import it.
 *        Returns the token (the file name) that can be used to import this
 *        snapshot.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>ExportSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>topXid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExportedSnapshot</name> <modifier>*</modifier></type><name>esnap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nchildren</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>addTopXid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>pathtmp</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*
     * It's tempting to call RequireTransactionChain here, since it's not very
     * useful to export a snapshot that will disappear immediately afterwards.
     * However, we haven't got enough information to do that, since we don't
     * know if we're at top level or not.  For example, we could be inside a
     * plpgsql function that is going to fire off other transactions via
     * dblink.  Rather than disallow perfectly legitimate usages, don't make a
     * check.
     *
     * Also note that we don't make any restriction on the transaction's
     * isolation level; however, importers must check the level if they are
     * serializable.
     */</comment>

    <comment type="block">/*
     * Get our transaction ID if there is one, to include in the snapshot.
     */</comment>
    <expr_stmt><expr><name>topXid</name> <operator>=</operator> <call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We cannot export a snapshot from a subtransaction because there's no
     * easy way for importers to verify that the same subtransaction is still
     * running.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsSubTransaction</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot export a snapshot from a subtransaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We do however allow previous committed subtransactions to exist.
     * Importers of the snapshot must see them as still running, so get their
     * XIDs to add them to the snapshot.
     */</comment>
    <expr_stmt><expr><name>nchildren</name> <operator>=</operator> <call><name>xactGetCommittedChildren</name><argument_list>(<argument><expr><operator>&amp;</operator><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Generate file path for the snapshot.  We start numbering of snapshots
     * inside the transaction from 1.
     */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>SNAPSHOT_EXPORT_DIR</name> <literal type="string">"/%08X-%08X-%d"</literal></expr></argument>,
             <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>backendId</name></name></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>exportedSnapshots</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Copy the snapshot into TopTransactionContext, add it to the
     * exportedSnapshots list, and mark it pseudo-registered.  We do this to
     * ensure that the snapshot's xmin is honored for the rest of the
     * transaction.
     */</comment>
    <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>CopySnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>esnap</name> <operator>=</operator> <operator>(</operator><name>ExportedSnapshot</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExportedSnapshot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>esnap</name><operator>-&gt;</operator><name>snapfile</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>esnap</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>exportedSnapshots</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>exportedSnapshots</name></expr></argument>, <argument><expr><name>esnap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>regd_count</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pairingheap_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>snapshot</name><operator>-&gt;</operator><name>ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Fill buf with a text serialization of the snapshot, plus identification
     * data about this transaction.  The format expected by ImportSnapshot is
     * pretty rigid: each line must be fieldname:value.
     */</comment>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"vxid:%d/%u\n"</literal></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>backendId</name></name></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"pid:%d\n"</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"dbid:%u\n"</literal></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"iso:%d\n"</literal></expr></argument>, <argument><expr><name>XactIsoLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ro:%d\n"</literal></expr></argument>, <argument><expr><name>XactReadOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"xmin:%u\n"</literal></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"xmax:%u\n"</literal></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"startts:"</literal><name>INT64_FORMAT</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"local:%d\n"</literal></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>local</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"preparexmin:%u\n"</literal></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"preparexcnt:%d\n"</literal></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xcnt</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"preparexip:%u\n"</literal></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xip</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xcnt</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"preparexipts:"</literal><name>INT64_FORMAT</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xip_ts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    
    <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>suboverflowed</name></name> <operator>||</operator>
        <name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name>  <operator>&gt;</operator> <call><name>GetMaxSnapshotSubxidCount</name><argument_list>()</argument_list></call> <operator>||</operator>
        <name><name>snapshot</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>+</operator> <name>nchildren</name> <operator>&gt;</operator> <call><name>GetMaxSnapshotSubxidCount</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"psof:1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"psof:0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"psubxcnt:%d\n"</literal></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"psubxip:%u\n"</literal></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxip</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"psubxipts:"</literal><name>INT64_FORMAT</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxip_ts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


    <comment type="block">/*
     * We must include our own top transaction ID in the top-xid data, since
     * by definition we will still be running when the importing transaction
     * adopts the snapshot, but GetSnapshotData never includes our own XID in
     * the snapshot.  (There must, therefore, be enough room to add it.)
     *
     * However, it could be that our topXid is after the xmax, in which case
     * we shouldn't include it because xip[] members are expected to be before
     * xmax.  (We need not make the same check for subxip[] members, see
     * snapshot.h.)
     */</comment>
    <expr_stmt><expr><name>addTopXid</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>topXid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                 <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>topXid</name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"xcnt:%d\n"</literal></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>+</operator> <name>addTopXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>xcnt</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"xip:%u\n"</literal></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <if_stmt><if>if <condition>(<expr><name>addTopXid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"xip:%u\n"</literal></expr></argument>, <argument><expr><name>topXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Similarly, we add our subcommitted child XIDs to the subxid data. Here,
     * we have to cope with possible overflow.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>suboverflowed</name></name> <operator>||</operator>
        <name><name>snapshot</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>+</operator> <name>nchildren</name> <operator>&gt;</operator> <call><name>GetMaxSnapshotSubxidCount</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"sof:1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"sof:0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"sxcnt:%d\n"</literal></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>+</operator> <name>nchildren</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>subxcnt</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"sxp:%u\n"</literal></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxip</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nchildren</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"sxp:%u\n"</literal></expr></argument>, <argument><expr><name><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"rec:%u\n"</literal></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>takenDuringRecovery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now write the text representation into a file.  We first write to a
     * ".tmp" filename, and rename to final filename if no error.  This
     * ensures that no other backend can read an incomplete file
     * (ImportSnapshot won't allow it because of its valid-characters check).
     */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathtmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pathtmp</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.tmp"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>f</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>pathtmp</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>pathtmp</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>pathtmp</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* no fsync() since file need not survive a system crash */</comment>

    <if_stmt><if>if <condition>(<expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>pathtmp</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Now that we have written everything into a .tmp file, rename the file
     * to remove the .tmp suffix.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>pathtmp</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rename file \"%s\" to \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>pathtmp</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * The basename of the file is what we return from pg_export_snapshot().
     * It's already in path in a textual format and we know that the path
     * starts with SNAPSHOT_EXPORT_DIR.  Skip over the prefix and the slash
     * and pstrdup it so as not to return the address of a local variable.
     */</comment>
    <return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>path</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>SNAPSHOT_EXPORT_DIR</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pg_export_snapshot
 *        SQL-callable wrapper for ExportSnapshot.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_export_snapshot</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>snapshotName</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>snapshotName</name> <operator>=</operator> <call><name>ExportSnapshot</name><argument_list>(<argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>snapshotName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Parsing subroutines for ImportSnapshot: parse a line with the given
 * prefix followed by a value, and advance *s to the next line.  The
 * filename is provided for use in error messages.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>parseIntFromText</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name> <init>= <expr><operator>*</operator><name>s</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>prefixlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>val</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>prefixlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot data in file \"%s\""</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>prefixlen</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot data in file \"%s\""</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot data in file \"%s\""</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64</name></type>
<name>parseInt64FromText</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name> <init>= <expr><operator>*</operator><name>s</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>prefixlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>            <name>val</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>prefixlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot data in file \"%s\""</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>prefixlen</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot data in file \"%s\""</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot data in file \"%s\""</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>TransactionId</name></type>
<name>parseXidFromText</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name> <init>= <expr><operator>*</operator><name>s</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>prefixlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>val</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>prefixlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot data in file \"%s\""</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>prefixlen</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot data in file \"%s\""</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot data in file \"%s\""</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parseVxidFromText</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
                  <parameter><decl><type><name>VirtualTransactionId</name> <modifier>*</modifier></type><name>vxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name> <init>= <expr><operator>*</operator><name>s</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>prefixlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>prefixlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot data in file \"%s\""</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>prefixlen</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"%d/%u"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vxid</name><operator>-&gt;</operator><name>backendId</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vxid</name><operator>-&gt;</operator><name>localTransactionId</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot data in file \"%s\""</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot data in file \"%s\""</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ImportSnapshot
 *        Import a previously exported snapshot.  The argument should be a
 *        filename in SNAPSHOT_EXPORT_DIR.  Load the snapshot from that file.
 *        This is called by "SET TRANSACTION SNAPSHOT 'foo'".
 */</comment>
<function><type><name>void</name></type>
<name>ImportSnapshot</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idstr</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>filebuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>xcnt</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type>         <name>prepare_xcnt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>prepare_subxcnt</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VirtualTransactionId</name></type> <name>src_vxid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>src_pid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>src_dbid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>src_isolevel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>src_readonly</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SnapshotData</name></type> <name>snapshot</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Must be at top level of a fresh transaction.  Note in particular that
     * we check we haven't acquired an XID --- if we have, it's conceivable
     * that the snapshot would show it as not running, making for very screwy
     * behavior.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>FirstSnapshotSet</name> <operator>||</operator>
        <call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>InvalidTransactionId</name> <operator>||</operator>
        <call><name>IsSubTransaction</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SET TRANSACTION SNAPSHOT must be called before any query"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If we are in read committed mode then the next query would execute with
     * a new snapshot thus making this function call quite useless.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a snapshot-importing transaction must have isolation level SERIALIZABLE or REPEATABLE READ"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Verify the identifier: only 0-9, A-F and hyphens are allowed.  We do
     * this mainly to prevent reading arbitrary files.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name>idstr</name></expr></argument>, <argument><expr><literal type="string">"0123456789ABCDEF-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>idstr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot identifier: \"%s\""</literal></expr></argument>, <argument><expr><name>idstr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* OK, read the file */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>SNAPSHOT_EXPORT_DIR</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><name>idstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot identifier: \"%s\""</literal></expr></argument>, <argument><expr><name>idstr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the size of the file so that we know how much memory we need */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* and read the file into a palloc'd string */</comment>
    <expr_stmt><expr><name>filebuf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>stat_buf</name><operator>.</operator><name>st_size</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>filebuf</name></expr></argument>, <argument><expr><name><name>stat_buf</name><operator>.</operator><name>st_size</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>filebuf</name><index>[<expr><name><name>stat_buf</name><operator>.</operator><name>st_size</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Construct a snapshot struct by parsing the file content.
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>parseVxidFromText</name><argument_list>(<argument><expr><literal type="string">"vxid:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>src_vxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>src_pid</name> <operator>=</operator> <call><name>parseIntFromText</name><argument_list>(<argument><expr><literal type="string">"pid:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* we abuse parseXidFromText a bit here ... */</comment>
    <expr_stmt><expr><name>src_dbid</name> <operator>=</operator> <call><name>parseXidFromText</name><argument_list>(<argument><expr><literal type="string">"dbid:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>src_isolevel</name> <operator>=</operator> <call><name>parseIntFromText</name><argument_list>(<argument><expr><literal type="string">"iso:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>src_readonly</name> <operator>=</operator> <call><name>parseIntFromText</name><argument_list>(<argument><expr><literal type="string">"ro:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>xmin</name></name> <operator>=</operator> <call><name>parseXidFromText</name><argument_list>(<argument><expr><literal type="string">"xmin:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>xmax</name></name> <operator>=</operator> <call><name>parseXidFromText</name><argument_list>(<argument><expr><literal type="string">"xmax:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>start_ts</name></name> <operator>=</operator> <call><name>parseInt64FromText</name><argument_list>(<argument><expr><literal type="string">"startts:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>local</name></name> <operator>=</operator> <call><name>parseIntFromText</name><argument_list>(<argument><expr><literal type="string">"local:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>prepare_xmin</name></name> <operator>=</operator> <call><name>parseXidFromText</name><argument_list>(<argument><expr><literal type="string">"preparexmin:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>prepare_xcnt</name></name> <operator>=</operator> <name>prepare_xcnt</name> <operator>=</operator> <call><name>parseIntFromText</name><argument_list>(<argument><expr><literal type="string">"preparexcnt:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>prepare_xcnt</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>prepare_xcnt</name></expr></argument> &gt;</argument_list></name> <call><name>GetMaxSnapshotXidCount</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot data in file \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>prepare_xip</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>prepare_xcnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>prepare_xip_ts</name></name> <operator>=</operator> <operator>(</operator><name>GlobalTimestamp</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>prepare_xcnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>prepare_xcnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>prepare_xip</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>parseXidFromText</name><argument_list>(<argument><expr><literal type="string">"preparexip:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>prepare_xcnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>prepare_xip_ts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>parseInt64FromText</name><argument_list>(<argument><expr><literal type="string">"preparexipts:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>suboverflowed</name></name> <operator>=</operator> <call><name>parseIntFromText</name><argument_list>(<argument><expr><literal type="string">"psof:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>snapshot</name><operator>.</operator><name>suboverflowed</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>prepare_subxcnt</name></name> <operator>=</operator> <name>prepare_subxcnt</name> <operator>=</operator> <call><name>parseIntFromText</name><argument_list>(<argument><expr><literal type="string">"psubxcnt:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* sanity-check the xid count before palloc */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>prepare_subxcnt</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>prepare_subxcnt</name></expr></argument> &gt;</argument_list></name> <call><name>GetMaxSnapshotSubxidCount</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot data in file \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>prepare_subxip</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>prepare_subxcnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>prepare_subxip_ts</name></name> <operator>=</operator> <operator>(</operator><name>GlobalTimestamp</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>prepare_subxcnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>prepare_subxcnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>prepare_subxip</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>parseXidFromText</name><argument_list>(<argument><expr><literal type="string">"psubxip:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>prepare_subxcnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>prepare_subxip_ts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>parseInt64FromText</name><argument_list>(<argument><expr><literal type="string">"psubxipts:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>prepare_subxcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>prepare_subxip</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>xcnt</name></name> <operator>=</operator> <name>xcnt</name> <operator>=</operator> <call><name>parseIntFromText</name><argument_list>(<argument><expr><literal type="string">"xcnt:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* sanity-check the xid count before palloc */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>xcnt</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>xcnt</name></expr></argument> &gt;</argument_list></name> <call><name>GetMaxSnapshotXidCount</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot data in file \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>xip</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>xcnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xcnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>xip</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>parseXidFromText</name><argument_list>(<argument><expr><literal type="string">"xip:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>suboverflowed</name></name> <operator>=</operator> <call><name>parseIntFromText</name><argument_list>(<argument><expr><literal type="string">"sof:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>snapshot</name><operator>.</operator><name>suboverflowed</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>subxcnt</name></name> <operator>=</operator> <name>xcnt</name> <operator>=</operator> <call><name>parseIntFromText</name><argument_list>(<argument><expr><literal type="string">"sxcnt:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* sanity-check the xid count before palloc */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>xcnt</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>xcnt</name></expr></argument> &gt;</argument_list></name> <call><name>GetMaxSnapshotSubxidCount</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot data in file \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>subxip</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>xcnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xcnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>subxip</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>parseXidFromText</name><argument_list>(<argument><expr><literal type="string">"sxp:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>subxcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>subxip</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>snapshot</name><operator>.</operator><name>takenDuringRecovery</name></name> <operator>=</operator> <call><name>parseIntFromText</name><argument_list>(<argument><expr><literal type="string">"rec:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filebuf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Do some additional sanity checking, just to protect ourselves.  We
     * don't trouble to check the array elements, just the most critical
     * fields.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VirtualTransactionIdIsValid</name><argument_list>(<argument><expr><name>src_vxid</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>src_dbid</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>.</operator><name>xmin</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>.</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid snapshot data in file \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If we're serializable, the source transaction must be too, otherwise
     * predicate.c has problems (SxactGlobalXmin could go backwards).  Also, a
     * non-read-only transaction can't adopt a snapshot from a read-only
     * transaction, as predicate.c handles the cases very differently.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsolationIsSerializable</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>src_isolevel</name> <operator>!=</operator> <name>XACT_SERIALIZABLE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a serializable transaction cannot import a snapshot from a non-serializable transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>src_readonly</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>XactReadOnly</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a non-read-only serializable transaction cannot import a snapshot from a read-only transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We cannot import a snapshot that was taken in a different database,
     * because vacuum calculates OldestXmin on a per-database basis; so the
     * source transaction's xmin doesn't protect us from data loss.  This
     * restriction could be removed if the source transaction were to mark its
     * xmin as being globally applicable.  But that would require some
     * additional syntax, since that has to be known when the snapshot is
     * initially taken.  (See pgsql-hackers discussion of 2011-10-21.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>src_dbid</name> <operator>!=</operator> <name>MyDatabaseId</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot import a snapshot from a different database"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* OK, install the snapshot */</comment>
    <expr_stmt><expr><call><name>SetTransactionSnapshot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>snapshot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>src_vxid</name></expr></argument>, <argument><expr><name>src_pid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * XactHasExportedSnapshots
 *        Test whether current transaction has exported any snapshots.
 */</comment>
<function><type><name>bool</name></type>
<name>XactHasExportedSnapshots</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name>exportedSnapshots</name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * DeleteAllExportedSnapshotFiles
 *        Clean up any files that have been left behind by a crashed backend
 *        that had exported snapshots before it died.
 *
 * This should be called during database startup or crash recovery.
 */</comment>
<function><type><name>void</name></type>
<name>DeleteAllExportedSnapshotFiles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>buf</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SNAPSHOT_EXPORT_DIR</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DIR</name>           <modifier>*</modifier></type><name>s_dir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>s_de</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>s_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>SNAPSHOT_EXPORT_DIR</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We really should have that directory in a sane cluster setup. But
         * then again if we don't, it's not fatal enough to make it FATAL.
         * Since we're running in the postmaster, LOG is our best bet.
         */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not open directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>SNAPSHOT_EXPORT_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>s_de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>s_dir</name></expr></argument>, <argument><expr><name>SNAPSHOT_EXPORT_DIR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>s_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>strcmp</name><argument_list>(<argument><expr><name><name>s_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>SNAPSHOT_EXPORT_DIR</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><name><name>s_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Again, unlink failure is not worthy of FATAL */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not unlink file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>s_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ThereAreNoPriorRegisteredSnapshots</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>pairingheap_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>pairingheap_is_singular</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RegisteredSnapshots</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Return a timestamp that is exactly on a minute boundary.
 *
 * If the argument is already aligned, return that value, otherwise move to
 * the next minute boundary following the given time.
 */</comment>
<function><type><specifier>static</specifier> <name>TimestampTz</name></type>
<name>AlignTimestampToMinuteBoundary</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>ts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>retval</name> <init>= <expr><name>ts</name> <operator>+</operator> <operator>(</operator><name>USECS_PER_MINUTE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

    <return>return <expr><name>retval</name> <operator>-</operator> <operator>(</operator><name>retval</name> <operator>%</operator> <name>USECS_PER_MINUTE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get current timestamp for snapshots
 *
 * This is basically GetCurrentTimestamp(), but with a guarantee that
 * the result never moves backward.
 */</comment>
<function><type><name>TimestampTz</name></type>
<name>GetSnapshotCurrentTimestamp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Don't let time move backward; if it hasn't advanced, use the old value.
     */</comment>
    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>mutex_current</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>now</name> <operator>&lt;=</operator> <name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>current_timestamp</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>now</name> <operator>=</operator> <name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>current_timestamp</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>current_timestamp</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>mutex_current</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>now</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get timestamp through which vacuum may have processed based on last stored
 * value for threshold_timestamp.
 *
 * XXX: So far, we never trust that a 64-bit value can be read atomically; if
 * that ever changes, we could get rid of the spinlock here.
 */</comment>
<function><type><name>TimestampTz</name></type>
<name>GetOldSnapshotThresholdTimestamp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>threshold_timestamp</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>mutex_threshold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>threshold_timestamp</name> <operator>=</operator> <name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>threshold_timestamp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>mutex_threshold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>threshold_timestamp</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetOldSnapshotThresholdTimestamp</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>ts</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xlimit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>mutex_threshold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>threshold_timestamp</name></name> <operator>=</operator> <name>ts</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>threshold_xid</name></name> <operator>=</operator> <name>xlimit</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>mutex_threshold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TransactionIdLimitedForOldSnapshots
 *
 * Apply old snapshot limit, if any.  This is intended to be called for page
 * pruning and table vacuuming, to allow old_snapshot_threshold to override
 * the normal global xmin value.  Actual testing for snapshot too old will be
 * based on whether a snapshot timestamp is prior to the threshold timestamp
 * set in this function.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>TransactionIdLimitedForOldSnapshots</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>recentXmin</name></decl></parameter>,
                                    <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>recentXmin</name></expr></argument>)</argument_list></call>
        <operator>&amp;&amp;</operator> <name>old_snapshot_threshold</name> <operator>&gt;=</operator> <literal type="number">0</literal>
        <operator>&amp;&amp;</operator> <call><name>RelationAllowsEarlyPruning</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TimestampTz</name></type> <name>ts</name> <init>= <expr><call><name>GetSnapshotCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>xlimit</name> <init>= <expr><name>recentXmin</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>latest_xmin</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TimestampTz</name></type> <name>update_ts</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>same_ts_as_threshold</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>mutex_latest_xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>latest_xmin</name> <operator>=</operator> <name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>latest_xmin</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>update_ts</name> <operator>=</operator> <name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>next_map_update</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>mutex_latest_xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Zero threshold always overrides to latest xmin, if valid.  Without
         * some heuristic it will find its own snapshot too old on, for
         * example, a simple UPDATE -- which would make it useless for most
         * testing, but there is no principled way to ensure that it doesn't
         * fail in this way.  Use a five-second delay to try to get useful
         * testing behavior, but this may need adjustment.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>old_snapshot_threshold</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>latest_xmin</name></expr></argument>, <argument><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>latest_xmin</name></expr></argument>, <argument><expr><name>xlimit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>xlimit</name> <operator>=</operator> <name>latest_xmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>ts</name> <operator>-=</operator> <literal type="number">5</literal> <operator>*</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SetOldSnapshotThresholdTimestamp</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><name>xlimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>xlimit</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>AlignTimestampToMinuteBoundary</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>
            <operator>-</operator> <operator>(</operator><name>old_snapshot_threshold</name> <operator>*</operator> <name>USECS_PER_MINUTE</name><operator>)</operator></expr>;</expr_stmt>

        <comment type="block">/* Check for fast exit without LW locking. */</comment>
        <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>mutex_threshold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ts</name> <operator>==</operator> <name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>threshold_timestamp</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>xlimit</name> <operator>=</operator> <name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>threshold_xid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>same_ts_as_threshold</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>mutex_threshold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>same_ts_as_threshold</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>ts</name> <operator>==</operator> <name>update_ts</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>xlimit</name> <operator>=</operator> <name>latest_xmin</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>NormalTransactionIdFollows</name><argument_list>(<argument><expr><name>xlimit</name></expr></argument>, <argument><expr><name>recentXmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>SetOldSnapshotThresholdTimestamp</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><name>xlimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>OldSnapshotTimeMapLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>count_used</name></name> <operator>&gt;</operator> <literal type="number">0</literal>
                    <operator>&amp;&amp;</operator> <name>ts</name> <operator>&gt;=</operator> <name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_timestamp</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type>            <name>offset</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ts</name> <operator>-</operator> <name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_timestamp</name></name><operator>)</operator>
                              <operator>/</operator> <name>USECS_PER_MINUTE</name><operator>)</operator></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>count_used</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>count_used</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_offset</name></name> <operator>+</operator> <name>offset</name><operator>)</operator>
                        <operator>%</operator> <name>OLD_SNAPSHOT_TIME_MAP_ENTRIES</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>xlimit</name> <operator>=</operator> <name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>xid_by_minute</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>NormalTransactionIdFollows</name><argument_list>(<argument><expr><name>xlimit</name></expr></argument>, <argument><expr><name>recentXmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>SetOldSnapshotThresholdTimestamp</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><name>xlimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OldSnapshotTimeMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Failsafe protection against vacuuming work of active transaction.
         *
         * This is not an assertion because we avoid the spinlock for
         * performance, leaving open the possibility that xlimit could advance
         * and be more current; but it seems prudent to apply this limit.  It
         * might make pruning a tiny bit less aggressive than it could be, but
         * protects against data loss bugs.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>latest_xmin</name></expr></argument>)</argument_list></call>
            <operator>&amp;&amp;</operator> <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>latest_xmin</name></expr></argument>, <argument><expr><name>xlimit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>xlimit</name> <operator>=</operator> <name>latest_xmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>NormalTransactionIdFollows</name><argument_list>(<argument><expr><name>xlimit</name></expr></argument>, <argument><expr><name>recentXmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>xlimit</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>recentXmin</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Take care of the circular buffer that maps time to xid.
 */</comment>
<function><type><name>void</name></type>
<name>MaintainOldSnapshotTimeMapping</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>whenTaken</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xmin</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>ts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>latest_xmin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>update_ts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>map_update_required</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Never call this function when old snapshot checking is disabled. */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>old_snapshot_threshold</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>AlignTimestampToMinuteBoundary</name><argument_list>(<argument><expr><name>whenTaken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Keep track of the latest xmin seen by any process. Update mapping with
     * a new value when we have crossed a bucket boundary.
     */</comment>
    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>mutex_latest_xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>latest_xmin</name> <operator>=</operator> <name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>latest_xmin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>update_ts</name> <operator>=</operator> <name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>next_map_update</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ts</name> <operator>&gt;</operator> <name>update_ts</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>next_map_update</name></name> <operator>=</operator> <name>ts</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>map_update_required</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>, <argument><expr><name>latest_xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>latest_xmin</name></name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>mutex_latest_xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We only needed to update the most recent xmin value. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>map_update_required</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* No further tracking needed for 0 (used for testing). */</comment>
    <if_stmt><if>if <condition>(<expr><name>old_snapshot_threshold</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We don't want to do something stupid with unusual values, but we don't
     * want to litter the log with warnings or break otherwise normal
     * processing for this feature; so if something seems unreasonable, just
     * log at DEBUG level and return without doing anything.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>whenTaken</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
             <argument><expr><literal type="string">"MaintainOldSnapshotTimeMapping called with negative whenTaken = %ld"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>whenTaken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
             <argument><expr><literal type="string">"MaintainOldSnapshotTimeMapping called with xmin = %lu"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>OldSnapshotTimeMapLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_offset</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_offset</name></name> <operator>&lt;</operator> <name>OLD_SNAPSHOT_TIME_MAP_ENTRIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_timestamp</name></name> <operator>%</operator> <name>USECS_PER_MINUTE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>count_used</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>count_used</name></name> <operator>&lt;=</operator> <name>OLD_SNAPSHOT_TIME_MAP_ENTRIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>count_used</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* set up first entry for empty mapping */</comment>
        <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_timestamp</name></name> <operator>=</operator> <name>ts</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>count_used</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>xid_by_minute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>ts</name> <operator>&lt;</operator> <name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_timestamp</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* old ts; log it at DEBUG */</comment>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OldSnapshotTimeMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
             <argument><expr><literal type="string">"MaintainOldSnapshotTimeMapping called with old whenTaken = %ld"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>whenTaken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>ts</name> <operator>&lt;=</operator> <operator>(</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_timestamp</name></name> <operator>+</operator>
                    <operator>(</operator><operator>(</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>count_used</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator>
                     <operator>*</operator> <name>USECS_PER_MINUTE</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* existing mapping; advance xid if possible */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>bucket</name> <init>= <expr><operator>(</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_offset</name></name>
                              <operator>+</operator> <operator>(</operator><operator>(</operator><name>ts</name> <operator>-</operator> <name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_timestamp</name></name><operator>)</operator>
                                 <operator>/</operator> <name>USECS_PER_MINUTE</name><operator>)</operator><operator>)</operator>
        <operator>%</operator> <name>OLD_SNAPSHOT_TIME_MAP_ENTRIES</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>xid_by_minute</name><index>[<expr><name>bucket</name></expr>]</index></name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>xid_by_minute</name><index>[<expr><name>bucket</name></expr>]</index></name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* We need a new bucket, but it might not be the very next one. */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>advance</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ts</name> <operator>-</operator> <name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_timestamp</name></name><operator>)</operator>
                               <operator>/</operator> <name>USECS_PER_MINUTE</name><operator>)</operator></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_timestamp</name></name> <operator>=</operator> <name>ts</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>advance</name> <operator>&gt;=</operator> <name>OLD_SNAPSHOT_TIME_MAP_ENTRIES</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Advance is so far that all old data is junk; start over. */</comment>
            <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>count_used</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>xid_by_minute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Store the new value in one or more buckets. */</comment>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>advance</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>count_used</name></name> <operator>==</operator> <name>OLD_SNAPSHOT_TIME_MAP_ENTRIES</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Map full and new value replaces old head. */</comment>
                    <decl_stmt><decl><type><name>int</name></type>            <name>old_head</name> <init>= <expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_offset</name></name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>old_head</name> <operator>==</operator> <operator>(</operator><name>OLD_SNAPSHOT_TIME_MAP_ENTRIES</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_offset</name></name> <operator>=</operator> <name>old_head</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>xid_by_minute</name><index>[<expr><name>old_head</name></expr>]</index></name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Extend map to unused entry. */</comment>
                    <decl_stmt><decl><type><name>int</name></type>            <name>new_tail</name> <init>= <expr><operator>(</operator><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>head_offset</name></name>
                                            <operator>+</operator> <name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>count_used</name></name><operator>)</operator>
                    <operator>%</operator> <name>OLD_SNAPSHOT_TIME_MAP_ENTRIES</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>count_used</name></name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>oldSnapshotControl</name><operator>-&gt;</operator><name>xid_by_minute</name><index>[<expr><name>new_tail</name></expr>]</index></name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OldSnapshotTimeMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Setup a snapshot that replaces normal catalog snapshots that allows catalog
 * access to behave just like it did at a certain point in the past.
 *
 * Needed for logical decoding.
 */</comment>
<function><type><name>void</name></type>
<name>SetupHistoricSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>historic_snapshot</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>tuplecids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>historic_snapshot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* setup the timetravel snapshot */</comment>
    <expr_stmt><expr><name>HistoricSnapshot</name> <operator>=</operator> <name>historic_snapshot</name></expr>;</expr_stmt>

    <comment type="block">/* setup (cmin, cmax) lookup hash */</comment>
    <expr_stmt><expr><name>tuplecid_data</name> <operator>=</operator> <name>tuplecids</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Make catalog snapshots behave normally again.
 */</comment>
<function><type><name>void</name></type>
<name>TeardownHistoricSnapshot</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>HistoricSnapshot</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuplecid_data</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>HistoricSnapshotActive</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>HistoricSnapshot</name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>HTAB</name> <modifier>*</modifier></type>
<name>HistoricSnapshotGetTupleCids</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HistoricSnapshotActive</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>tuplecid_data</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * EstimateSnapshotSpace
 *        Returns the size needed to store the given snapshot.
 *
 * We are exporting only required fields from the Snapshot, stored in
 * SerializedSnapshotData.
 */</comment>
<function><type><name>Size</name></type>
<name>EstimateSnapshotSpace</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snap</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>snap</name> <operator>!=</operator> <name>InvalidSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>satisfies</name></name> <operator>==</operator> <name>HeapTupleSatisfiesMVCC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We allocate any XID arrays needed in the same palloc block. */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SerializedSnapshotData</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                    <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xcnt</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>prepare_xcnt</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>prepare_xcnt</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name><name>snap</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>(</operator><operator>!</operator><name><name>snap</name><operator>-&gt;</operator><name>suboverflowed</name></name> <operator>||</operator> <name><name>snap</name><operator>-&gt;</operator><name>takenDuringRecovery</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>,
                        <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>subxcnt</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>snap</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>(</operator><operator>!</operator><name><name>snap</name><operator>-&gt;</operator><name>suboverflowed</name></name> <operator>||</operator> <name><name>snap</name><operator>-&gt;</operator><name>takenDuringRecovery</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SerializeSnapshot
 *        Dumps the serialized snapshot (extracted from given snapshot) onto the
 *        memory location at start_address.
 */</comment>
<function><type><name>void</name></type>
<name>SerializeSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start_address</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>SerializedSnapshotData</name></type> <name>serialized_snapshot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name>  <name>curoff</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"serialize snapshot "</literal><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Copy all required fields */</comment>
    <expr_stmt><expr><name><name>serialized_snapshot</name><operator>.</operator><name>xmin</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>serialized_snapshot</name><operator>.</operator><name>xmax</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>xmax</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>serialized_snapshot</name><operator>.</operator><name>xcnt</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>xcnt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>serialized_snapshot</name><operator>.</operator><name>subxcnt</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>subxcnt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>serialized_snapshot</name><operator>.</operator><name>suboverflowed</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>suboverflowed</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>serialized_snapshot</name><operator>.</operator><name>takenDuringRecovery</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>takenDuringRecovery</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>serialized_snapshot</name><operator>.</operator><name>curcid</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>curcid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>serialized_snapshot</name><operator>.</operator><name>whenTaken</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>whenTaken</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>serialized_snapshot</name><operator>.</operator><name>lsn</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>lsn</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>serialized_snapshot</name><operator>.</operator><name>start_ts</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>serialized_snapshot</name><operator>.</operator><name>local</name></name>    <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>local</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>serialized_snapshot</name><operator>.</operator><name>prepare_xmin</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xmin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>serialized_snapshot</name><operator>.</operator><name>prepare_xcnt</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xcnt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>serialized_snapshot</name><operator>.</operator><name>prepare_subxcnt</name></name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Ignore the SubXID array if it has overflowed, unless the snapshot was
     * taken during recovery - in that case, top-level XIDs are in subxip as
     * well, and we mustn't lose them.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>serialized_snapshot</name><operator>.</operator><name>suboverflowed</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>snapshot</name><operator>-&gt;</operator><name>takenDuringRecovery</name></name></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
        <expr_stmt><expr><name><name>serialized_snapshot</name><operator>.</operator><name>prepare_subxcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name><name>serialized_snapshot</name><operator>.</operator><name>subxcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Copy struct to possibly-unaligned buffer */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>start_address</name></expr></argument>,
           <argument><expr><operator>&amp;</operator><name>serialized_snapshot</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SerializedSnapshotData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Copy XID array */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>start_address</name> <operator>+</operator>
                                  <sizeof>sizeof<argument_list>(<argument><expr><name>SerializedSnapshotData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>,
               <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Copy SubXID array. Don't bother to copy it if it had overflowed,
     * though, because it's not used anywhere in that case. Except if it's a
     * snapshot taken during recovery; all the top-level XIDs are in subxip as
     * well in that case, so we mustn't lose them.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>serialized_snapshot</name><operator>.</operator><name>subxcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Size</name></type>        <name>subxipoff</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>SerializedSnapshotData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
        <name><name>snapshot</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>start_address</name> <operator>+</operator> <name>subxipoff</name><operator>)</operator></expr></argument>,
               <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxip</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><name>curoff</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SerializedSnapshotData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
        <name><name>snapshot</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
        <name><name>snapshot</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>start_address</name> <operator>+</operator> <name>curoff</name><operator>)</operator></expr></argument>,
               <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xip</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>curoff</name> <operator>+=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>GlobalTimestamp</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>start_address</name> <operator>+</operator> <name>curoff</name><operator>)</operator></expr></argument>,
               <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xip_ts</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>curoff</name> <operator>+=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name><name>serialized_snapshot</name><operator>.</operator><name>prepare_subxcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>start_address</name> <operator>+</operator> <name>curoff</name><operator>)</operator></expr></argument>,
               <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxip</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>curoff</name> <operator>+=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>GlobalTimestamp</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>start_address</name> <operator>+</operator> <name>curoff</name><operator>)</operator></expr></argument>,
               <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxip_ts</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * RestoreSnapshot
 *        Restore a serialized snapshot from the specified address.
 *
 * The copy is palloc'd in TopTransactionContext and has initial refcounts set
 * to 0.  The returned snapshot has the copied flag set.
 */</comment>
<function><type><name>Snapshot</name></type>
<name>RestoreSnapshot</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start_address</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>SerializedSnapshotData</name></type> <name>serialized_snapshot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Snapshot</name></type>    <name>snapshot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>serialized_xids</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Size</name></type>        <name>prepare_xid_off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>prepare_xid_ts_off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>prepare_subxid_off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>prepare_subxid_ts_off</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>Size</name></type>        <name>curoff</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>serialized_snapshot</name></expr></argument>, <argument><expr><name>start_address</name></expr></argument>,
           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SerializedSnapshotData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>serialized_xids</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator>
        <operator>(</operator><name>start_address</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SerializedSnapshotData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><name>prepare_xid_off</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SerializedSnapshotData</name></expr></argument>)</argument_list></sizeof> 
                <operator>+</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof>
                <operator>+</operator>  <name><name>serialized_snapshot</name><operator>.</operator><name>subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>prepare_xid_ts_off</name> <operator>=</operator> <name>prepare_xid_off</name> <operator>+</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>prepare_xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>prepare_subxid_off</name> <operator>=</operator> <name>prepare_xid_ts_off</name> <operator>+</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>prepare_xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>prepare_subxid_ts_off</name> <operator>=</operator> <name>prepare_subxid_off</name> <operator>+</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>prepare_subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


    <comment type="block">/* We allocate any XID arrays needed in the same palloc block. */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof>
        <operator>+</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof>
        <operator>+</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><name>size</name> <operator>+=</operator> <operator>(</operator><name><name>serialized_snapshot</name><operator>.</operator><name>prepare_xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof>
             <operator>+</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>prepare_xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof>
             <operator>+</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>prepare_subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof>
             <operator>+</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>prepare_subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


    <comment type="block">/* Copy all required fields */</comment>
    <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <operator>(</operator><name>Snapshot</name><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>satisfies</name></name> <operator>=</operator> <name>HeapTupleSatisfiesMVCC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>xmin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>xmax</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xip</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>=</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>xcnt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxip</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>=</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>subxcnt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>suboverflowed</name></name> <operator>=</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>suboverflowed</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>takenDuringRecovery</name></name> <operator>=</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>takenDuringRecovery</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>curcid</name></name> <operator>=</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>curcid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>whenTaken</name></name> <operator>=</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>whenTaken</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>lsn</name></name> <operator>=</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>lsn</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>start_ts</name></name> <operator>=</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>start_ts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>local</name></name> <operator>=</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>local</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xmin</name></name> <operator>=</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>prepare_xmin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xcnt</name></name> <operator>=</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>prepare_xcnt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxcnt</name></name> <operator>=</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>prepare_subxcnt</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"restore snapshot "</literal><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>groupsize</name></name> <operator>=</operator> <call><name>GetGroupSize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SnapshotGetShardTable</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>Bitmapset</name> <operator>*</operator><operator>)</operator><name><name>snapshot</name><operator>-&gt;</operator><name>sg_filler</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>CopyShardGroups_DN</name><argument_list>(<argument><expr><call><name>SnapshotGetShardTable</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Copy XIDs, if present. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>serialized_snapshot</name><operator>.</operator><name>xcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xip</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>snapshot</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>, <argument><expr><name>serialized_xids</name></expr></argument>,
               <argument><expr><name><name>serialized_snapshot</name><operator>.</operator><name>xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Copy SubXIDs, if present. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>serialized_snapshot</name><operator>.</operator><name>subxcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxip</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>snapshot</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>+</operator>
            <name><name>serialized_snapshot</name><operator>.</operator><name>xcnt</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxip</name></name></expr></argument>, <argument><expr><name>serialized_xids</name> <operator>+</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>xcnt</name></name></expr></argument>,
               <argument><expr><name><name>serialized_snapshot</name><operator>.</operator><name>subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><name>curoff</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof>
                <operator>+</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><name><name>serialized_snapshot</name><operator>.</operator><name>prepare_xcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xip</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>snapshot</name> <operator>+</operator> <name>curoff</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xip</name></name></expr></argument>, <argument><expr><operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>start_address</name> <operator>+</operator> <name>prepare_xid_off</name><operator>)</operator></expr></argument>,
               <argument><expr><name><name>serialized_snapshot</name><operator>.</operator><name>prepare_xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>curoff</name> <operator>+=</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>prepare_xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xip_ts</name></name> <operator>=</operator> <operator>(</operator><name>GlobalTimestamp</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>snapshot</name> <operator>+</operator> <name>curoff</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_xip_ts</name></name></expr></argument>, <argument><expr><operator>(</operator><name>GlobalTimestamp</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>start_address</name> <operator>+</operator> <name>prepare_xid_ts_off</name><operator>)</operator></expr></argument>,
               <argument><expr><name><name>serialized_snapshot</name><operator>.</operator><name>prepare_xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>curoff</name> <operator>+=</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>prepare_xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>serialized_snapshot</name><operator>.</operator><name>prepare_subxcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxip</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>snapshot</name> <operator>+</operator> <name>curoff</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxip</name></name></expr></argument>, <argument><expr><operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>start_address</name> <operator>+</operator> <name>prepare_subxid_off</name><operator>)</operator></expr></argument>,
               <argument><expr><name><name>serialized_snapshot</name><operator>.</operator><name>prepare_subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>curoff</name> <operator>+=</operator> <name><name>serialized_snapshot</name><operator>.</operator><name>prepare_subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxip_ts</name></name> <operator>=</operator> <operator>(</operator><name>GlobalTimestamp</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>snapshot</name> <operator>+</operator> <name>curoff</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>prepare_subxip_ts</name></name></expr></argument>, <argument><expr><operator>(</operator><name>GlobalTimestamp</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>start_address</name> <operator>+</operator> <name>prepare_subxid_ts_off</name><operator>)</operator></expr></argument>,
               <argument><expr><name><name>serialized_snapshot</name><operator>.</operator><name>prepare_subxcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Set the copied flag so that the caller will set refcounts correctly. */</comment>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>regd_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>active_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>copied</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <return>return <expr><name>snapshot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Install a restored snapshot as the transaction snapshot.
 *
 * The second argument is of type void * so that snapmgr.h need not include
 * the declaration for PGPROC.
 */</comment>
<function><type><name>void</name></type>
<name>RestoreTransactionSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>master_pgproc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>SetTransactionSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidPid</name></expr></argument>, <argument><expr><name>master_pgproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
