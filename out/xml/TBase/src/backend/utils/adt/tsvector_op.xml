<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/adt/tsvector_op.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * tsvector_op.c
 *      operations over tsvector
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *      src/backend/utils/adt/tsvector_op.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsearch/ts_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/regproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>arrb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>arre</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>operand</name></decl>;</decl_stmt>
}</block></struct></type> <name>CHKVAL</name>;</typedef>


<typedef>typedef <type><struct>struct <name>StatEntry</name>
<block>{
    <decl_stmt><decl><type><name>uint32</name></type>        <name>ndoc</name></decl>;</decl_stmt>            <comment type="block">/* zero indicates that we were already here
                                 * while walking through the tree */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>nentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>StatEntry</name></name> <modifier>*</modifier></type><name>left</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>StatEntry</name></name> <modifier>*</modifier></type><name>right</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>lenlexeme</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>lexeme</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>StatEntry</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATENTRYHDRSZ</name></cpp:macro>    <cpp:value>(offsetof(StatEntry, lexeme))</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int32</name></type>        <name>weight</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>uint32</name></type>        <name>maxdepth</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>StatEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>stackpos</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>StatEntry</name>  <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
}</block></struct></type> <name>TSVectorStat</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATHDRSIZE</name></cpp:macro> <cpp:value>(offsetof(TSVectorStat, data))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>tsvector_update_trigger</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>config_column</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>tsvector_bsearch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TSVector</name></type> <name>tsv</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>lexeme</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lexeme_len</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Order: haspos, len, word, for all positions (pos, weight)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>silly_cmp_tsvector</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TSVector</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TSVector</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>aptr</name> <init>= <expr><call><name>ARRPTR</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>bptr</name> <init>= <expr><call><name>ARRPTR</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>res</name></decl>;</decl_stmt>


        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>aptr</name><operator>-&gt;</operator><name>haspos</name></name> <operator>!=</operator> <name><name>bptr</name><operator>-&gt;</operator><name>haspos</name></name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>aptr</name><operator>-&gt;</operator><name>haspos</name></name> <operator>&gt;</operator> <name><name>bptr</name><operator>-&gt;</operator><name>haspos</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>tsCompareString</name><argument_list>(<argument><expr><call><name>STRPTR</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>aptr</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name><name>aptr</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><call><name>STRPTR</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>bptr</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name><name>bptr</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>res</name></expr>;</return>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>aptr</name><operator>-&gt;</operator><name>haspos</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><call><name>POSDATAPTR</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>aptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>bp</name> <init>= <expr><call><name>POSDATAPTR</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>bptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>POSDATALEN</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>aptr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>POSDATALEN</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>bptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><ternary><condition><expr><operator>(</operator><call><name>POSDATALEN</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>aptr</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>POSDATALEN</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>bptr</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

                <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <call><name>POSDATALEN</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>aptr</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>WEP_GETPOS</name><argument_list>(<argument><expr><operator>*</operator><name>ap</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>WEP_GETPOS</name><argument_list>(<argument><expr><operator>*</operator><name>bp</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <return>return <expr><ternary><condition><expr><operator>(</operator><call><name>WEP_GETPOS</name><argument_list>(<argument><expr><operator>*</operator><name>ap</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>WEP_GETPOS</name><argument_list>(<argument><expr><operator>*</operator><name>bp</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><call><name>WEP_GETWEIGHT</name><argument_list>(<argument><expr><operator>*</operator><name>ap</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>WEP_GETWEIGHT</name><argument_list>(<argument><expr><operator>*</operator><name>bp</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <return>return <expr><ternary><condition><expr><operator>(</operator><call><name>WEP_GETWEIGHT</name><argument_list>(<argument><expr><operator>*</operator><name>ap</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>WEP_GETWEIGHT</name><argument_list>(<argument><expr><operator>*</operator><name>bp</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>ap</name><operator>++</operator></expr><operator>,</operator> <expr><name>bp</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>aptr</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>bptr</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TSVECTORCMPFUNC</name><parameter_list>( <parameter><type><name>type</name></type></parameter>, <parameter><type><name>action</name></type></parameter>, <parameter><type><name>ret</name></type></parameter> )</parameter_list></cpp:macro>            \
<cpp:value>Datum                                                    \
tsvector_##type(PG_FUNCTION_ARGS)                        \
{                                                        \
    TSVector    a = PG_GETARG_TSVECTOR(0);                \
    TSVector    b = PG_GETARG_TSVECTOR(1);                \
    int            res = silly_cmp_tsvector(a, b);            \
    PG_FREE_IF_COPY(a,0);                                \
    PG_FREE_IF_COPY(b,1);                                \
    PG_RETURN_##ret( res action 0 );                    \
}    \
<comment type="block">/* keep compiler quiet - no extra ; */</comment>                    \
extern int no_such_variable</cpp:value></cpp:define>

<expr_stmt><expr><call><name>TSVECTORCMPFUNC</name><argument_list>(<argument><expr><name>lt</name></expr></argument>, <argument><expr><operator>&lt;</operator></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TSVECTORCMPFUNC</name><argument_list>(<argument><expr><name>le</name></expr></argument>, <argument><expr><operator>&lt;=</operator></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TSVECTORCMPFUNC</name><argument_list>(<argument><expr><name>eq</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TSVECTORCMPFUNC</name><argument_list>(<argument><expr><name>ge</name></expr></argument>, <argument><expr><operator>&gt;=</operator></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TSVECTORCMPFUNC</name><argument_list>(<argument><expr><name>gt</name></expr></argument>, <argument><expr><operator>&gt;</operator></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TSVECTORCMPFUNC</name><argument_list>(<argument><expr><name>ne</name></expr></argument>, <argument><expr><operator>!=</operator></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TSVECTORCMPFUNC</name><argument_list>(<argument><expr><name>cmp</name></expr></argument>, <argument><expr><operator>+</operator></expr></argument>, <argument><expr><name>INT32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>tsvector_strip</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>in</name> <init>= <expr><call><name>PG_GETARG_TSVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>out</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>arrin</name> <init>= <expr><call><name>ARRPTR</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>arrout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>CALCDATASIZE</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>out</name> <operator>=</operator> <operator>(</operator><name>TSVector</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>in</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>arrout</name> <operator>=</operator> <call><name>ARRPTR</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cur</name> <operator>=</operator> <call><name>STRPTR</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><call><name>STRPTR</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name></expr></argument>, <argument><expr><name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arrout</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>haspos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arrout</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arrout</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>=</operator> <name>cur</name> <operator>-</operator> <call><name>STRPTR</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cur</name> <operator>+=</operator> <name><name>arrout</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsvector_length</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>in</name> <init>= <expr><call><name>PG_GETARG_TSVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>ret</name> <init>= <expr><name><name>in</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsvector_setweight</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>in</name> <init>= <expr><call><name>PG_GETARG_TSVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>cw</name> <init>= <expr><call><name>PG_GETARG_CHAR</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>out</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>w</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>cw</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="char">'A'</literal></expr>:</case>
        <case>case <expr><literal type="char">'a'</literal></expr>:</case>
            <expr_stmt><expr><name>w</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'B'</literal></expr>:</case>
        <case>case <expr><literal type="char">'b'</literal></expr>:</case>
            <expr_stmt><expr><name>w</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'C'</literal></expr>:</case>
        <case>case <expr><literal type="char">'c'</literal></expr>:</case>
            <expr_stmt><expr><name>w</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'D'</literal></expr>:</case>
        <case>case <expr><literal type="char">'d'</literal></expr>:</case>
            <expr_stmt><expr><name>w</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <comment type="block">/* internal error */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized weight: %d"</literal></expr></argument>, <argument><expr><name>cw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <expr_stmt><expr><name>out</name> <operator>=</operator> <operator>(</operator><name>TSVector</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>ARRPTR</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>out</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>i</name><operator>--</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>j</name> <operator>=</operator> <call><name>POSDATALEN</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>POSDATAPTR</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>j</name><operator>--</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>WEP_SETWEIGHT</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>entry</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * setweight(tsin tsvector, char_weight "char", lexemes "text"[])
 *
 * Assign weight w to elements of tsin that are listed in lexemes.
 */</comment>
<function><type><name>Datum</name></type>
<name>tsvector_setweight_by_filter</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>tsin</name> <init>= <expr><call><name>PG_GETARG_TSVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>char_weight</name> <init>= <expr><call><name>PG_GETARG_CHAR</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>lexemes</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>TSVector</name></type>    <name>tsout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>,
                <decl><type ref="prev"/><name>nlexemes</name></decl>,
                <decl><type ref="prev"/><name>weight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>dlexemes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>char_weight</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="char">'A'</literal></expr>:</case>
        <case>case <expr><literal type="char">'a'</literal></expr>:</case>
            <expr_stmt><expr><name>weight</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'B'</literal></expr>:</case>
        <case>case <expr><literal type="char">'b'</literal></expr>:</case>
            <expr_stmt><expr><name>weight</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'C'</literal></expr>:</case>
        <case>case <expr><literal type="char">'c'</literal></expr>:</case>
            <expr_stmt><expr><name>weight</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'D'</literal></expr>:</case>
        <case>case <expr><literal type="char">'d'</literal></expr>:</case>
            <expr_stmt><expr><name>weight</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <comment type="block">/* internal error */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized weight: %c"</literal></expr></argument>, <argument><expr><name>char_weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <expr_stmt><expr><name>tsout</name> <operator>=</operator> <operator>(</operator><name>TSVector</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>, <argument><expr><name>tsin</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>ARRPTR</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>lexemes</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
                      <argument><expr><operator>&amp;</operator><name>dlexemes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlexemes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Assuming that lexemes array is significantly shorter than tsvector we
     * can iterate through lexemes performing binary search of each lexeme
     * from lexemes in tsvector.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nlexemes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>lex_len</name></decl>,
                    <decl><type ref="prev"/><name>lex_pos</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lexeme array may not contain nulls"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>lex</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name><name>dlexemes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lex_len</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name><name>dlexemes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lex_pos</name> <operator>=</operator> <call><name>tsvector_bsearch</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>, <argument><expr><name>lex_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>lex_pos</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>j</name> <operator>=</operator> <call><name>POSDATALEN</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>, <argument><expr><name>entry</name> <operator>+</operator> <name>lex_pos</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>POSDATAPTR</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>, <argument><expr><name>entry</name> <operator>+</operator> <name>lex_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><name>j</name><operator>--</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>WEP_SETWEIGHT</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>lexemes</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>compareEntry</name><parameter_list>(<parameter><type><name>pa</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>pb</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>tsCompareString((pa) + (a)-&gt;pos, (a)-&gt;len,    \
                    (pb) + (b)-&gt;pos, (b)-&gt;len,    \
                    false)</cpp:value></cpp:define>

<comment type="block">/*
 * Add positions from src to dest after offsetting them by maxpos.
 * Return the number added (might be less than expected due to overflow)
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>add_pos</name><parameter_list>(<parameter><decl><type><name>TSVector</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>WordEntry</name> <modifier>*</modifier></type><name>srcptr</name></decl></parameter>,
        <parameter><decl><type><name>TSVector</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>WordEntry</name> <modifier>*</modifier></type><name>destptr</name></decl></parameter>,
        <parameter><decl><type><name>int32</name></type> <name>maxpos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint16</name>       <modifier>*</modifier></type><name>clen</name> <init>= <expr><operator>&amp;</operator><call><name>_POSVECPTR</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>destptr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>npos</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name></type>        <name>slen</name> <init>= <expr><call><name>POSDATALEN</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcptr</name></expr></argument>)</argument_list></call></expr></init></decl>,
                <decl><type ref="prev"/><name>startlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>spos</name> <init>= <expr><call><name>POSDATAPTR</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcptr</name></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>dpos</name> <init>= <expr><call><name>POSDATAPTR</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>destptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>destptr</name><operator>-&gt;</operator><name>haspos</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>clen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>startlen</name> <operator>=</operator> <operator>*</operator><name>clen</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
         <condition><expr><name>i</name> <operator>&lt;</operator> <name>slen</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>clen</name> <operator>&lt;</operator> <name>MAXNUMPOS</name> <operator>&amp;&amp;</operator>
         <operator>(</operator><operator>*</operator><name>clen</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>WEP_GETPOS</name><argument_list>(<argument><expr><name><name>dpos</name><index>[<expr><operator>*</operator><name>clen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>MAXENTRYPOS</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</condition>
         <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>WEP_SETWEIGHT</name><argument_list>(<argument><expr><name><name>dpos</name><index>[<expr><operator>*</operator><name>clen</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>WEP_GETWEIGHT</name><argument_list>(<argument><expr><name><name>spos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>WEP_SETPOS</name><argument_list>(<argument><expr><name><name>dpos</name><index>[<expr><operator>*</operator><name>clen</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>LIMITPOS</name><argument_list>(<argument><expr><call><name>WEP_GETPOS</name><argument_list>(<argument><expr><name><name>spos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>maxpos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>clen</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>clen</name> <operator>!=</operator> <name>startlen</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>destptr</name><operator>-&gt;</operator><name>haspos</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><operator>*</operator><name>clen</name> <operator>-</operator> <name>startlen</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform binary search of given lexeme in TSVector.
 * Returns lexeme position in TSVector's entry array or -1 if lexeme wasn't
 * found.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tsvector_bsearch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TSVector</name></type> <name>tsv</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>lexeme</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lexeme_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>arrin</name> <init>= <expr><call><name>ARRPTR</name><argument_list>(<argument><expr><name>tsv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>StopLow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>StopHigh</name> <init>= <expr><name><name>tsv</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>,
                <decl><type ref="prev"/><name>StopMiddle</name></decl>,
                <decl><type ref="prev"/><name>cmp</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>StopLow</name> <operator>&lt;</operator> <name>StopHigh</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>StopMiddle</name> <operator>=</operator> <operator>(</operator><name>StopLow</name> <operator>+</operator> <name>StopHigh</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>tsCompareString</name><argument_list>(<argument><expr><name>lexeme</name></expr></argument>, <argument><expr><name>lexeme_len</name></expr></argument>,
                              <argument><expr><call><name>STRPTR</name><argument_list>(<argument><expr><name>tsv</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>arrin</name><index>[<expr><name>StopMiddle</name></expr>]</index></name><operator>.</operator><name>pos</name></expr></argument>,
                              <argument><expr><name><name>arrin</name><index>[<expr><name>StopMiddle</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>,
                              <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>StopHigh</name> <operator>=</operator> <name>StopMiddle</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>StopLow</name> <operator>=</operator> <name>StopMiddle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>                    <comment type="block">/* found it */</comment>
            <return>return <expr><name>StopMiddle</name></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></while>

    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator functions
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_int</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>va</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>vb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>int</name> <operator>*</operator><operator>)</operator> <name>va</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>int</name> <operator>*</operator><operator>)</operator> <name>vb</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>a</name> <operator>&gt;</operator> <name>b</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_text_lexemes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>va</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>vb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Datum</name> <operator>*</operator><operator>)</operator> <name>va</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Datum</name> <operator>*</operator><operator>)</operator> <name>vb</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>alex</name> <init>= <expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>alex_len</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>blex</name> <init>= <expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>blex_len</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>tsCompareString</name><argument_list>(<argument><expr><name>alex</name></expr></argument>, <argument><expr><name>alex_len</name></expr></argument>, <argument><expr><name>blex</name></expr></argument>, <argument><expr><name>blex_len</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Internal routine to delete lexemes from TSVector by array of offsets.
 *
 * int *indices_to_delete -- array of lexeme offsets to delete (modified here!)
 * int indices_count -- size of that array
 *
 * Returns new TSVector without given lexemes along with their positions
 * and weights.
 */</comment>
<function><type><specifier>static</specifier> <name>TSVector</name></type>
<name>tsvector_delete_by_indices</name><parameter_list>(<parameter><decl><type><name>TSVector</name></type> <name>tsv</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>indices_to_delete</name></decl></parameter>,
                           <parameter><decl><type><name>int</name></type> <name>indices_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>tsout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>arrin</name> <init>= <expr><call><name>ARRPTR</name><argument_list>(<argument><expr><name>tsv</name></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>arrout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>STRPTR</name><argument_list>(<argument><expr><name>tsv</name></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>dataout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,                <comment type="block">/* index in arrin */</comment>
                <decl><type ref="prev"/><name>j</name></decl>,                <comment type="block">/* index in arrout */</comment>
                <decl><type ref="prev"/><name>k</name></decl>,                <comment type="block">/* index in indices_to_delete */</comment>
                <decl><type ref="prev"/><name>curoff</name></decl>;</decl_stmt>            <comment type="block">/* index in dataout area */</comment>

    <comment type="block">/*
     * Sort the filter array to simplify membership checks below.  Also, get
     * rid of any duplicate entries, so that we can assume that indices_count
     * is exactly equal to the number of lexemes that will be removed.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>indices_count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>kp</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>indices_to_delete</name></expr></argument>, <argument><expr><name>indices_count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compare_int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>kp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>indices_count</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>indices_to_delete</name><index>[<expr><name>k</name></expr>]</index></name> <operator>!=</operator> <name><name>indices_to_delete</name><index>[<expr><name>kp</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>indices_to_delete</name><index>[<expr><operator>++</operator><name>kp</name></expr>]</index></name> <operator>=</operator> <name><name>indices_to_delete</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>indices_count</name> <operator>=</operator> <operator>++</operator><name>kp</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Here we overestimate tsout size, since we don't know how much space is
     * used by the deleted lexeme(s).  We will set exact size below.
     */</comment>
    <expr_stmt><expr><name>tsout</name> <operator>=</operator> <operator>(</operator><name>TSVector</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>tsv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* This count must be correct because STRPTR(tsout) relies on it. */</comment>
    <expr_stmt><expr><name><name>tsout</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>tsv</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name>indices_count</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Copy tsv to tsout, skipping lexemes listed in indices_to_delete.
     */</comment>
    <expr_stmt><expr><name>arrout</name> <operator>=</operator> <call><name>ARRPTR</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dataout</name> <operator>=</operator> <call><name>STRPTR</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>curoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tsv</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * If current i is present in indices_to_delete, skip this lexeme.
         * Since indices_to_delete is already sorted, we only need to check
         * the current (k'th) entry.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&lt;</operator> <name>indices_count</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <name><name>indices_to_delete</name><index>[<expr><name>k</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Copy lexeme and its positions and weights */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dataout</name> <operator>+</operator> <name>curoff</name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name></expr></argument>, <argument><expr><name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arrout</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>haspos</name> <operator>=</operator> <name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>haspos</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arrout</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arrout</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>=</operator> <name>curoff</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>curoff</name> <operator>+=</operator> <name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>haspos</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>len</name> <init>= <expr><call><name>POSDATALEN</name><argument_list>(<argument><expr><name>tsv</name></expr></argument>, <argument><expr><name>arrin</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof>
            <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>curoff</name> <operator>=</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>curoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dataout</name> <operator>+</operator> <name>curoff</name></expr></argument>,
                   <argument><expr><call><name>STRPTR</name><argument_list>(<argument><expr><name>tsv</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>+</operator> <name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>curoff</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * k should now be exactly equal to indices_count. If it isn't then the
     * caller provided us with indices outside of [0, tsv-&gt;size) range and
     * estimation of tsout's size is wrong.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>k</name> <operator>==</operator> <name>indices_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>, <argument><expr><call><name>CALCDATASIZE</name><argument_list>(<argument><expr><name><name>tsout</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>curoff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>tsout</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Delete given lexeme from tsvector.
 * Implementation of user-level ts_delete(tsvector, text).
 */</comment>
<function><type><name>Datum</name></type>
<name>tsvector_delete_str</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>tsin</name> <init>= <expr><call><name>PG_GETARG_TSVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
                <decl><type ref="prev"/><name>tsout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>tlexeme</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>lexeme</name> <init>= <expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>tlexeme</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>lexeme_len</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>tlexeme</name></expr></argument>)</argument_list></call></expr></init></decl>,
                <decl><type ref="prev"/><name>skip_index</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>skip_index</name> <operator>=</operator> <call><name>tsvector_bsearch</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>, <argument><expr><name>lexeme</name></expr></argument>, <argument><expr><name>lexeme_len</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>tsout</name> <operator>=</operator> <call><name>tsvector_delete_by_indices</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>skip_index</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>tlexeme</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Delete given array of lexemes from tsvector.
 * Implementation of user-level ts_delete(tsvector, text[]).
 */</comment>
<function><type><name>Datum</name></type>
<name>tsvector_delete_arr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>tsin</name> <init>= <expr><call><name>PG_GETARG_TSVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
                <decl><type ref="prev"/><name>tsout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>lexemes</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>nlex</name></decl>,
                <decl><type ref="prev"/><name>skip_count</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>skip_indices</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>dlexemes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>lexemes</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
                      <argument><expr><operator>&amp;</operator><name>dlexemes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * In typical use case array of lexemes to delete is relatively small. So
     * here we optimize things for that scenario: iterate through lexarr
     * performing binary search of each lexeme from lexarr in tsvector.
     */</comment>
    <expr_stmt><expr><name>skip_indices</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nlex</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>skip_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nlex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>lex_len</name></decl>,
                    <decl><type ref="prev"/><name>lex_pos</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lexeme array may not contain nulls"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>lex</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name><name>dlexemes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lex_len</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name><name>dlexemes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lex_pos</name> <operator>=</operator> <call><name>tsvector_bsearch</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>, <argument><expr><name>lex_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>lex_pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>skip_indices</name><index>[<expr><name>skip_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>lex_pos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>tsout</name> <operator>=</operator> <call><name>tsvector_delete_by_indices</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>, <argument><expr><name>skip_indices</name></expr></argument>, <argument><expr><name>skip_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>skip_indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>lexemes</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Expand tsvector as table with following columns:
 *       lexeme: lexeme text
 *       positions: integer array of lexeme positions
 *       weights: char array of weights corresponding to positions
 */</comment>
<function><type><name>Datum</name></type>
<name>tsvector_unnest</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>tsin</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"lexeme"</literal></expr></argument>,
                           <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"positions"</literal></expr></argument>,
                           <argument><expr><name>INT2ARRAYOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"weights"</literal></expr></argument>,
                           <argument><expr><name>TEXTARRAYOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <call><name>PG_GETARG_TSVECTOR_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tsin</name> <operator>=</operator> <operator>(</operator><name>TSVector</name><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name> <operator>&lt;</operator> <name><name>tsin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>arrin</name> <init>= <expr><call><name>ARRPTR</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>STRPTR</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>,
                    <decl><type ref="prev"/><name>i</name> <init>= <expr><name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(
                                    <argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name>data</name> <operator>+</operator> <name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name></expr></argument>, <argument><expr><name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>)</argument_list></call></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>haspos</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>WordEntryPosVector</name> <modifier>*</modifier></type><name>posv</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>positions</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>weights</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type>        <name>weight</name></decl>;</decl_stmt>

            <comment type="block">/*
             * Internally tsvector stores position and weight in the same
             * uint16 (2 bits for weight, 14 for position). Here we extract
             * that in two separate arrays.
             */</comment>
            <expr_stmt><expr><name>posv</name> <operator>=</operator> <call><name>_POSVECPTR</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>, <argument><expr><name>arrin</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>positions</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>posv</name><operator>-&gt;</operator><name>npos</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>weights</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>posv</name><operator>-&gt;</operator><name>npos</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>posv</name><operator>-&gt;</operator><name>npos</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>positions</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><call><name>WEP_GETPOS</name><argument_list>(<argument><expr><name><name>posv</name><operator>-&gt;</operator><name>pos</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>weight</name> <operator>=</operator> <literal type="char">'D'</literal> <operator>-</operator> <call><name>WEP_GETWEIGHT</name><argument_list>(<argument><expr><name><name>posv</name><operator>-&gt;</operator><name>pos</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>weights</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(
                                             <argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name>weight</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>
                    )</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(
                                        <argument><expr><call><name>construct_array</name><argument_list>(<argument><expr><name>positions</name></expr></argument>, <argument><expr><name><name>posv</name><operator>-&gt;</operator><name>npos</name></name></expr></argument>, <argument><expr><name>INT2OID</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(
                                        <argument><expr><call><name>construct_array</name><argument_list>(<argument><expr><name>weights</name></expr></argument>, <argument><expr><name><name>posv</name><operator>-&gt;</operator><name>npos</name></name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert tsvector to array of lexemes.
 */</comment>
<function><type><name>Datum</name></type>
<name>tsvector_to_array</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>tsin</name> <init>= <expr><call><name>PG_GETARG_TSVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>arrin</name> <init>= <expr><call><name>ARRPTR</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>elements</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>elements</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tsin</name><operator>-&gt;</operator><name>size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tsin</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>elements</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(
                                      <argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><call><name>STRPTR</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name></expr></argument>, <argument><expr><name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>)</argument_list></call></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>elements</name></expr></argument>, <argument><expr><name><name>tsin</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build tsvector from array of lexemes.
 */</comment>
<function><type><name>Datum</name></type>
<name>array_to_tsvector</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>tsout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>dlexemes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>arrout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nitems</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>,
                <decl><type ref="prev"/><name>tslen</name></decl>,
                <decl><type ref="prev"/><name>datalen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dlexemes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reject nulls (maybe we should just ignore them, instead?) */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lexeme array may not contain nulls"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Sort and de-dup, because this is required for a valid tsvector. */</comment>
    <if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>dlexemes</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compare_text_lexemes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>compare_text_lexemes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dlexemes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dlexemes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>dlexemes</name><index>[<expr><operator>++</operator><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>dlexemes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>nitems</name> <operator>=</operator> <operator>++</operator><name>j</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Calculate space needed for surviving lexemes. */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>datalen</name> <operator>+=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name><name>dlexemes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name>tslen</name> <operator>=</operator> <call><name>CALCDATASIZE</name><argument_list>(<argument><expr><name>nitems</name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Allocate and fill tsvector. */</comment>
    <expr_stmt><expr><name>tsout</name> <operator>=</operator> <operator>(</operator><name>TSVector</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>tslen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>, <argument><expr><name>tslen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tsout</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>nitems</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>arrout</name> <operator>=</operator> <call><name>ARRPTR</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cur</name> <operator>=</operator> <call><name>STRPTR</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>lex</name> <init>= <expr><call><name>VARDATA</name><argument_list>(<argument><expr><name><name>dlexemes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>lex_len</name> <init>= <expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name><name>dlexemes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>, <argument><expr><name>lex_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arrout</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>haspos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arrout</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <name>lex_len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arrout</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>=</operator> <name>cur</name> <operator>-</operator> <call><name>STRPTR</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cur</name> <operator>+=</operator> <name>lex_len</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ts_filter(): keep only lexemes with given weights in tsvector.
 */</comment>
<function><type><name>Datum</name></type>
<name>tsvector_filter</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>tsin</name> <init>= <expr><call><name>PG_GETARG_TSVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
                <decl><type ref="prev"/><name>tsout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>weights</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>arrin</name> <init>= <expr><call><name>ARRPTR</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>arrout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>datain</name> <init>= <expr><call><name>STRPTR</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>dataout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>dweights</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nweights</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>cur_pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>mask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>weights</name></expr></argument>, <argument><expr><name>CHAROID</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'c'</literal></expr></argument>,
                      <argument><expr><operator>&amp;</operator><name>dweights</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nweights</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nweights</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name>char_weight</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"weight array may not contain nulls"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>char_weight</name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><name><name>dweights</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>char_weight</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'A'</literal></expr>:</case>
            <case>case <expr><literal type="char">'a'</literal></expr>:</case>
                <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>mask</name> <operator>|</operator> <literal type="number">8</literal></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'B'</literal></expr>:</case>
            <case>case <expr><literal type="char">'b'</literal></expr>:</case>
                <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>mask</name> <operator>|</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'C'</literal></expr>:</case>
            <case>case <expr><literal type="char">'c'</literal></expr>:</case>
                <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>mask</name> <operator>|</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'D'</literal></expr>:</case>
            <case>case <expr><literal type="char">'d'</literal></expr>:</case>
                <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>mask</name> <operator>|</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized weight: \"%c\""</literal></expr></argument>, <argument><expr><name>char_weight</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></for>

    <expr_stmt><expr><name>tsout</name> <operator>=</operator> <operator>(</operator><name>TSVector</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tsout</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>tsin</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>arrout</name> <operator>=</operator> <call><name>ARRPTR</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dataout</name> <operator>=</operator> <call><name>STRPTR</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tsin</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>WordEntryPosVector</name> <modifier>*</modifier></type><name>posvin</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>posvout</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>npos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>k</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>haspos</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>posvin</name> <operator>=</operator> <call><name>_POSVECPTR</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>, <argument><expr><name>arrin</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>posvout</name> <operator>=</operator> <operator>(</operator><name>WordEntryPosVector</name> <operator>*</operator><operator>)</operator>
            <operator>(</operator><name>dataout</name> <operator>+</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>cur_pos</name> <operator>+</operator> <name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>posvin</name><operator>-&gt;</operator><name>npos</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>mask</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>WEP_GETWEIGHT</name><argument_list>(<argument><expr><name><name>posvin</name><operator>-&gt;</operator><name>pos</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>posvout</name><operator>-&gt;</operator><name>pos</name><index>[<expr><name>npos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>posvin</name><operator>-&gt;</operator><name>pos</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* if no satisfactory positions found, skip lexeme */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>npos</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>arrout</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>haspos</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arrout</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arrout</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>=</operator> <name>cur_pos</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dataout</name> <operator>+</operator> <name>cur_pos</name></expr></argument>, <argument><expr><name>datain</name> <operator>+</operator> <name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name></expr></argument>, <argument><expr><name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>posvout</name><operator>-&gt;</operator><name>npos</name></name> <operator>=</operator> <name>npos</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cur_pos</name> <operator>+=</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name><name>arrin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cur_pos</name> <operator>+=</operator> <call><name>POSDATALEN</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>, <argument><expr><name>arrout</name> <operator>+</operator> <name>j</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
            <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>tsout</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dataout</name> <operator>!=</operator> <call><name>STRPTR</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><call><name>STRPTR</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dataout</name></expr></argument>, <argument><expr><name>cur_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>, <argument><expr><call><name>CALCDATASIZE</name><argument_list>(<argument><expr><name><name>tsout</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>cur_pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>tsin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>tsout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsvector_concat</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>in1</name> <init>= <expr><call><name>PG_GETARG_TSVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>in2</name> <init>= <expr><call><name>PG_GETARG_TSVECTOR</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>out</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>ptr1</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>ptr2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>maxpos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>,
                <decl><type ref="prev"/><name>i1</name></decl>,
                <decl><type ref="prev"/><name>i2</name></decl>,
                <decl><type ref="prev"/><name>dataoff</name></decl>,
                <decl><type ref="prev"/><name>output_bytes</name></decl>,
                <decl><type ref="prev"/><name>output_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>data1</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>data2</name></decl>;</decl_stmt>

    <comment type="block">/* Get max position in in1; we'll need this to offset in2's positions */</comment>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>ARRPTR</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>in1</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>i</name><operator>--</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>j</name> <operator>=</operator> <call><name>POSDATALEN</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>POSDATAPTR</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>j</name><operator>--</operator></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>WEP_GETPOS</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>maxpos</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>maxpos</name> <operator>=</operator> <call><name>WEP_GETPOS</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name>ptr1</name> <operator>=</operator> <call><name>ARRPTR</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptr2</name> <operator>=</operator> <call><name>ARRPTR</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>data1</name> <operator>=</operator> <call><name>STRPTR</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>data2</name> <operator>=</operator> <call><name>STRPTR</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i1</name> <operator>=</operator> <name><name>in1</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i2</name> <operator>=</operator> <name><name>in2</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Conservative estimate of space needed.  We might need all the data in
     * both inputs, and conceivably add a pad byte before position data for
     * each item where there was none before.
     */</comment>
    <expr_stmt><expr><name>output_bytes</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>i1</name> <operator>+</operator> <name>i2</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>out</name> <operator>=</operator> <operator>(</operator><name>TSVector</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>output_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>output_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We must make out-&gt;size valid so that STRPTR(out) is sensible.  We'll
     * collapse out any unused space at the end.
     */</comment>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>in1</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <name><name>in2</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>ARRPTR</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>STRPTR</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dataoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>i1</name> <operator>&amp;&amp;</operator> <name>i2</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>cmp</name> <init>= <expr><call><name>compareEntry</name><argument_list>(<argument><expr><name>data1</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>, <argument><expr><name>data2</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>                        <comment type="block">/* in1 first */</comment>
            <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>haspos</name></name> <operator>=</operator> <name><name>ptr1</name><operator>-&gt;</operator><name>haspos</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>ptr1</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name> <operator>+</operator> <name>dataoff</name></expr></argument>, <argument><expr><name>data1</name> <operator>+</operator> <name><name>ptr1</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name><name>ptr1</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>dataoff</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>dataoff</name> <operator>+=</operator> <name><name>ptr1</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>haspos</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>dataoff</name> <operator>=</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>dataoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name> <operator>+</operator> <name>dataoff</name></expr></argument>, <argument><expr><call><name>_POSVECPTR</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>POSDATALEN</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>dataoff</name> <operator>+=</operator> <call><name>POSDATALEN</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>ptr1</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>i1</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>                        <comment type="block">/* in2 first */</comment>
            <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>haspos</name></name> <operator>=</operator> <name><name>ptr2</name><operator>-&gt;</operator><name>haspos</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>ptr2</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name> <operator>+</operator> <name>dataoff</name></expr></argument>, <argument><expr><name>data2</name> <operator>+</operator> <name><name>ptr2</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name><name>ptr2</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>dataoff</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>dataoff</name> <operator>+=</operator> <name><name>ptr2</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>haspos</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>addlen</name> <init>= <expr><call><name>add_pos</name><argument_list>(<argument><expr><name>in2</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>maxpos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>addlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>haspos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>dataoff</name> <operator>=</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>dataoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>dataoff</name> <operator>+=</operator> <name>addlen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>ptr2</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>i2</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>haspos</name></name> <operator>=</operator> <name><name>ptr1</name><operator>-&gt;</operator><name>haspos</name></name> <operator>|</operator> <name><name>ptr2</name><operator>-&gt;</operator><name>haspos</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>ptr1</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name> <operator>+</operator> <name>dataoff</name></expr></argument>, <argument><expr><name>data1</name> <operator>+</operator> <name><name>ptr1</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name><name>ptr1</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>dataoff</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>dataoff</name> <operator>+=</operator> <name><name>ptr1</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>haspos</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>ptr1</name><operator>-&gt;</operator><name>haspos</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>dataoff</name> <operator>=</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>dataoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name> <operator>+</operator> <name>dataoff</name></expr></argument>, <argument><expr><call><name>_POSVECPTR</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>POSDATALEN</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>dataoff</name> <operator>+=</operator> <call><name>POSDATALEN</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>ptr2</name><operator>-&gt;</operator><name>haspos</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>dataoff</name> <operator>+=</operator> <call><name>add_pos</name><argument_list>(<argument><expr><name>in2</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>maxpos</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <else>else            <comment type="block">/* must have ptr2-&gt;haspos */</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type>            <name>addlen</name> <init>= <expr><call><name>add_pos</name><argument_list>(<argument><expr><name>in2</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>maxpos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>addlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>haspos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>dataoff</name> <operator>=</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>dataoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>dataoff</name> <operator>+=</operator> <name>addlen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>ptr1</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>ptr2</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>i1</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>i2</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <while>while <condition>(<expr><name>i1</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>haspos</name></name> <operator>=</operator> <name><name>ptr1</name><operator>-&gt;</operator><name>haspos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>ptr1</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name> <operator>+</operator> <name>dataoff</name></expr></argument>, <argument><expr><name>data1</name> <operator>+</operator> <name><name>ptr1</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name><name>ptr1</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>dataoff</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dataoff</name> <operator>+=</operator> <name><name>ptr1</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>haspos</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>dataoff</name> <operator>=</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>dataoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name> <operator>+</operator> <name>dataoff</name></expr></argument>, <argument><expr><call><name>_POSVECPTR</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>POSDATALEN</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>dataoff</name> <operator>+=</operator> <call><name>POSDATALEN</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>ptr1</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>i1</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <while>while <condition>(<expr><name>i2</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>haspos</name></name> <operator>=</operator> <name><name>ptr2</name><operator>-&gt;</operator><name>haspos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>ptr2</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name> <operator>+</operator> <name>dataoff</name></expr></argument>, <argument><expr><name>data2</name> <operator>+</operator> <name><name>ptr2</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name><name>ptr2</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>dataoff</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dataoff</name> <operator>+=</operator> <name><name>ptr2</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>haspos</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>addlen</name> <init>= <expr><call><name>add_pos</name><argument_list>(<argument><expr><name>in2</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>maxpos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>addlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>haspos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>dataoff</name> <operator>=</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>dataoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>dataoff</name> <operator>+=</operator> <name>addlen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>ptr2</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>i2</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Instead of checking each offset individually, we check for overflow of
     * pos fields once at the end.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>dataoff</name> <operator>&gt;</operator> <name>MAXSTRPOS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"string is too long for tsvector (%d bytes, max %d bytes)"</literal></expr></argument>, <argument><expr><name>dataoff</name></expr></argument>, <argument><expr><name>MAXSTRPOS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Adjust sizes (asserting that we didn't overrun the original estimates)
     * and collapse out any unused array entries.
     */</comment>
    <expr_stmt><expr><name>output_size</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <call><name>ARRPTR</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>output_size</name> <operator>&lt;=</operator> <name><name>out</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>output_size</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>data</name> <operator>!=</operator> <call><name>STRPTR</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><call><name>STRPTR</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>dataoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>output_bytes</name> <operator>=</operator> <call><name>CALCDATASIZE</name><argument_list>(<argument><expr><name><name>out</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>dataoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>output_bytes</name> <operator>&lt;=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>output_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compare two strings by tsvector rules.
 *
 * if isPrefix = true then it returns zero value iff b has prefix a
 */</comment>
<function><type><name>int32</name></type>
<name>tsCompareString</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lena</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lenb</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>cmp</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>lena</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>prefix</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>cmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>            <comment type="block">/* empty string is prefix of anything */</comment>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>cmp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>lenb</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>lenb</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>cmp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>lena</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>lena</name></expr></argument>, <argument><expr><name>lenb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>prefix</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>lena</name> <operator>&gt;</operator> <name>lenb</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>cmp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>        <comment type="block">/* a is longer, so not a prefix of b */</comment>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>lena</name> <operator>!=</operator> <name>lenb</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>cmp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>lena</name> <operator>&lt;</operator> <name>lenb</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>cmp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check weight info or/and fill 'data' with the required positions
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>checkclass_str</name><parameter_list>(<parameter><decl><type><name>CHKVAL</name> <modifier>*</modifier></type><name>chkval</name></decl></parameter>, <parameter><decl><type><name>WordEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>QueryOperand</name> <modifier>*</modifier></type><name>val</name></decl></parameter>,
               <parameter><decl><type><name>ExecPhraseData</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>haspos</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>val</name><operator>-&gt;</operator><name>weight</name></name> <operator>||</operator> <name>data</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>WordEntryPosVector</name> <modifier>*</modifier></type><name>posvec</name></decl>;</decl_stmt>

        <comment type="block">/*
         * We can't use the _POSVECPTR macro here because the pointer to the
         * tsvector's lexeme storage is already contained in chkval-&gt;values.
         */</comment>
        <expr_stmt><expr><name>posvec</name> <operator>=</operator> <operator>(</operator><name>WordEntryPosVector</name> <operator>*</operator><operator>)</operator>
            <operator>(</operator><name><name>chkval</name><operator>-&gt;</operator><name>values</name></name> <operator>+</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>pos</name></name> <operator>+</operator> <name><name>entry</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>weight</name></name> <operator>&amp;&amp;</operator> <name>data</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>posvec_iter</name> <init>= <expr><name><name>posvec</name><operator>-&gt;</operator><name>pos</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>dptr</name></decl>;</decl_stmt>

            <comment type="block">/*
             * Filter position information by weights
             */</comment>
            <expr_stmt><expr><name>dptr</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>posvec</name><operator>-&gt;</operator><name>npos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <comment type="block">/* Is there a position with a matching weight? */</comment>
            <while>while <condition>(<expr><name>posvec_iter</name> <operator>&lt;</operator> <name><name>posvec</name><operator>-&gt;</operator><name>pos</name></name> <operator>+</operator> <name><name>posvec</name><operator>-&gt;</operator><name>npos</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* If true, append this position to the data-&gt;pos */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>weight</name></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>WEP_GETWEIGHT</name><argument_list>(<argument><expr><operator>*</operator><name>posvec_iter</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>dptr</name> <operator>=</operator> <call><name>WEP_GETPOS</name><argument_list>(<argument><expr><operator>*</operator><name>posvec_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>dptr</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>posvec_iter</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>

            <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>npos</name></name> <operator>=</operator> <name>dptr</name> <operator>-</operator> <name><name>data</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>npos</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>weight</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>posvec_iter</name> <init>= <expr><name><name>posvec</name><operator>-&gt;</operator><name>pos</name></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Is there a position with a matching weight? */</comment>
            <while>while <condition>(<expr><name>posvec_iter</name> <operator>&lt;</operator> <name><name>posvec</name><operator>-&gt;</operator><name>pos</name></name> <operator>+</operator> <name><name>posvec</name><operator>-&gt;</operator><name>npos</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>weight</name></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>WEP_GETWEIGHT</name><argument_list>(<argument><expr><operator>*</operator><name>posvec_iter</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>        <comment type="block">/* no need to go further */</comment>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>posvec_iter</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if>
        <else>else                    <comment type="block">/* data != NULL */</comment>
        <block>{<block_content>
            <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>npos</name></name> <operator>=</operator> <name><name>posvec</name><operator>-&gt;</operator><name>npos</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name><name>posvec</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Removes duplicate pos entries. We can't use uniquePos() from
 * tsvector.c because array might be longer than MAXENTRYPOS
 *
 * Returns new length.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>uniqueLongPos</name><parameter_list>(<parameter><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>npos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>pos_iter</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>npos</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>npos</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>pos</name></expr></argument>, <argument><expr><name>npos</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compareWordEntryPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pos_iter</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>pos_iter</name> <operator>&lt;</operator> <name>pos</name> <operator>+</operator> <name>npos</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>WEP_GETPOS</name><argument_list>(<argument><expr><operator>*</operator><name>pos_iter</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>WEP_GETPOS</name><argument_list>(<argument><expr><operator>*</operator><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>WEP_GETPOS</name><argument_list>(<argument><expr><operator>*</operator><name>pos_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>pos_iter</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>result</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>pos</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is there value 'val' in array or not ?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>checkcondition_str</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>checkval</name></decl></parameter>, <parameter><decl><type><name>QueryOperand</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>ExecPhraseData</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CHKVAL</name>       <modifier>*</modifier></type><name>chkval</name> <init>= <expr><operator>(</operator><name>CHKVAL</name> <operator>*</operator><operator>)</operator> <name>checkval</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>StopLow</name> <init>= <expr><name><name>chkval</name><operator>-&gt;</operator><name>arrb</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>StopHigh</name> <init>= <expr><name><name>chkval</name><operator>-&gt;</operator><name>arre</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>StopMiddle</name> <init>= <expr><name>StopHigh</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>difference</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Loop invariant: StopLow &lt;= val &lt; StopHigh */</comment>
    <while>while <condition>(<expr><name>StopLow</name> <operator>&lt;</operator> <name>StopHigh</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>StopMiddle</name> <operator>=</operator> <name>StopLow</name> <operator>+</operator> <operator>(</operator><name>StopHigh</name> <operator>-</operator> <name>StopLow</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>difference</name> <operator>=</operator> <call><name>tsCompareString</name><argument_list>(<argument><expr><name><name>chkval</name><operator>-&gt;</operator><name>operand</name></name> <operator>+</operator> <name><name>val</name><operator>-&gt;</operator><name>distance</name></name></expr></argument>,
                                     <argument><expr><name><name>val</name><operator>-&gt;</operator><name>length</name></name></expr></argument>,
                                     <argument><expr><name><name>chkval</name><operator>-&gt;</operator><name>values</name></name> <operator>+</operator> <name><name>StopMiddle</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>,
                                     <argument><expr><name><name>StopMiddle</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
                                     <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>difference</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Check weight info &amp; fill 'data' with positions */</comment>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>checkclass_str</name><argument_list>(<argument><expr><name>chkval</name></expr></argument>, <argument><expr><name>StopMiddle</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>difference</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>StopLow</name> <operator>=</operator> <name>StopMiddle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>StopHigh</name> <operator>=</operator> <name>StopMiddle</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>res</name> <operator>||</operator> <name>data</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>val</name><operator>-&gt;</operator><name>prefix</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>allpos</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>npos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                    <decl><type ref="prev"/><name>totalpos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * there was a failed exact search, so we should scan further to find
         * a prefix match. We also need to do so if caller needs position info
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>StopLow</name> <operator>&gt;=</operator> <name>StopHigh</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>StopMiddle</name> <operator>=</operator> <name>StopHigh</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <while>while <condition>(<expr><operator>(</operator><operator>!</operator><name>res</name> <operator>||</operator> <name>data</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>StopMiddle</name> <operator>&lt;</operator> <name><name>chkval</name><operator>-&gt;</operator><name>arre</name></name> <operator>&amp;&amp;</operator>
               <call><name>tsCompareString</name><argument_list>(<argument><expr><name><name>chkval</name><operator>-&gt;</operator><name>operand</name></name> <operator>+</operator> <name><name>val</name><operator>-&gt;</operator><name>distance</name></name></expr></argument>,
                               <argument><expr><name><name>val</name><operator>-&gt;</operator><name>length</name></name></expr></argument>,
                               <argument><expr><name><name>chkval</name><operator>-&gt;</operator><name>values</name></name> <operator>+</operator> <name><name>StopMiddle</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>,
                               <argument><expr><name><name>StopMiddle</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
                               <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * We need to join position information
                 */</comment>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>checkclass_str</name><argument_list>(<argument><expr><name>chkval</name></expr></argument>, <argument><expr><name>StopMiddle</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition>
                <block>{<block_content>
                    <while>while <condition>(<expr><name>npos</name> <operator>+</operator> <name><name>data</name><operator>-&gt;</operator><name>npos</name></name> <operator>&gt;=</operator> <name>totalpos</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>totalpos</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>totalpos</name> <operator>=</operator> <literal type="number">256</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>allpos</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>totalpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><name>totalpos</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>allpos</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>allpos</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>totalpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></while>

                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>allpos</name> <operator>+</operator> <name>npos</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>data</name><operator>-&gt;</operator><name>npos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>npos</name> <operator>+=</operator> <name><name>data</name><operator>-&gt;</operator><name>npos</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>checkclass_str</name><argument_list>(<argument><expr><name>chkval</name></expr></argument>, <argument><expr><name>StopMiddle</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>StopMiddle</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><name>res</name> <operator>&amp;&amp;</operator> <name>data</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Sort and make unique array of found positions */</comment>
            <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>allpos</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>npos</name></name> <operator>=</operator> <call><name>uniqueLongPos</name><argument_list>(<argument><expr><name>allpos</name></expr></argument>, <argument><expr><name>npos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute output position list for a tsquery operator in phrase mode.
 *
 * Merge the position lists in Ldata and Rdata as specified by "emit",
 * returning the result list into *data.  The input position lists must be
 * sorted and unique, and the output will be as well.
 *
 * data: pointer to initially-all-zeroes output struct, or NULL
 * Ldata, Rdata: input position lists
 * emit: bitmask of TSPO_XXX flags
 * Loffset: offset to be added to Ldata positions before comparing/outputting
 * Roffset: offset to be added to Rdata positions before comparing/outputting
 * max_npos: maximum possible required size of output position array
 *
 * Loffset and Roffset should not be negative, else we risk trying to output
 * negative positions, which won't fit into WordEntryPos.
 *
 * Returns true if any positions were emitted to *data; or if data is NULL,
 * returns true if any positions would have been emitted.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TSPO_L_ONLY</name></cpp:macro>        <cpp:value>0x01</cpp:value></cpp:define>    <comment type="block">/* emit positions appearing only in L */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TSPO_R_ONLY</name></cpp:macro>        <cpp:value>0x02</cpp:value></cpp:define>    <comment type="block">/* emit positions appearing only in R */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TSPO_BOTH</name></cpp:macro>        <cpp:value>0x04</cpp:value></cpp:define>    <comment type="block">/* emit positions appearing in both L&amp;R */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TS_phrase_output</name><parameter_list>(<parameter><decl><type><name>ExecPhraseData</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
                 <parameter><decl><type><name>ExecPhraseData</name> <modifier>*</modifier></type><name>Ldata</name></decl></parameter>,
                 <parameter><decl><type><name>ExecPhraseData</name> <modifier>*</modifier></type><name>Rdata</name></decl></parameter>,
                 <parameter><decl><type><name>int</name></type> <name>emit</name></decl></parameter>,
                 <parameter><decl><type><name>int</name></type> <name>Loffset</name></decl></parameter>,
                 <parameter><decl><type><name>int</name></type> <name>Roffset</name></decl></parameter>,
                 <parameter><decl><type><name>int</name></type> <name>max_npos</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>Lindex</name></decl>,
                <decl><type ref="prev"/><name>Rindex</name></decl>;</decl_stmt>

    <comment type="block">/* Loop until both inputs are exhausted */</comment>
    <expr_stmt><expr><name>Lindex</name> <operator>=</operator> <name>Rindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>Lindex</name> <operator>&lt;</operator> <name><name>Ldata</name><operator>-&gt;</operator><name>npos</name></name> <operator>||</operator> <name>Rindex</name> <operator>&lt;</operator> <name><name>Rdata</name><operator>-&gt;</operator><name>npos</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>Lpos</name></decl>,
                    <decl><type ref="prev"/><name>Rpos</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>output_pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Fetch current values to compare.  WEP_GETPOS() is needed because
         * ExecPhraseData-&gt;data can point to a tsvector's WordEntryPosVector.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>Lindex</name> <operator>&lt;</operator> <name><name>Ldata</name><operator>-&gt;</operator><name>npos</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>Lpos</name> <operator>=</operator> <call><name>WEP_GETPOS</name><argument_list>(<argument><expr><name><name>Ldata</name><operator>-&gt;</operator><name>pos</name><index>[<expr><name>Lindex</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>Loffset</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* L array exhausted, so we're done if R_ONLY isn't set */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>emit</name> <operator>&amp;</operator> <name>TSPO_R_ONLY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Lpos</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>Rindex</name> <operator>&lt;</operator> <name><name>Rdata</name><operator>-&gt;</operator><name>npos</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>Rpos</name> <operator>=</operator> <call><name>WEP_GETPOS</name><argument_list>(<argument><expr><name><name>Rdata</name><operator>-&gt;</operator><name>pos</name><index>[<expr><name>Rindex</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>Roffset</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* R array exhausted, so we're done if L_ONLY isn't set */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>emit</name> <operator>&amp;</operator> <name>TSPO_L_ONLY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Rpos</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Merge-join the two input lists */</comment>
        <if_stmt><if>if <condition>(<expr><name>Lpos</name> <operator>&lt;</operator> <name>Rpos</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Lpos is not matched in Rdata, should we output it? */</comment>
            <if_stmt><if>if <condition>(<expr><name>emit</name> <operator>&amp;</operator> <name>TSPO_L_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>output_pos</name> <operator>=</operator> <name>Lpos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Lindex</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>Lpos</name> <operator>==</operator> <name>Rpos</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Lpos and Rpos match ... should we output it? */</comment>
            <if_stmt><if>if <condition>(<expr><name>emit</name> <operator>&amp;</operator> <name>TSPO_BOTH</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>output_pos</name> <operator>=</operator> <name>Rpos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Lindex</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>Rindex</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else                    <comment type="block">/* Lpos &gt; Rpos */</comment>
        <block>{<block_content>
            <comment type="block">/* Rpos is not matched in Ldata, should we output it? */</comment>
            <if_stmt><if>if <condition>(<expr><name>emit</name> <operator>&amp;</operator> <name>TSPO_R_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>output_pos</name> <operator>=</operator> <name>Rpos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Rindex</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>output_pos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Store position, first allocating output array if needed */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>pos</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <operator>(</operator><name>WordEntryPos</name> <operator>*</operator><operator>)</operator>
                        <call><name>palloc</name><argument_list>(<argument><expr><name>max_npos</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>pos</name><index>[<expr><name><name>data</name><operator>-&gt;</operator><name>npos</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>output_pos</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * Exact positions not needed, so return true as soon as we
                 * know there is at least one.
                 */</comment>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>data</name> <operator>&amp;&amp;</operator> <name><name>data</name><operator>-&gt;</operator><name>npos</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Let's assert we didn't overrun the array */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>npos</name></name> <operator>&lt;=</operator> <name>max_npos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Execute tsquery at or below an OP_PHRASE operator.
 *
 * This handles tsquery execution at recursion levels where we need to care
 * about match locations.
 *
 * In addition to the same arguments used for TS_execute, the caller may pass
 * a preinitialized-to-zeroes ExecPhraseData struct, to be filled with lexeme
 * match position info on success.  data == NULL if no position data need be
 * returned.  (In practice, outside callers pass NULL, and only the internal
 * recursion cases pass a data pointer.)
 * Note: the function assumes data != NULL for operators other than OP_PHRASE.
 * This is OK because an outside call always starts from an OP_PHRASE node.
 *
 * The detailed semantics of the match data, given that the function returned
 * "true" (successful match, or possible match), are:
 *
 * npos &gt; 0, negate = false:
 *     query is matched at specified position(s) (and only those positions)
 * npos &gt; 0, negate = true:
 *     query is matched at all positions *except* specified position(s)
 * npos = 0, negate = false:
 *     query is possibly matched, matching position(s) are unknown
 *     (this should only be returned when TS_EXEC_PHRASE_NO_POS flag is set)
 * npos = 0, negate = true:
 *     query is matched at all positions
 *
 * Successful matches also return a "width" value which is the match width in
 * lexemes, less one.  Hence, "width" is zero for simple one-lexeme matches,
 * and is the sum of the phrase operator distances for phrase matches.  Note
 * that when width &gt; 0, the listed positions represent the ends of matches not
 * the starts.  (This unintuitive rule is needed to avoid possibly generating
 * negative positions, which wouldn't fit into the WordEntryPos arrays.)
 *
 * When the function returns "false" (no match), it must return npos = 0,
 * negate = false (which is the state initialized by the caller); but the
 * "width" output in such cases is undefined.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TS_phrase_execute</name><parameter_list>(<parameter><decl><type><name>QueryItem</name> <modifier>*</modifier></type><name>curitem</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>,
                  <parameter><decl><type><name>TSExecuteCallback</name></type> <name>chkcond</name></decl></parameter>,
                  <parameter><decl><type><name>ExecPhraseData</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ExecPhraseData</name></type> <name>Ldata</name></decl>,
                <decl><type ref="prev"/><name>Rdata</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>lmatch</name></decl>,
                <decl><type ref="prev"/><name>rmatch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>Loffset</name></decl>,
                <decl><type ref="prev"/><name>Roffset</name></decl>,
                <decl><type ref="prev"/><name>maxwidth</name></decl>;</decl_stmt>

    <comment type="block">/* since this function recurses, it could be driven to stack overflow */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>curitem</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_VAL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>chkcond</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>(</operator><name>QueryOperand</name> <operator>*</operator><operator>)</operator> <name>curitem</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <switch>switch <condition>(<expr><name><name>curitem</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>OP_NOT</name></expr>:</case>

            <comment type="block">/*
             * Because a "true" result with no specific positions is taken as
             * uncertain, we need no special care here for !TS_EXEC_CALC_NOT.
             * If it's a false positive, the right things happen anyway.
             *
             * Also, we need not touch data-&gt;width, since a NOT operation does
             * not change the match width.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>TS_phrase_execute</name><argument_list>(<argument><expr><name>curitem</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>chkcond</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>npos</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* we have some positions, invert negate flag */</comment>
                    <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>negate</name></name> <operator>=</operator> <operator>!</operator><name><name>data</name><operator>-&gt;</operator><name>negate</name></name></expr>;</expr_stmt>
                    <return>return <expr><name>true</name></expr>;</return>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>negate</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* change "match everywhere" to "match nowhere" */</comment>
                    <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>negate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <return>return <expr><name>false</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* match positions are, and remain, uncertain */</comment>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* change "match nowhere" to "match everywhere" */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>npos</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>data</name><operator>-&gt;</operator><name>negate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>negate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></else></if_stmt>

        <case>case <expr><name>OP_PHRASE</name></expr>:</case>
        <case>case <expr><name>OP_AND</name></expr>:</case>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Ldata</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Ldata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Rdata</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Rdata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TS_phrase_execute</name><argument_list>(<argument><expr><name>curitem</name> <operator>+</operator> <name><name>curitem</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>left</name></name></expr></argument>,
                                   <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>chkcond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ldata</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TS_phrase_execute</name><argument_list>(<argument><expr><name>curitem</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                                   <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>chkcond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Rdata</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/*
             * If either operand has no position information, then we can't
             * return position data, only a "possible match" result. "Possible
             * match" answers are only wanted when TS_EXEC_PHRASE_NO_POS flag
             * is set, otherwise return false.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>Ldata</name><operator>.</operator><name>npos</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>Ldata</name><operator>.</operator><name>negate</name></name><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name><name>Rdata</name><operator>.</operator><name>npos</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>Rdata</name><operator>.</operator><name>negate</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>TS_EXEC_PHRASE_NO_POS</name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>curitem</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name> <operator>==</operator> <name>OP_PHRASE</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Compute Loffset and Roffset suitable for phrase match, and
                 * compute overall width of whole phrase match.
                 */</comment>
                <expr_stmt><expr><name>Loffset</name> <operator>=</operator> <name><name>curitem</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>distance</name></name> <operator>+</operator> <name><name>Rdata</name><operator>.</operator><name>width</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>Roffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name><name>curitem</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>distance</name></name> <operator>+</operator>
                        <name><name>Ldata</name><operator>.</operator><name>width</name></name> <operator>+</operator> <name><name>Rdata</name><operator>.</operator><name>width</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * For OP_AND, set output width and alignment like OP_OR (see
                 * comment below)
                 */</comment>
                <expr_stmt><expr><name>maxwidth</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>Ldata</name><operator>.</operator><name>width</name></name></expr></argument>, <argument><expr><name><name>Rdata</name><operator>.</operator><name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>Loffset</name> <operator>=</operator> <name>maxwidth</name> <operator>-</operator> <name><name>Ldata</name><operator>.</operator><name>width</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>Roffset</name> <operator>=</operator> <name>maxwidth</name> <operator>-</operator> <name><name>Rdata</name><operator>.</operator><name>width</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name>maxwidth</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>Ldata</name><operator>.</operator><name>negate</name></name> <operator>&amp;&amp;</operator> <name><name>Rdata</name><operator>.</operator><name>negate</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* !L &amp; !R: treat as !(L | R) */</comment>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>TS_phrase_output</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ldata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Rdata</name></expr></argument>,
                                        <argument><expr><name>TSPO_BOTH</name> <operator>|</operator> <name>TSPO_L_ONLY</name> <operator>|</operator> <name>TSPO_R_ONLY</name></expr></argument>,
                                        <argument><expr><name>Loffset</name></expr></argument>, <argument><expr><name>Roffset</name></expr></argument>,
                                        <argument><expr><name><name>Ldata</name><operator>.</operator><name>npos</name></name> <operator>+</operator> <name><name>Rdata</name><operator>.</operator><name>npos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>negate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>Ldata</name><operator>.</operator><name>negate</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* !L &amp; R */</comment>
                <return>return <expr><call><name>TS_phrase_output</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ldata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Rdata</name></expr></argument>,
                                        <argument><expr><name>TSPO_R_ONLY</name></expr></argument>,
                                        <argument><expr><name>Loffset</name></expr></argument>, <argument><expr><name>Roffset</name></expr></argument>,
                                        <argument><expr><name><name>Rdata</name><operator>.</operator><name>npos</name></name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>Rdata</name><operator>.</operator><name>negate</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* L &amp; !R */</comment>
                <return>return <expr><call><name>TS_phrase_output</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ldata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Rdata</name></expr></argument>,
                                        <argument><expr><name>TSPO_L_ONLY</name></expr></argument>,
                                        <argument><expr><name>Loffset</name></expr></argument>, <argument><expr><name>Roffset</name></expr></argument>,
                                        <argument><expr><name><name>Ldata</name><operator>.</operator><name>npos</name></name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* straight AND */</comment>
                <return>return <expr><call><name>TS_phrase_output</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ldata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Rdata</name></expr></argument>,
                                        <argument><expr><name>TSPO_BOTH</name></expr></argument>,
                                        <argument><expr><name>Loffset</name></expr></argument>, <argument><expr><name>Roffset</name></expr></argument>,
                                        <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name><name>Ldata</name><operator>.</operator><name>npos</name></name></expr></argument>, <argument><expr><name><name>Rdata</name><operator>.</operator><name>npos</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></else></if_stmt>

        <case>case <expr><name>OP_OR</name></expr>:</case>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Ldata</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Ldata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Rdata</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Rdata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>lmatch</name> <operator>=</operator> <call><name>TS_phrase_execute</name><argument_list>(<argument><expr><name>curitem</name> <operator>+</operator> <name><name>curitem</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>left</name></name></expr></argument>,
                                       <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>chkcond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ldata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rmatch</name> <operator>=</operator> <call><name>TS_phrase_execute</name><argument_list>(<argument><expr><name>curitem</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                                       <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>chkcond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Rdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lmatch</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>rmatch</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/*
             * If a valid operand has no position information, then we can't
             * return position data, only a "possible match" result. "Possible
             * match" answers are only wanted when TS_EXEC_PHRASE_NO_POS flag
             * is set, otherwise return false.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>lmatch</name> <operator>&amp;&amp;</operator> <name><name>Ldata</name><operator>.</operator><name>npos</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>Ldata</name><operator>.</operator><name>negate</name></name><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>rmatch</name> <operator>&amp;&amp;</operator> <name><name>Rdata</name><operator>.</operator><name>npos</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>Rdata</name><operator>.</operator><name>negate</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>TS_EXEC_PHRASE_NO_POS</name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Cope with undefined output width from failed submatch.  (This
             * takes less code than trying to ensure that all failure returns
             * set data-&gt;width to zero.)
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lmatch</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>Ldata</name><operator>.</operator><name>width</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>rmatch</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>Rdata</name><operator>.</operator><name>width</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * For OP_AND and OP_OR, report the width of the wider of the two
             * inputs, and align the narrower input's positions to the right
             * end of that width.  This rule deals at least somewhat
             * reasonably with cases like "x &lt;-&gt; (y | z &lt;-&gt; q)".
             */</comment>
            <expr_stmt><expr><name>maxwidth</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>Ldata</name><operator>.</operator><name>width</name></name></expr></argument>, <argument><expr><name><name>Rdata</name><operator>.</operator><name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>Loffset</name> <operator>=</operator> <name>maxwidth</name> <operator>-</operator> <name><name>Ldata</name><operator>.</operator><name>width</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>Roffset</name> <operator>=</operator> <name>maxwidth</name> <operator>-</operator> <name><name>Rdata</name><operator>.</operator><name>width</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name>maxwidth</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>Ldata</name><operator>.</operator><name>negate</name></name> <operator>&amp;&amp;</operator> <name><name>Rdata</name><operator>.</operator><name>negate</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* !L | !R: treat as !(L &amp; R) */</comment>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>TS_phrase_output</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ldata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Rdata</name></expr></argument>,
                                        <argument><expr><name>TSPO_BOTH</name></expr></argument>,
                                        <argument><expr><name>Loffset</name></expr></argument>, <argument><expr><name>Roffset</name></expr></argument>,
                                        <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name><name>Ldata</name><operator>.</operator><name>npos</name></name></expr></argument>, <argument><expr><name><name>Rdata</name><operator>.</operator><name>npos</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>negate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>Ldata</name><operator>.</operator><name>negate</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* !L | R: treat as !(L &amp; !R) */</comment>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>TS_phrase_output</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ldata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Rdata</name></expr></argument>,
                                        <argument><expr><name>TSPO_L_ONLY</name></expr></argument>,
                                        <argument><expr><name>Loffset</name></expr></argument>, <argument><expr><name>Roffset</name></expr></argument>,
                                        <argument><expr><name><name>Ldata</name><operator>.</operator><name>npos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>negate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>Rdata</name><operator>.</operator><name>negate</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* L | !R: treat as !(!L &amp; R) */</comment>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>TS_phrase_output</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ldata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Rdata</name></expr></argument>,
                                        <argument><expr><name>TSPO_R_ONLY</name></expr></argument>,
                                        <argument><expr><name>Loffset</name></expr></argument>, <argument><expr><name>Roffset</name></expr></argument>,
                                        <argument><expr><name><name>Rdata</name><operator>.</operator><name>npos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>negate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* straight OR */</comment>
                <return>return <expr><call><name>TS_phrase_output</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Ldata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Rdata</name></expr></argument>,
                                        <argument><expr><name>TSPO_BOTH</name> <operator>|</operator> <name>TSPO_L_ONLY</name> <operator>|</operator> <name>TSPO_R_ONLY</name></expr></argument>,
                                        <argument><expr><name>Loffset</name></expr></argument>, <argument><expr><name>Roffset</name></expr></argument>,
                                        <argument><expr><name><name>Ldata</name><operator>.</operator><name>npos</name></name> <operator>+</operator> <name><name>Rdata</name><operator>.</operator><name>npos</name></name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></else></if_stmt>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized operator: %d"</literal></expr></argument>, <argument><expr><name><name>curitem</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <comment type="block">/* not reachable, but keep compiler quiet */</comment>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Evaluate tsquery boolean expression.
 *
 * curitem: current tsquery item (initially, the first one)
 * arg: opaque value to pass through to callback function
 * flags: bitmask of flag bits shown in ts_utils.h
 * chkcond: callback function to check whether a primitive value is present
 *
 * The logic here deals only with operators above any phrase operator, for
 * which we do not need to worry about lexeme positions.  As soon as we hit an
 * OP_PHRASE operator, we pass it off to TS_phrase_execute which does worry.
 */</comment>
<function><type><name>bool</name></type>
<name>TS_execute</name><parameter_list>(<parameter><decl><type><name>QueryItem</name> <modifier>*</modifier></type><name>curitem</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>,
           <parameter><decl><type><name>TSExecuteCallback</name></type> <name>chkcond</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* since this function recurses, it could be driven to stack overflow */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>curitem</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_VAL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>chkcond</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>(</operator><name>QueryOperand</name> <operator>*</operator><operator>)</operator> <name>curitem</name></expr></argument>,
                       <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* we don't need position info */</comment> )</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <switch>switch <condition>(<expr><name><name>curitem</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>OP_NOT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>TS_EXEC_CALC_NOT</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><operator>!</operator><call><name>TS_execute</name><argument_list>(<argument><expr><name>curitem</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>chkcond</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>

        <case>case <expr><name>OP_AND</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>TS_execute</name><argument_list>(<argument><expr><name>curitem</name> <operator>+</operator> <name><name>curitem</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>chkcond</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>TS_execute</name><argument_list>(<argument><expr><name>curitem</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>chkcond</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>

        <case>case <expr><name>OP_OR</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>TS_execute</name><argument_list>(<argument><expr><name>curitem</name> <operator>+</operator> <name><name>curitem</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>chkcond</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><call><name>TS_execute</name><argument_list>(<argument><expr><name>curitem</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>chkcond</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

        <case>case <expr><name>OP_PHRASE</name></expr>:</case>
            <return>return <expr><call><name>TS_phrase_execute</name><argument_list>(<argument><expr><name>curitem</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>chkcond</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized operator: %d"</literal></expr></argument>, <argument><expr><name><name>curitem</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <comment type="block">/* not reachable, but keep compiler quiet */</comment>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Detect whether a tsquery boolean expression requires any positive matches
 * to values shown in the tsquery.
 *
 * This is needed to know whether a GIN index search requires full index scan.
 * For example, 'x &amp; !y' requires a match of x, so it's sufficient to scan
 * entries for x; but 'x | !y' could match rows containing neither x nor y.
 */</comment>
<function><type><name>bool</name></type>
<name>tsquery_requires_match</name><parameter_list>(<parameter><decl><type><name>QueryItem</name> <modifier>*</modifier></type><name>curitem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* since this function recurses, it could be driven to stack overflow */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>curitem</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_VAL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <switch>switch <condition>(<expr><name><name>curitem</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>OP_NOT</name></expr>:</case>

            <comment type="block">/*
             * Assume there are no required matches underneath a NOT.  For
             * some cases with nested NOTs, we could prove there's a required
             * match, but it seems unlikely to be worth the trouble.
             */</comment>
            <return>return <expr><name>false</name></expr>;</return>

        <case>case <expr><name>OP_PHRASE</name></expr>:</case>

            <comment type="block">/*
             * Treat OP_PHRASE as OP_AND here
             */</comment>
        <case>case <expr><name>OP_AND</name></expr>:</case>
            <comment type="block">/* If either side requires a match, we're good */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>tsquery_requires_match</name><argument_list>(<argument><expr><name>curitem</name> <operator>+</operator> <name><name>curitem</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><call><name>tsquery_requires_match</name><argument_list>(<argument><expr><name>curitem</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

        <case>case <expr><name>OP_OR</name></expr>:</case>
            <comment type="block">/* Both sides must require a match */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>tsquery_requires_match</name><argument_list>(<argument><expr><name>curitem</name> <operator>+</operator> <name><name>curitem</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>tsquery_requires_match</name><argument_list>(<argument><expr><name>curitem</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized operator: %d"</literal></expr></argument>, <argument><expr><name><name>curitem</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <comment type="block">/* not reachable, but keep compiler quiet */</comment>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * boolean operations
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_match_qv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>ts_match_vq</name></expr></argument>,
                                        <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>ts_match_vq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>val</name> <init>= <expr><call><name>PG_GETARG_TSVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TSQuery</name></type>        <name>query</name> <init>= <expr><call><name>PG_GETARG_TSQUERY</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CHKVAL</name></type>        <name>chkval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* empty query matches nothing */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>chkval</name><operator>.</operator><name>arrb</name></name> <operator>=</operator> <call><name>ARRPTR</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>chkval</name><operator>.</operator><name>arre</name></name> <operator>=</operator> <name><name>chkval</name><operator>.</operator><name>arrb</name></name> <operator>+</operator> <name><name>val</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>chkval</name><operator>.</operator><name>values</name></name> <operator>=</operator> <call><name>STRPTR</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>chkval</name><operator>.</operator><name>operand</name></name> <operator>=</operator> <call><name>GETOPERAND</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>TS_execute</name><argument_list>(<argument><expr><call><name>GETQUERY</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>chkval</name></expr></argument>,
                        <argument><expr><name>TS_EXEC_CALC_NOT</name></expr></argument>,
                        <argument><expr><name>checkcondition_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>ts_match_tt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>vector</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TSQuery</name></type>        <name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>vector</name> <operator>=</operator> <call><name>DatumGetTSVector</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>to_tsvector</name></expr></argument>,
                                                  <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>DatumGetTSQuery</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>plainto_tsquery</name></expr></argument>,
                                                <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>ts_match_vq</name></expr></argument>,
                                           <argument><expr><call><name>TSVectorGetDatum</name><argument_list>(<argument><expr><name>vector</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>TSQueryGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>vector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>ts_match_tq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>vector</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TSQuery</name></type>        <name>query</name> <init>= <expr><call><name>PG_GETARG_TSQUERY</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>vector</name> <operator>=</operator> <call><name>DatumGetTSVector</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>to_tsvector</name></expr></argument>,
                                                  <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>ts_match_vq</name></expr></argument>,
                                           <argument><expr><call><name>TSVectorGetDatum</name><argument_list>(<argument><expr><name>vector</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>TSQueryGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>vector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ts_stat statistic function support
 */</comment>


<comment type="block">/*
 * Returns the number of positions in value 'wptr' within tsvector 'txt',
 * that have a weight equal to one of the weights in 'weight' bitmask.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_weight</name><parameter_list>(<parameter><decl><type><name>TSVector</name></type> <name>txt</name></decl></parameter>, <parameter><decl><type><name>WordEntry</name> <modifier>*</modifier></type><name>wptr</name></decl></parameter>, <parameter><decl><type><name>int8</name></type> <name>weight</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name> <init>= <expr><call><name>POSDATALEN</name><argument_list>(<argument><expr><name>txt</name></expr></argument>, <argument><expr><name>wptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>POSDATAPTR</name><argument_list>(<argument><expr><name>txt</name></expr></argument>, <argument><expr><name>wptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>len</name><operator>--</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>weight</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>WEP_GETWEIGHT</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>num</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>compareStatWord</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro>                            \
    <cpp:value>tsCompareString((a)-&gt;lexeme, (a)-&gt;lenlexeme,        \
                    STRPTR(t) + (e)-&gt;pos, (e)-&gt;len,        \
                    false)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>insertStatEntry</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>persistentContext</name></decl></parameter>, <parameter><decl><type><name>TSVectorStat</name> <modifier>*</modifier></type><name>stat</name></decl></parameter>, <parameter><decl><type><name>TSVector</name></type> <name>txt</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>off</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>we</name> <init>= <expr><call><name>ARRPTR</name><argument_list>(<argument><expr><name>txt</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>off</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StatEntry</name>  <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>stat</name><operator>-&gt;</operator><name>root</name></name></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>pnode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>n</name></decl>,
                <decl><type ref="prev"/><name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>depth</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>stat</name><operator>-&gt;</operator><name>weight</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>we</name><operator>-&gt;</operator><name>haspos</name></name><operator>)</operator></expr> ?</condition><then> <expr><call><name>POSDATALEN</name><argument_list>(<argument><expr><name>txt</name></expr></argument>, <argument><expr><name>we</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>we</name><operator>-&gt;</operator><name>haspos</name></name><operator>)</operator></expr> ?</condition><then> <expr><call><name>check_weight</name><argument_list>(<argument><expr><name>txt</name></expr></argument>, <argument><expr><name>we</name></expr></argument>, <argument><expr><name><name>stat</name><operator>-&gt;</operator><name>weight</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* nothing to insert */</comment>

    <while>while <condition>(<expr><name>node</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>compareStatWord</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>we</name></expr></argument>, <argument><expr><name>txt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>pnode</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>node</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr> </then><else>: <expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;</operator> <name><name>stat</name><operator>-&gt;</operator><name>maxdepth</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>maxdepth</name></name> <operator>=</operator> <name>depth</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>persistentContext</name></expr></argument>, <argument><expr><name>STATENTRYHDRSZ</name> <operator>+</operator> <name><name>we</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ndoc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nentry</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>lenlexeme</name></name> <operator>=</operator> <name><name>we</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>lexeme</name></name></expr></argument>, <argument><expr><call><name>STRPTR</name><argument_list>(<argument><expr><name>txt</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>we</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>lenlexeme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>pnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>root</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></else></if_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ndoc</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nentry</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>chooseNextStatEntry</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>persistentContext</name></decl></parameter>, <parameter><decl><type><name>TSVectorStat</name> <modifier>*</modifier></type><name>stat</name></decl></parameter>, <parameter><decl><type><name>TSVector</name></type> <name>txt</name></decl></parameter>,
                    <parameter><decl><type><name>uint32</name></type> <name>low</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>high</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>middle</name> <init>= <expr><operator>(</operator><name>low</name> <operator>+</operator> <name>high</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>(</operator><name>low</name> <operator>+</operator> <name>middle</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>low</name> <operator>!=</operator> <name>middle</name> <operator>&amp;&amp;</operator> <name>pos</name> <operator>&gt;=</operator> <name>offset</name> <operator>&amp;&amp;</operator> <name>pos</name> <operator>-</operator> <name>offset</name> <operator>&lt;</operator> <name><name>txt</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>insertStatEntry</name><argument_list>(<argument><expr><name>persistentContext</name></expr></argument>, <argument><expr><name>stat</name></expr></argument>, <argument><expr><name>txt</name></expr></argument>, <argument><expr><name>pos</name> <operator>-</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>(</operator><name>high</name> <operator>+</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>middle</name> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <name>high</name> <operator>&amp;&amp;</operator> <name>pos</name> <operator>&gt;=</operator> <name>offset</name> <operator>&amp;&amp;</operator> <name>pos</name> <operator>-</operator> <name>offset</name> <operator>&lt;</operator> <name><name>txt</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>insertStatEntry</name><argument_list>(<argument><expr><name>persistentContext</name></expr></argument>, <argument><expr><name>stat</name></expr></argument>, <argument><expr><name>txt</name></expr></argument>, <argument><expr><name>pos</name> <operator>-</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>low</name> <operator>!=</operator> <name>middle</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>chooseNextStatEntry</name><argument_list>(<argument><expr><name>persistentContext</name></expr></argument>, <argument><expr><name>stat</name></expr></argument>, <argument><expr><name>txt</name></expr></argument>, <argument><expr><name>low</name></expr></argument>, <argument><expr><name>middle</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>high</name> <operator>!=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>chooseNextStatEntry</name><argument_list>(<argument><expr><name>persistentContext</name></expr></argument>, <argument><expr><name>stat</name></expr></argument>, <argument><expr><name>txt</name></expr></argument>, <argument><expr><name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>high</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This is written like a custom aggregate function, because the
 * original plan was to do just that. Unfortunately, an aggregate function
 * can't return a set, so that plan was abandoned. If that limitation is
 * lifted in the future, ts_stat could be a real aggregate function so that
 * you could use it like this:
 *
 *     SELECT ts_stat(vector_column) FROM vector_table;
 *
 *    where vector_column is a tsvector-type column in vector_table.
 */</comment>

<function><type><specifier>static</specifier> <name>TSVectorStat</name> <modifier>*</modifier></type>
<name>ts_accum</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>persistentContext</name></decl></parameter>, <parameter><decl><type><name>TSVectorStat</name> <modifier>*</modifier></type><name>stat</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TSVector</name></type>    <name>txt</name> <init>= <expr><call><name>DatumGetTSVector</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>i</name></decl>,
                <decl><type ref="prev"/><name>nbit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>stat</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>                            <comment type="block">/* Init in first */</comment>
        <expr_stmt><expr><name>stat</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>persistentContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TSVectorStat</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>maxdepth</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* simple check of correctness */</comment>
    <if_stmt><if>if <condition>(<expr><name>txt</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>txt</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>txt</name> <operator>&amp;&amp;</operator> <name>txt</name> <operator>!=</operator> <operator>(</operator><name>TSVector</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>txt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>stat</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>txt</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nbit</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name>nbit</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>nbit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>nbit</name> <operator>-</operator> <name><name>txt</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>insertStatEntry</name><argument_list>(<argument><expr><name>persistentContext</name></expr></argument>, <argument><expr><name>stat</name></expr></argument>, <argument><expr><name>txt</name></expr></argument>, <argument><expr><operator>(</operator><name>nbit</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>chooseNextStatEntry</name><argument_list>(<argument><expr><name>persistentContext</name></expr></argument>, <argument><expr><name>stat</name></expr></argument>, <argument><expr><name>txt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nbit</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>stat</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ts_setup_firstcall</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl></parameter>,
                   <parameter><decl><type><name>TSVectorStat</name> <modifier>*</modifier></type><name>stat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StatEntry</name>  <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>stat</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StatEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>stat</name><operator>-&gt;</operator><name>maxdepth</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>stackpos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>stat</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>
    <comment type="block">/* find leftmost value */</comment>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>stat</name><operator>-&gt;</operator><name>stackpos</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>stat</name><operator>-&gt;</operator><name>stackpos</name></name></expr>]</index></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>stackpos</name></name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <break>break;</break></block_content></block></else></if_stmt>
        </block_content>}</block></for></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>stackpos</name></name> <operator>&lt;=</operator> <name><name>stat</name><operator>-&gt;</operator><name>maxdepth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"word"</literal></expr></argument>,
                       <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"ndoc"</literal></expr></argument>,
                       <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"nentry"</literal></expr></argument>,
                       <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>attinmeta</name></name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>StatEntry</name> <modifier>*</modifier></type>
<name>walkStatEntryTree</name><parameter_list>(<parameter><decl><type><name>TSVectorStat</name> <modifier>*</modifier></type><name>stat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StatEntry</name>  <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>stat</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>stat</name><operator>-&gt;</operator><name>stackpos</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ndoc</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* return entry itself: we already was at left sublink */</comment>
        <return>return <expr><name>node</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>right</name></name> <operator>!=</operator> <name><name>stat</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>stat</name><operator>-&gt;</operator><name>stackpos</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* go on right sublink */</comment>
        <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>stackpos</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt>

        <comment type="block">/* find most-left value */</comment>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>stat</name><operator>-&gt;</operator><name>stackpos</name></name></expr>]</index></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>stackpos</name></name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <break>break;</break></block_content></block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>stackpos</name></name> <operator>&lt;=</operator> <name><name>stat</name><operator>-&gt;</operator><name>maxdepth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* we already return all left subtree, itself and  right subtree */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>stat</name><operator>-&gt;</operator><name>stackpos</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>stackpos</name></name><operator>--</operator></expr>;</expr_stmt>
        <return>return <expr><call><name>walkStatEntryTree</name><argument_list>(<argument><expr><name>stat</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ts_process_call</name><parameter_list>(<parameter><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TSVectorStat</name> <modifier>*</modifier></type><name>st</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StatEntry</name>  <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>st</name> <operator>=</operator> <operator>(</operator><name>TSVectorStat</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>walkStatEntryTree</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>entry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>ndoc</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>nentry</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>lenlexeme</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>lexeme</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>lenlexeme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>lenlexeme</name></name></expr>]</index> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>ndoc</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>ndoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>ndoc</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>nentry</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>nentry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>nentry</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>BuildTupleFromCStrings</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>attinmeta</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* mark entry as already visited */</comment>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ndoc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TSVectorStat</name> <modifier>*</modifier></type>
<name>ts_stat_sql</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>persistentContext</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>txt</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>ws</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>txt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TSVectorStat</name> <modifier>*</modifier></type><name>stat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Portal</name></type>        <name>portal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SPIPlanPtr</name></type>    <name>plan</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>plan</name> <operator>=</operator> <call><name>SPI_prepare</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <comment type="block">/* internal error */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_prepare(\"%s\") failed"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_open</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <comment type="block">/* internal error */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_cursor_open(\"%s\") failed"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>SPI_cursor_fetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>SPI_tuptable</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
        <operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><call><name>SPI_gettypeid</name><argument_list>(<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>TSVECTOROID</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ts_stat query must return one tsvector column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>stat</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>persistentContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TSVectorStat</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>maxdepth</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>ws</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>ws</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>buf</name> <operator>-</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>ws</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>ws</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>pg_mblen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <switch>switch <condition>(<expr><operator>*</operator><name>buf</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><literal type="char">'A'</literal></expr>:</case>
                    <case>case <expr><literal type="char">'a'</literal></expr>:</case>
                        <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>weight</name></name> <operator>|=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'B'</literal></expr>:</case>
                    <case>case <expr><literal type="char">'b'</literal></expr>:</case>
                        <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>weight</name></name> <operator>|=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'C'</literal></expr>:</case>
                    <case>case <expr><literal type="char">'c'</literal></expr>:</case>
                        <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>weight</name></name> <operator>|=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'D'</literal></expr>:</case>
                    <case>case <expr><literal type="char">'d'</literal></expr>:</case>
                        <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>weight</name></name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <default>default:</default>
                        <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>weight</name></name> <operator>|=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></switch>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>buf</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><name>SPI_processed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint64</name></type>        <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SPI_processed</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Datum</name></type>        <name>data</name> <init>= <expr><call><name>SPI_getbinval</name><argument_list>(<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>stat</name> <operator>=</operator> <call><name>ts_accum</name><argument_list>(<argument><expr><name>persistentContext</name></expr></argument>, <argument><expr><name>stat</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SPI_cursor_fetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SPI_cursor_close</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SPI_freeplan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>stat</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>ts_stat1</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TSVectorStat</name> <modifier>*</modifier></type><name>stat</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>txt</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>stat</name> <operator>=</operator> <call><name>ts_stat_sql</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>, <argument><expr><name>txt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>txt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ts_setup_firstcall</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>result</name> <operator>=</operator> <call><name>ts_process_call</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>ts_stat2</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TSVectorStat</name> <modifier>*</modifier></type><name>stat</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>txt</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>ws</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>stat</name> <operator>=</operator> <call><name>ts_stat_sql</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>, <argument><expr><name>txt</name></expr></argument>, <argument><expr><name>ws</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>txt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ts_setup_firstcall</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>result</name> <operator>=</operator> <call><name>ts_process_call</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Triggers for automatic update of a tsvector column from text column(s)
 *
 * Trigger arguments are either
 *        name of tsvector col, name of tsconfig to use, name(s) of text col(s)
 *        name of tsvector col, name of regconfig col, name(s) of text col(s)
 * ie, tsconfig can either be specified by name, or indirectly as the
 * contents of a regconfig field in the row.  If the name is used, it must
 * be explicitly schema-qualified.
 */</comment>
<function><type><name>Datum</name></type>
<name>tsvector_update_trigger_byid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>tsvector_update_trigger</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsvector_update_trigger_bycolumn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>tsvector_update_trigger</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>tsvector_update_trigger</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>config_column</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trigger</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>rettuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>tsvector_attr_num</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParsedText</name></type>    <name>prs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>txt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>cfgId</name></decl>;</decl_stmt>

    <comment type="block">/* Check call context */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CALLED_AS_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* internal error */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tsvector_update_trigger: not fired by trigger manager"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>trigdata</name> <operator>=</operator> <operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FIRED_FOR_ROW</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tsvector_update_trigger: must be fired for row"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FIRED_BEFORE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tsvector_update_trigger: must be fired BEFORE event"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BY_INSERT</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>rettuple</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>rettuple</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_newtuple</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tsvector_update_trigger: must be fired for INSERT or UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>trigger</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgnargs</name></name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tsvector_update_trigger: arguments must be tsvector_field, ts_config, text_field1, ...)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Find the target tsvector column */</comment>
    <expr_stmt><expr><name>tsvector_attr_num</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>tsvector_attr_num</name> <operator>==</operator> <name>SPI_ERROR_NOATTRIBUTE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tsvector column \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* This will effectively reject system columns, so no separate test: */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><call><name>SPI_gettypeid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>tsvector_attr_num</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>TSVECTOROID</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" is not of tsvector type"</literal></expr></argument>,
                        <argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Find the configuration to use */</comment>
    <if_stmt><if>if <condition>(<expr><name>config_column</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>config_attr_num</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>config_attr_num</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>config_attr_num</name> <operator>==</operator> <name>SPI_ERROR_NOATTRIBUTE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"configuration column \"%s\" does not exist"</literal></expr></argument>,
                            <argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><call><name>SPI_gettypeid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>config_attr_num</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>REGCONFIGOID</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" is not of regconfig type"</literal></expr></argument>,
                            <argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name>rettuple</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>config_attr_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"configuration column \"%s\" must not be null"</literal></expr></argument>,
                            <argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>cfgId</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* require a schema so that results are not search path dependent */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"text search configuration name \"%s\" must be schema-qualified"</literal></expr></argument>,
                            <argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>cfgId</name> <operator>=</operator> <call><name>get_ts_config_oid</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* initialize parse state */</comment>
    <expr_stmt><expr><name><name>prs</name><operator>.</operator><name>lenwords</name></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>prs</name><operator>.</operator><name>curwords</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>prs</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>prs</name><operator>.</operator><name>words</name></name> <operator>=</operator> <operator>(</operator><name>ParsedWord</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParsedWord</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>prs</name><operator>.</operator><name>lenwords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* find all words in indexable column(s) */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigger</name><operator>-&gt;</operator><name>tgnargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>numattr</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>numattr</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>numattr</name> <operator>==</operator> <name>SPI_ERROR_NOATTRIBUTE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>,
                            <argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><call><name>SPI_gettypeid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>numattr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" is not of a character type"</literal></expr></argument>,
                            <argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name>rettuple</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>numattr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>txt</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>parsetext</name><argument_list>(<argument><expr><name>cfgId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prs</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>txt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>txt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>txt</name> <operator>!=</operator> <operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>txt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* make tsvector value */</comment>
    <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>TSVectorGetDatum</name><argument_list>(<argument><expr><call><name>make_tsvector</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* and insert it into tuple */</comment>
    <expr_stmt><expr><name>rettuple</name> <operator>=</operator> <call><name>heap_modify_tuple_by_cols</name><argument_list>(<argument><expr><name>rettuple</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>,
                                         <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tsvector_attr_num</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>datum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>rettuple</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
