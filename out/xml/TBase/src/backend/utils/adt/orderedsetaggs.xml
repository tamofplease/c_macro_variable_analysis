<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/adt/orderedsetaggs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * orderedsetaggs.c
 *        Ordered-set aggregate functions.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/utils/adt/orderedsetaggs.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplesort.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Generic support for ordered-set aggregates
 *
 * The state for an ordered-set aggregate is divided into a per-group struct
 * (which is the internal-type transition state datum returned to nodeAgg.c)
 * and a per-query struct, which contains data and sub-objects that we can
 * create just once per query because they will not change across groups.
 * The per-query struct and subsidiary data live in the executor's per-query
 * memory context, and go away implicitly at ExecutorEnd().
 */</comment>

<typedef>typedef <type><struct>struct <name>OSAPerQueryState</name>
<block>{
    <comment type="block">/* Aggref for this aggregate: */</comment>
    <decl_stmt><decl><type><name>Aggref</name>       <modifier>*</modifier></type><name>aggref</name></decl>;</decl_stmt>
    <comment type="block">/* Memory context containing this struct and other per-query data: */</comment>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>qcontext</name></decl>;</decl_stmt>

    <comment type="block">/* These fields are used only when accumulating tuples: */</comment>

    <comment type="block">/* Tuple descriptor for tuples inserted into sortstate: */</comment>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
    <comment type="block">/* Tuple slot we can use for inserting/extracting tuples: */</comment>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupslot</name></decl>;</decl_stmt>
    <comment type="block">/* Per-sort-column sorting information */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>numSortCols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>eqOperators</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>sortCollations</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>sortNullsFirsts</name></decl>;</decl_stmt>
    <comment type="block">/* Equality operator call info, created only if needed: */</comment>
    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>equalfns</name></decl>;</decl_stmt>

    <comment type="block">/* These fields are used only when accumulating datums: */</comment>

    <comment type="block">/* Info about datatype of datums being sorted: */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>sortColType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>        <name>typLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>typByVal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>typAlign</name></decl>;</decl_stmt>
    <comment type="block">/* Info about sort ordering: */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>sortOperator</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>eqOperator</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>sortCollation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>sortNullsFirst</name></decl>;</decl_stmt>
    <comment type="block">/* Equality operator call info, created only if needed: */</comment>
    <decl_stmt><decl><type><name>FmgrInfo</name></type>    <name>equalfn</name></decl>;</decl_stmt>
}</block></struct></type> <name>OSAPerQueryState</name>;</typedef>

<typedef>typedef <type><struct>struct <name>OSAPerGroupState</name>
<block>{
    <comment type="block">/* Link to the per-query state for this aggregate: */</comment>
    <decl_stmt><decl><type><name>OSAPerQueryState</name> <modifier>*</modifier></type><name>qstate</name></decl>;</decl_stmt>
    <comment type="block">/* Memory context containing per-group data: */</comment>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>gcontext</name></decl>;</decl_stmt>
    <comment type="block">/* Sort object we're accumulating data in: */</comment>
    <decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>sortstate</name></decl>;</decl_stmt>
    <comment type="block">/* Number of normal rows inserted into sortstate: */</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>number_of_rows</name></decl>;</decl_stmt>
}</block></struct></type> <name>OSAPerGroupState</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ordered_set_shutdown</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Set up working state for an ordered-set aggregate
 */</comment>
<function><type><specifier>static</specifier> <name>OSAPerGroupState</name> <modifier>*</modifier></type>
<name>ordered_set_startup</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_tuples</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>OSAPerGroupState</name> <modifier>*</modifier></type><name>osastate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OSAPerQueryState</name> <modifier>*</modifier></type><name>qstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>gcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Check we're called as aggregate (and not a window function), and get
     * the Agg node's group-lifespan context (which might change from group to
     * group, so we shouldn't cache it in the per-query state).
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gcontext</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AGG_CONTEXT_AGGREGATE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ordered-set aggregate called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We keep a link to the per-query state in fn_extra; if it's not there,
     * create it, and do the per-query setup we need.
     */</comment>
    <expr_stmt><expr><name>qstate</name> <operator>=</operator> <operator>(</operator><name>OSAPerQueryState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>qstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Aggref</name>       <modifier>*</modifier></type><name>aggref</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>qcontext</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sortlist</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>numSortCols</name></decl>;</decl_stmt>

        <comment type="block">/* Get the Aggref so we can examine aggregate's arguments */</comment>
        <expr_stmt><expr><name>aggref</name> <operator>=</operator> <call><name>AggGetAggref</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>aggref</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ordered-set aggregate called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGGKIND_IS_ORDERED_SET</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggkind</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ordered-set aggregate support function called for non-ordered-set aggregate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Prepare per-query structures in the fn_mcxt, which we assume is the
         * executor's per-query context; in any case it's the right place to
         * keep anything found via fn_extra.
         */</comment>
        <expr_stmt><expr><name>qcontext</name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>qcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>qstate</name> <operator>=</operator> <operator>(</operator><name>OSAPerQueryState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OSAPerQueryState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>aggref</name></name> <operator>=</operator> <name>aggref</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>qcontext</name></name> <operator>=</operator> <name>qcontext</name></expr>;</expr_stmt>

        <comment type="block">/* Extract the sort information */</comment>
        <expr_stmt><expr><name>sortlist</name> <operator>=</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>numSortCols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>sortlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>use_tuples</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type>        <name>ishypothetical</name> <init>= <expr><operator>(</operator><name><name>aggref</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>==</operator> <name>AGGKIND_HYPOTHETICAL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>ishypothetical</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>numSortCols</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* make space for flag column */</comment>
            <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>numSortCols</name></name> <operator>=</operator> <name>numSortCols</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortColIdx</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numSortCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortOperators</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numSortCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>eqOperators</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numSortCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortCollations</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numSortCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortNullsFirsts</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numSortCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>sortlist</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sortcl</name></expr></argument>,
                                                           <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="block">/* the parser should have made sure of this */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortColIdx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>eqOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>eqop</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortCollations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortNullsFirsts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block>

            <if_stmt><if>if <condition>(<expr><name>ishypothetical</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Add an integer flag column as the last sort column */</comment>
                <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortColIdx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>Int4LessOperator</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>eqOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>Int4EqualOperator</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortCollations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortNullsFirsts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>numSortCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Get a tupledesc corresponding to the aggregated inputs
             * (including sort expressions) of the agg.
             */</comment>
            <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <call><name>ExecTypeFromTL</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* If we need a flag column, hack the tupledesc to include that */</comment>
            <if_stmt><if>if <condition>(<expr><name>ishypothetical</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>newdesc</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>natts</name> <init>= <expr><name><name>qstate</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>newdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>natts</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>TupleDescCopyEntry</name><argument_list>(<argument><expr><name>newdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>qstate</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>newdesc</name></expr></argument>,
                                   <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <operator>++</operator><name>natts</name></expr></argument>,
                                   <argument><expr><literal type="string">"flag"</literal></expr></argument>,
                                   <argument><expr><name>INT4OID</name></expr></argument>,
                                   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name><name>qstate</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <name>newdesc</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Create slot we'll use to store/retrieve rows */</comment>
            <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>tupslot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>qstate</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Sort single datums */</comment>
            <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>numSortCols</name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>==</operator> <name>AGGKIND_HYPOTHETICAL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ordered-set aggregate support function does not support multiple aggregated columns"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>sortcl</name> <operator>=</operator> <operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>sortlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sortcl</name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* the parser should have made sure of this */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Save sort ordering info */</comment>
            <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortColType</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortOperator</name></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>eqOperator</name></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>eqop</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortCollation</name></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortNullsFirst</name></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>;</expr_stmt>

            <comment type="block">/* Save datatype info */</comment>
            <expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortColType</name></name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name><name>qstate</name><operator>-&gt;</operator><name>typLen</name></name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name><name>qstate</name><operator>-&gt;</operator><name>typByVal</name></name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name><name>qstate</name><operator>-&gt;</operator><name>typAlign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>qstate</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Now build the stuff we need in group-lifespan context */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>gcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>osastate</name> <operator>=</operator> <operator>(</operator><name>OSAPerGroupState</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OSAPerGroupState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name></name> <operator>=</operator> <name>qstate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>osastate</name><operator>-&gt;</operator><name>gcontext</name></name> <operator>=</operator> <name>gcontext</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize tuplesort object.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>use_tuples</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name> <operator>=</operator> <call><name>tuplesort_begin_heap</name><argument_list>(<argument><expr><name><name>qstate</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>,
                                                   <argument><expr><name><name>qstate</name><operator>-&gt;</operator><name>numSortCols</name></name></expr></argument>,
                                                   <argument><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
                                                   <argument><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>,
                                                   <argument><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortCollations</name></name></expr></argument>,
                                                   <argument><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortNullsFirsts</name></name></expr></argument>,
                                                   <argument><expr><name>work_mem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name> <operator>=</operator> <call><name>tuplesort_begin_datum</name><argument_list>(<argument><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortColType</name></name></expr></argument>,
                                                    <argument><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortOperator</name></name></expr></argument>,
                                                    <argument><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortCollation</name></name></expr></argument>,
                                                    <argument><expr><name><name>qstate</name><operator>-&gt;</operator><name>sortNullsFirst</name></name></expr></argument>,
                                                    <argument><expr><name>work_mem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>osastate</name><operator>-&gt;</operator><name>number_of_rows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Now register a shutdown callback to clean things up at end of group */</comment>
    <expr_stmt><expr><call><name>AggRegisterCallback</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>,
                        <argument><expr><name>ordered_set_shutdown</name></expr></argument>,
                        <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>osastate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>osastate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Clean up when evaluation of an ordered-set aggregate is complete.
 *
 * We don't need to bother freeing objects in the per-group memory context,
 * since that will get reset anyway by nodeAgg.c; nor should we free anything
 * in the per-query context, which will get cleared (if this was the last
 * group) by ExecutorEnd.  But we must take care to release any potential
 * non-memory resources.
 *
 * This callback is arguably unnecessary, since we don't support use of
 * ordered-set aggs in AGG_HASHED mode and there is currently no non-error
 * code path in non-hashed modes wherein nodeAgg.c won't call the finalfn
 * after calling the transfn one or more times.  So in principle we could rely
 * on the finalfn to delete the tuplestore etc.  However, it's possible that
 * such a code path might exist in future, and in any case it'd be
 * notationally tedious and sometimes require extra data copying to ensure
 * we always delete the tuplestore in the finalfn.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ordered_set_shutdown</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>OSAPerGroupState</name> <modifier>*</modifier></type><name>osastate</name> <init>= <expr><operator>(</operator><name>OSAPerGroupState</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Tuplesort object might have temp files. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <comment type="block">/* The tupleslot probably can't be holding a pin, but let's be safe. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>tupslot</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>tupslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Generic transition function for ordered-set aggregates
 * with a single input column in which we want to suppress nulls
 */</comment>
<function><type><name>Datum</name></type>
<name>ordered_set_transition</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>OSAPerGroupState</name> <modifier>*</modifier></type><name>osastate</name></decl>;</decl_stmt>

    <comment type="block">/* If first call, create the transition state workspace */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>osastate</name> <operator>=</operator> <call><name>ordered_set_startup</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>osastate</name> <operator>=</operator> <operator>(</operator><name>OSAPerGroupState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Load the datum into the tuplesort object, but only if it's not null */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>tuplesort_putdatum</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>osastate</name><operator>-&gt;</operator><name>number_of_rows</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>osastate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Generic transition function for ordered-set aggregates
 * with (potentially) multiple aggregated input columns
 */</comment>
<function><type><name>Datum</name></type>
<name>ordered_set_transition_multi</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>OSAPerGroupState</name> <modifier>*</modifier></type><name>osastate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* If first call, create the transition state workspace */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>osastate</name> <operator>=</operator> <call><name>ordered_set_startup</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>osastate</name> <operator>=</operator> <operator>(</operator><name>OSAPerGroupState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Form a tuple from all the other inputs besides the transition value */</comment>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>tupslot</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>aggref</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>==</operator> <name>AGGKIND_HYPOTHETICAL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Add a zero flag value to mark this row as a normal input row */</comment>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Load the row into the tuplesort object */</comment>
    <expr_stmt><expr><call><name>tuplesort_puttupleslot</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>osastate</name><operator>-&gt;</operator><name>number_of_rows</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>osastate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * percentile_disc(float8) within group(anyelement) - discrete percentile
 */</comment>
<function><type><name>Datum</name></type>
<name>percentile_disc_final</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>OSAPerGroupState</name> <modifier>*</modifier></type><name>osastate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>percentile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>rownum</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGG_CONTEXT_AGGREGATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get and check the percentile argument */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>percentile</name> <operator>=</operator> <call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>percentile</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>percentile</name></expr></argument> &gt;</argument_list></name> <literal type="number">1</literal> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>percentile</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"percentile value %g is not between 0 and 1"</literal></expr></argument>,
                        <argument><expr><name>percentile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If there were no regular rows, the result is NULL */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>osastate</name> <operator>=</operator> <operator>(</operator><name>OSAPerGroupState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* number_of_rows could be zero if we only saw NULL input values */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>osastate</name><operator>-&gt;</operator><name>number_of_rows</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Finish the sort */</comment>
    <expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*----------
     * We need the smallest K such that (K/N) &gt;= percentile.
     * N&gt;0, therefore K &gt;= N*percentile, therefore K = ceil(N*percentile).
     * So we skip K-1 rows (if K&gt;0) and return the next row fetched.
     *----------
     */</comment>
    <expr_stmt><expr><name>rownum</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>percentile</name> <operator>*</operator> <name><name>osastate</name><operator>-&gt;</operator><name>number_of_rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rownum</name> <operator>&lt;=</operator> <name><name>osastate</name><operator>-&gt;</operator><name>number_of_rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>rownum</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_skiptuples</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>rownum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing row in percentile_disc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_getdatum</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing row in percentile_disc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Note: we *cannot* clean up the tuplesort object here, because the value
     * to be returned is allocated inside its sortcontext.  We could use
     * datumCopy to copy it out of there, but it doesn't seem worth the
     * trouble, since the cleanup callback will clear the tuplesort later.
     */</comment>

    <comment type="block">/* We shouldn't have stored any nulls, but do the right thing anyway */</comment>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * For percentile_cont, we need a way to interpolate between consecutive
 * values. Use a helper function for that, so that we can share the rest
 * of the code between types.
 */</comment>
<typedef>typedef <function_decl><type><name>Datum</name></type> (<modifier>*</modifier><name>LerpFunc</name>) <parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>hi</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>pct</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>float8_lerp</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>hi</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>pct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>loval</name> <init>= <expr><call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>hival</name> <init>= <expr><call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>loval</name> <operator>+</operator> <operator>(</operator><name>pct</name> <operator>*</operator> <operator>(</operator><name>hival</name> <operator>-</operator> <name>loval</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>interval_lerp</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>hi</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>pct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>diff_result</name> <init>= <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_mi</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>mul_result</name> <init>= <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_mul</name></expr></argument>,
                                                 <argument><expr><name>diff_result</name></expr></argument>,
                                                 <argument><expr><call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name>pct</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_pl</name></expr></argument>, <argument><expr><name>mul_result</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Continuous percentile
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>percentile_cont_final_common</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
                             <parameter><decl><type><name>Oid</name></type> <name>expect_type</name></decl></parameter>,
                             <parameter><decl><type><name>LerpFunc</name></type> <name>lerpfunc</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>OSAPerGroupState</name> <modifier>*</modifier></type><name>osastate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>percentile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>first_row</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>second_row</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>first_val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>second_val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>proportion</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGG_CONTEXT_AGGREGATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get and check the percentile argument */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>percentile</name> <operator>=</operator> <call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>percentile</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>percentile</name></expr></argument> &gt;</argument_list></name> <literal type="number">1</literal> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>percentile</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"percentile value %g is not between 0 and 1"</literal></expr></argument>,
                        <argument><expr><name>percentile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If there were no regular rows, the result is NULL */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>osastate</name> <operator>=</operator> <operator>(</operator><name>OSAPerGroupState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* number_of_rows could be zero if we only saw NULL input values */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>osastate</name><operator>-&gt;</operator><name>number_of_rows</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expect_type</name> <operator>==</operator> <name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>sortColType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Finish the sort */</comment>
    <expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>first_row</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><name>percentile</name> <operator>*</operator> <operator>(</operator><name><name>osastate</name><operator>-&gt;</operator><name>number_of_rows</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>second_row</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>percentile</name> <operator>*</operator> <operator>(</operator><name><name>osastate</name><operator>-&gt;</operator><name>number_of_rows</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>first_row</name> <operator>&lt;</operator> <name><name>osastate</name><operator>-&gt;</operator><name>number_of_rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_skiptuples</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>first_row</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing row in percentile_cont"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_getdatum</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>first_val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing row in percentile_cont"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>first_row</name> <operator>==</operator> <name>second_row</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>val</name> <operator>=</operator> <name>first_val</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_getdatum</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>second_val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing row in percentile_cont"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>proportion</name> <operator>=</operator> <operator>(</operator><name>percentile</name> <operator>*</operator> <operator>(</operator><name><name>osastate</name><operator>-&gt;</operator><name>number_of_rows</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>-</operator> <name>first_row</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>lerpfunc</name><argument_list>(<argument><expr><name>first_val</name></expr></argument>, <argument><expr><name>second_val</name></expr></argument>, <argument><expr><name>proportion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Note: we *cannot* clean up the tuplesort object here, because the value
     * to be returned may be allocated inside its sortcontext.  We could use
     * datumCopy to copy it out of there, but it doesn't seem worth the
     * trouble, since the cleanup callback will clear the tuplesort later.
     */</comment>

    <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * percentile_cont(float8) within group (float8)    - continuous percentile
 */</comment>
<function><type><name>Datum</name></type>
<name>percentile_cont_float8_final</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>percentile_cont_final_common</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>FLOAT8OID</name></expr></argument>, <argument><expr><name>float8_lerp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * percentile_cont(float8) within group (interval)    - continuous percentile
 */</comment>
<function><type><name>Datum</name></type>
<name>percentile_cont_interval_final</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>percentile_cont_final_common</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>INTERVALOID</name></expr></argument>, <argument><expr><name>interval_lerp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Support code for handling arrays of percentiles
 *
 * Note: in each pct_info entry, second_row should be equal to or
 * exactly one more than first_row.
 */</comment>
<struct>struct <name>pct_info</name>
<block>{
    <decl_stmt><decl><type><name>int64</name></type>        <name>first_row</name></decl>;</decl_stmt>        <comment type="block">/* first row to sample */</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>second_row</name></decl>;</decl_stmt>        <comment type="block">/* possible second row to sample */</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>proportion</name></decl>;</decl_stmt>        <comment type="block">/* interpolation fraction */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>idx</name></decl>;</decl_stmt>            <comment type="block">/* index of this item in original array */</comment>
}</block>;</struct>

<comment type="block">/*
 * Sort comparator to sort pct_infos by first_row then second_row
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pct_info_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pa</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pct_info</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>pct_info</name> <operator>*</operator><operator>)</operator> <name>pa</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pct_info</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>pct_info</name> <operator>*</operator><operator>)</operator> <name>pb</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>first_row</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>first_row</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>first_row</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>first_row</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>second_row</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>second_row</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>second_row</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>second_row</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Construct array showing which rows to sample for percentiles.
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>pct_info</name></name> <modifier>*</modifier></type>
<name>setup_pct_info</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_percentiles</name></decl></parameter>,
               <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>percentiles_datum</name></decl></parameter>,
               <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>percentiles_null</name></decl></parameter>,
               <parameter><decl><type><name>int64</name></type> <name>rowcount</name></decl></parameter>,
               <parameter><decl><type><name>bool</name></type> <name>continuous</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>pct_info</name></name> <modifier>*</modifier></type><name>pct_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pct_info</name> <operator>=</operator> <operator>(</operator>struct <name>pct_info</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_percentiles</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>pct_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_percentiles</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>percentiles_null</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* dummy entry for any NULL in array */</comment>
            <expr_stmt><expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>first_row</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>second_row</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>proportion</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>double</name></type>        <name>p</name> <init>= <expr><call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name><name>percentiles_datum</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>p</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>p</name></expr></argument> &gt;</argument_list></name> <literal type="number">1</literal> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"percentile value %g is not between 0 and 1"</literal></expr></argument>,
                                <argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>continuous</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>first_row</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>floor</name><argument_list>(<argument><expr><name>p</name> <operator>*</operator> <operator>(</operator><name>rowcount</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>second_row</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>p</name> <operator>*</operator> <operator>(</operator><name>rowcount</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>proportion</name> <operator>=</operator> <operator>(</operator><name>p</name> <operator>*</operator> <operator>(</operator><name>rowcount</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>-</operator> <call><name>floor</name><argument_list>(<argument><expr><name>p</name> <operator>*</operator> <operator>(</operator><name>rowcount</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*----------
                 * We need the smallest K such that (K/N) &gt;= percentile.
                 * N&gt;0, therefore K &gt;= N*percentile, therefore
                 * K = ceil(N*percentile); but not less than 1.
                 *----------
                 */</comment>
                <decl_stmt><decl><type><name>int64</name></type>        <name>row</name> <init>= <expr><operator>(</operator><name>int64</name><operator>)</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>p</name> <operator>*</operator> <name>rowcount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>row</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>first_row</name> <operator>=</operator> <name>row</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>second_row</name> <operator>=</operator> <name>row</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>proportion</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * The parameter array wasn't necessarily in sorted order, but we need to
     * visit the rows in order, so sort by first_row/second_row.
     */</comment>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>pct_info</name></expr></argument>, <argument><expr><name>num_percentiles</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>pct_info</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pct_info_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pct_info</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * percentile_disc(float8[]) within group (anyelement)    - discrete percentiles
 */</comment>
<function><type><name>Datum</name></type>
<name>percentile_disc_multi_final</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>OSAPerGroupState</name> <modifier>*</modifier></type><name>osastate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>percentiles_datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>percentiles_null</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_percentiles</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>pct_info</name></name> <modifier>*</modifier></type><name>pct_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>result_datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>result_isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>rownum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>val</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGG_CONTEXT_AGGREGATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If there were no regular rows, the result is NULL */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>osastate</name> <operator>=</operator> <operator>(</operator><name>OSAPerGroupState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* number_of_rows could be zero if we only saw NULL input values */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>osastate</name><operator>-&gt;</operator><name>number_of_rows</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Deconstruct the percentile-array input */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>FLOAT8OID</name></expr></argument>,
    <comment type="block">/* hard-wired info on type float8 */</comment>
                      <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>FLOAT8PASSBYVAL</name></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>,
                      <argument><expr><operator>&amp;</operator><name>percentiles_datum</name></expr></argument>,
                      <argument><expr><operator>&amp;</operator><name>percentiles_null</name></expr></argument>,
                      <argument><expr><operator>&amp;</operator><name>num_percentiles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>num_percentiles</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>sortColType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>pct_info</name> <operator>=</operator> <call><name>setup_pct_info</name><argument_list>(<argument><expr><name>num_percentiles</name></expr></argument>,
                              <argument><expr><name>percentiles_datum</name></expr></argument>,
                              <argument><expr><name>percentiles_null</name></expr></argument>,
                              <argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>number_of_rows</name></name></expr></argument>,
                              <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result_datum</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_percentiles</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result_isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_percentiles</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Start by dealing with any nulls in the param array - those are sorted
     * to the front on row=0, so set the corresponding result indexes to null
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_percentiles</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>idx</name> <init>= <expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>idx</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>first_row</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>result_datum</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result_isnull</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * If there's anything left after doing the nulls, then grind the input
     * and extract the needed values
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>num_percentiles</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Finish the sort */</comment>
        <expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_percentiles</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int64</name></type>        <name>target_row</name> <init>= <expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>first_row</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>idx</name> <init>= <expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>idx</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Advance to target row, if not already there */</comment>
            <if_stmt><if>if <condition>(<expr><name>target_row</name> <operator>&gt;</operator> <name>rownum</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_skiptuples</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>target_row</name> <operator>-</operator> <name>rownum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing row in percentile_disc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_getdatum</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing row in percentile_disc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>rownum</name> <operator>=</operator> <name>target_row</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>result_datum</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result_isnull</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>isnull</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We could clean up the tuplesort object after forming the array, but
     * probably not worth the trouble.
     */</comment>

    <comment type="block">/* We make the output array the same shape as the input */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>construct_md_array</name><argument_list>(<argument><expr><name>result_datum</name></expr></argument>, <argument><expr><name>result_isnull</name></expr></argument>,
                                         <argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>sortColType</name></name></expr></argument>,
                                         <argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>typLen</name></name></expr></argument>,
                                         <argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>typByVal</name></name></expr></argument>,
                                         <argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>typAlign</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * percentile_cont(float8[]) within group ()    - continuous percentiles
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>percentile_cont_multi_final_common</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
                                   <parameter><decl><type><name>Oid</name></type> <name>expect_type</name></decl></parameter>,
                                   <parameter><decl><type><name>int16</name></type> <name>typLen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typByVal</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typAlign</name></decl></parameter>,
                                   <parameter><decl><type><name>LerpFunc</name></type> <name>lerpfunc</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>OSAPerGroupState</name> <modifier>*</modifier></type><name>osastate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>percentiles_datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>percentiles_null</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_percentiles</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>pct_info</name></name> <modifier>*</modifier></type><name>pct_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>result_datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>result_isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>rownum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>first_val</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>second_val</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGG_CONTEXT_AGGREGATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If there were no regular rows, the result is NULL */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>osastate</name> <operator>=</operator> <operator>(</operator><name>OSAPerGroupState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* number_of_rows could be zero if we only saw NULL input values */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>osastate</name><operator>-&gt;</operator><name>number_of_rows</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expect_type</name> <operator>==</operator> <name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>sortColType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Deconstruct the percentile-array input */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>FLOAT8OID</name></expr></argument>,
    <comment type="block">/* hard-wired info on type float8 */</comment>
                      <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>FLOAT8PASSBYVAL</name></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>,
                      <argument><expr><operator>&amp;</operator><name>percentiles_datum</name></expr></argument>,
                      <argument><expr><operator>&amp;</operator><name>percentiles_null</name></expr></argument>,
                      <argument><expr><operator>&amp;</operator><name>num_percentiles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>num_percentiles</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>sortColType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>pct_info</name> <operator>=</operator> <call><name>setup_pct_info</name><argument_list>(<argument><expr><name>num_percentiles</name></expr></argument>,
                              <argument><expr><name>percentiles_datum</name></expr></argument>,
                              <argument><expr><name>percentiles_null</name></expr></argument>,
                              <argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>number_of_rows</name></name></expr></argument>,
                              <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result_datum</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_percentiles</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result_isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_percentiles</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Start by dealing with any nulls in the param array - those are sorted
     * to the front on row=0, so set the corresponding result indexes to null
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_percentiles</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>idx</name> <init>= <expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>idx</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>first_row</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>result_datum</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result_isnull</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * If there's anything left after doing the nulls, then grind the input
     * and extract the needed values
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>num_percentiles</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Finish the sort */</comment>
        <expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_percentiles</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int64</name></type>        <name>first_row</name> <init>= <expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>first_row</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int64</name></type>        <name>second_row</name> <init>= <expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>second_row</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>idx</name> <init>= <expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>idx</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * Advance to first_row, if not already there.  Note that we might
             * already have rownum beyond first_row, in which case first_val
             * is already correct.  (This occurs when interpolating between
             * the same two input rows as for the previous percentile.)
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>first_row</name> <operator>&gt;</operator> <name>rownum</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_skiptuples</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>first_row</name> <operator>-</operator> <name>rownum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing row in percentile_cont"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_getdatum</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>first_val</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing row in percentile_cont"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>rownum</name> <operator>=</operator> <name>first_row</name></expr>;</expr_stmt>
                <comment type="block">/* Always advance second_val to be latest input value */</comment>
                <expr_stmt><expr><name>second_val</name> <operator>=</operator> <name>first_val</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>first_row</name> <operator>==</operator> <name>rownum</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * We are already at the desired row, so we must previously
                 * have read its value into second_val (and perhaps first_val
                 * as well, but this assignment is harmless in that case).
                 */</comment>
                <expr_stmt><expr><name>first_val</name> <operator>=</operator> <name>second_val</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Fetch second_row if needed */</comment>
            <if_stmt><if>if <condition>(<expr><name>second_row</name> <operator>&gt;</operator> <name>rownum</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_getdatum</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>second_val</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing row in percentile_cont"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>rownum</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* We should now certainly be on second_row exactly */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>second_row</name> <operator>==</operator> <name>rownum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Compute appropriate result */</comment>
            <if_stmt><if>if <condition>(<expr><name>second_row</name> <operator>&gt;</operator> <name>first_row</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>result_datum</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <call><name>lerpfunc</name><argument_list>(<argument><expr><name>first_val</name></expr></argument>, <argument><expr><name>second_val</name></expr></argument>,
                                             <argument><expr><name><name>pct_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>proportion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>result_datum</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>first_val</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><name><name>result_isnull</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We could clean up the tuplesort object after forming the array, but
     * probably not worth the trouble.
     */</comment>

    <comment type="block">/* We make the output array the same shape as the input */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>construct_md_array</name><argument_list>(<argument><expr><name>result_datum</name></expr></argument>, <argument><expr><name>result_isnull</name></expr></argument>,
                                         <argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name>expect_type</name></expr></argument>,
                                         <argument><expr><name>typLen</name></expr></argument>,
                                         <argument><expr><name>typByVal</name></expr></argument>,
                                         <argument><expr><name>typAlign</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * percentile_cont(float8[]) within group (float8)    - continuous percentiles
 */</comment>
<function><type><name>Datum</name></type>
<name>percentile_cont_float8_multi_final</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>percentile_cont_multi_final_common</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>,
                                              <argument><expr><name>FLOAT8OID</name></expr></argument>,
    <comment type="block">/* hard-wired info on type float8 */</comment>
                                              <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>FLOAT8PASSBYVAL</name></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>,
                                              <argument><expr><name>float8_lerp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * percentile_cont(float8[]) within group (interval)  - continuous percentiles
 */</comment>
<function><type><name>Datum</name></type>
<name>percentile_cont_interval_multi_final</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>percentile_cont_multi_final_common</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>,
                                              <argument><expr><name>INTERVALOID</name></expr></argument>,
    <comment type="block">/* hard-wired info on type interval */</comment>
                                              <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>,
                                              <argument><expr><name>interval_lerp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * mode() within group (anyelement) - most common value
 */</comment>
<function><type><name>Datum</name></type>
<name>mode_final</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>OSAPerGroupState</name> <modifier>*</modifier></type><name>osastate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>mode_val</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>mode_freq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>last_val</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>last_val_freq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>last_val_is_mode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>equalfn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>abbrev_val</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>last_abbrev_val</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>shouldfree</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGG_CONTEXT_AGGREGATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If there were no regular rows, the result is NULL */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>osastate</name> <operator>=</operator> <operator>(</operator><name>OSAPerGroupState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* number_of_rows could be zero if we only saw NULL input values */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>osastate</name><operator>-&gt;</operator><name>number_of_rows</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Look up the equality function for the datatype, if we didn't already */</comment>
    <expr_stmt><expr><name>equalfn</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>equalfn</name></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>equalfn</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><call><name>get_opcode</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>eqOperator</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>equalfn</name></expr></argument>,
                      <argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>qcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>shouldfree</name> <operator>=</operator> <operator>!</operator><operator>(</operator><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>typByVal</name></name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Finish the sort */</comment>
    <expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Scan tuples and count frequencies */</comment>
    <while>while <condition>(<expr><call><name>tuplesort_getdatum</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>abbrev_val</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* we don't expect any nulls, but ignore them if found */</comment>
        <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>last_val_freq</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* first nonnull value - it's the mode for now */</comment>
            <expr_stmt><expr><name>mode_val</name> <operator>=</operator> <name>last_val</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>mode_freq</name> <operator>=</operator> <name>last_val_freq</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>last_val_is_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>last_abbrev_val</name> <operator>=</operator> <name>abbrev_val</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>abbrev_val</name> <operator>==</operator> <name>last_abbrev_val</name> <operator>&amp;&amp;</operator>
                 <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2</name><argument_list>(<argument><expr><name>equalfn</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>last_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* value equal to previous value, count it */</comment>
            <if_stmt><if>if <condition>(<expr><name>last_val_is_mode</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>mode_freq</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* needn't maintain last_val_freq */</comment>
            <if type="elseif">else if <condition>(<expr><operator>++</operator><name>last_val_freq</name> <operator>&gt;</operator> <name>mode_freq</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* last_val becomes new mode */</comment>
                <if_stmt><if>if <condition>(<expr><name>shouldfree</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>mode_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>mode_val</name> <operator>=</operator> <name>last_val</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>mode_freq</name> <operator>=</operator> <name>last_val_freq</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>last_val_is_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>shouldfree</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* val should replace last_val */</comment>
            <if_stmt><if>if <condition>(<expr><name>shouldfree</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>last_val_is_mode</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>last_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>last_val</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
            <comment type="block">/* avoid equality function calls by reusing abbreviated keys */</comment>
            <expr_stmt><expr><name>last_abbrev_val</name> <operator>=</operator> <name>abbrev_val</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>last_val_freq</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>last_val_is_mode</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>shouldfree</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>last_val_is_mode</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>last_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Note: we *cannot* clean up the tuplesort object here, because the value
     * to be returned is allocated inside its sortcontext.  We could use
     * datumCopy to copy it out of there, but it doesn't seem worth the
     * trouble, since the cleanup callback will clear the tuplesort later.
     */</comment>

    <if_stmt><if>if <condition>(<expr><name>mode_freq</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>mode_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Common code to sanity-check args for hypothetical-set functions. No need
 * for friendly errors, these can only happen if someone's messing up the
 * aggregate definitions. The checks are needed for security, however.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>hypothetical_check_argtypes</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>,
                            <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* check that we have an int4 flag column */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tupdesc</name> <operator>||</operator>
        <operator>(</operator><name>nargs</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>||</operator>
        <name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>nargs</name></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name> <operator>!=</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"type mismatch in hypothetical-set function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check that direct args match in type with aggregated args */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"type mismatch in hypothetical-set function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * compute rank of hypothetical row
 *
 * flag should be -1 to sort hypothetical row ahead of its peers, or +1
 * to sort behind.
 * total number of regular rows is returned into *number_of_rows.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>hypothetical_rank_common</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>,
                         <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>number_of_rows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>nargs</name> <init>= <expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>rank</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OSAPerGroupState</name> <modifier>*</modifier></type><name>osastate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGG_CONTEXT_AGGREGATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If there were no regular rows, the rank is always 1 */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>number_of_rows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>osastate</name> <operator>=</operator> <operator>(</operator><name>OSAPerGroupState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>number_of_rows</name> <operator>=</operator> <name><name>osastate</name><operator>-&gt;</operator><name>number_of_rows</name></name></expr>;</expr_stmt>

    <comment type="block">/* Adjust nargs to be the number of direct (or aggregated) args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>%</operator> <literal type="number">2</literal> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of arguments in hypothetical-set function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nargs</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>hypothetical_check_argtypes</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* insert the hypothetical row into the sort */</comment>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>tupslot</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>tuplesort_puttupleslot</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* finish the sort */</comment>
    <expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* iterate till we find the hypothetical row */</comment>
    <while>while <condition>(<expr><call><name>tuplesort_gettupleslot</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>d</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>nargs</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name> <operator>&amp;&amp;</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>rank</name><operator>++</operator></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Might as well clean up the tuplesort object immediately */</comment>
    <expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <return>return <expr><name>rank</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * rank()  - rank of hypothetical row
 */</comment>
<function><type><name>Datum</name></type>
<name>hypothetical_rank_final</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type>        <name>rank</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>rowcount</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rank</name> <operator>=</operator> <call><name>hypothetical_rank_common</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rowcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>rank</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * percent_rank()    - percentile rank of hypothetical row
 */</comment>
<function><type><name>Datum</name></type>
<name>hypothetical_percent_rank_final</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type>        <name>rank</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>rowcount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>result_val</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rank</name> <operator>=</operator> <call><name>hypothetical_rank_common</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rowcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>rowcount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result_val</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>rank</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>rowcount</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cume_dist()    - cumulative distribution of hypothetical row
 */</comment>
<function><type><name>Datum</name></type>
<name>hypothetical_cume_dist_final</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type>        <name>rank</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>rowcount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>result_val</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rank</name> <operator>=</operator> <call><name>hypothetical_rank_common</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rowcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result_val</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>rank</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>rowcount</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dense_rank() - rank of hypothetical row without gaps in ranking
 */</comment>
<function><type><name>Datum</name></type>
<name>hypothetical_dense_rank_final</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>nargs</name> <init>= <expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>rank</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>duplicate_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OSAPerGroupState</name> <modifier>*</modifier></type><name>osastate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numDistinctCols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>abbrevVal</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>abbrevOld</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>equalfns</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>extraslot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmpcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGG_CONTEXT_AGGREGATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If there were no regular rows, the rank is always 1 */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>rank</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>osastate</name> <operator>=</operator> <operator>(</operator><name>OSAPerGroupState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Adjust nargs to be the number of direct (or aggregated) args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>%</operator> <literal type="number">2</literal> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of arguments in hypothetical-set function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nargs</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>hypothetical_check_argtypes</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * When comparing tuples, we can omit the flag column since we will only
     * compare rows with flag == 0.
     */</comment>
    <expr_stmt><expr><name>numDistinctCols</name> <operator>=</operator> <name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>numSortCols</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* Look up the equality function(s), if we didn't already */</comment>
    <expr_stmt><expr><name>equalfns</name> <operator>=</operator> <name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>equalfns</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>equalfns</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>qcontext</name> <init>= <expr><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>qcontext</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>equalfns</name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator>
            <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>qcontext</name></expr></argument>, <argument><expr><name>numDistinctCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numDistinctCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><call><name>get_opcode</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>eqOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name><name>equalfns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                          <argument><expr><name>qcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>equalfns</name></name> <operator>=</operator> <name>equalfns</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>sortColIdx</name> <operator>=</operator> <name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr>;</expr_stmt>

    <comment type="block">/* Get short-term context we can use for execTuplesMatch */</comment>
    <expr_stmt><expr><name>tmpcontext</name> <operator>=</operator> <call><name>AggGetTempMemoryContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* insert the hypothetical row into the sort */</comment>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>tupslot</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>tuplesort_puttupleslot</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* finish the sort */</comment>
    <expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We alternate fetching into tupslot and extraslot so that we have the
     * previous row available for comparisons.  This is accomplished by
     * swapping the slot pointer variables after each row.
     */</comment>
    <expr_stmt><expr><name>extraslot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>qstate</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>slot2</name> <operator>=</operator> <name>extraslot</name></expr>;</expr_stmt>

    <comment type="block">/* iterate till we find the hypothetical row */</comment>
    <while>while <condition>(<expr><call><name>tuplesort_gettupleslot</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>abbrevVal</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>d</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>nargs</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tmpslot</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name> <operator>&amp;&amp;</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/* count non-distinct tuples */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <name>abbrevVal</name> <operator>==</operator> <name>abbrevOld</name> <operator>&amp;&amp;</operator>
            <call><name>execTuplesMatch</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>slot2</name></expr></argument>,
                            <argument><expr><name>numDistinctCols</name></expr></argument>,
                            <argument><expr><name>sortColIdx</name></expr></argument>,
                            <argument><expr><name>equalfns</name></expr></argument>,
                            <argument><expr><name>tmpcontext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>duplicate_count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>tmpslot</name> <operator>=</operator> <name>slot2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>slot2</name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>slot</name> <operator>=</operator> <name>tmpslot</name></expr>;</expr_stmt>
        <comment type="block">/* avoid execTuplesMatch() calls by reusing abbreviated keys */</comment>
        <expr_stmt><expr><name>abbrevOld</name> <operator>=</operator> <name>abbrevVal</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>rank</name><operator>++</operator></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>extraslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Might as well clean up the tuplesort object immediately */</comment>
    <expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>osastate</name><operator>-&gt;</operator><name>sortstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>rank</name> <operator>=</operator> <name>rank</name> <operator>-</operator> <name>duplicate_count</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>rank</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
