<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/adt/lockfuncs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * lockfuncs.c
 *        Functions for SQL access to various lock-manager capabilities.
 *
 * Copyright (c) 2002-2017, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *        src/backend/utils/adt/lockfuncs.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxcnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>


<comment type="block">/* This must match enum LockTagType! */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>LockTagTypeNames</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="string">"relation"</literal></expr>,
    <expr><literal type="string">"extend"</literal></expr>,
    <expr><literal type="string">"page"</literal></expr>,
    <expr><literal type="string">"tuple"</literal></expr>,
    <expr><literal type="string">"transactionid"</literal></expr>,
    <expr><literal type="string">"virtualxid"</literal></expr>,
    <expr><literal type="string">"speculative token"</literal></expr>,
    <expr><literal type="string">"object"</literal></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <expr><literal type="string">"shard"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><literal type="string">"userlock"</literal></expr>,
    <expr><literal type="string">"advisory"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* This must match enum PredicateLockTargetType (predicate_internals.h) */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>PredicateLockTagTypeNames</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="string">"relation"</literal></expr>,
    <expr><literal type="string">"page"</literal></expr>,
    <expr><literal type="string">"tuple"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Working status for pg_lock_status */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>LockData</name>   <modifier>*</modifier></type><name>lockData</name></decl>;</decl_stmt>        <comment type="block">/* state data from lmgr */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>currIdx</name></decl>;</decl_stmt>        <comment type="block">/* current PROCLOCK index */</comment>
    <decl_stmt><decl><type><name>PredicateLockData</name> <modifier>*</modifier></type><name>predLockData</name></decl>;</decl_stmt>    <comment type="block">/* state data for pred locks */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>predLockIdx</name></decl>;</decl_stmt>    <comment type="block">/* current index for pred lock */</comment>
}</block></struct></type> <name>PG_Lock_Status</name>;</typedef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/*
 * These enums are defined to make calls to pgxc_advisory_lock more readable.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
    <decl><name>SESSION_LOCK</name></decl>,
    <decl><name>TRANSACTION_LOCK</name></decl>
}</block></enum></type> <name>LockLevel</name>;</typedef>

<typedef>typedef <type><enum>enum
<block>{
    <decl><name>WAIT</name></decl>,
    <decl><name>DONT_WAIT</name></decl>
}</block></enum></type> <name>TryType</name>;</typedef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><name>bool</name></type> <name>is_session_locked_for_backup</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>bool</name></type>
<name>pgxc_advisory_lock</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>key64</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>key1</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>key2</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iskeybig</name></decl></parameter>,
            <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>LockLevel</name></type> <name>locklevel</name></decl></parameter>, <parameter><decl><type><name>TryType</name></type> <name>try</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Number of columns in pg_locks output */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_LOCK_STATUS_COLUMNS</name></cpp:macro>        <cpp:value>15</cpp:value></cpp:define>

<comment type="block">/*
 * VXIDGetDatum - Construct a text representation of a VXID
 *
 * This is currently only used in pg_lock_status, so we put it here.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>VXIDGetDatum</name><parameter_list>(<parameter><decl><type><name>BackendId</name></type> <name>bid</name></decl></parameter>, <parameter><decl><type><name>LocalTransactionId</name></type> <name>lxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * The representation is "&lt;bid&gt;/&lt;lxid&gt;", decimal and unsigned decimal
     * respectively.  Note that elog.c also knows how to format a vxid.
     */</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>vxidstr</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>vxidstr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>vxidstr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d/%u"</literal></expr></argument>, <argument><expr><name>bid</name></expr></argument>, <argument><expr><name>lxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>vxidstr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pg_lock_status - produce a view with one row per held or awaited lock mode
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_lock_status</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PG_Lock_Status</name> <modifier>*</modifier></type><name>mystatus</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LockData</name>   <modifier>*</modifier></type><name>lockData</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PredicateLockData</name> <modifier>*</modifier></type><name>predLockData</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

        <comment type="block">/* create a function context for cross-call persistence */</comment>
        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * switch to memory context appropriate for multiple function calls
         */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* build tupdesc for result tuples */</comment>
        <comment type="block">/* this had better match function's declaration in pg_proc.h */</comment>
        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>NUM_LOCK_STATUS_COLUMNS</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"locktype"</literal></expr></argument>,
                           <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"database"</literal></expr></argument>,
                           <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"relation"</literal></expr></argument>,
                           <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"page"</literal></expr></argument>,
                           <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"tuple"</literal></expr></argument>,
                           <argument><expr><name>INT2OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"virtualxid"</literal></expr></argument>,
                           <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"transactionid"</literal></expr></argument>,
                           <argument><expr><name>XIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"classid"</literal></expr></argument>,
                           <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">9</literal></expr></argument>, <argument><expr><literal type="string">"objid"</literal></expr></argument>,
                           <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><literal type="string">"objsubid"</literal></expr></argument>,
                           <argument><expr><name>INT2OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">11</literal></expr></argument>, <argument><expr><literal type="string">"virtualtransaction"</literal></expr></argument>,
                           <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><literal type="string">"pid"</literal></expr></argument>,
                           <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">13</literal></expr></argument>, <argument><expr><literal type="string">"mode"</literal></expr></argument>,
                           <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">14</literal></expr></argument>, <argument><expr><literal type="string">"granted"</literal></expr></argument>,
                           <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">15</literal></expr></argument>, <argument><expr><literal type="string">"fastpath"</literal></expr></argument>,
                           <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Collect all the locking information that we will format and send
         * out as a result set.
         */</comment>
        <expr_stmt><expr><name>mystatus</name> <operator>=</operator> <operator>(</operator><name>PG_Lock_Status</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PG_Lock_Status</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>mystatus</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>mystatus</name><operator>-&gt;</operator><name>lockData</name></name> <operator>=</operator> <call><name>GetLockStatusData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mystatus</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mystatus</name><operator>-&gt;</operator><name>predLockData</name></name> <operator>=</operator> <call><name>GetPredicateLockStatusData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mystatus</name><operator>-&gt;</operator><name>predLockIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mystatus</name> <operator>=</operator> <operator>(</operator><name>PG_Lock_Status</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lockData</name> <operator>=</operator> <name><name>mystatus</name><operator>-&gt;</operator><name>lockData</name></name></expr>;</expr_stmt>

    <while>while <condition>(<expr><name><name>mystatus</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&lt;</operator> <name><name>lockData</name><operator>-&gt;</operator><name>nelements</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>granted</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LOCKMODE</name></type>    <name>mode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>locktypename</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>tnbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>NUM_LOCK_STATUS_COLUMNS</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>NUM_LOCK_STATUS_COLUMNS</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LockInstanceData</name> <modifier>*</modifier></type><name>instance</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>instance</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>lockData</name><operator>-&gt;</operator><name>locks</name><index>[<expr><name><name>mystatus</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

        <comment type="block">/*
         * Look to see if there are any held lock modes in this PROCLOCK. If
         * so, report, and destructively modify lockData so we don't report
         * again.
         */</comment>
        <expr_stmt><expr><name>granted</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>holdMask</name></name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>mode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>mode</name> <operator>&lt;</operator> <name>MAX_LOCKMODES</name></expr>;</condition> <incr><expr><name>mode</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>granted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;=</operator> <call><name>LOCKBIT_OFF</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If no (more) held modes to report, see if PROC is waiting for a
         * lock on this lock.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>granted</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>waitLockMode</name></name> <operator>!=</operator> <name>NoLock</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Yes, so report it with proper mode */</comment>
                <expr_stmt><expr><name>mode</name> <operator>=</operator> <name><name>instance</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr>;</expr_stmt>

                <comment type="block">/*
                 * We are now done with this PROCLOCK, so advance pointer to
                 * continue with next one on next call.
                 */</comment>
                <expr_stmt><expr><name><name>mystatus</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * Okay, we've displayed all the locks associated with this
                 * PROCLOCK, proceed to the next one.
                 */</comment>
                <expr_stmt><expr><name><name>mystatus</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Form tuple with appropriate data.
         */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_type</name></name> <operator>&lt;=</operator> <name>LOCKTAG_LAST_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>locktypename</name> <operator>=</operator> <name><name>LockTagTypeNames</name><index>[<expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_type</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tnbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tnbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"unknown %d"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>locktypename</name> <operator>=</operator> <name>tnbuf</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>locktypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><operator>(</operator><name>LockTagType</name><operator>)</operator> <name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_type</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>LOCKTAG_RELATION</name></expr>:</case>
            <case>case <expr><name>LOCKTAG_RELATION_EXTEND</name></expr>:</case>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCKTAG_PAGE</name></expr>:</case>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCKTAG_TUPLE</name></expr>:</case>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt16GetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field4</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCKTAG_TRANSACTION</name></expr>:</case>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator>
                    <call><name>TransactionIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCKTAG_VIRTUALTRANSACTION</name></expr>:</case>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>VXIDGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field1</name></name></expr></argument>,
                                         <argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCKTAG_OBJECT</name></expr>:</case>
            <case>case <expr><name>LOCKTAG_USERLOCK</name></expr>:</case>
            <case>case <expr><name>LOCKTAG_ADVISORY</name></expr>:</case>
            <default>default:</default>            <comment type="block">/* treat unknown locktags like OBJECT */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field4</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>

        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>VXIDGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>backend</name></name></expr></argument>, <argument><expr><name><name>instance</name><operator>-&gt;</operator><name>lxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>GetLockmodeName</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_lockmethodid</name></name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>granted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>fastpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Have returned all regular locks. Now start on the SIREAD predicate
     * locks.
     */</comment>
    <expr_stmt><expr><name>predLockData</name> <operator>=</operator> <name><name>mystatus</name><operator>-&gt;</operator><name>predLockData</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>mystatus</name><operator>-&gt;</operator><name>predLockIdx</name></name> <operator>&lt;</operator> <name><name>predLockData</name><operator>-&gt;</operator><name>nelements</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PredicateLockTargetType</name></type> <name>lockType</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>predTag</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>predLockData</name><operator>-&gt;</operator><name>locktags</name><index>[<expr><name><name>mystatus</name><operator>-&gt;</operator><name>predLockIdx</name></name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>xact</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>predLockData</name><operator>-&gt;</operator><name>xacts</name><index>[<expr><name><name>mystatus</name><operator>-&gt;</operator><name>predLockIdx</name></name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>NUM_LOCK_STATUS_COLUMNS</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>NUM_LOCK_STATUS_COLUMNS</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>mystatus</name><operator>-&gt;</operator><name>predLockIdx</name></name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/*
         * Form tuple with appropriate data.
         */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* lock type */</comment>
        <expr_stmt><expr><name>lockType</name> <operator>=</operator> <call><name>GET_PREDICATELOCKTARGETTAG_TYPE</name><argument_list>(<argument><expr><operator>*</operator><name>predTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>PredicateLockTagTypeNames</name><index>[<expr><name>lockType</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* lock target */</comment>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>GET_PREDICATELOCKTARGETTAG_DB</name><argument_list>(<argument><expr><operator>*</operator><name>predTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>GET_PREDICATELOCKTARGETTAG_RELATION</name><argument_list>(<argument><expr><operator>*</operator><name>predTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>lockType</name> <operator>==</operator> <name>PREDLOCKTAG_TUPLE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>GET_PREDICATELOCKTARGETTAG_OFFSET</name><argument_list>(<argument><expr><operator>*</operator><name>predTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>lockType</name> <operator>==</operator> <name>PREDLOCKTAG_TUPLE</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>lockType</name> <operator>==</operator> <name>PREDLOCKTAG_PAGE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>GET_PREDICATELOCKTARGETTAG_PAGE</name><argument_list>(<argument><expr><operator>*</operator><name>predTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* these fields are targets for other types of locks */</comment>
        <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>        <comment type="block">/* virtualxid */</comment>
        <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>        <comment type="block">/* transactionid */</comment>
        <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>        <comment type="block">/* classid */</comment>
        <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>        <comment type="block">/* objid */</comment>
        <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>        <comment type="block">/* objsubid */</comment>

        <comment type="block">/* lock holder */</comment>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>VXIDGetDatum</name><argument_list>(<argument><expr><name><name>xact</name><operator>-&gt;</operator><name>vxid</name><operator>.</operator><name>backendId</name></name></expr></argument>,
                                  <argument><expr><name><name>xact</name><operator>-&gt;</operator><name>vxid</name><operator>.</operator><name>localTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>xact</name><operator>-&gt;</operator><name>pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>xact</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * Lock mode. Currently all predicate locks are SIReadLocks, which are
         * always held (never waiting) and have no fast path
         */</comment>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"SIReadLock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pg_blocking_pids - produce an array of the PIDs blocking given PID
 *
 * The reported PIDs are those that hold a lock conflicting with blocked_pid's
 * current request (hard block), or are requesting such a lock and are ahead
 * of blocked_pid in the lock's wait queue (soft block).
 *
 * In parallel-query cases, we report all PIDs blocking any member of the
 * given PID's lock group, and the reported PIDs are those of the blocking
 * PIDs' lock group leaders.  This allows callers to compare the result to
 * lists of clients' pg_backend_pid() results even during a parallel query.
 *
 * Parallel query makes it possible for there to be duplicate PIDs in the
 * result (either because multiple waiters are blocked by same PID, or
 * because multiple blockers have same group leader PID).  We do not bother
 * to eliminate such duplicates from the result.
 *
 * We need not consider predicate locks here, since those don't block anything.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_blocking_pids</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>blocked_pid</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>arrayelems</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>narrayelems</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockedProcsData</name> <modifier>*</modifier></type><name>lockData</name></decl>;</decl_stmt> <comment type="block">/* state data from lmgr */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <comment type="block">/* Collect a snapshot of lock manager state */</comment>
    <expr_stmt><expr><name>lockData</name> <operator>=</operator> <call><name>GetBlockerStatusData</name><argument_list>(<argument><expr><name>blocked_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We can't need more output entries than there are reported PROCLOCKs */</comment>
    <expr_stmt><expr><name>arrayelems</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>lockData</name><operator>-&gt;</operator><name>nlocks</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>narrayelems</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* For each blocked proc in the lock group ... */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lockData</name><operator>-&gt;</operator><name>nprocs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BlockedProcData</name> <modifier>*</modifier></type><name>bproc</name> <init>= <expr><operator>&amp;</operator><name><name>lockData</name><operator>-&gt;</operator><name>procs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LockInstanceData</name> <modifier>*</modifier></type><name>instances</name> <init>= <expr><operator>&amp;</operator><name><name>lockData</name><operator>-&gt;</operator><name>locks</name><index>[<expr><name><name>bproc</name><operator>-&gt;</operator><name>first_lock</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>preceding_waiters</name> <init>= <expr><operator>&amp;</operator><name><name>lockData</name><operator>-&gt;</operator><name>waiter_pids</name><index>[<expr><name><name>bproc</name><operator>-&gt;</operator><name>first_waiter</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LockInstanceData</name> <modifier>*</modifier></type><name>blocked_instance</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LockMethod</name></type>    <name>lockMethodTable</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>conflictMask</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Locate the blocked proc's own entry in the LockInstanceData array.
         * There should be exactly one matching entry.
         */</comment>
        <expr_stmt><expr><name>blocked_instance</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>bproc</name><operator>-&gt;</operator><name>num_locks</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>LockInstanceData</name> <modifier>*</modifier></type><name>instance</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>instances</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name><name>bproc</name><operator>-&gt;</operator><name>pid</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blocked_instance</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>blocked_instance</name> <operator>=</operator> <name>instance</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blocked_instance</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>lockMethodTable</name> <operator>=</operator> <call><name>GetLockTagsMethodTable</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>blocked_instance</name><operator>-&gt;</operator><name>locktag</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>conflictMask</name> <operator>=</operator> <name><name>lockMethodTable</name><operator>-&gt;</operator><name>conflictTab</name><index>[<expr><name><name>blocked_instance</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/* Now scan the PROCLOCK data for conflicting procs */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>bproc</name><operator>-&gt;</operator><name>num_locks</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>LockInstanceData</name> <modifier>*</modifier></type><name>instance</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>instances</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

            <comment type="block">/* A proc never blocks itself, so ignore that entry */</comment>
            <if_stmt><if>if <condition>(<expr><name>instance</name> <operator>==</operator> <name>blocked_instance</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <comment type="block">/* Members of same lock group never block each other, either */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>leaderPid</name></name> <operator>==</operator> <name><name>blocked_instance</name><operator>-&gt;</operator><name>leaderPid</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>conflictMask</name> <operator>&amp;</operator> <name><name>instance</name><operator>-&gt;</operator><name>holdMask</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* hard block: blocked by lock already held by this entry */</comment>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>waitLockMode</name></name> <operator>!=</operator> <name>NoLock</name> <operator>&amp;&amp;</operator>
                     <operator>(</operator><name>conflictMask</name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* conflict in lock requests; who's in front in wait queue? */</comment>
                <decl_stmt><decl><type><name>bool</name></type>        <name>ahead</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>k</name></decl>;</decl_stmt>

                <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>bproc</name><operator>-&gt;</operator><name>num_waiters</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>preceding_waiters</name><index>[<expr><name>k</name></expr>]</index></name> <operator>==</operator> <name><name>instance</name><operator>-&gt;</operator><name>pid</name></name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* soft block: this entry is ahead of blocked proc */</comment>
                        <expr_stmt><expr><name>ahead</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ahead</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* not blocked by this entry */</comment>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* not blocked by this entry */</comment>
                <continue>continue;</continue>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* blocked by this entry, so emit a record */</comment>
            <expr_stmt><expr><name><name>arrayelems</name><index>[<expr><name>narrayelems</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>leaderPid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <comment type="block">/* Assert we didn't overrun arrayelems[] */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>narrayelems</name> <operator>&lt;=</operator> <name><name>lockData</name><operator>-&gt;</operator><name>nlocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Construct array, using hardwired knowledge about int4 type */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>construct_array</name><argument_list>(<argument><expr><name>arrayelems</name></expr></argument>, <argument><expr><name>narrayelems</name></expr></argument>,
                                          <argument><expr><name>INT4OID</name></expr></argument>,
                                          <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pg_safe_snapshot_blocking_pids - produce an array of the PIDs blocking
 * given PID from getting a safe snapshot
 *
 * XXX this does not consider parallel-query cases; not clear how big a
 * problem that is in practice
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_safe_snapshot_blocking_pids</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>blocked_pid</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>blockers</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_blockers</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>blocker_datums</name></decl>;</decl_stmt>

    <comment type="block">/* A buffer big enough for any possible blocker list without truncation */</comment>
    <expr_stmt><expr><name>blockers</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MaxBackends</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Collect a snapshot of processes waited for by GetSafeSnapshot */</comment>
    <expr_stmt><expr><name>num_blockers</name> <operator>=</operator>
        <call><name>GetSafeSnapshotBlockingPids</name><argument_list>(<argument><expr><name>blocked_pid</name></expr></argument>, <argument><expr><name>blockers</name></expr></argument>, <argument><expr><name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Convert int array to Datum array */</comment>
    <if_stmt><if>if <condition>(<expr><name>num_blockers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>blocker_datums</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_blockers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_blockers</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>blocker_datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>blockers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>blocker_datums</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Construct array, using hardwired knowledge about int4 type */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>construct_array</name><argument_list>(<argument><expr><name>blocker_datums</name></expr></argument>, <argument><expr><name>num_blockers</name></expr></argument>,
                                          <argument><expr><name>INT4OID</name></expr></argument>,
                                          <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pg_isolation_test_session_is_blocked - support function for isolationtester
 *
 * Check if specified PID is blocked by any of the PIDs listed in the second
 * argument.  Currently, this looks for blocking caused by waiting for
 * heavyweight locks or safe snapshots.  We ignore blockage caused by PIDs
 * not directly under the isolationtester's control, eg autovacuum.
 *
 * This is an undocumented function intended for use by the isolation tester,
 * and may change in future releases as required for testing purposes.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_isolation_test_session_is_blocked</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>blocked_pid</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>interesting_pids_a</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>blocking_pids_a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name>       <modifier>*</modifier></type><name>interesting_pids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name>       <modifier>*</modifier></type><name>blocking_pids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_interesting_pids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_blocking_pids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>dummy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <comment type="block">/* Validate the passed-in array */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>interesting_pids_a</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>INT4OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>array_contains_nulls</name><argument_list>(<argument><expr><name>interesting_pids_a</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"array must not contain nulls"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>interesting_pids</name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>interesting_pids_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>num_interesting_pids</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>interesting_pids_a</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>interesting_pids_a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get the PIDs of all sessions blocking the given session's attempt to
     * acquire heavyweight locks.
     */</comment>
    <expr_stmt><expr><name>blocking_pids_a</name> <operator>=</operator>
        <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_blocking_pids</name></expr></argument>, <argument><expr><name>blocked_pid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>blocking_pids_a</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>INT4OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>array_contains_nulls</name><argument_list>(<argument><expr><name>blocking_pids_a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>blocking_pids</name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>blocking_pids_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>num_blocking_pids</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>blocking_pids_a</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>blocking_pids_a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check if any of these are in the list of interesting PIDs, that being
     * the sessions that the isolation tester is running.  We don't use
     * "arrayoverlaps" here, because it would lead to cache lookups and one of
     * our goals is to run quickly under CLOBBER_CACHE_ALWAYS.  We expect
     * blocking_pids to be usually empty and otherwise a very small number in
     * isolation tester cases, so make that the outer loop of a naive search
     * for a match.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_blocking_pids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>num_interesting_pids</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>blocking_pids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>interesting_pids</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for></block_content></block></for>

    <comment type="block">/*
     * Check if blocked_pid is waiting for a safe snapshot.  We could in
     * theory check the resulting array of blocker PIDs against the
     * interesting PIDs whitelist, but since there is no danger of autovacuum
     * blocking GetSafeSnapshot there seems to be no point in expending cycles
     * on allocating a buffer and searching for overlap; so it's presently
     * sufficient for the isolation tester's purposes to use a single element
     * buffer and check if the number of safe snapshot blockers is non-zero.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>GetSafeSnapshotBlockingPids</name><argument_list>(<argument><expr><name>blocked_pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Functions for manipulating advisory locks
 *
 * We make use of the locktag fields as follows:
 *
 *    field1: MyDatabaseId ... ensures locks are local to each database
 *    field2: first of 2 int4 keys, or high-order half of an int8 key
 *    field3: second of 2 int4 keys, or low-order half of an int8 key
 *    field4: 1 if using an int8 key, 2 if using 2 int4 keys
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_LOCKTAG_INT64</name><parameter_list>(<parameter><type><name>tag</name></type></parameter>, <parameter><type><name>key64</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>SET_LOCKTAG_ADVISORY(tag, \
                         MyDatabaseId, \
                         (uint32) ((key64) &gt;&gt; 32), \
                         (uint32) (key64), \
                         1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_LOCKTAG_INT32</name><parameter_list>(<parameter><type><name>tag</name></type></parameter>, <parameter><type><name>key1</name></type></parameter>, <parameter><type><name>key2</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>SET_LOCKTAG_ADVISORY(tag, MyDatabaseId, key1, key2, 2)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXINT8LEN</name></cpp:macro> <cpp:value>25</cpp:value></cpp:define>

<comment type="block">/*
 * pgxc_advisory_lock - Core function that implements the algorithm needed to
 * propogate the advisory lock function calls to all Coordinators.
 * The idea is to make the advisory locks cluster-aware, so that a user having
 * a lock from Coordinator 1 will make the user from Coordinator 2 to wait for
 * the same lock.
 *
 * Return true if all locks are returned successfully. False otherwise.
 * Effectively this function returns false only if dontWait is true. Otherwise
 * it either returns true, or waits on a resource, or throws an exception
 * returned by the lock function calls in case of unexpected or fatal errors.
 *
 * Currently used only for session level locks; not used for transaction level
 * locks.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgxc_advisory_lock</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>key64</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>key1</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>key2</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iskeybig</name></decl></parameter>,
            <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
            <parameter><decl><type><name>LockLevel</name></type> <name>locklevel</name></decl></parameter>,
            <parameter><decl><type><name>TryType</name></type> <name>try</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>locktag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>                <modifier>*</modifier></type><name>coOids</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dnOids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numdnodes</name></decl>, <decl><type ref="prev"/><name>numcoords</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type>  <name>lock_cmd</name></decl>, <decl><type ref="prev"/><name>unlock_cmd</name></decl>, <decl><type ref="prev"/><name>lock_funcname</name></decl>, <decl><type ref="prev"/><name>unlock_funcname</name></decl>, <decl><type ref="prev"/><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>str_key</name><index>[<expr><name>MAXINT8LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>prev</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>abort_locking</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>lock_status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>sessionLock</name> <init>= <expr><operator>(</operator><name>locklevel</name> <operator>==</operator> <name>SESSION_LOCK</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>dontWait</name> <init>= <expr><operator>(</operator><name>try</name> <operator>==</operator> <name>DONT_WAIT</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type> <name>session_backup_lock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>key1</name> <operator>==</operator> <name>xc_lockForBackupKey1</name> <operator>&amp;&amp;</operator> <name>key2</name> <operator>==</operator> <name>xc_lockForBackupKey2</name> <operator>&amp;&amp;</operator>
        <name>lockmode</name> <operator>==</operator> <name>ExclusiveLock</name> <operator>&amp;&amp;</operator> <name>locklevel</name> <operator>==</operator> <name>SESSION_LOCK</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>session_backup_lock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>iskeybig</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>, <argument><expr><name>key64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>PgxcNodeGetOids</name><argument_list>(<argument><expr><operator>&amp;</operator><name>coOids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dnOids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numcoords</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numdnodes</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Skip everything XC specific if there's only one Coordinator running */</comment>
    <if_stmt><if>if <condition>(<expr><name>numcoords</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>result</name> <init>= <expr><call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locktag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>, <argument><expr><name>dontWait</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>LOCKACQUIRE_OK</name> <operator>||</operator> <name>result</name> <operator>==</operator> <name>LOCKACQUIRE_ALREADY_HELD</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>session_backup_lock</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>is_session_locked_for_backup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locktag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>, <argument><expr><name>dontWait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If there is already a lock held by us, just increment and return; we
     * already did all necessary steps when we locked for the first time.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>LockIncrementIfExists</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locktag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>true</name></expr>)</condition>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>session_backup_lock</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>is_session_locked_for_backup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><name>true</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_funcname</name></expr></argument>, <argument><expr><literal type="string">"pg_%sadvisory_%slock%s"</literal></expr></argument>,
                                     <argument><expr><operator>(</operator><ternary><condition><expr><name>dontWait</name></expr> ?</condition><then> <expr><literal type="string">"try_"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
                                     <argument><expr><operator>(</operator><ternary><condition><expr><name>sessionLock</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"xact_"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
                                     <argument><expr><operator>(</operator><ternary><condition><expr><name>lockmode</name> <operator>==</operator> <name>ShareLock</name></expr> ?</condition><then> <expr><literal type="string">"_shared"</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unlock_funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unlock_funcname</name></expr></argument>, <argument><expr><literal type="string">"pg_advisory_unlock%s"</literal></expr></argument>,
                                     <argument><expr><operator>(</operator><ternary><condition><expr><name>lockmode</name> <operator>==</operator> <name>ShareLock</name></expr> ?</condition><then> <expr><literal type="string">"_shared"</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>iskeybig</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pg_lltoa</name><argument_list>(<argument><expr><name>key64</name></expr></argument>, <argument><expr><name>str_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>str_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>pg_ltoa</name><argument_list>(<argument><expr><name>key1</name></expr></argument>, <argument><expr><name>str_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><literal type="string">"%s, "</literal></expr></argument>, <argument><expr><name>str_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pg_ltoa</name><argument_list>(<argument><expr><name>key2</name></expr></argument>, <argument><expr><name>str_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>str_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_cmd</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.%s(%s)"</literal></expr></argument>, <argument><expr><name><name>lock_funcname</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unlock_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unlock_cmd</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.%s(%s)"</literal></expr></argument>, <argument><expr><name><name>unlock_funcname</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Go on locking on each Coordinator. Keep on unlocking the previous one
     * after a lock is held on next Coordinator. Don't unlock the local
     * Coordinator. After finishing all Coordinators, ultimately only the local
     * Coordinator would be locked, but still we will have scanned all
     * Coordinators to make sure no one else has already grabbed the lock. The
     * reason for unlocking all remote locks is because the session level locks
     * don't get unlocked until explicitly unlocked or the session quits. After
     * the user session quits without explicitly unlocking, the coord-to-coord
     * pooler connection stays and so does the remote Coordinator lock.
     */</comment>
    <expr_stmt><expr><name>prev</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>numcoords</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>abort_locking</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>prev</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>numcoords</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* If this Coordinator is myself, execute native lock calls */</comment>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>PGXCNodeId</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>lock_status</name> <operator>=</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locktag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>, <argument><expr><name>dontWait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>lock_status</name> <operator>=</operator> <call><name>pgxc_execute_on_nodes</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>coOids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>lock_cmd</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>dontWait</name> <operator>==</operator> <name>true</name> <operator>&amp;&amp;</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name>lock_status</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>abort_locking</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <comment type="block">/*
                 * If we have gone past the local Coordinator node, it implies
                 * that we have obtained a local lock. But now that we are
                 * aborting, we need to release the local lock first.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>PGXCNodeId</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locktag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If we are dealing with session locks, unlock the previous lock, but
         * only if it is a remote Coordinator. If it is a local one, we want to
         * keep that lock. Remember, the final status should be that there is
         * only *one* lock held, and that is the local lock.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>sessionLock</name> <operator>&amp;&amp;</operator> <name>prev</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>prev</name> <operator>!=</operator> <name>PGXCNodeId</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pgxc_execute_on_nodes</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>coOids</name><index>[<expr><name>prev</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>unlock_cmd</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>abort_locking</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>session_backup_lock</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>is_session_locked_for_backup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><operator>(</operator><operator>!</operator><name>abort_locking</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>PreventAdvisoryLocksInParallelMode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use advisory locks during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_lock(int8) - acquire exclusive lock on an int8 key
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_lock_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type>        <name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pgxc_advisory_lock</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>SESSION_LOCK</name></expr></argument>, <argument><expr><name>WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_xact_lock(int8) - acquire xact scoped
 * exclusive lock on an int8 key
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_xact_lock_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type>        <name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pgxc_advisory_lock</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>TRANSACTION_LOCK</name></expr></argument>, <argument><expr><name>WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_lock_shared(int8) - acquire share lock on an int8 key
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_lock_shared_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type>        <name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pgxc_advisory_lock</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>SESSION_LOCK</name></expr></argument>, <argument><expr><name>WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_xact_lock_shared(int8) - acquire xact scoped
 * share lock on an int8 key
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_xact_lock_shared_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type>        <name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pgxc_advisory_lock</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>TRANSACTION_LOCK</name></expr></argument>, <argument><expr><name>WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_try_advisory_lock(int8) - acquire exclusive lock on an int8 key, no wait
 *
 * Returns true if successful, false if lock not available
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_try_advisory_lock_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type>        <name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>pgxc_advisory_lock</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>SESSION_LOCK</name></expr></argument>, <argument><expr><name>DONT_WAIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_try_advisory_xact_lock(int8) - acquire xact scoped
 * exclusive lock on an int8 key, no wait
 *
 * Returns true if successful, false if lock not available
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_try_advisory_xact_lock_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type>        <name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>pgxc_advisory_lock</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>TRANSACTION_LOCK</name></expr></argument>, <argument><expr><name>DONT_WAIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_try_advisory_lock_shared(int8) - acquire share lock on an int8 key, no wait
 *
 * Returns true if successful, false if lock not available
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_try_advisory_lock_shared_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type>        <name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>pgxc_advisory_lock</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>SESSION_LOCK</name></expr></argument>, <argument><expr><name>DONT_WAIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_try_advisory_xact_lock_shared(int8) - acquire xact scoped
 * share lock on an int8 key, no wait
 *
 * Returns true if successful, false if lock not available
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_try_advisory_xact_lock_shared_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type>        <name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>pgxc_advisory_lock</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>TRANSACTION_LOCK</name></expr></argument>, <argument><expr><name>DONT_WAIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_unlock(int8) - release exclusive lock on an int8 key
 *
 * Returns true if successful, false if lock was not held
*/</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_unlock_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type>        <name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_unlock_shared(int8) - release share lock on an int8 key
 *
 * Returns true if successful, false if lock was not held
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_unlock_shared_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type>        <name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_lock(int4, int4) - acquire exclusive lock on 2 int4 keys
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_lock_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pgxc_advisory_lock</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>SESSION_LOCK</name></expr></argument>, <argument><expr><name>WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_xact_lock(int4, int4) - acquire xact scoped
 * exclusive lock on 2 int4 keys
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_xact_lock_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pgxc_advisory_lock</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>TRANSACTION_LOCK</name></expr></argument>, <argument><expr><name>WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_lock_shared(int4, int4) - acquire share lock on 2 int4 keys
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_lock_shared_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pgxc_advisory_lock</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>SESSION_LOCK</name></expr></argument>, <argument><expr><name>WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_xact_lock_shared(int4, int4) - acquire xact scoped
 * share lock on 2 int4 keys
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_xact_lock_shared_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pgxc_advisory_lock</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>TRANSACTION_LOCK</name></expr></argument>, <argument><expr><name>WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_try_advisory_lock(int4, int4) - acquire exclusive lock on 2 int4 keys, no wait
 *
 * Returns true if successful, false if lock not available
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_try_advisory_lock_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>pgxc_advisory_lock</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>SESSION_LOCK</name></expr></argument>, <argument><expr><name>DONT_WAIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_try_advisory_xact_lock(int4, int4) - acquire xact scoped
 * exclusive lock on 2 int4 keys, no wait
 *
 * Returns true if successful, false if lock not available
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_try_advisory_xact_lock_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>pgxc_advisory_lock</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>TRANSACTION_LOCK</name></expr></argument>, <argument><expr><name>DONT_WAIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_try_advisory_lock_shared(int4, int4) - acquire share lock on 2 int4 keys, no wait
 *
 * Returns true if successful, false if lock not available
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_try_advisory_lock_shared_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>pgxc_advisory_lock</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>SESSION_LOCK</name></expr></argument>, <argument><expr><name>DONT_WAIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_try_advisory_xact_lock_shared(int4, int4) - acquire xact scoped
 * share lock on 2 int4 keys, no wait
 *
 * Returns true if successful, false if lock not available
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_try_advisory_xact_lock_shared_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>pgxc_advisory_lock</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>TRANSACTION_LOCK</name></expr></argument>, <argument><expr><name>DONT_WAIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_unlock(int4, int4) - release exclusive lock on 2 int4 keys
 *
 * Returns true if successful, false if lock was not held
*/</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_unlock_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_unlock_shared(int4, int4) - release share lock on 2 int4 keys
 *
 * Returns true if successful, false if lock was not held
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_unlock_shared_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKTAG</name></type>        <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_unlock_all() - release all advisory locks
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_unlock_all</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LockReleaseSession</name><argument_list>(<argument><expr><name>USER_LOCKMETHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name>is_session_locked_for_backup</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/*
 * pgxc_lock_for_backup
 *
 * Lock the cluster for taking backup
 * To lock the cluster, try to acquire a session level advisory lock exclusivly
 * By lock we mean to disallow any statements that change
 * the portions of the catalog which are backed up by pg_dump/pg_dumpall
 * Returns true or fails with an error message.
 */</comment>
<function><type><name>Datum</name></type>
<name>pgxc_lock_for_backup</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>lockAcquired</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>prepared_xact_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only superuser can lock the cluster for backup"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * The system cannot be locked for backup if there is an uncommitted
     * prepared transaction, the reason is as follows:
     * Utility statements are divided into two groups, one is allowed group
     * and the other is disallowed group. A statement is put in allowed group
     * if it does not make changes to the catalog or makes such changes which
     * are not backed up by pg_dump or pg_dumpall, otherwise it is put in
     * disallowed group. Every time a disallowed statement is issued we try to
     * hold an advisory lock in shared mode and if the lock can be acquired
     * only then the statement is allowed.
     * In case of prepared transactions suppose the lock is not released at
     * prepare transaction 'txn_id'
     * Consider the following scenario:
     *
     *    begin;
     *    create table abc_def(a int, b int);
     *    insert into abc_def values(1,2),(3,4);
     *    prepare transaction 'abc';
     *
     * Now assume that the server is restarted for any reason.
     * When prepared transactions are saved on disk, session level locks are
     * ignored and hence when the prepared transactions are reterieved and all
     * the other locks are reclaimed, but session level advisory locks are
     * not reclaimed.
     * Hence we made the following decisions
     * a) Transaction level advisory locks should be used for DDLs which are
     *    automatically released at prepare transaction 'txn_id'
     * b) If there is any uncomitted prepared transaction, it is assumed
     *    that it must be issuing a statement that belongs to disallowed
     *    group and hence the request to hold the advisory lock exclusively
     *    is denied.
     */</comment>

    <comment type="block">/* Connect to SPI manager to check any prepared transactions */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"internal error while locking the cluster for backup"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Are there any prepared transactions that have not yet been committed? */</comment>
    <expr_stmt><expr><call><name>SPI_execute</name><argument_list>(<argument><expr><literal type="string">"select gid from pg_catalog.pg_prepared_xacts limit 1"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>prepared_xact_count</name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>prepared_xact_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot lock cluster for backup in presence of %d uncommitted prepared transactions"</literal></expr></argument>,
                        <argument><expr><name>prepared_xact_count</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* try to acquire the advisory lock in exclusive mode */</comment>
    <expr_stmt><expr><name>lockAcquired</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(
                                        <argument><expr><name>pg_try_advisory_lock_int4</name></expr></argument>,
                                        <argument><expr><name>xc_lockForBackupKey1</name></expr></argument>,
                                        <argument><expr><name>xc_lockForBackupKey2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lockAcquired</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot lock cluster for backup, lock is already held"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * sessin level advisory locks stay for only as long as the session
     * that issues them does
     */</comment>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"please do not close this session until you are done adding the new node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* will be true always */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>lockAcquired</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_lock_for_backup
 *
 * Lock the cluster for taking backup
 * To lock the cluster, try to acquire a session level advisory lock exclusivly
 * By lock we mean to disallow any statements that change
 * the portions of the catalog which are backed up by pg_dump/pg_dumpall
 * Returns true or fails with an error message.
 */</comment>
<function><type><name>bool</name></type>
<name>pgxc_lock_for_utility_stmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>lockAcquired</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>is_session_locked_for_backup</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_READ_ONLY_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute %s in a locked cluster"</literal></expr></argument>,
                        <argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>lockAcquired</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(
                                <argument><expr><name>pg_try_advisory_xact_lock_shared_int4</name></expr></argument>,
                                <argument><expr><name>xc_lockForBackupKey1</name></expr></argument>,
                                <argument><expr><name>xc_lockForBackupKey2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lockAcquired</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_READ_ONLY_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute %s in a locked cluster"</literal></expr></argument>,
                        <argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>lockAcquired</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
