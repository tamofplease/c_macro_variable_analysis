<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/adt/tsquery_cleanup.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * tsquery_cleanup.c
 *     Cleanup query from NOT values and/or stopword
 *     Utility functions to correct work.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *      src/backend/utils/adt/tsquery_cleanup.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsearch/ts_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>NODE</name>
<block>{
    <decl_stmt><decl><type><name><name>struct</name> <name>NODE</name></name> <modifier>*</modifier></type><name>left</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>NODE</name></name> <modifier>*</modifier></type><name>right</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>QueryItem</name>  <modifier>*</modifier></type><name>valnode</name></decl>;</decl_stmt>
}</block></struct></type> <name>NODE</name>;</typedef>

<comment type="block">/*
 * make query tree from plain view of query
 */</comment>
<function><type><specifier>static</specifier> <name>NODE</name> <modifier>*</modifier></type>
<name>maketree</name><parameter_list>(<parameter><decl><type><name>QueryItem</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NODE</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>NODE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NODE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* since this function recurses, it could be driven to stack overflow. */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name></name> <operator>=</operator> <name>in</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>in</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_OPR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <call><name>maketree</name><argument_list>(<argument><expr><name>in</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>in</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name> <operator>!=</operator> <name>OP_NOT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <call><name>maketree</name><argument_list>(<argument><expr><name>in</name> <operator>+</operator> <name><name>in</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Internal state for plaintree and plainnode
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>QueryItem</name>  <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>;</decl_stmt>            <comment type="block">/* allocated size of ptr */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>cur</name></decl>;</decl_stmt>            <comment type="block">/* number of elements in ptr */</comment>
}</block></struct></type> <name>PLAINTREE</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>plainnode</name><parameter_list>(<parameter><decl><type><name>PLAINTREE</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* since this function recurses, it could be driven to stack overflow. */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>cur</name></name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>len</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <operator>(</operator><name>QueryItem</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>len</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>QueryItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ptr</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>cur</name></name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>valnode</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueryItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_VAL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>cur</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name> <operator>==</operator> <name>OP_NOT</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ptr</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>cur</name></name></expr>]</index></name><operator>.</operator><name><name>qoperator</name><operator>.</operator><name>left</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>cur</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>plainnode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>cur</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>cur</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>cur</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>plainnode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ptr</name><index>[<expr><name>cur</name></expr>]</index></name><operator>.</operator><name><name>qoperator</name><operator>.</operator><name>left</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>cur</name></name> <operator>-</operator> <name>cur</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>plainnode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * make plain view of tree from a NODE-tree representation
 */</comment>
<function><type><specifier>static</specifier> <name>QueryItem</name> <modifier>*</modifier></type>
<name>plaintree</name><parameter_list>(<parameter><decl><type><name>NODE</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PLAINTREE</name></type>    <name>pl</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pl</name><operator>.</operator><name>cur</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pl</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>root</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_VAL</name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_OPR</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pl</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <operator>(</operator><name>QueryItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>pl</name><operator>.</operator><name>len</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>QueryItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>plainnode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pl</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pl</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name><name>pl</name><operator>.</operator><name>cur</name></name></expr>;</expr_stmt>
    <return>return <expr><name><name>pl</name><operator>.</operator><name>ptr</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>freetree</name><parameter_list>(<parameter><decl><type><name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* since this function recurses, it could be driven to stack overflow. */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>freetree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>freetree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * clean tree for ! operator.
 * It's useful for debug, but in
 * other case, such view is used with search in index.
 * Operator ! always return TRUE
 */</comment>
<function><type><specifier>static</specifier> <name>NODE</name> <modifier>*</modifier></type>
<name>clean_NOT_intree</name><parameter_list>(<parameter><decl><type><name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* since this function recurses, it could be driven to stack overflow. */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_VAL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name> <operator>==</operator> <name>OP_NOT</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>freetree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* operator &amp; or | */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name> <operator>==</operator> <name>OP_OR</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <call><name>clean_NOT_intree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
            <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <call><name>clean_NOT_intree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>freetree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>NODE</name>       <modifier>*</modifier></type><name>res</name> <init>= <expr><name>node</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name> <operator>==</operator> <name>OP_AND</name> <operator>||</operator>
               <name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name> <operator>==</operator> <name>OP_PHRASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <call><name>clean_NOT_intree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <call><name>clean_NOT_intree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>right</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>res</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>QueryItem</name> <modifier>*</modifier></type>
<name>clean_NOT</name><parameter_list>(<parameter><decl><type><name>QueryItem</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NODE</name>       <modifier>*</modifier></type><name>root</name> <init>= <expr><call><name>maketree</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>plaintree</name><argument_list>(<argument><expr><call><name>clean_NOT_intree</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Remove QI_VALSTOP (stopword) nodes from query tree.
 *
 * Returns NULL if the query degenerates to nothing.  Input must not be NULL.
 *
 * When we remove a phrase operator due to removing one or both of its
 * arguments, we might need to adjust the distance of a parent phrase
 * operator.  For example, 'a' is a stopword, so:
 *        (b &lt;-&gt; a) &lt;-&gt; c  should become    b &lt;2&gt; c
 *        b &lt;-&gt; (a &lt;-&gt; c)  should become    b &lt;2&gt; c
 *        (b &lt;-&gt; (a &lt;-&gt; a)) &lt;-&gt; c  should become    b &lt;3&gt; c
 *        b &lt;-&gt; ((a &lt;-&gt; a) &lt;-&gt; c)  should become    b &lt;3&gt; c
 * To handle that, we define two output parameters:
 *        ladd: amount to add to a phrase distance to the left of this node
 *        radd: amount to add to a phrase distance to the right of this node
 * We need two outputs because we could need to bubble up adjustments to two
 * different parent phrase operators.  Consider
 *        w &lt;-&gt; (((a &lt;-&gt; x) &lt;2&gt; (y &lt;3&gt; a)) &lt;-&gt; z)
 * After we've removed the two a's and are considering the &lt;2&gt; node (which is
 * now just x &lt;2&gt; y), we have an ladd distance of 1 that needs to propagate
 * up to the topmost (leftmost) &lt;-&gt;, and an radd distance of 3 that needs to
 * propagate to the rightmost &lt;-&gt;, so that we'll end up with
 *        w &lt;2&gt; ((x &lt;2&gt; y) &lt;4&gt; z)
 * Near the bottom of the tree, we may have subtrees consisting only of
 * stopwords.  The distances of any phrase operators within such a subtree are
 * summed and propagated to both ladd and radd, since we don't know which side
 * of the lowest surviving phrase operator we are in.  The rule is that any
 * subtree that degenerates to NULL must return equal values of ladd and radd,
 * and the parent node dealing with it should incorporate only one of those.
 *
 * Currently, we only implement this adjustment for adjacent phrase operators.
 * Thus for example 'x &lt;-&gt; ((a &lt;-&gt; y) | z)' will become 'x &lt;-&gt; (y | z)', which
 * isn't ideal, but there is no way to represent the really desired semantics
 * without some redesign of the tsquery structure.  Certainly it would not be
 * any better to convert that to 'x &lt;2&gt; (y | z)'.  Since this is such a weird
 * corner case, let it go for now.  But we can fix it in cases where the
 * intervening non-phrase operator also gets removed, for example
 * '((x &lt;-&gt; a) | a) &lt;-&gt; y' will become 'x &lt;2&gt; y'.
 */</comment>
<function><type><specifier>static</specifier> <name>NODE</name> <modifier>*</modifier></type>
<name>clean_stopword_intree</name><parameter_list>(<parameter><decl><type><name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ladd</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>radd</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* since this function recurses, it could be driven to stack overflow. */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* default output parameters indicate no change in parent distance */</comment>
    <expr_stmt><expr><operator>*</operator><name>ladd</name> <operator>=</operator> <operator>*</operator><name>radd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_VAL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>node</name></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_VALSTOP</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name> <operator>==</operator> <name>OP_NOT</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* NOT doesn't change pattern width, so just report child distances */</comment>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <call><name>clean_stopword_intree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name></expr></argument>, <argument><expr><name>ladd</name></expr></argument>, <argument><expr><name>radd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>right</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>freetree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>NODE</name>       <modifier>*</modifier></type><name>res</name> <init>= <expr><name>node</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isphrase</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>ndistance</name></decl>,
                    <decl><type ref="prev"/><name>lladd</name></decl>,
                    <decl><type ref="prev"/><name>lradd</name></decl>,
                    <decl><type ref="prev"/><name>rladd</name></decl>,
                    <decl><type ref="prev"/><name>rradd</name></decl>;</decl_stmt>

        <comment type="block">/* First, recurse */</comment>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <call><name>clean_stopword_intree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lladd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lradd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <call><name>clean_stopword_intree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rladd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rradd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Check if current node is OP_PHRASE, get its distance */</comment>
        <expr_stmt><expr><name>isphrase</name> <operator>=</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name> <operator>==</operator> <name>OP_PHRASE</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>ndistance</name> <operator>=</operator> <ternary><condition><expr><name>isphrase</name></expr> ?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>distance</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>right</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * When we collapse out a phrase node entirely, propagate its own
             * distance into both *ladd and *radd; it is the responsibility of
             * the parent node to count it only once.  Also, for a phrase
             * node, distances coming from children are summed and propagated
             * up to parent (we assume lladd == lradd and rladd == rradd, else
             * rule was broken at a lower level).  But if this isn't a phrase
             * node, take the larger of the two child distances; that
             * corresponds to what TS_execute will do in non-stopword cases.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>isphrase</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>ladd</name> <operator>=</operator> <operator>*</operator><name>radd</name> <operator>=</operator> <name>lladd</name> <operator>+</operator> <name>ndistance</name> <operator>+</operator> <name>rladd</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>ladd</name> <operator>=</operator> <operator>*</operator><name>radd</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>lladd</name></expr></argument>, <argument><expr><name>rladd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>freetree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Removing this operator and left subnode */</comment>
            <comment type="block">/* lladd and lradd are equal/redundant, don't count both */</comment>
            <if_stmt><if>if <condition>(<expr><name>isphrase</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* operator's own distance must propagate to left */</comment>
                <expr_stmt><expr><operator>*</operator><name>ladd</name> <operator>=</operator> <name>lladd</name> <operator>+</operator> <name>ndistance</name> <operator>+</operator> <name>rladd</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>radd</name> <operator>=</operator> <name>rradd</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* at non-phrase op, just forget the left subnode entirely */</comment>
                <expr_stmt><expr><operator>*</operator><name>ladd</name> <operator>=</operator> <name>rladd</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>radd</name> <operator>=</operator> <name>rradd</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Removing this operator and right subnode */</comment>
            <comment type="block">/* rladd and rradd are equal/redundant, don't count both */</comment>
            <if_stmt><if>if <condition>(<expr><name>isphrase</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* operator's own distance must propagate to right */</comment>
                <expr_stmt><expr><operator>*</operator><name>ladd</name> <operator>=</operator> <name>lladd</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>radd</name> <operator>=</operator> <name>lradd</name> <operator>+</operator> <name>ndistance</name> <operator>+</operator> <name>rradd</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* at non-phrase op, just forget the right subnode entirely */</comment>
                <expr_stmt><expr><operator>*</operator><name>ladd</name> <operator>=</operator> <name>lladd</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>radd</name> <operator>=</operator> <name>lradd</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>isphrase</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Absorb appropriate corrections at this level */</comment>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>distance</name></name> <operator>+=</operator> <name>lradd</name> <operator>+</operator> <name>rladd</name></expr>;</expr_stmt>
            <comment type="block">/* Propagate up any unaccounted-for corrections */</comment>
            <expr_stmt><expr><operator>*</operator><name>ladd</name> <operator>=</operator> <name>lladd</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>radd</name> <operator>=</operator> <name>rradd</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* We're keeping a non-phrase operator, so ladd/radd remain 0 */</comment>
        </block_content>}</block></else></if_stmt>

        <return>return <expr><name>res</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Number of elements in query tree
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>calcstrlen</name><parameter_list>(<parameter><decl><type><name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_VAL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>qoperand</name><operator>.</operator><name>length</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>calcstrlen</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name> <operator>!=</operator> <name>OP_NOT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>calcstrlen</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove QI_VALSTOP (stopword) nodes from TSQuery.
 */</comment>
<function><type><name>TSQuery</name></type>
<name>cleanup_tsquery_stopwords</name><parameter_list>(<parameter><decl><type><name>TSQuery</name></type> <name>in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>len</name></decl>,
                <decl><type ref="prev"/><name>lenstr</name></decl>,
                <decl><type ref="prev"/><name>commonlen</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NODE</name>       <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ladd</name></decl>,
                <decl><type ref="prev"/><name>radd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TSQuery</name></type>        <name>out</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>QueryItem</name>  <modifier>*</modifier></type><name>items</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>operands</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>in</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>in</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* eliminate stop words */</comment>
    <expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>clean_stopword_intree</name><argument_list>(<argument><expr><call><name>maketree</name><argument_list>(<argument><expr><call><name>GETQUERY</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ladd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>radd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>root</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"text-search query contains only stop words or doesn't contain lexemes, ignored"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>HDRSIZETQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>HDRSIZETQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>out</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Build TSQuery from plain view
     */</comment>

    <expr_stmt><expr><name>lenstr</name> <operator>=</operator> <call><name>calcstrlen</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>items</name> <operator>=</operator> <call><name>plaintree</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>commonlen</name> <operator>=</operator> <call><name>COMPUTESIZE</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>lenstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>commonlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>commonlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>GETQUERY</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>items</name></expr></argument>, <argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>QueryItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>items</name> <operator>=</operator> <call><name>GETQUERY</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>operands</name> <operator>=</operator> <call><name>GETOPERAND</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>out</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>QueryOperand</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>QueryOperand</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>QI_VAL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>operands</name></expr></argument>, <argument><expr><call><name>GETOPERAND</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>op</name><operator>-&gt;</operator><name>distance</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>operands</name><index>[<expr><name><name>op</name><operator>-&gt;</operator><name>length</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>distance</name></name> <operator>=</operator> <name>operands</name> <operator>-</operator> <call><name>GETOPERAND</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>operands</name> <operator>+=</operator> <name><name>op</name><operator>-&gt;</operator><name>length</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>
</unit>
