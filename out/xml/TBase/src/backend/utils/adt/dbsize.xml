<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/adt/dbsize.c"><comment type="block">/*
 * dbsize.c
 *        Database object size functions, and related inquiries
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Copyright (c) 2002-2017, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *      src/backend/utils/adt/dbsize.c
 *
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxcnode.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/numeric.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relfilenodemap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relmapper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits_fn.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>pgxc_database_size</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dbOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>pgxc_allocated_database_size</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dbOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>pgxc_tablespace_size</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tbOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>pgxc_allocated_tablespace_size</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tbOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int64</name></type> <name>pgxc_exec_sizefunc</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>extra_arg</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Below macro is important when the object size functions are called
 * for system catalog tables. For pg_catalog tables and other Coordinator-only
 * tables, we should return the data from Coordinator. If we don't find
 * locator info, that means it is a Coordinator-only table.
 * also, skip temporary relation.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLLECT_FROM_DATANODES</name><parameter_list>(<parameter><type><name>relid</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>(IS_PGXC_LOCAL_COORDINATOR &amp;&amp; \
    (GetRelationLocInfo((relid)) != NULL)&amp;&amp;(false == IsTempTable((relid))))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* Divide by two and round towards positive infinity. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>half_rounded</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>(((x) + ((x) &lt; 0 ? 0 : 1)) / 2)</cpp:value></cpp:define>

<comment type="block">/* Return physical size of directory contents, or 0 if dir doesn't exist */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>db_dir_size</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>alloc_size</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>dirsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>direntry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DIR</name>           <modifier>*</modifier></type><name>dirdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>filename</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>dirdesc</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dirdesc</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>alloc_size</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>alloc_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <while>while <condition>(<expr><operator>(</operator><name>direntry</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>dirdesc</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>fst</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>direntry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>strcmp</name><argument_list>(<argument><expr><name><name>direntry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>direntry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fst</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>dirsize</name> <operator>+=</operator> <name><name>fst</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><name>alloc_size</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>alloc_size</name> <operator>+=</operator> <name><name>fst</name><operator>.</operator><name>st_blocks</name></name> <operator>*</operator> <literal type="number">512</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dirdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>dirsize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * calculate size of database in all tablespaces
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>calculate_database_size</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dbOid</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>alloc_size</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>totalsize</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int64</name></type>        <name>ph_size</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>DIR</name>           <modifier>*</modifier></type><name>dirdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>direntry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>dirpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>pathname</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <literal type="number">12</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TABLESPACE_VERSION_DIRECTORY</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AclResult</name></type>    <name>aclresult</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>alloc_size</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>alloc_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * User must have connect privilege for target database or be a member of
     * pg_read_all_stats
     */</comment>
    <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_database_aclcheck</name><argument_list>(<argument><expr><name>dbOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CONNECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_STATS</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_DATABASE</name></expr></argument>,
                       <argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>dbOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Shared storage in pg_global is not counted */</comment>

    <comment type="block">/* Include pg_default storage */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"base/%u"</literal></expr></argument>, <argument><expr><name>dbOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>totalsize</name> <operator>=</operator> <call><name>db_dir_size</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ph_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>alloc_size</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>alloc_size</name> <operator>+=</operator> <name>ph_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <comment type="block">/* Scan the non-default tablespaces */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>dirpath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"pg_tblspc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dirdesc</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>dirpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dirdesc</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open tablespace directory \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>dirpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>direntry</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>dirdesc</name></expr></argument>, <argument><expr><name>dirpath</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>direntry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>strcmp</name><argument_list>(<argument><expr><name><name>direntry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <comment type="block">/* Postgres-XC tablespaces include node name in path */</comment>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pg_tblspc/%s/%s_%s/%u"</literal></expr></argument>,
                 <argument><expr><name><name>direntry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>TABLESPACE_VERSION_DIRECTORY</name></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>dbOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pg_tblspc/%s/%s/%u"</literal></expr></argument>,
                 <argument><expr><name><name>direntry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>TABLESPACE_VERSION_DIRECTORY</name></expr></argument>, <argument><expr><name>dbOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>totalsize</name> <operator>+=</operator> <call><name>db_dir_size</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ph_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><name>alloc_size</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>alloc_size</name> <operator>+=</operator> <name>ph_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dirdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>totalsize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_database_size_oid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>dbOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>pgxc_database_size</name><argument_list>(<argument><expr><name>dbOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>calculate_database_size</name><argument_list>(<argument><expr><name>dbOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_database_size_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Name</name></type>        <name>dbName</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>dbOid</name> <init>= <expr><call><name>get_database_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>dbName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>pgxc_database_size</name><argument_list>(<argument><expr><name>dbOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>calculate_database_size</name><argument_list>(<argument><expr><name>dbOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
<function><type><name>Datum</name></type>
<name>pg_allocated_database_size_oid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>dbOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>pgxc_allocated_database_size</name><argument_list>(<argument><expr><name>dbOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>calculate_database_size</name><argument_list>(<argument><expr><name>dbOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_allocated_database_size_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Name</name></type>        <name>dbName</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>dbOid</name> <init>= <expr><call><name>get_database_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>dbName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>pgxc_allocated_database_size</name><argument_list>(<argument><expr><name>dbOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>calculate_database_size</name><argument_list>(<argument><expr><name>dbOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Calculate total size of tablespace. Returns -1 if the tablespace directory
 * cannot be found.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>calculate_tablespace_size</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tblspcOid</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>alloc_size</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>tblspcPath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>pathname</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>totalsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int64</name></type>        <name>ph_size</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>DIR</name>           <modifier>*</modifier></type><name>dirdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>direntry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AclResult</name></type>    <name>aclresult</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>alloc_size</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>alloc_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * User must be a member of pg_read_all_stats or have CREATE privilege for
     * target tablespace, either explicitly granted or implicitly because it
     * is default for current database.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>tblspcOid</name> <operator>!=</operator> <name>MyDatabaseTableSpace</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_STATS</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_tablespace_aclcheck</name><argument_list>(<argument><expr><name>tblspcOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_TABLESPACE</name></expr></argument>,
                           <argument><expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>tblspcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>tblspcOid</name> <operator>==</operator> <name>DEFAULTTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tblspcPath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"base"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>tblspcOid</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tblspcPath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"global"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <comment type="block">/* Postgres-XC tablespaces include node name in path */</comment>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tblspcPath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"pg_tblspc/%u/%s_%s"</literal></expr></argument>, <argument><expr><name>tblspcOid</name></expr></argument>,
                 <argument><expr><name>TABLESPACE_VERSION_DIRECTORY</name></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tblspcPath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"pg_tblspc/%u/%s"</literal></expr></argument>, <argument><expr><name>tblspcOid</name></expr></argument>,
                 <argument><expr><name>TABLESPACE_VERSION_DIRECTORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>dirdesc</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>tblspcPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dirdesc</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>direntry</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>dirdesc</name></expr></argument>, <argument><expr><name>tblspcPath</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>fst</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>direntry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>strcmp</name><argument_list>(<argument><expr><name><name>direntry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>tblspcPath</name></expr></argument>, <argument><expr><name><name>direntry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fst</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>fst</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>totalsize</name> <operator>+=</operator> <call><name>db_dir_size</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ph_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
            <if_stmt><if>if<condition>(<expr><name>alloc_size</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>alloc_size</name> <operator>+=</operator> <name>ph_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>totalsize</name> <operator>+=</operator> <name><name>fst</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><name>alloc_size</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>alloc_size</name> <operator>+=</operator> <name><name>fst</name><operator>.</operator><name>st_blocks</name></name> <operator>*</operator> <literal type="number">512</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </block_content>}</block></while>

    <expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dirdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>totalsize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_tablespace_size_oid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>tblspcOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>pgxc_tablespace_size</name><argument_list>(<argument><expr><name>tblspcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>calculate_tablespace_size</name><argument_list>(<argument><expr><name>tblspcOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_tablespace_size_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Name</name></type>        <name>tblspcName</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>tblspcOid</name> <init>= <expr><call><name>get_tablespace_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>tblspcName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>pgxc_tablespace_size</name><argument_list>(<argument><expr><name>tblspcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>calculate_tablespace_size</name><argument_list>(<argument><expr><name>tblspcOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
<function><type><name>Datum</name></type>
<name>pg_allocated_tablespace_size_oid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>tblspcOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>pgxc_allocated_tablespace_size</name><argument_list>(<argument><expr><name>tblspcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>calculate_tablespace_size</name><argument_list>(<argument><expr><name>tblspcOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_allocated_tablespace_size_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Name</name></type>        <name>tblspcName</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>tblspcOid</name> <init>= <expr><call><name>get_tablespace_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>tblspcName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>pgxc_allocated_tablespace_size</name><argument_list>(<argument><expr><name>tblspcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>calculate_tablespace_size</name><argument_list>(<argument><expr><name>tblspcOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * calculate size of (one fork of) a relation
 *
 * Note: we can safely apply this to temp tables of other sessions, so there
 * is no check here or at the call sites for that.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>calculate_relation_size</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rfn</name></decl></parameter>, <parameter><decl><type><name>BackendId</name></type> <name>backend</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>alloc_size</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>totalsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int64</name></type>        <name>total_physical_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>relationpath</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>pathname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>segcount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>relationpath</name> <operator>=</operator> <call><name>relpathbackend</name><argument_list>(<argument><expr><operator>*</operator><name>rfn</name></expr></argument>, <argument><expr><name>backend</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>segcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>segcount</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>fst</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>segcount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
                     <argument><expr><name>relationpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s.%u"</literal></expr></argument>,
                     <argument><expr><name>relationpath</name></expr></argument>, <argument><expr><name>segcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fst</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>totalsize</name> <operator>+=</operator> <name><name>fst</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <expr_stmt><expr><name>total_physical_size</name> <operator>+=</operator> <name><name>fst</name><operator>.</operator><name>st_blocks</name></name><operator>*</operator><literal type="number">512</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>alloc_size</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>alloc_size</name> <operator>=</operator> <name>total_physical_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>totalsize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_relation_size</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>forkName</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>child_rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>children</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>COLLECT_FROM_DATANODES</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>pgxc_exec_sizefunc</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><literal type="string">"pg_relation_size"</literal></expr></argument>, <argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>forkName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Before 9.2, we used to throw an error if the relation didn't exist, but
     * that makes queries like "SELECT pg_relation_size(oid) FROM pg_class"
     * less robust, because while we scan pg_class with an MVCC snapshot,
     * someone else might drop the table. It's better to return NULL for
     * already-dropped tables than throw an error and abort the whole query.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>calculate_relation_size</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>,
                                   <argument><expr><call><name>forkname_to_number</name><argument_list>(<argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>forkName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <comment type="block">/* scan all partitions if exists */</comment>
    <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>FetchAllParitionList</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NIL</name> <operator>!=</operator> <name>children</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type>    <name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>         <name>partoid</name></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>children</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>partoid</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name>child_rel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>partoid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>child_rel</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>calculate_relation_size</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>child_rel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>child_rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>,
                                           <argument><expr><call><name>forkname_to_number</name><argument_list>(<argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>forkName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
<function><type><name>Datum</name></type>
<name>pg_allocated_relation_size</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>forkName</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>COLLECT_FROM_DATANODES</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>pgxc_exec_sizefunc</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><literal type="string">"pg_allocated_relation_size"</literal></expr></argument>, <argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>forkName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Before 9.2, we used to throw an error if the relation didn't exist, but
     * that makes queries like "SELECT pg_relation_size(oid) FROM pg_class"
     * less robust, because while we scan pg_class with an MVCC snapshot,
     * someone else might drop the table. It's better to return NULL for
     * already-dropped tables than throw an error and abort the whole query.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>calculate_relation_size</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>,
                                   <argument><expr><call><name>forkname_to_number</name><argument_list>(<argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>forkName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Calculate total on-disk size of a TOAST relation, including its indexes.
 * Must not be applied to non-TOAST relations.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>calculate_toast_table_size</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>toastrelid</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>alloc_size</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>    
    <decl_stmt><decl><type><name>int64</name></type>        <name>ph_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>toastRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ForkNumber</name></type>    <name>forkNum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>indexlist</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>alloc_size</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>alloc_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>toastRel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>toastrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* toast heap size, including FSM and VM size */</comment>
    <for>for <control>(<init><expr><name>forkNum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forkNum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forkNum</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>calculate_relation_size</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>toastRel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>,
                                        <argument><expr><name><name>toastRel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ph_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><name>alloc_size</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>alloc_size</name> <operator>+=</operator> <name>ph_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>

    <comment type="block">/* toast index size, including FSM and VM size */</comment>
    <expr_stmt><expr><name>indexlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>toastRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Size is calculated using all the indexes available */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>indexlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>toastIdxRel</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>toastIdxRel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>forkNum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forkNum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forkNum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>calculate_relation_size</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>toastIdxRel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>,
                                            <argument><expr><name><name>toastIdxRel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ph_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><name>alloc_size</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>alloc_size</name> <operator>+=</operator> <name>ph_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>toastIdxRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>toastRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate total on-disk size of a given table,
 * including FSM and VM, plus TOAST table if any.
 * Indexes other than the TOAST table's index are not included.
 *
 * Note that this also behaves sanely if applied to an index or toast table;
 * those won't have attached toast tables, but they can have multiple forks.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>calculate_table_size</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>alloc_size</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int64</name></type>        <name>ph_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>ForkNumber</name></type>    <name>forkNum</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>alloc_size</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>alloc_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * heap size, including FSM and VM
     */</comment>
    <for>for <control>(<init><expr><name>forkNum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forkNum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forkNum</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>calculate_relation_size</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>,
                                        <argument><expr><name>forkNum</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>ph_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>alloc_size</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>alloc_size</name> <operator>+=</operator> <name>ph_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
    </block_content>}</block></for>
    
    <comment type="block">/*
     * Size of toast relation
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>calculate_toast_table_size</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ph_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><name>alloc_size</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>alloc_size</name> <operator>+=</operator> <name>ph_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate total on-disk size of all indexes attached to the given table.
 *
 * Can be applied safely to an index, but you'll just get zero.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>calculate_indexes_size</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Aggregate all indexes on the given relation
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>index_oids</name> <init>= <expr><call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>index_oids</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>idxOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>idxRel</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ForkNumber</name></type>    <name>forkNum</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>idxRel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>idxOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>forkNum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forkNum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forkNum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>calculate_relation_size</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>idxRel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>,
                                                <argument><expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>,
                                                <argument><expr><name>forkNum</name></expr></argument>,
                                                <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

            <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>index_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_table_size</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>COLLECT_FROM_DATANODES</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><call><name>pgxc_exec_sizefunc</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><literal type="string">"pg_table_size"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>isRestoreMode</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type>        <name>parts</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type>    <name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>         <name>partoid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>partrel</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>parts</name> <operator>=</operator> <call><name>RelationGetAllPartitions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parts</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>partoid</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>partrel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>partoid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><name>partrel</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"partition %d of relation %s can not be found"</literal></expr></argument>, <argument><expr><name>partoid</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>calculate_table_size</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name>isRestoreMode</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>RELKIND_PARTITIONED_TABLE</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * this is orignal partition, use \d+ show the parent and all its children 'table size' together,
         * while, if it is a sub parent, the result contains this sub parent table and all its children. 
         */</comment>
        <decl_stmt><decl><type><name>List</name>     <modifier>*</modifier></type>  <name>children</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type>    <name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>         <name>partoid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>child_rel</name></decl>;</decl_stmt>
        
        <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>children</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>partoid</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name>child_rel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>partoid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>child_rel</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"partition %d of relation %s can not be found"</literal></expr></argument>, <argument><expr><name>partoid</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>calculate_table_size</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>calculate_table_size</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
<function><type><name>Datum</name></type>
<name>pg_allocated_table_size</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>COLLECT_FROM_DATANODES</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><call><name>pgxc_exec_sizefunc</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><literal type="string">"pg_allocated_table_size"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>isRestoreMode</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type>        <name>parts</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type>    <name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>         <name>partoid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>partrel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64</name></type>        <name>asize</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>parts</name> <operator>=</operator> <call><name>RelationGetAllPartitions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parts</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>partoid</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>partrel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>partoid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><name>partrel</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"partition %d of relation %s can not be found"</literal></expr></argument>, <argument><expr><name>partoid</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><call><name>calculate_table_size</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>size</name> <operator>+=</operator> <name>asize</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>calculate_table_size</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>Datum</name></type>
<name>pg_indexes_size</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>COLLECT_FROM_DATANODES</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><call><name>pgxc_exec_sizefunc</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><literal type="string">"pg_indexes_size"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>calculate_indexes_size</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    Compute the on-disk size of all files for the relation,
 *    including heap data, index data, toast data, FSM, VM.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>calculate_total_relation_size</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>alloc_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int64</name></type>        <name>ph_size</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name>alloc_size</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>alloc_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Aggregate the table size, this includes size of the heap, toast and
     * toast index with free space and visibility map
     */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>calculate_table_size</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ph_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>alloc_size</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>alloc_size</name> <operator>+=</operator> <name>ph_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Add size of all attached indexes as well
     */</comment>
    <expr_stmt><expr><name>ph_size</name> <operator>=</operator> <call><name>calculate_indexes_size</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>+=</operator> <name>ph_size</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>alloc_size</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>alloc_size</name> <operator>+=</operator> <name>ph_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>int64</name></type>
<name>get_total_relation_size</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>rel</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>calculate_total_relation_size</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>Datum</name></type>
<name>pg_total_relation_size</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>COLLECT_FROM_DATANODES</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><call><name>pgxc_exec_sizefunc</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><literal type="string">"pg_total_relation_size"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>calculate_total_relation_size</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
<function><type><name>Datum</name></type>
<name>pg_allocated_total_relation_size</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>COLLECT_FROM_DATANODES</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><call><name>pgxc_exec_sizefunc</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><literal type="string">"pg_allocated_total_relation_size"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>calculate_total_relation_size</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * formatting with size units
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_size_pretty</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type>        <name>size</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>limit</name> <init>= <expr><literal type="number">10</literal> <operator>*</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>limit2</name> <init>= <expr><name>limit</name> <operator>*</operator> <literal type="number">2</literal> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>Abs</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>limit</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name> <literal type="string">" bytes"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>&gt;&gt;=</operator> <literal type="number">9</literal></expr>;</expr_stmt>                <comment type="block">/* keep one extra bit for rounding */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>Abs</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>limit2</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name> <literal type="string">" kB"</literal></expr></argument>,
                     <argument><expr><call><name>half_rounded</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>size</name> <operator>&gt;&gt;=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>Abs</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>limit2</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name> <literal type="string">" MB"</literal></expr></argument>,
                         <argument><expr><call><name>half_rounded</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>size</name> <operator>&gt;&gt;=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>Abs</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>limit2</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name> <literal type="string">" GB"</literal></expr></argument>,
                             <argument><expr><call><name>half_rounded</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>size</name> <operator>&gt;&gt;=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name> <literal type="string">" TB"</literal></expr></argument>,
                             <argument><expr><call><name>half_rounded</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>numeric_to_cstring</name><parameter_list>(<parameter><decl><type><name>Numeric</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>d</name> <init>= <expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_out</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Numeric</name></type>
<name>int64_to_numeric</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>d</name> <init>= <expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>numeric_is_less</name><parameter_list>(<parameter><decl><type><name>Numeric</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>Numeric</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>da</name> <init>= <expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>db</name> <init>= <expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_lt</name></expr></argument>, <argument><expr><name>da</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Numeric</name></type>
<name>numeric_absolute</name><parameter_list>(<parameter><decl><type><name>Numeric</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>d</name> <init>= <expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_abs</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>DatumGetNumeric</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Numeric</name></type>
<name>numeric_half_rounded</name><parameter_list>(<parameter><decl><type><name>Numeric</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>d</name> <init>= <expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>zero</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>one</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>two</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>zero</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>one</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>two</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_ge</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_add</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_sub</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_div_trunc</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>two</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>DatumGetNumeric</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Numeric</name></type>
<name>numeric_shift_right</name><parameter_list>(<parameter><decl><type><name>Numeric</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>d</name> <init>= <expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>divisor_int64</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>divisor_numeric</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>divisor_int64</name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>count</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>divisor_numeric</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><name>divisor_int64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_div_trunc</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>divisor_numeric</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>DatumGetNumeric</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_size_pretty_numeric</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Numeric</name></type>        <name>size</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type>        <name>limit</name></decl>,
                <decl><type ref="prev"/><name>limit2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>limit</name> <operator>=</operator> <call><name>int64_to_numeric</name><argument_list>(<argument><expr><literal type="number">10</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>limit2</name> <operator>=</operator> <call><name>int64_to_numeric</name><argument_list>(<argument><expr><literal type="number">10</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">2</literal> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>numeric_is_less</name><argument_list>(<argument><expr><call><name>numeric_absolute</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s bytes"</literal></expr></argument>, <argument><expr><call><name>numeric_to_cstring</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* keep one extra bit for rounding */</comment>
        <comment type="block">/* size &gt;&gt;= 9 */</comment>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>numeric_shift_right</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>numeric_is_less</name><argument_list>(<argument><expr><call><name>numeric_absolute</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>limit2</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>numeric_half_rounded</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s kB"</literal></expr></argument>, <argument><expr><call><name>numeric_to_cstring</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* size &gt;&gt;= 10 */</comment>
            <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>numeric_shift_right</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>numeric_is_less</name><argument_list>(<argument><expr><call><name>numeric_absolute</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>limit2</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>numeric_half_rounded</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s MB"</literal></expr></argument>, <argument><expr><call><name>numeric_to_cstring</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* size &gt;&gt;= 10 */</comment>
                <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>numeric_shift_right</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>numeric_is_less</name><argument_list>(<argument><expr><call><name>numeric_absolute</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>limit2</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>numeric_half_rounded</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s GB"</literal></expr></argument>, <argument><expr><call><name>numeric_to_cstring</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* size &gt;&gt;= 10 */</comment>
                    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>numeric_shift_right</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>numeric_half_rounded</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s TB"</literal></expr></argument>, <argument><expr><call><name>numeric_to_cstring</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a human-readable size to a size in bytes
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_size_bytes</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>str</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>strptr</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>saved_char</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type>        <name>num</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>have_digits</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Skip leading whitespace */</comment>
    <expr_stmt><expr><name>strptr</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>strptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>strptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

    <comment type="block">/* Check that we have a valid number and determine where it ends */</comment>
    <expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>strptr</name></expr>;</expr_stmt>

    <comment type="block">/* Part (1): sign */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Part (2): main digit string */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>have_digits</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <do>do<block type="pseudo"><block_content>
            <expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block>
        while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Part (3): optional decimal point and fractional digits */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>have_digits</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <do>do<block type="pseudo"><block_content>
                <expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block>
            while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Complain if we don't have a valid number at this point */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_digits</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid size: \"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Part (4): optional exponent */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="char">'e'</literal> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type>        <name>exponent</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Note we might one day support EB units, so if what follows 'E'
         * isn't a number, just treat it all as a unit to be parsed.
         */</comment>
        <expr_stmt><expr><name>exponent</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>endptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>exponent</name></expr>;</expr_stmt>        <comment type="block">/* Silence -Wunused-result warnings */</comment>
        <if_stmt><if>if <condition>(<expr><name>cp</name> <operator>&gt;</operator> <name>endptr</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Parse the number, saving the next character, which may be the first
     * character of the unit string.
     */</comment>
    <expr_stmt><expr><name>saved_char</name> <operator>=</operator> <operator>*</operator><name>endptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>endptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>numeric_in</name></expr></argument>,
                                              <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>strptr</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>endptr</name> <operator>=</operator> <name>saved_char</name></expr>;</expr_stmt>

    <comment type="block">/* Skip whitespace between number and unit */</comment>
    <expr_stmt><expr><name>strptr</name> <operator>=</operator> <name>endptr</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>strptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>strptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

    <comment type="block">/* Handle possible unit */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>strptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int64</name></type>        <name>multiplier</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Trim any trailing whitespace */</comment>
        <expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>str</name> <operator>+</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>endptr</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

        <expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>endptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

        <comment type="block">/* Parse the unit case-insensitively */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>strptr</name></expr></argument>, <argument><expr><literal type="string">"bytes"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>multiplier</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>strptr</name></expr></argument>, <argument><expr><literal type="string">"kb"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>multiplier</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>strptr</name></expr></argument>, <argument><expr><literal type="string">"mb"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>multiplier</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">1024</literal><operator>)</operator> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></if>

        <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>strptr</name></expr></argument>, <argument><expr><literal type="string">"gb"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>multiplier</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">1024</literal><operator>)</operator> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></if>

        <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>strptr</name></expr></argument>, <argument><expr><literal type="string">"tb"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>multiplier</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">1024</literal><operator>)</operator> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></if>

        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid size: \"%s\""</literal></expr></argument>, <argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Invalid size unit: \"%s\"."</literal></expr></argument>, <argument><expr><name>strptr</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Valid units are \"bytes\", \"kB\", \"MB\", \"GB\", and \"TB\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>multiplier</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Numeric</name></type>        <name>mul_num</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>mul_num</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>,
                                                          <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>multiplier</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_mul</name></expr></argument>,
                                                      <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>mul_num</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_int8</name></expr></argument>,
                                               <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the filenode of a relation
 *
 * This is expected to be used in queries like
 *        SELECT pg_relation_filenode(oid) FROM pg_class;
 * That leads to a couple of choices.  We work from the pg_class row alone
 * rather than actually opening each relation, for efficiency.  We don't
 * fail if we can't find the relation --- some rows might be visible in
 * the query's MVCC snapshot even though the relations have been dropped.
 * (Note: we could avoid using the catcache, but there's little point
 * because the relation mapper also works "in the now".)  We also don't
 * fail if the relation doesn't have storage.  In all these cases it
 * seems better to quietly return NULL.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_relation_filenode</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relform</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>relform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>relform</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
        <case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
        <case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
        <case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
        <case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
            <comment type="block">/* okay, these have storage */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>relform</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>relform</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>                <comment type="block">/* Consult the relation mapper */</comment>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>RelationMapOidToFilenode</name><argument_list>(<argument><expr><name>relid</name></expr></argument>,
                                                  <argument><expr><name><name>relform</name><operator>-&gt;</operator><name>relisshared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>

        <default>default:</default>
            <comment type="block">/* no storage, return NULL */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the relation via (reltablespace, relfilenode)
 *
 * This is expected to be used when somebody wants to match an individual file
 * on the filesystem back to its table. That's not trivially possible via
 * pg_class, because that doesn't contain the relfilenodes of shared and nailed
 * tables.
 *
 * We don't fail but return NULL if we cannot find a mapping.
 *
 * InvalidOid can be passed instead of the current database's default
 * tablespace.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_filenode_relation</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>reltablespace</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relfilenode</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>heaprel</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>heaprel</name> <operator>=</operator> <call><name>RelidByRelfilenode</name><argument_list>(<argument><expr><name>reltablespace</name></expr></argument>, <argument><expr><name>relfilenode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>heaprel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>heaprel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the pathname (relative to $PGDATA) of a relation
 *
 * See comments for pg_relation_filenode.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_relation_filepath</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BackendId</name></type>    <name>backend</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>relform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>relform</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
        <case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
        <case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
        <case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
        <case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
            <comment type="block">/* okay, these have storage */</comment>

            <comment type="block">/* This logic should match RelationInitPhysicalAddr */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>relform</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <name><name>relform</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <name>MyDatabaseTableSpace</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>relform</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <name><name>relform</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>                <comment type="block">/* Consult the relation mapper */</comment>
                <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <call><name>RelationMapOidToFilenode</name><argument_list>(<argument><expr><name>relid</name></expr></argument>,
                                                         <argument><expr><name><name>relform</name><operator>-&gt;</operator><name>relisshared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>

        <default>default:</default>
            <comment type="block">/* no storage, return NULL */</comment>
            <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
            <comment type="block">/* some compilers generate warnings without these next two lines */</comment>
            <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Determine owning backend. */</comment>
    <switch>switch <condition>(<expr><name><name>relform</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>RELPERSISTENCE_UNLOGGED</name></expr>:</case>
        <case>case <expr><name>RELPERSISTENCE_PERMANENT</name></expr>:</case>
            <expr_stmt><expr><name>backend</name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RELPERSISTENCE_TEMP</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>isTempOrTempToastNamespace</name><argument_list>(<argument><expr><name><name>relform</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
                <expr_stmt><expr><name>backend</name> <operator>=</operator> <ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>MyCoordId</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidBackendId</name></expr> </then><else>: <expr><name>MyBackendId</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><name>backend</name> <operator>=</operator> <call><name>BackendIdForTempRelations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if_stmt><else>else
            <block>{<block_content>
                <comment type="block">/* Do it the hard way. */</comment>
                <expr_stmt><expr><name>backend</name> <operator>=</operator> <call><name>GetTempNamespaceBackendId</name><argument_list>(<argument><expr><name><name>relform</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>backend</name> <operator>!=</operator> <name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid relpersistence: %c"</literal></expr></argument>, <argument><expr><name><name>relform</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>backend</name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt> <comment type="block">/* placate compiler */</comment>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>relpathbackend</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>backend</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>

<comment type="block">/*
 * pgxc_tablespace_size
 * Given a tablespace oid, return sum of pg_tablespace_size() executed on all the Datanodes
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>pgxc_tablespace_size</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tsOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfoData</name></type>  <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>           <modifier>*</modifier></type><name>tsname</name> <init>= <expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>tsOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>                <modifier>*</modifier></type><name>coOids</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dnOids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numdnodes</name></decl>, <decl><type ref="prev"/><name>numcoords</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tsname</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><name>ERRCODE_UNDEFINED_OBJECT</name><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tablespace with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>tsOid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.pg_tablespace_size('%s')"</literal></expr></argument>, <argument><expr><name>tsname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PgxcNodeGetOids</name><argument_list>(<argument><expr><operator>&amp;</operator><name>coOids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dnOids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numcoords</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numdnodes</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>pgxc_execute_on_nodes</name><argument_list>(<argument><expr><name>numdnodes</name></expr></argument>, <argument><expr><name>dnOids</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>pgxc_allocated_tablespace_size</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tsOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfoData</name></type>  <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>           <modifier>*</modifier></type><name>tsname</name> <init>= <expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>tsOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>                <modifier>*</modifier></type><name>coOids</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dnOids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numdnodes</name></decl>, <decl><type ref="prev"/><name>numcoords</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tsname</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><name>ERRCODE_UNDEFINED_OBJECT</name><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tablespace with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>tsOid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.pg_allocated_tablespace_size('%s')"</literal></expr></argument>, <argument><expr><name>tsname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PgxcNodeGetOids</name><argument_list>(<argument><expr><operator>&amp;</operator><name>coOids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dnOids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numcoords</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numdnodes</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>pgxc_execute_on_nodes</name><argument_list>(<argument><expr><name>numdnodes</name></expr></argument>, <argument><expr><name>dnOids</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * pgxc_database_size
 * Given a dboid, return sum of pg_database_size() executed on all the Datanodes
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>pgxc_database_size</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dbOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfoData</name></type>  <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>           <modifier>*</modifier></type><name>dbname</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>dbOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>                <modifier>*</modifier></type><name>coOids</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dnOids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numdnodes</name></decl>, <decl><type ref="prev"/><name>numcoords</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dbname</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><name>ERRCODE_UNDEFINED_DATABASE</name><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>dbOid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.pg_database_size('%s')"</literal></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PgxcNodeGetOids</name><argument_list>(<argument><expr><operator>&amp;</operator><name>coOids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dnOids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numcoords</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numdnodes</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>pgxc_execute_on_nodes</name><argument_list>(<argument><expr><name>numdnodes</name></expr></argument>, <argument><expr><name>dnOids</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>pgxc_allocated_database_size</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dbOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfoData</name></type>  <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>           <modifier>*</modifier></type><name>dbname</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>dbOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>                <modifier>*</modifier></type><name>coOids</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dnOids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numdnodes</name></decl>, <decl><type ref="prev"/><name>numcoords</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dbname</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><name>ERRCODE_UNDEFINED_DATABASE</name><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>dbOid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.pg_allocated_database_size('%s')"</literal></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PgxcNodeGetOids</name><argument_list>(<argument><expr><operator>&amp;</operator><name>coOids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dnOids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numcoords</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numdnodes</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>pgxc_execute_on_nodes</name><argument_list>(<argument><expr><name>numdnodes</name></expr></argument>, <argument><expr><name>dnOids</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * pgxc_execute_on_nodes
 * Execute 'query' on all the nodes in 'nodelist', and returns int64 datum
 * which has the sum of all the results. If multiples nodes are involved, it
 * assumes that the query returns exactly one row with one attribute of type
 * int64. If there is a single node, it just returns the datum as-is without
 * checking the type of the returned value.
 *
 * Note: nodelist should either have all coordinators or all datanodes in it.
 * Mixing both will result an error being thrown
 */</comment>
<function><type><name>Datum</name></type>
<name>pgxc_execute_on_nodes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numnodes</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>nodelist</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>           <name>total_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>           <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>            <name>datum</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <decl_stmt><decl><type><name>EState</name>           <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>    <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQuery</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQueryState</name>   <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Var</name>               <modifier>*</modifier></type><name>dummy</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Make up RemoteQuery plan node
     */</comment>
    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_NONE</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numnodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name>ntype</name> <init>= <expr><name>PGXC_NODE_NONE</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>,
            <argument><expr><call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name><name>nodelist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ntype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ntype</name> <operator>==</operator> <name>PGXC_NODE_NONE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unknown node Oid: %u"</literal></expr></argument>, <argument><expr><name><name>nodelist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>ntype</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name></expr>)</condition> 
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>==</operator> <name>EXEC_ON_DATANODES</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cannot mix datanodes and coordinators"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_COORDS</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>==</operator> <name>EXEC_ON_COORDS</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cannot mix datanodes and coordinators"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

    </block_content>}</block></for>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <name>query</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>force_autocommit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <comment type="block">/*
     * We only need the target entry to determine result data type.
     * So create dummy even if real expression is a function.
     */</comment>
    <expr_stmt><expr><name>dummy</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                      <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>dummy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* prepare to execute */</comment>
    <expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>ExecInitRemoteQuery</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* For single node, don't assume the type of datum. It can be bool also. */</comment>
        <if_stmt><if>if <condition>(<expr><name>numnodes</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <comment type="block">/* We should not cast a null into an int */</comment>
        <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Expected Int64 but got null instead "</literal>
                        <literal type="string">"while executing query '%s'"</literal></expr></argument>,
                        <argument><expr><name>query</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>total_size</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>ExecEndRemoteQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/*
     * Connect to SPI manager
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>SPI_connect</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <comment type="block">/* internal error */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI connect failure - returned %d"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get pg_***_size function results from all Datanodes */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numnodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>nodename</name> <operator>=</operator> <call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name><name>nodelist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>SPI_execute_direct</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>spi_tupdesc</name> <operator>=</operator> <name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>SPI_OK_SELECT</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to execute query '%s' on node '%s'"</literal></expr></argument>,
                            <argument><expr><name>query</name></expr></argument>, <argument><expr><name>nodename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * The query must always return one row having one column:
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>SPI_processed</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>spi_tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>spi_tupdesc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* For single node, don't assume the type of datum. It can be bool also. */</comment>
        <if_stmt><if>if <condition>(<expr><name>numnodes</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>total_size</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>numnodes</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* 
         * if result is NULL, so no need to check isnull value, just return 0
         * isnull also needs explict asignment.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>isnull</name> 
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
            <operator>&amp;&amp;</operator> <operator>(</operator><name>NULL</name> <operator>!=</operator> <name>result</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>            
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Expected datum but got null instead "</literal>
                        <literal type="string">"while executing query '%s'"</literal></expr></argument>,
                        <argument><expr><name>query</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>total_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pgxc_exec_sizefunc
 * Execute the given object size system function on all the Datanodes associated
 * with relOid, and return the sum of all.
 *
 * Args:
 *
 * relOid: Oid of the table for which the object size function is to be executed.
 *
 * funcname: Name of the system function.
 *
 * extra_arg: The first argument to such sys functions is always table name.
 * Some functions can have a second argument. To pass this argument, extra_arg
 * is used. Currently only pg_relation_size() is the only one that requires
 * a 2nd argument: fork text.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>pgxc_exec_sizefunc</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>extra_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>             <name>numnodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>            <modifier>*</modifier></type><name>nodelist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>           <modifier>*</modifier></type><name>relname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type>  <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>        <name>rel</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr>)</condition><block type="pseudo"><block_content>
    <comment type="block">/* get relation name including any needed schema prefix and quoting */</comment>
    <expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>extra_arg</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.%s('%s')"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.%s('%s', '%s')"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>extra_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>numnodes</name> <operator>=</operator> <call><name>get_pgxc_classnodes</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>pgxc_execute_on_nodes</name><argument_list>(<argument><expr><name>numnodes</name></expr></argument>, <argument><expr><name>nodelist</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>
</unit>
