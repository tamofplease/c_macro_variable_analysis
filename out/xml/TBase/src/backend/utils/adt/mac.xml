<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/adt/mac.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * mac.c
 *      PostgreSQL type definitions for 6 byte, EUI-48, MAC addresses.
 *
 * Portions Copyright (c) 1998-2017, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *          src/backend/utils/adt/mac.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/hyperloglog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_bswap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sortsupport.h"</cpp:file></cpp:include>


<comment type="block">/*
 *    Utility macros used for sorting and comparing:
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hibits</name><parameter_list>(<parameter><type><name>addr</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>((unsigned long)(((addr)-&gt;a&lt;&lt;16)|((addr)-&gt;b&lt;&lt;8)|((addr)-&gt;c)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lobits</name><parameter_list>(<parameter><type><name>addr</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>((unsigned long)(((addr)-&gt;d&lt;&lt;16)|((addr)-&gt;e&lt;&lt;8)|((addr)-&gt;f)))</cpp:value></cpp:define>

<comment type="block">/* sortsupport for macaddr */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int64</name></type>        <name>input_count</name></decl>;</decl_stmt>    <comment type="block">/* number of non-null values seen */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>estimating</name></decl>;</decl_stmt>        <comment type="block">/* true if estimating cardinality */</comment>

    <decl_stmt><decl><type><name>hyperLogLogState</name></type> <name>abbr_card</name></decl>;</decl_stmt> <comment type="block">/* cardinality estimator */</comment>
}</block></struct></type> <name>macaddr_sortsupport_state</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>macaddr_cmp_internal</name><parameter_list>(<parameter><decl><type><name>macaddr</name> <modifier>*</modifier></type><name>a1</name></decl></parameter>, <parameter><decl><type><name>macaddr</name> <modifier>*</modifier></type><name>a2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>macaddr_fast_cmp</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>macaddr_cmp_abbrev</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>macaddr_abbrev_abort</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>memtupcount</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>macaddr_abbrev_convert</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>original</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 *    MAC address reader.  Accepts several common notations.
 */</comment>

<function><type><name>Datum</name></type>
<name>macaddr_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>a</name></decl>,
                <decl><type ref="prev"/><name>b</name></decl>,
                <decl><type ref="prev"/><name>c</name></decl>,
                <decl><type ref="prev"/><name>d</name></decl>,
                <decl><type ref="prev"/><name>e</name></decl>,
                <decl><type ref="prev"/><name>f</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>junk</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>count</name></decl>;</decl_stmt>

    <comment type="block">/* %1s matches iff there is trailing non-whitespace garbage */</comment>

    <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%x:%x:%x:%x:%x:%x%1s"</literal></expr></argument>,
                   <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><name>junk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%x-%x-%x-%x-%x-%x%1s"</literal></expr></argument>,
                       <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><name>junk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%2x%2x%2x:%2x%2x%2x%1s"</literal></expr></argument>,
                       <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><name>junk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%2x%2x%2x-%2x%2x%2x%1s"</literal></expr></argument>,
                       <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><name>junk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%2x%2x.%2x%2x.%2x%2x%1s"</literal></expr></argument>,
                       <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><name>junk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%2x%2x-%2x%2x-%2x%2x%1s"</literal></expr></argument>,
                       <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><name>junk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%2x%2x%2x%2x%2x%2x%1s"</literal></expr></argument>,
                       <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><name>junk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>, <argument><expr><literal type="string">"macaddr"</literal></expr></argument>,
                        <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>a</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>a</name> <operator>&gt;</operator> <literal type="number">255</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>b</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>b</name> <operator>&gt;</operator> <literal type="number">255</literal><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>c</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>c</name> <operator>&gt;</operator> <literal type="number">255</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>d</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>d</name> <operator>&gt;</operator> <literal type="number">255</literal><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>e</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>e</name> <operator>&gt;</operator> <literal type="number">255</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>f</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>f</name> <operator>&gt;</operator> <literal type="number">255</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid octet value in \"macaddr\" value: \"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>macaddr</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>macaddr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>c</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>d</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>e</name></name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_MACADDR_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    MAC address output function.  Fixed format.
 */</comment>

<function><type><name>Datum</name></type>
<name>macaddr_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>addr</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="string">"%02x:%02x:%02x:%02x:%02x:%02x"</literal></expr></argument>,
             <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>c</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>d</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>e</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        macaddr_recv            - converts external binary format to macaddr
 *
 * The external representation is just the six bytes, MSB first.
 */</comment>
<function><type><name>Datum</name></type>
<name>macaddr_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfo</name></type>    <name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>addr</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>addr</name> <operator>=</operator> <operator>(</operator><name>macaddr</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>macaddr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>addr</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addr</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addr</name><operator>-&gt;</operator><name>c</name></name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addr</name><operator>-&gt;</operator><name>d</name></name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addr</name><operator>-&gt;</operator><name>e</name></name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addr</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_MACADDR_P</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        macaddr_send            - converts macaddr to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>macaddr_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>addr</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>d</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>e</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *    Comparison function for sorting:
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>macaddr_cmp_internal</name><parameter_list>(<parameter><decl><type><name>macaddr</name> <modifier>*</modifier></type><name>a1</name></decl></parameter>, <parameter><decl><type><name>macaddr</name> <modifier>*</modifier></type><name>a2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>hibits</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>hibits</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>hibits</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>hibits</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>lobits</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>lobits</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>lobits</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>lobits</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>macaddr_cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>a1</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>a2</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>macaddr_cmp_internal</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    Boolean comparisons.
 */</comment>

<function><type><name>Datum</name></type>
<name>macaddr_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>a1</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>a2</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>macaddr_cmp_internal</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>macaddr_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>a1</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>a2</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>macaddr_cmp_internal</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>macaddr_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>a1</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>a2</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>macaddr_cmp_internal</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>macaddr_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>a1</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>a2</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>macaddr_cmp_internal</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>macaddr_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>a1</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>a2</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>macaddr_cmp_internal</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>macaddr_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>a1</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>a2</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>macaddr_cmp_internal</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Support function for hash indexes on macaddr.
 */</comment>
<function><type><name>Datum</name></type>
<name>hashmacaddr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>macaddr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>hashmacaddrextended</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>hash_any_extended</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>macaddr</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							 <argument><expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Arithmetic functions: bitwise NOT, AND, OR.
 */</comment>
<function><type><name>Datum</name></type>
<name>macaddr_not</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>addr</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>macaddr</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>macaddr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <operator>~</operator><name><name>addr</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <operator>~</operator><name><name>addr</name><operator>-&gt;</operator><name>b</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>c</name></name> <operator>=</operator> <operator>~</operator><name><name>addr</name><operator>-&gt;</operator><name>c</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>d</name></name> <operator>=</operator> <operator>~</operator><name><name>addr</name><operator>-&gt;</operator><name>d</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>e</name></name> <operator>=</operator> <operator>~</operator><name><name>addr</name><operator>-&gt;</operator><name>e</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <operator>~</operator><name><name>addr</name><operator>-&gt;</operator><name>f</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_MACADDR_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>macaddr_and</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>addr1</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>addr2</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>macaddr</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>macaddr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <name><name>addr1</name><operator>-&gt;</operator><name>a</name></name> <operator>&amp;</operator> <name><name>addr2</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name><name>addr1</name><operator>-&gt;</operator><name>b</name></name> <operator>&amp;</operator> <name><name>addr2</name><operator>-&gt;</operator><name>b</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>c</name></name> <operator>=</operator> <name><name>addr1</name><operator>-&gt;</operator><name>c</name></name> <operator>&amp;</operator> <name><name>addr2</name><operator>-&gt;</operator><name>c</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>d</name></name> <operator>=</operator> <name><name>addr1</name><operator>-&gt;</operator><name>d</name></name> <operator>&amp;</operator> <name><name>addr2</name><operator>-&gt;</operator><name>d</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>e</name></name> <operator>=</operator> <name><name>addr1</name><operator>-&gt;</operator><name>e</name></name> <operator>&amp;</operator> <name><name>addr2</name><operator>-&gt;</operator><name>e</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name><name>addr1</name><operator>-&gt;</operator><name>f</name></name> <operator>&amp;</operator> <name><name>addr2</name><operator>-&gt;</operator><name>f</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_MACADDR_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>macaddr_or</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>addr1</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>addr2</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>macaddr</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>macaddr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <name><name>addr1</name><operator>-&gt;</operator><name>a</name></name> <operator>|</operator> <name><name>addr2</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name><name>addr1</name><operator>-&gt;</operator><name>b</name></name> <operator>|</operator> <name><name>addr2</name><operator>-&gt;</operator><name>b</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>c</name></name> <operator>=</operator> <name><name>addr1</name><operator>-&gt;</operator><name>c</name></name> <operator>|</operator> <name><name>addr2</name><operator>-&gt;</operator><name>c</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>d</name></name> <operator>=</operator> <name><name>addr1</name><operator>-&gt;</operator><name>d</name></name> <operator>|</operator> <name><name>addr2</name><operator>-&gt;</operator><name>d</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>e</name></name> <operator>=</operator> <name><name>addr1</name><operator>-&gt;</operator><name>e</name></name> <operator>|</operator> <name><name>addr2</name><operator>-&gt;</operator><name>e</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name><name>addr1</name><operator>-&gt;</operator><name>f</name></name> <operator>|</operator> <name><name>addr2</name><operator>-&gt;</operator><name>f</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_MACADDR_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    Truncation function to allow comparing mac manufacturers.
 *    From suggestion by Alex Pilosov &lt;alex@pilosoft.com&gt;
 */</comment>
<function><type><name>Datum</name></type>
<name>macaddr_trunc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>addr</name> <init>= <expr><call><name>PG_GETARG_MACADDR_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>macaddr</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>macaddr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <name><name>addr</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name><name>addr</name><operator>-&gt;</operator><name>b</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>c</name></name> <operator>=</operator> <name><name>addr</name><operator>-&gt;</operator><name>c</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>d</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>e</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_MACADDR_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SortSupport strategy function. Populates a SortSupport struct with the
 * information necessary to use comparison by abbreviated keys.
 */</comment>
<function><type><name>Datum</name></type>
<name>macaddr_sortsupport</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SortSupport</name></type> <name>ssup</name> <init>= <expr><operator>(</operator><name>SortSupport</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>comparator</name></name> <operator>=</operator> <name>macaddr_fast_cmp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>ssup_extra</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>ssup</name><operator>-&gt;</operator><name>abbreviate</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>macaddr_sortsupport_state</name> <modifier>*</modifier></type><name>uss</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ssup</name><operator>-&gt;</operator><name>ssup_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>uss</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>macaddr_sortsupport_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>uss</name><operator>-&gt;</operator><name>input_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>uss</name><operator>-&gt;</operator><name>estimating</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>initHyperLogLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>uss</name><operator>-&gt;</operator><name>abbr_card</name></name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>ssup_extra</name></name> <operator>=</operator> <name>uss</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>comparator</name></name> <operator>=</operator> <name>macaddr_cmp_abbrev</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>abbrev_converter</name></name> <operator>=</operator> <name>macaddr_abbrev_convert</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>abbrev_abort</name></name> <operator>=</operator> <name>macaddr_abbrev_abort</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>abbrev_full_comparator</name></name> <operator>=</operator> <name>macaddr_fast_cmp</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SortSupport "traditional" comparison function. Pulls two MAC addresses from
 * the heap and runs a standard comparison on them.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>macaddr_fast_cmp</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>DatumGetMacaddrP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>DatumGetMacaddrP</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>macaddr_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SortSupport abbreviated key comparison function. Compares two MAC addresses
 * quickly by treating them like integers, and without having to go to the
 * heap.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>macaddr_cmp_abbrev</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;</operator> <name>y</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>x</name> <operator>==</operator> <name>y</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Callback for estimating effectiveness of abbreviated key optimization.
 *
 * We pay no attention to the cardinality of the non-abbreviated data, because
 * there is no equality fast-path within authoritative macaddr comparator.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>macaddr_abbrev_abort</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>memtupcount</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>macaddr_sortsupport_state</name> <modifier>*</modifier></type><name>uss</name> <init>= <expr><name><name>ssup</name><operator>-&gt;</operator><name>ssup_extra</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>abbr_card</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>memtupcount</name> <operator>&lt;</operator> <literal type="number">10000</literal> <operator>||</operator> <name><name>uss</name><operator>-&gt;</operator><name>input_count</name></name> <operator>&lt;</operator> <literal type="number">10000</literal> <operator>||</operator> <operator>!</operator><name><name>uss</name><operator>-&gt;</operator><name>estimating</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>abbr_card</name> <operator>=</operator> <call><name>estimateHyperLogLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>uss</name><operator>-&gt;</operator><name>abbr_card</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we have &gt;100k distinct values, then even if we were sorting many
     * billion rows we'd likely still break even, and the penalty of undoing
     * that many rows of abbrevs would probably not be worth it. At this point
     * we stop counting because we know that we're now fully committed.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>abbr_card</name> <operator>&gt;</operator> <literal type="number">100000.0</literal></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                 <argument><expr><literal type="string">"macaddr_abbrev: estimation ends at cardinality %f"</literal>
                 <literal type="string">" after "</literal> <name>INT64_FORMAT</name> <literal type="string">" values (%d rows)"</literal></expr></argument>,
                 <argument><expr><name>abbr_card</name></expr></argument>, <argument><expr><name><name>uss</name><operator>-&gt;</operator><name>input_count</name></name></expr></argument>, <argument><expr><name>memtupcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name><name>uss</name><operator>-&gt;</operator><name>estimating</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Target minimum cardinality is 1 per ~2k of non-null inputs. 0.5 row
     * fudge factor allows us to abort earlier on genuinely pathological data
     * where we've had exactly one abbreviated value in the first 2k
     * (non-null) rows.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>abbr_card</name> <operator>&lt;</operator> <name><name>uss</name><operator>-&gt;</operator><name>input_count</name></name> <operator>/</operator> <literal type="number">2000.0</literal> <operator>+</operator> <literal type="number">0.5</literal></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                 <argument><expr><literal type="string">"macaddr_abbrev: aborting abbreviation at cardinality %f"</literal>
                 <literal type="string">" below threshold %f after "</literal> <name>INT64_FORMAT</name> <literal type="string">" values (%d rows)"</literal></expr></argument>,
                 <argument><expr><name>abbr_card</name></expr></argument>, <argument><expr><name><name>uss</name><operator>-&gt;</operator><name>input_count</name></name> <operator>/</operator> <literal type="number">2000.0</literal> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>, <argument><expr><name><name>uss</name><operator>-&gt;</operator><name>input_count</name></name></expr></argument>,
                 <argument><expr><name>memtupcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
             <argument><expr><literal type="string">"macaddr_abbrev: cardinality %f after "</literal> <name>INT64_FORMAT</name>
             <literal type="string">" values (%d rows)"</literal></expr></argument>, <argument><expr><name>abbr_card</name></expr></argument>, <argument><expr><name><name>uss</name><operator>-&gt;</operator><name>input_count</name></name></expr></argument>, <argument><expr><name>memtupcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SortSupport conversion routine. Converts original macaddr representation
 * to abbreviated key representation.
 *
 * Packs the bytes of a 6-byte MAC address into a Datum and treats it as an
 * unsigned integer for purposes of comparison. On a 64-bit machine, there
 * will be two zeroed bytes of padding. The integer is converted to native
 * endianness to facilitate easy comparison.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>macaddr_abbrev_convert</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>original</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>macaddr_sortsupport_state</name> <modifier>*</modifier></type><name>uss</name> <init>= <expr><name><name>ssup</name><operator>-&gt;</operator><name>ssup_extra</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>macaddr</name>    <modifier>*</modifier></type><name>authoritative</name> <init>= <expr><call><name>DatumGetMacaddrP</name><argument_list>(<argument><expr><name>original</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>res</name></decl>;</decl_stmt>

    <comment type="block">/*
     * On a 64-bit machine, zero out the 8-byte datum and copy the 6 bytes of
     * the MAC address in. There will be two bytes of zero padding on the end
     * of the least significant bits.
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_DATUM</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SIZEOF_DATUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>res</name></expr></argument>, <argument><expr><name>authoritative</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>macaddr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>                            <comment type="block">/* SIZEOF_DATUM != 8 */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>res</name></expr></argument>, <argument><expr><name>authoritative</name></expr></argument>, <argument><expr><name>SIZEOF_DATUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>uss</name><operator>-&gt;</operator><name>input_count</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Cardinality estimation. The estimate uses uint32, so on a 64-bit
     * architecture, XOR the two 32-bit halves together to produce slightly
     * more entropy. The two zeroed bytes won't have any practical impact on
     * this operation.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>uss</name><operator>-&gt;</operator><name>estimating</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint32</name></type>        <name>tmp</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_DATUM</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>res</name> <operator>^</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>res</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>                            <comment type="block">/* SIZEOF_DATUM != 8 */</comment>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>res</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>addHyperLogLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>uss</name><operator>-&gt;</operator><name>abbr_card</name></name></expr></argument>, <argument><expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Byteswap on little-endian machines.
     *
     * This is needed so that macaddr_cmp_abbrev() (an unsigned integer 3-way
     * comparator) works correctly on all platforms. Without this, the
     * comparator would have to call memcmp() with a pair of pointers to the
     * first byte of each abbreviated key, which is slower.
     */</comment>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>DatumBigEndianToNative</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
</unit>
