<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/adt/geo_ops.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * geo_ops.c
 *      2D geometric operations
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/utils/adt/geo_ops.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/geo_decls.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>M_PI</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_PI</name></cpp:macro> <cpp:value>3.14159265358979323846</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * Internal routines
 */</comment>

<enum>enum <name>path_delim</name>
<block>{
    <decl><name>PATH_NONE</name></decl>, <decl><name>PATH_OPEN</name></decl>, <decl><name>PATH_CLOSED</name></decl>
}</block>;</enum>

<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>point_inside</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>npts</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>plist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>lseg_crossing</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>px</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>py</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BOX</name> <modifier>*</modifier></type><name>box_construct</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>x2</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>y1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>y2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BOX</name> <modifier>*</modifier></type><name>box_copy</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BOX</name> <modifier>*</modifier></type><name>box_fill</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>x1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>x2</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>y1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>y2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>box_ov</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box1</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>box_ht</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>box_wd</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>circle_ar</name><parameter_list>(<parameter><decl><type><name>CIRCLE</name> <modifier>*</modifier></type><name>circle</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CIRCLE</name> <modifier>*</modifier></type><name>circle_copy</name><parameter_list>(<parameter><decl><type><name>CIRCLE</name> <modifier>*</modifier></type><name>circle</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>LINE</name> <modifier>*</modifier></type><name>line_construct_pm</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>m</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>line_construct_pts</name><parameter_list>(<parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>lseg_intersect_internal</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>l1</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>l2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>lseg_dt</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>l1</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>l2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>on_ps_internal</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_bound_box</name><parameter_list>(<parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>poly</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>plist_same</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>npts</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Point</name> <modifier>*</modifier></type><name>point_construct</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>y</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Point</name> <modifier>*</modifier></type><name>point_copy</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>single_decode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>num</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endptr_p</name></decl></parameter>,
              <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig_string</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>single_encode</name><parameter_list>(<parameter><decl><type><name>float8</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pair_decode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>y</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endptr_p</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig_string</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pair_encode</name><parameter_list>(<parameter><decl><type><name>float8</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>pair_count</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>delim</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>path_decode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>opentype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>npts</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
            <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isopen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endptr_p</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig_string</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>path_encode</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>path_delim</name></name></type> <name>path_delim</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>npts</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>statlseg_construct</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>box_ar</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>box_cn</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>center</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Point</name> <modifier>*</modifier></type><name>interpt_sl</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>has_interpt_sl</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>dist_pl_internal</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>dist_ps_internal</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Point</name> <modifier>*</modifier></type><name>line_interpt_internal</name><parameter_list>(<parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>l1</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>l2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>lseg_inside_poly</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>poly</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Point</name> <modifier>*</modifier></type><name>lseg_interpt_internal</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>l1</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>l2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>dist_ppoly_internal</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>poly</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Delimiters for input and output strings.
 * LDELIM, RDELIM, and DELIM are left, right, and separator delimiters, respectively.
 * LDELIM_EP, RDELIM_EP are left and right delimiters for paths with endpoints.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDELIM</name></cpp:macro>            <cpp:value>'('</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RDELIM</name></cpp:macro>            <cpp:value>')'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELIM</name></cpp:macro>            <cpp:value>','</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDELIM_EP</name></cpp:macro>        <cpp:value>'['</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RDELIM_EP</name></cpp:macro>        <cpp:value>']'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDELIM_C</name></cpp:macro>        <cpp:value>'&lt;'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RDELIM_C</name></cpp:macro>        <cpp:value>'&gt;'</cpp:value></cpp:define>


<comment type="block">/*
 * Geometric data types are composed of points.
 * This code tries to support a common format throughout the data types,
 *    to allow for more predictable usage and data type conversion.
 * The fundamental unit is the point. Other units are line segments,
 *    open paths, boxes, closed paths, and polygons (which should be considered
 *    non-intersecting closed paths).
 *
 * Data representation is as follows:
 *    point:                (x,y)
 *    line segment:        [(x1,y1),(x2,y2)]
 *    box:                (x1,y1),(x2,y2)
 *    open path:            [(x1,y1),...,(xn,yn)]
 *    closed path:        ((x1,y1),...,(xn,yn))
 *    polygon:            ((x1,y1),...,(xn,yn))
 *
 * For boxes, the points are opposite corners with the first point at the top right.
 * For closed paths and polygons, the points should be reordered to allow
 *    fast and correct equality comparisons.
 *
 * XXX perhaps points in complex shapes should be reordered internally
 *    to allow faster internal operations, but should keep track of input order
 *    and restore that order for text output - tgl 97/01/16
 */</comment>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>single_decode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>num</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endptr_p</name></decl></parameter>,
              <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>float8in_internal</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>endptr_p</name></expr></argument>, <argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>                                <comment type="block">/* single_decode() */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>single_encode</name><parameter_list>(<parameter><decl><type><name>float8</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>xstr</name> <init>= <expr><call><name>float8out_internal</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>xstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>xstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>                                <comment type="block">/* single_encode() */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pair_decode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>y</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endptr_p</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig_string</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>has_delim</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>has_delim</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>str</name> <operator>==</operator> <name>LDELIM</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>x</name> <operator>=</operator> <call><name>float8in_internal</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name><operator>++</operator> <operator>!=</operator> <name>DELIM</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
                        <argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>y</name> <operator>=</operator> <call><name>float8in_internal</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>has_delim</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name><operator>++</operator> <operator>!=</operator> <name>RDELIM</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
                            <argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* report stopping point if wanted, else complain if not end of string */</comment>
    <if_stmt><if>if <condition>(<expr><name>endptr_p</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>endptr_p</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
                        <argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pair_encode</name><parameter_list>(<parameter><decl><type><name>float8</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>xstr</name> <init>= <expr><call><name>float8out_internal</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ystr</name> <init>= <expr><call><name>float8out_internal</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%s,%s"</literal></expr></argument>, <argument><expr><name>xstr</name></expr></argument>, <argument><expr><name>ystr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>xstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ystr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>path_decode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>opentype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>npts</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
            <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isopen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endptr_p</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig_string</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>isopen</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>str</name> <operator>==</operator> <name>LDELIM_EP</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* no open delimiter allowed? */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opentype</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
                            <argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <name>LDELIM</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>cp</name> <operator>=</operator> <operator>(</operator><name>str</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <name>LDELIM</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>str</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strrchr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>LDELIM</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>str</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>str</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pair_decode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <name>DELIM</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <while>while <condition>(<expr><name>depth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>str</name> <operator>==</operator> <name>RDELIM</name><operator>)</operator>
            <operator>||</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>str</name> <operator>==</operator> <name>RDELIM_EP</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>isopen</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>depth</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>depth</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
            <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
                            <argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* report stopping point if wanted, else complain if not end of string */</comment>
    <if_stmt><if>if <condition>(<expr><name>endptr_p</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>endptr_p</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
                        <argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>                                <comment type="block">/* path_decode() */</comment>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>path_encode</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>path_delim</name></name></type> <name>path_delim</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>npts</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>path_delim</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PATH_CLOSED</name></expr>:</case>
            <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>LDELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PATH_OPEN</name></expr>:</case>
            <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>LDELIM_EP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PATH_NONE</name></expr>:</case>
            <break>break;</break>
    </block_content>}</block></switch>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>LDELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pair_encode</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>RDELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pt</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <switch>switch <condition>(<expr><name>path_delim</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PATH_CLOSED</name></expr>:</case>
            <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>RDELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PATH_OPEN</name></expr>:</case>
            <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>RDELIM_EP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PATH_NONE</name></expr>:</case>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name><name>str</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>                                <comment type="block">/* path_encode() */</comment>

<comment type="block">/*-------------------------------------------------------------
 * pair_count - count the number of points
 * allow the following notation:
 * '((1,2),(3,4))'
 * '(1,3,2,4)'
 * require an odd number of delim characters in the string
 *-------------------------------------------------------------*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pair_count</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>delim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>ndelim</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>s</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ndelim</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>ndelim</name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>ndelim</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 **
 **        Routines for two-dimensional boxes.
 **
 ***********************************************************************/</comment>

<comment type="block">/*----------------------------------------------------------
 * Formatting and conversion routines.
 *---------------------------------------------------------*/</comment>

<comment type="block">/*        box_in    -        convert a string to internal form.
 *
 *        External format: (two corners of box)
 *                "(f8, f8), (f8, f8)"
 *                also supports the older style "(f8, f8, f8, f8)"
 */</comment>
<function><type><name>Datum</name></type>
<name>box_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isopen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>x</name></decl>,
                <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>path_decode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isopen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"box"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* reorder corners if necessary... */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>&lt;</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>&lt;</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>y</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        box_out -        convert a box to external form.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>path_encode</name><argument_list>(<argument><expr><name>PATH_NONE</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        box_recv            - converts external binary format to box
 */</comment>
<function><type><name>Datum</name></type>
<name>box_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfo</name></type>    <name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>x</name></decl>,
                <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>box</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* reorder corners if necessary... */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>&lt;</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>&lt;</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>y</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        box_send            - converts box to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>box_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*        box_construct    -        fill in a new box.
 */</comment>
<function><type><specifier>static</specifier> <name>BOX</name> <modifier>*</modifier></type>
<name>box_construct</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>x2</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>y1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>y2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>box_fill</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>x1</name></expr></argument>, <argument><expr><name>x2</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>, <argument><expr><name>y2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*        box_fill        -        fill in a given box struct
 */</comment>
<function><type><specifier>static</specifier> <name>BOX</name> <modifier>*</modifier></type>
<name>box_fill</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>x1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>x2</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>y1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>y2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>x1</name> <operator>&gt;</operator> <name>x2</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name>x1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name>x2</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name>x2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name>x1</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>y1</name> <operator>&gt;</operator> <name>y2</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name>y1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name>y2</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name>y2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name>y1</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*        box_copy        -        copy a box
 */</comment>
<function><type><specifier>static</specifier> <name>BOX</name> <modifier>*</modifier></type>
<name>box_copy</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>result</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>box</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *    Relational operators for BOXes.
 *        &lt;, &gt;, &lt;=, &gt;=, and == are based on box area.
 *---------------------------------------------------------*/</comment>

<comment type="block">/*        box_same        -        are two boxes identical?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_same</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FPeq</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FPeq</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FPeq</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        box_overlap        -        does box1 overlap box2?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_overlap</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>box_ov</name><argument_list>(<argument><expr><name>box1</name></expr></argument>, <argument><expr><name>box2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>box_ov</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box1</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>FPle</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>FPle</name><argument_list>(<argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>FPle</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>FPle</name><argument_list>(<argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*        box_left        -        is box1 strictly left of box2?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_left</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPlt</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        box_overleft    -        is the right edge of box1 at or left of
 *                                the right edge of box2?
 *
 *        This is "less than or equal" for the end of a time range,
 *        when time ranges are stored as rectangles.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_overleft</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        box_right        -        is box1 strictly right of box2?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_right</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPgt</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        box_overright    -        is the left edge of box1 at or right of
 *                                the left edge of box2?
 *
 *        This is "greater than or equal" for time ranges, when time ranges
 *        are stored as rectangles.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_overright</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPge</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        box_below        -        is box1 strictly below box2?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_below</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPlt</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        box_overbelow    -        is the upper edge of box1 at or below
 *                                the upper edge of box2?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_overbelow</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        box_above        -        is box1 strictly above box2?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_above</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPgt</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        box_overabove    -        is the lower edge of box1 at or above
 *                                the lower edge of box2?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_overabove</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPge</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        box_contained    -        is box1 contained by box2?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_contained</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FPge</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FPle</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FPge</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        box_contain        -        does box1 contain box2?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_contain</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPge</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FPle</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FPge</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FPle</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*        box_positionop    -
 *                is box1 entirely {above,below} box2?
 *
 * box_below_eq and box_above_eq are obsolete versions that (probably
 * erroneously) accept the equal-boundaries case.  Since these are not
 * in sync with the box_left and box_right code, they are deprecated and
 * not supported in the PG 8.1 rtree operator class extension.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_below_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_above_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPge</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*        box_relop        -        is area(box1) relop area(box2), within
 *                                our accuracy constraint?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPlt</name><argument_list>(<argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPgt</name><argument_list>(<argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPge</name><argument_list>(<argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *    "Arithmetic" operators on boxes.
 *---------------------------------------------------------*/</comment>

<comment type="block">/*        box_area        -        returns the area of the box.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_area</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*        box_width        -        returns the width of the box
 *                                  (horizontal magnitude).
 */</comment>
<function><type><name>Datum</name></type>
<name>box_width</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*        box_height        -        returns the height of the box
 *                                  (vertical magnitude).
 */</comment>
<function><type><name>Datum</name></type>
<name>box_height</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*        box_distance    -        returns the distance between the
 *                                  center points of two boxes.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name></type>        <name>a</name></decl>,
                <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>box_cn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><name>box1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>box_cn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>box2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>HYPOT</name><argument_list>(<argument><expr><name><name>a</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>b</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>b</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*        box_center        -        returns the center point of the box.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_center</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>box_cn</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*        box_ar    -        returns the area of the box.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>box_ar</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>box_wd</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>box_ht</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*        box_cn    -        stores the centerpoint of the box into *center.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>box_cn</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>center</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>center</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>center</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <operator>(</operator><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*        box_wd    -        returns the width (length) of the box
 *                                  (horizontal magnitude).
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>box_wd</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*        box_ht    -        returns the height of the box
 *                                  (vertical magnitude).
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>box_ht</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *    Funky operations.
 *---------------------------------------------------------*/</comment>

<comment type="block">/*        box_intersect    -
 *                returns the overlapping portion of two boxes,
 *                  or NULL if they do not intersect.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_intersect</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>box_ov</name><argument_list>(<argument><expr><name>box1</name></expr></argument>, <argument><expr><name>box2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*        box_diagonal    -
 *                returns a line segment which happens to be the
 *                  positive-slope diagonal of "box".
 */</comment>
<function><type><name>Datum</name></type>
<name>box_diagonal</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>LSEG</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LSEG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_LSEG_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************
 **
 **        Routines for 2D lines.
 **
 ***********************************************************************/</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>line_decode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* s was already advanced over leading '{' */</comment>
    <expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name> <operator>=</operator> <call><name>single_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"line"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name><operator>++</operator> <operator>!=</operator> <name>DELIM</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name> <operator>=</operator> <call><name>single_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"line"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name><operator>++</operator> <operator>!=</operator> <name>DELIM</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>C</name></name> <operator>=</operator> <call><name>single_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"line"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name><operator>++</operator> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>line_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>line</name> <init>= <expr><operator>(</operator><name>LINE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LINE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name></type>        <name>lseg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isopen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>line_decode</name><argument_list>(<argument><expr><name>s</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
                            <argument><expr><literal type="string">"line"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FPzero</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid line specification: A and B cannot both be zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>path_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lseg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isopen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"line"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>lseg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FPeq</name><argument_list>(<argument><expr><name><name>lseg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid line specification: must be two distinct points"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>line_construct_pts</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_LINE_P</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>line_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>astr</name> <init>= <expr><call><name>float8out_internal</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>bstr</name> <init>= <expr><call><name>float8out_internal</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cstr</name> <init>= <expr><call><name>float8out_internal</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"{%s,%s,%s}"</literal></expr></argument>, <argument><expr><name>astr</name></expr></argument>, <argument><expr><name>bstr</name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        line_recv            - converts external binary format to line
 */</comment>
<function><type><name>Datum</name></type>
<name>line_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfo</name></type>    <name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>line</name> <operator>=</operator> <operator>(</operator><name>LINE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LINE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>C</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_LINE_P</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        line_send            - converts line to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>line_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *    Conversion routines from one line formula to internal.
 *        Internal form:    Ax+By+C=0
 *---------------------------------------------------------*/</comment>

<comment type="block">/* line_construct_pm()
 * point-slope
 */</comment>
<function><type><specifier>static</specifier> <name>LINE</name> <modifier>*</modifier></type>
<name>line_construct_pm</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>m</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>LINE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LINE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>m</name> <operator>==</operator> <name>DBL_MAX</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* vertical - use "x = C" */</comment>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>A</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>B</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>C</name></name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* use "mx - y + yinter = 0" */</comment>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>A</name></name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>B</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>C</name></name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <name>m</name> <operator>*</operator> <name><name>pt</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fill already-allocated LINE struct from two points on the line
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>line_construct_pts</name><parameter_list>(<parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>                            <comment type="block">/* vertical */</comment>
        <comment type="block">/* use "x = C" */</comment>
        <expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>C</name></name> <operator>=</operator> <name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"line_construct_pts- line is vertical\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>                            <comment type="block">/* horizontal */</comment>
        <comment type="block">/* use "y = C" */</comment>
        <expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>C</name></name> <operator>=</operator> <name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"line_construct_pts- line is horizontal\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* use "mx - y + yinter = 0" */</comment>
        <expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name> <operator>=</operator> <operator>(</operator><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <name><name>pt1</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <name><name>pt1</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>C</name></name> <operator>=</operator> <name><name>pt1</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <name><name>line</name><operator>-&gt;</operator><name>A</name></name> <operator>*</operator> <name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
        <comment type="block">/* on some platforms, the preceding expression tends to produce -0 */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>line</name><operator>-&gt;</operator><name>C</name></name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>C</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"line_construct_pts- line is neither vertical nor horizontal (diffs x=%.*g, y=%.*g\n"</literal></expr></argument>,
               <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><operator>(</operator><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <name><name>pt1</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><operator>(</operator><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <name><name>pt1</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* line_construct_pp()
 * two points
 */</comment>
<function><type><name>Datum</name></type>
<name>line_construct_pp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>LINE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LINE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>line_construct_pts</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>pt1</name></expr></argument>, <argument><expr><name>pt2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_LINE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *    Relative position routines.
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>line_intersect</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>line_parallel</name></expr></argument>,
                                                     <argument><expr><call><name>LinePGetDatum</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></argument>,
                                                     <argument><expr><call><name>LinePGetDatum</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>line_parallel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name> <operator>*</operator> <operator>(</operator><name><name>l2</name><operator>-&gt;</operator><name>B</name></name> <operator>/</operator> <name><name>l1</name><operator>-&gt;</operator><name>B</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>line_perp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name><name>l1</name><operator>-&gt;</operator><name>A</name></name> <operator>*</operator> <name><name>l2</name><operator>-&gt;</operator><name>B</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><name><name>l1</name><operator>-&gt;</operator><name>B</name></name> <operator>*</operator> <name><name>l2</name><operator>-&gt;</operator><name>A</name></name><operator>)</operator><operator>)</operator></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>line_vertical</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>line_horizontal</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>line_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>k</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>l1</name><operator>-&gt;</operator><name>A</name></name> <operator>/</operator> <name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>l1</name><operator>-&gt;</operator><name>B</name></name> <operator>/</operator> <name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>l1</name><operator>-&gt;</operator><name>C</name></name> <operator>/</operator> <name><name>l2</name><operator>-&gt;</operator><name>C</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name>k</name> <operator>*</operator> <name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name>k</name> <operator>*</operator> <name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>C</name></name></expr></argument>, <argument><expr><name>k</name> <operator>*</operator> <name><name>l2</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *    Line arithmetic routines.
 *---------------------------------------------------------*/</comment>

<comment type="block">/* line_distance()
 * Distance between two lines.
 */</comment>
<function><type><name>Datum</name></type>
<name>line_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>line_parallel</name></expr></argument>,
                                          <argument><expr><call><name>LinePGetDatum</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><call><name>LinePGetDatum</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>            <comment type="block">/* vertical? */</comment>
        <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>fabs</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>C</name></name> <operator>-</operator> <name><name>l2</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>point_construct</name><argument_list>(<argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><name><name>l1</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>dist_pl_internal</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* line_interpt()
 * Point where two lines l1, l2 intersect (if any)
 */</comment>
<function><type><name>Datum</name></type>
<name>line_interpt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>line_interpt_internal</name><argument_list>(<argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Internal version of line_interpt
 *
 * returns a NULL pointer if no intersection point
 */</comment>
<function><type><specifier>static</specifier> <name>Point</name> <modifier>*</modifier></type>
<name>line_interpt_internal</name><parameter_list>(<parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>l1</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>l2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>x</name></decl>,
                <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

    <comment type="block">/*
     * NOTE: if the lines are identical then we will find they are parallel
     * and report "no intersection".  This is a little weird, but since
     * there's no *unique* intersection, maybe it's appropriate behavior.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>line_parallel</name></expr></argument>,
                                         <argument><expr><call><name>LinePGetDatum</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>LinePGetDatum</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>)</condition>            <comment type="block">/* l1 vertical? */</comment>
    <block>{<block_content>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>l1</name><operator>-&gt;</operator><name>C</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>y</name> <operator>=</operator> <operator>(</operator><name><name>l2</name><operator>-&gt;</operator><name>A</name></name> <operator>*</operator> <name>x</name> <operator>+</operator> <name><name>l2</name><operator>-&gt;</operator><name>C</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>)</condition>        <comment type="block">/* l2 vertical? */</comment>
    <block>{<block_content>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>l2</name><operator>-&gt;</operator><name>C</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>y</name> <operator>=</operator> <operator>(</operator><name><name>l1</name><operator>-&gt;</operator><name>A</name></name> <operator>*</operator> <name>x</name> <operator>+</operator> <name><name>l1</name><operator>-&gt;</operator><name>C</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name><name>l1</name><operator>-&gt;</operator><name>C</name></name> <operator>-</operator> <name><name>l2</name><operator>-&gt;</operator><name>C</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><name><name>l2</name><operator>-&gt;</operator><name>A</name></name> <operator>-</operator> <name><name>l1</name><operator>-&gt;</operator><name>A</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>y</name> <operator>=</operator> <operator>(</operator><name><name>l1</name><operator>-&gt;</operator><name>A</name></name> <operator>*</operator> <name>x</name> <operator>+</operator> <name><name>l1</name><operator>-&gt;</operator><name>C</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_construct</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"line_interpt- lines are A=%.*g, B=%.*g, C=%.*g, A=%.*g, B=%.*g, C=%.*g\n"</literal></expr></argument>,
           <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>l1</name><operator>-&gt;</operator><name>C</name></name></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"line_interpt- lines intersect at (%.*g,%.*g)\n"</literal></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 **
 **        Routines for 2D paths (sequences of line segments, also
 **                called `polylines').
 **
 **                This is not a general package for geometric paths,
 **                which of course include polygons; the emphasis here
 **                is on (for example) usefulness in wire layout.
 **
 ***********************************************************************/</comment>

<comment type="block">/*----------------------------------------------------------
 *    String to path / path to string conversion.
 *        External format:
 *                "((xcoord, ycoord),... )"
 *                "[(xcoord, ycoord),... ]"
 *                "(xcoord, ycoord),... "
 *                "[xcoord, ycoord,... ]"
 *        Also support older format:
 *                "(closed, npts, xcoord, ycoord,... )"
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>path_area</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>area</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>path</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>area</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>area</name> <operator>-=</operator> <name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>area</name> <operator>*=</operator> <literal type="number">0.5</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><ternary><condition><expr><name>area</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr> ?</condition><then> <expr><operator>-</operator><name>area</name></expr> </then><else>: <expr><name>area</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>path_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isopen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>npts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>base_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>npts</name> <operator>=</operator> <call><name>pair_count</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
                        <argument><expr><literal type="string">"path"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>s</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

    <comment type="block">/* skip single leading paren */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <name>LDELIM</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strrchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>LDELIM</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>s</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>base_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>npts</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PATH</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>base_size</name></expr>;</expr_stmt>

    <comment type="block">/* Check for integer overflow */</comment>
    <if_stmt><if>if <condition>(<expr><name>base_size</name> <operator>/</operator> <name>npts</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>||</operator> <name>size</name> <operator>&lt;=</operator> <name>base_size</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many points requested"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>PATH</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>npts</name></name> <operator>=</operator> <name>npts</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>path_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>npts</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isopen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"path"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name><operator>++</operator> <operator>!=</operator> <name>RDELIM</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
                            <argument><expr><literal type="string">"path"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
                        <argument><expr><literal type="string">"path"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <operator>(</operator><operator>!</operator><name>isopen</name><operator>)</operator></expr>;</expr_stmt>
    <comment type="block">/* prevent instability in unused pad bytes */</comment>
    <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>dummy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>path_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>path_encode</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>path</name><operator>-&gt;</operator><name>closed</name></name></expr> ?</condition><then> <expr><name>PATH_CLOSED</name></expr> </then><else>: <expr><name>PATH_OPEN</name></expr></else></ternary></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        path_recv            - converts external binary format to path
 *
 * External representation is closed flag (a boolean byte), int32 number
 * of points, and the points.
 */</comment>
<function><type><name>Datum</name></type>
<name>path_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfo</name></type>    <name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>closed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>npts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>closed</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>npts</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>npts</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>npts</name> <operator>&gt;=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>INT_MAX</name> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PATH</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid number of points in external \"path\" value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PATH</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>npts</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>PATH</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>npts</name></name> <operator>=</operator> <name>npts</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>closed</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <comment type="block">/* prevent instability in unused pad bytes */</comment>
    <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>dummy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        path_send            - converts path to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>path_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>path</name><operator>-&gt;</operator><name>closed</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *    Relational operators.
 *        These are based on the path cardinality,
 *        as stupid as that sounds.
 *
 *        Better relops and access methods coming soon.
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>path_n_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>&lt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_n_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_n_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>==</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_n_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>&lt;=</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_n_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;=</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*----------------------------------------------------------
 * Conversion operators.
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>path_isclosed</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>closed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_isopen</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>!</operator><name><name>path</name><operator>-&gt;</operator><name>closed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_npoints</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>path_close</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_open</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* path_inter -
 *        Does p1 intersect p2 at any point?
 *        Use bounding boxes for a quick (O(n)) check, then do a
 *        O(n^2) iterative edge check.
 */</comment>
<function><type><name>Datum</name></type>
<name>path_inter</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name></type>            <name>b1</name></decl>,
                <decl><type ref="prev"/><name>b2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name></type>        <name>seg1</name></decl>,
                <decl><type ref="prev"/><name>seg2</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>b1</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>b1</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>b1</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>b1</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p1</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>b1</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>b1</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b1</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>b1</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b1</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>b1</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b1</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>b1</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>b2</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>b2</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>b2</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>b2</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>b2</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>b2</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b2</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>b2</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b2</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>b2</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b2</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>b2</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>box_ov</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* pairwise check lseg intersections */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p1</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>iprev</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>iprev</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p1</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>iprev</name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* include the closure segment */</comment>
        </block_content>}</block></else></if_stmt>

        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>jprev</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>jprev</name> <operator>=</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p2</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>jprev</name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* include the closure segment */</comment>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>iprev</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>jprev</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>lseg_intersect_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <comment type="block">/* if we dropped through, no two segs intersected */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* path_distance()
 * This essentially does a cartesian product of the lsegs in the
 *    two paths, and finds the min distance between any two lsegs
 */</comment>
<function><type><name>Datum</name></type>
<name>path_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>min</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* initialize to keep compiler quiet */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>have_min</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name></type>        <name>seg1</name></decl>,
                <decl><type ref="prev"/><name>seg2</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p1</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>iprev</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>iprev</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p1</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>iprev</name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* include the closure segment */</comment>
        </block_content>}</block></else></if_stmt>

        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>jprev</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>jprev</name> <operator>=</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p2</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>jprev</name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* include the closure segment */</comment>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>iprev</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>jprev</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>lseg_distance</name></expr></argument>,
                                                     <argument><expr><call><name>LsegPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seg1</name></expr></argument>)</argument_list></call></expr></argument>,
                                                     <argument><expr><call><name>LsegPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seg2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_min</name> <operator>||</operator> <name>tmp</name> <operator>&lt;</operator> <name>min</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>min</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>have_min</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_min</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *    "Arithmetic" operations.
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>path_length</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>result</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>iprev</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>iprev</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>path</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>iprev</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* include the closure segment */</comment>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>iprev</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************
 **
 **        Routines for 2D points.
 **
 ***********************************************************************/</comment>

<comment type="block">/*----------------------------------------------------------
 *    String to point, point to string conversion.
 *        External format:
 *                "(x,y)"
 *                "x,y"
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>point_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>point</name> <init>= <expr><operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pair_decode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>point</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>point</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"point"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>path_encode</name><argument_list>(<argument><expr><name>PATH_NONE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        point_recv            - converts external binary format to point
 */</comment>
<function><type><name>Datum</name></type>
<name>point_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfo</name></type>    <name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>point</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>point</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>point</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>point</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        point_send            - converts point to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>point_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Point</name> <modifier>*</modifier></type>
<name>point_construct</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Point</name> <modifier>*</modifier></type>
<name>point_copy</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *    Relational operators for Points.
 *        Since we do have a sense of coordinates being
 *        "equal" to a given accuracy (point_vert, point_horiz),
 *        the other ops must preserve that sense.  This means
 *        that results may, strictly speaking, be a lie (unless
 *        EPSILON = 0.0).
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>point_left</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPlt</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_right</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPgt</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_above</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPgt</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_below</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPlt</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_vert</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_horiz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FPeq</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPne</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>FPne</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*----------------------------------------------------------
 *    "Arithmetic" operators on points.
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>point_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>HYPOT</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>double</name></type>
<name>point_dt</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"point_dt- segment (%f,%f),(%f,%f) length is %f\n"</literal></expr></argument>,
           <argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><call><name>HYPOT</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><call><name>HYPOT</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_slope</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>point_sl</name><argument_list>(<argument><expr><name>pt1</name></expr></argument>, <argument><expr><name>pt2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>double</name></type>
<name>point_sl</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><ternary><condition><expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>
            ?</condition><then> <expr><operator>(</operator><name>double</name><operator>)</operator> <name>DBL_MAX</name></expr>
            </then><else>: <expr><operator>(</operator><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <name><name>pt2</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <name><name>pt2</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 **
 **        Routines for 2D line segments.
 **
 ***********************************************************************/</comment>

<comment type="block">/*----------------------------------------------------------
 *    String to lseg, lseg to string conversion.
 *        External forms: "[(x1, y1), (x2, y2)]"
 *                        "(x1, y1), (x2, y2)"
 *                        "x1, y1, x2, y2"
 *        closed form ok    "((x1, y1), (x2, y2))"
 *        (old form)        "(x1, y1, x2, y2)"
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>lseg_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>lseg</name> <init>= <expr><operator>(</operator><name>LSEG</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LSEG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isopen</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>path_decode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isopen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"lseg"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_LSEG_P</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>lseg_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>ls</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>path_encode</name><argument_list>(<argument><expr><name>PATH_OPEN</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        lseg_recv            - converts external binary format to lseg
 */</comment>
<function><type><name>Datum</name></type>
<name>lseg_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfo</name></type>    <name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>lseg</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>lseg</name> <operator>=</operator> <operator>(</operator><name>LSEG</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LSEG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_LSEG_P</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        lseg_send            - converts lseg to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>lseg_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>ls</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* lseg_construct -
 *        form a LSEG from two Points.
 */</comment>
<function><type><name>Datum</name></type>
<name>lseg_construct</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>LSEG</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LSEG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_LSEG_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* like lseg_construct, but assume space already allocated */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>statlseg_construct</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>lseg_length</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*----------------------------------------------------------
 *    Relative position routines.
 *---------------------------------------------------------*/</comment>

<comment type="block">/*
 **  find intersection of the two lines, and see if it falls on
 **  both segments.
 */</comment>
<function><type><name>Datum</name></type>
<name>lseg_intersect</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>lseg_intersect_internal</name><argument_list>(<argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>lseg_intersect_internal</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>l1</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>l2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LINE</name></type>        <name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>interpt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>retval</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>line_construct_pts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ln</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>interpt</name> <operator>=</operator> <call><name>interpt_sl</name><argument_list>(<argument><expr><name>l1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>interpt</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>on_ps_internal</name><argument_list>(<argument><expr><name>interpt</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>            <comment type="block">/* interpt on l1 and l2 */</comment>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>lseg_parallel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><call><name>point_sl</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>point_sl</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* lseg_perp()
 * Determine if two line segments are perpendicular.
 *
 * This code did not get the correct answer for
 *    '((0,0),(0,1))'::lseg ?-| '((0,0),(1,0))'::lseg
 * So, modified it to check explicitly for slope of vertical line
 *    returned by point_sl() and the results seem better.
 * - thomas 1998-01-31
 */</comment>
<function><type><name>Datum</name></type>
<name>lseg_perp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>m1</name></decl>,
                <decl><type ref="prev"/><name>m2</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>m1</name> <operator>=</operator> <call><name>point_sl</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>m2</name> <operator>=</operator> <call><name>point_sl</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"lseg_perp- slopes are %g and %g\n"</literal></expr></argument>, <argument><expr><name>m1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name>m1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><name>m2</name></expr></argument>, <argument><expr><name>DBL_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><name>m1</name></expr></argument>, <argument><expr><name>DBL_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><name>m1</name> <operator>/</operator> <name>m2</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>lseg_vertical</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>lseg_horizontal</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>lseg_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>lseg_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>!</operator><call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call> <operator>||</operator>
                   <operator>!</operator><call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call> <operator>||</operator>
                   <operator>!</operator><call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call> <operator>||</operator>
                   <operator>!</operator><call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>lseg_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPlt</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>lseg_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>lseg_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPgt</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>lseg_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPge</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *    Line arithmetic routines.
 *---------------------------------------------------------*/</comment>

<comment type="block">/* lseg_distance -
 *        If two segments don't intersect, then the closest
 *        point will be from one of the endpoints to the other
 *        segment.
 */</comment>
<function><type><name>Datum</name></type>
<name>lseg_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>lseg_dt</name><argument_list>(<argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* lseg_dt()
 * Distance between two line segments.
 * Must check both sets of endpoints to ensure minimum distance is found.
 * - thomas 1998-02-01
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>lseg_dt</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>l1</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>l2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>result</name></decl>,
                <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>lseg_intersect_internal</name><argument_list>(<argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>dist_ps_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>dist_ps_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>dist_ps_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>dist_ps_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>lseg_center</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>+</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <operator>(</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>+</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Point</name> <modifier>*</modifier></type>
<name>lseg_interpt_internal</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>l1</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>l2</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name></type>        <name>tmp1</name></decl>,
                <decl><type ref="prev"/><name>tmp2</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Find the intersection of the appropriate lines, if any.
     */</comment>
    <expr_stmt><expr><call><name>line_construct_pts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>line_construct_pts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>line_interpt_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If the line intersection point isn't within l1 (or equivalently l2),
     * there is no valid segment intersection point at all.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>on_ps_internal</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>!</operator><call><name>on_ps_internal</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If there is an intersection, then check explicitly for matching
     * endpoints since there may be rounding effects with annoying lsb
     * residue. - tgl 1997-07-09
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
        <operator>(</operator><call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
             <operator>(</operator><call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* lseg_interpt -
 *        Find the intersection point of two segments (if any).
 */</comment>
<function><type><name>Datum</name></type>
<name>lseg_interpt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lseg_interpt_internal</name><argument_list>(<argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************
 **
 **        Routines for position comparisons of differently-typed
 **                2D objects.
 **
 ***********************************************************************/</comment>

<comment type="block">/*---------------------------------------------------------------------
 *        dist_
 *                Minimum distance from one object to another.
 *-------------------------------------------------------------------*/</comment>

<comment type="block">/*
 * Distance from a point to a line
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_pl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>dist_pl_internal</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>dist_pl_internal</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>fabs</name><argument_list>(<argument><expr><operator>(</operator><name><name>line</name><operator>-&gt;</operator><name>A</name></name> <operator>*</operator> <name><name>pt</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name><name>line</name><operator>-&gt;</operator><name>B</name></name> <operator>*</operator> <name><name>pt</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <name><name>line</name><operator>-&gt;</operator><name>C</name></name><operator>)</operator> <operator>/</operator>
                <call><name>HYPOT</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a point to a lseg
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_ps</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>dist_ps_internal</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>dist_ps_internal</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>m</name></decl>;</decl_stmt>                <comment type="block">/* slope of perp. */</comment>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>result</name></decl>,
                <decl><type ref="prev"/><name>tmpdist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>ip</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Construct a line perpendicular to the input segment and through the
     * input point
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>==</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>m</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>==</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>m</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>DBL_MAX</name></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* slope is infinite */</comment>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>m</name> <operator>=</operator> <operator>(</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>-</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>-</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>line_construct_pm</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"dist_ps- line is A=%g B=%g C=%g from (point) slope (%f,%f) %g\n"</literal></expr></argument>,
           <argument><expr><name><name>ln</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name><name>ln</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name><name>ln</name><operator>-&gt;</operator><name>C</name></name></expr></argument>, <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Calculate distance to the line segment or to the nearest endpoint of
     * the segment.
     */</comment>

    <comment type="block">/* intersection is on the line segment? */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ip</name> <operator>=</operator> <call><name>interpt_sl</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>, <argument><expr><name>ln</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* yes, so use distance to the intersection point */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"dist_ps- distance is %f to intersection point is (%f,%f)\n"</literal></expr></argument>,
               <argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>ip</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>ip</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* no, so use distance to the nearer endpoint */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmpdist</name> <operator>=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>tmpdist</name> <operator>&lt;</operator> <name>result</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>tmpdist</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a point to a path
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_ppath</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>result</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* keep compiler quiet */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>have_min</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name></type>        <name>lseg</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="number">0</literal></expr>:</case>
            <comment type="block">/* no points in path? then result is undefined... */</comment>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <case>case <expr><literal type="number">1</literal></expr>:</case>
            <comment type="block">/* one point in path? then get distance between two points... */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <comment type="block">/* make sure the path makes sense... */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * the distance from a point to a path is the smallest distance
             * from the point to any of its constituent segments.
             */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>iprev</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>iprev</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>path</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>iprev</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* include the closure segment */</comment>
                </block_content>}</block></else></if_stmt>

                <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>iprev</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>dist_ps_internal</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_min</name> <operator>||</operator> <name>tmp</name> <operator>&lt;</operator> <name>result</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>have_min</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a point to a box
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_pb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>near</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>near</name> <operator>=</operator> <call><name>DatumGetPointP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>close_pb</name></expr></argument>,
                                              <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><call><name>BoxPGetDatum</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><name>near</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a lseg to a line
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_sl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>result</name></decl>,
                <decl><type ref="prev"/><name>d2</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>has_interpt_sl</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>dist_pl_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>d2</name> <operator>=</operator> <call><name>dist_pl_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* XXX shouldn't we take the min not max? */</comment>
        <if_stmt><if>if <condition>(<expr><name>d2</name> <operator>&gt;</operator> <name>result</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>d2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a lseg to a box
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_sb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetPointP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>close_sb</name></expr></argument>,
                                             <argument><expr><call><name>LsegPGetDatum</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><call><name>BoxPGetDatum</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>dist_pb</name></expr></argument>,
                                 <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>BoxPGetDatum</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a line to a box
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_lb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* need to think about this one for a while */</comment>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"dist_lb\" not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a circle to a polygon
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_cpoly</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* calculate distance to center, and subtract radius */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>dist_ppoly_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>-=</operator> <name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a point to a polygon
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_ppoly</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>dist_ppoly_internal</name><argument_list>(<argument><expr><name>point</name></expr></argument>, <argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>dist_polyp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>dist_ppoly_internal</name><argument_list>(<argument><expr><name>point</name></expr></argument>, <argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>dist_ppoly_internal</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>poly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>float8</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name></type>        <name>seg</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>point_inside</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"dist_ppoly_internal- point inside of polygon\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><literal type="number">0.0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* initialize distance with segment between first and last points */</comment>
    <expr_stmt><expr><name><name>seg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>dist_ps_internal</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"dist_ppoly_internal- segment 0/n distance is %f\n"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* check distances for other segments */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>seg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>seg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>seg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>seg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>dist_ps_internal</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"dist_ppoly_internal- segment %d distance is %f\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;</operator> <name>result</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*---------------------------------------------------------------------
 *        interpt_
 *                Intersection point of objects.
 *                We choose to ignore the "point" of intersection between
 *                  lines and boxes, since there are typically two.
 *-------------------------------------------------------------------*/</comment>

<comment type="block">/* Get intersection point of lseg and line; returns NULL if no intersection */</comment>
<function><type><specifier>static</specifier> <name>Point</name> <modifier>*</modifier></type>
<name>interpt_sl</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LINE</name></type>        <name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>line_construct_pts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>line_interpt_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"interpt_sl- segment is (%.*g %.*g) (%.*g %.*g)\n"</literal></expr></argument>,
           <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"interpt_sl- segment becomes line A=%.*g B=%.*g C=%.*g\n"</literal></expr></argument>,
           <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>tmp</name><operator>.</operator><name>A</name></name></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>tmp</name><operator>.</operator><name>B</name></name></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>tmp</name><operator>.</operator><name>C</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"interpt_sl- intersection point is (%.*g %.*g)\n"</literal></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><call><name>on_ps_internal</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"interpt_sl- intersection point is on segment\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* variant: just indicate if intersection point exists */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>has_interpt_sl</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>interpt_sl</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*---------------------------------------------------------------------
 *        close_
 *                Point of closest proximity between objects.
 *-------------------------------------------------------------------*/</comment>

<comment type="block">/* close_pl -
 *        The intersection point of a perpendicular of the line
 *        through the point.
 */</comment>
<function><type><name>Datum</name></type>
<name>close_pl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>invm</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>)</condition>        <comment type="block">/* vertical? */</comment>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>line</name><operator>-&gt;</operator><name>C</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr>)</condition>        <comment type="block">/* horizontal? */</comment>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name><name>line</name><operator>-&gt;</operator><name>C</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* drop a perpendicular and find the intersection point */</comment>

    <comment type="block">/* invert and flip the sign on the slope to get a perpendicular */</comment>
    <expr_stmt><expr><name>invm</name> <operator>=</operator> <name><name>line</name><operator>-&gt;</operator><name>B</name></name> <operator>/</operator> <name><name>line</name><operator>-&gt;</operator><name>A</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>line_construct_pm</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>invm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>line_interpt_internal</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* close_ps()
 * Closest point on line segment to specified point.
 * Take the closest endpoint if the point is left, right,
 *    above, or below the segment, otherwise find the intersection
 *    point of the segment and its perpendicular through the point.
 *
 * Some tricky code here, relying on boolean expressions
 *    evaluating to only zero or one to use as an array index.
 *        bug fixes by gthaker@atl.lmco.com; May 1, 1998
 */</comment>
<function><type><name>Datum</name></type>
<name>close_ps</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>invm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>xh</name></decl>,
                <decl><type ref="prev"/><name>yh</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"close_sp:pt-&gt;x %f pt-&gt;y %f\nlseg(0).x %f lseg(0).y %f  lseg(1).x %f lseg(1).y %f\n"</literal></expr></argument>,
           <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>,
           <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* xh (or yh) is the index of upper x( or y) end point of lseg */</comment>
    <comment type="block">/* !xh (or !yh) is the index of lower x( or y) end point of lseg */</comment>
    <expr_stmt><expr><name>xh</name> <operator>=</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>&lt;</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>yh</name> <operator>=</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>&lt;</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call></expr>)</condition>    <comment type="block">/* vertical? */</comment>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"close_ps- segment is vertical\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* first check if point is below or above the entire lseg. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pt</name><operator>-&gt;</operator><name>y</name></name> <operator>&lt;</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><operator>!</operator><name>yh</name></expr>]</index></name><operator>.</operator><name>y</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><operator>!</operator><name>yh</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* below the lseg */</comment>
        <if type="elseif">else if <condition>(<expr><name><name>pt</name><operator>-&gt;</operator><name>y</name></name> <operator>&gt;</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>yh</name></expr>]</index></name><operator>.</operator><name>y</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>yh</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* above the lseg */</comment>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* point lines along (to left or right) of the vertical lseg. */</comment>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr>)</condition>    <comment type="block">/* horizontal? */</comment>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"close_ps- segment is horizontal\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* first check if point is left or right of the entire lseg. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pt</name><operator>-&gt;</operator><name>x</name></name> <operator>&lt;</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><operator>!</operator><name>xh</name></expr>]</index></name><operator>.</operator><name>x</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><operator>!</operator><name>xh</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* left of the lseg */</comment>
        <if type="elseif">else if <condition>(<expr><name><name>pt</name><operator>-&gt;</operator><name>x</name></name> <operator>&gt;</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>xh</name></expr>]</index></name><operator>.</operator><name>x</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>xh</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* right of the lseg */</comment>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* point lines along (at top or below) the horiz. lseg. */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * vert. and horiz. cases are down, now check if the closest point is one
     * of the end points or someplace on the lseg.
     */</comment>

    <expr_stmt><expr><name>invm</name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal> <operator>/</operator> <call><name>point_sl</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>line_construct_pm</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><operator>!</operator><name>yh</name></expr>]</index></name></expr></argument>, <argument><expr><name>invm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* lower edge of the
                                                     * "band" */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pt</name><operator>-&gt;</operator><name>y</name></name> <operator>&lt;</operator> <operator>(</operator><name><name>tmp</name><operator>-&gt;</operator><name>A</name></name> <operator>*</operator> <name><name>pt</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name><name>tmp</name><operator>-&gt;</operator><name>C</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>                            <comment type="block">/* we are below the lower edge */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><operator>!</operator><name>yh</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* below the lseg, take lower end
                                             * pt */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"close_ps below: tmp A %f  B %f   C %f\n"</literal></expr></argument>,
               <argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>line_construct_pm</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>yh</name></expr>]</index></name></expr></argument>, <argument><expr><name>invm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* upper edge of the
                                                     * "band" */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pt</name><operator>-&gt;</operator><name>y</name></name> <operator>&gt;</operator> <operator>(</operator><name><name>tmp</name><operator>-&gt;</operator><name>A</name></name> <operator>*</operator> <name><name>pt</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name><name>tmp</name><operator>-&gt;</operator><name>C</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>                            <comment type="block">/* we are below the lower edge */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>yh</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* above the lseg, take higher end
                                             * pt */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"close_ps above: tmp A %f  B %f   C %f\n"</literal></expr></argument>,
               <argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * at this point the "normal" from point will hit lseg. The closest point
     * will be somewhere on the lseg
     */</comment>
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>line_construct_pm</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>invm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"close_ps- tmp A %f  B %f   C %f\n"</literal></expr></argument>,
           <argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>interpt_sl</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * ordinarily we should always find an intersection point, but that could
     * fail in the presence of NaN coordinates, and perhaps even from simple
     * roundoff issues.  Return a SQL NULL if so.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"close_ps- result.x %f  result.y %f\n"</literal></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* close_lseg()
 * Closest point to l1 on l2.
 */</comment>
<function><type><name>Datum</name></type>
<name>close_lseg</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name></type>        <name>point</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>dist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>d</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>dist_ps_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dist</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>point</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>dist_ps_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <name>dist</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>dist</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>point</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>dist_ps_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>dist</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetPointP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>close_ps</name></expr></argument>,
                                                    <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><call><name>LsegPGetDatum</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>point</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetPointP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>close_ps</name></expr></argument>,
                                                    <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><call><name>LsegPGetDatum</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>dist_ps_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>dist</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetPointP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>close_ps</name></expr></argument>,
                                                    <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><call><name>LsegPGetDatum</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>point</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetPointP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>close_ps</name></expr></argument>,
                                                    <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><call><name>LsegPGetDatum</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* close_pb()
 * Closest point on or in box to specified point.
 */</comment>
<function><type><name>Datum</name></type>
<name>close_pb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name></type>        <name>lseg</name></decl>,
                <decl><type ref="prev"/><name>seg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name></type>        <name>point</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>dist</name></decl>,
                <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>on_pb</name></expr></argument>,
                                         <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>BoxPGetDatum</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* pairwise check lseg distances */</comment>
    <expr_stmt><expr><name><name>point</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>point</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dist</name> <operator>=</operator> <call><name>dist_ps_internal</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>dist_ps_internal</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <name>dist</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>dist</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lseg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>point</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>point</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>dist_ps_internal</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <name>dist</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>dist</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lseg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>dist_ps_internal</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <name>dist</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>dist</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lseg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>close_ps</name></expr></argument>,
                                        <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>LsegPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* close_sl()
 * Closest point on line to line segment.
 *
 * XXX THIS CODE IS WRONG
 * The code is actually calculating the point on the line segment
 *    which is backwards from the routine naming convention.
 * Copied code to new routine close_ls() but haven't fixed this one yet.
 * - thomas 1998-01-31
 */</comment>
<function><type><name>Datum</name></type>
<name>close_sl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>d1</name></decl>,
                <decl><type ref="prev"/><name>d2</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>interpt_sl</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>d1</name> <operator>=</operator> <call><name>dist_pl_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d2</name> <operator>=</operator> <call><name>dist_pl_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>d1</name> <operator>&lt;</operator> <name>d2</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"close_sl\" not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* close_ls()
 * Closest point on line segment to line.
 */</comment>
<function><type><name>Datum</name></type>
<name>close_ls</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>d1</name></decl>,
                <decl><type ref="prev"/><name>d2</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>interpt_sl</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>d1</name> <operator>=</operator> <call><name>dist_pl_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d2</name> <operator>=</operator> <call><name>dist_pl_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>d1</name> <operator>&lt;</operator> <name>d2</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* close_sb()
 * Closest point on or in box to line segment.
 */</comment>
<function><type><name>Datum</name></type>
<name>close_sb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name></type>        <name>point</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name></type>        <name>bseg</name></decl>,
                <decl><type ref="prev"/><name>seg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>dist</name></decl>,
                <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

    <comment type="block">/* segment intersects box? then just return closest point to center */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>inter_sb</name></expr></argument>,
                                         <argument><expr><call><name>LsegPGetDatum</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>BoxPGetDatum</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>box_cn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>point</name></expr></argument>, <argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>close_ps</name></expr></argument>,
                                            <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>LsegPGetDatum</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* pairwise check lseg distances */</comment>
    <expr_stmt><expr><name><name>point</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>point</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dist</name> <operator>=</operator> <call><name>lseg_dt</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>lseg_dt</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <name>dist</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>dist</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bseg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>point</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>point</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>lseg_dt</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <name>dist</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>dist</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bseg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>lseg_dt</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <name>dist</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>dist</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bseg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* OK, we now have the closest line segment on the box boundary */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>close_lseg</name></expr></argument>,
                                        <argument><expr><call><name>LsegPGetDatum</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>LsegPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>close_lb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* think about this one for a while */</comment>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"close_lb\" not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*---------------------------------------------------------------------
 *        on_
 *                Whether one object lies completely within another.
 *-------------------------------------------------------------------*/</comment>

<comment type="block">/* on_pl -
 *        Does the point satisfy the equation?
 */</comment>
<function><type><name>Datum</name></type>
<name>on_pl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name> <operator>*</operator> <name><name>pt</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name><name>line</name><operator>-&gt;</operator><name>B</name></name> <operator>*</operator> <name><name>pt</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <name><name>line</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* on_ps -
 *        Determine colinearity by detecting a triangle inequality.
 * This algorithm seems to behave nicely even with lsb residues - tgl 1997-07-09
 */</comment>
<function><type><name>Datum</name></type>
<name>on_ps</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>on_ps_internal</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>on_ps_internal</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>FPeq</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>point_dt</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>on_pb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>x</name></name> <operator>&lt;=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>&amp;&amp;</operator> <name><name>pt</name><operator>-&gt;</operator><name>x</name></name> <operator>&gt;=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>&amp;&amp;</operator>
                   <name><name>pt</name><operator>-&gt;</operator><name>y</name></name> <operator>&lt;=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>&amp;&amp;</operator> <name><name>pt</name><operator>-&gt;</operator><name>y</name></name> <operator>&gt;=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_contain_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>x</name></name> <operator>&lt;=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>&amp;&amp;</operator> <name><name>pt</name><operator>-&gt;</operator><name>x</name></name> <operator>&gt;=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>&amp;&amp;</operator>
                   <name><name>pt</name><operator>-&gt;</operator><name>y</name></name> <operator>&lt;=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>&amp;&amp;</operator> <name><name>pt</name><operator>-&gt;</operator><name>y</name></name> <operator>&gt;=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* on_ppath -
 *        Whether a point lies within (on) a polyline.
 *        If open, we have to (groan) check each segment.
 * (uses same algorithm as for point intersecting segment - tgl 1997-07-09)
 *        If closed, we use the old O(n) ray method for point-in-polygon.
 *                The ray is horizontal, from pt out to the right.
 *                Each segment that crosses the ray counts as an
 *                intersection; note that an endpoint or edge may touch
 *                but not cross.
 *                (we can do p-in-p in lg(n), but it takes preprocessing)
 */</comment>
<function><type><name>Datum</name></type>
<name>on_ppath</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>a</name></decl>,
                <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>

    <comment type="block">/*-- OPEN --*/</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>path</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>FPeq</name><argument_list>(<argument><expr><name>a</name> <operator>+</operator> <name>b</name></expr></argument>,
                     <argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*-- CLOSED --*/</comment>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>point_inside</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>on_sl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>on_pl</name></expr></argument>,
                                                    <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><call><name>LinePGetDatum</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>on_pl</name></expr></argument>,
                                                    <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><call><name>LinePGetDatum</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>on_sb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>on_pb</name></expr></argument>,
                                                    <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><call><name>BoxPGetDatum</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>on_pb</name></expr></argument>,
                                                    <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><call><name>BoxPGetDatum</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*---------------------------------------------------------------------
 *        inter_
 *                Whether one object intersects another.
 *-------------------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>inter_sl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>has_interpt_sl</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* inter_sb()
 * Do line segment and box intersect?
 *
 * Segment completely inside box counts as intersection.
 * If you want only segments crossing box boundaries,
 *    try converting box to path first.
 *
 * Optimize for non-intersection by checking for box intersection first.
 * - thomas 1998-01-30
 */</comment>
<function><type><name>Datum</name></type>
<name>inter_sb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>LSEG</name>       <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name></type>            <name>lbox</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name></type>        <name>bseg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name></type>        <name>point</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>lbox</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lbox</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lbox</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lbox</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* nothing close to overlap? then not going to intersect */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>box_ov</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lbox</name></expr></argument>, <argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* an endpoint of segment is inside box? then clearly intersects */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>on_pb</name></expr></argument>,
                                         <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>BoxPGetDatum</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>on_pb</name></expr></argument>,
                                         <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>BoxPGetDatum</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* pairwise check lseg intersections */</comment>
    <expr_stmt><expr><name><name>point</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>point</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>lseg_intersect_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>lseg_intersect_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>point</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>point</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>lseg_intersect_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>lseg_intersect_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* if we dropped through, no two segs intersected */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* inter_lb()
 * Do line and box intersect?
 */</comment>
<function><type><name>Datum</name></type>
<name>inter_lb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LINE</name>       <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LSEG</name></type>        <name>bseg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name></type>        <name>p1</name></decl>,
                <decl><type ref="prev"/><name>p2</name></decl>;</decl_stmt>

    <comment type="block">/* pairwise check lseg intersections */</comment>
    <expr_stmt><expr><name><name>p1</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p1</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p2</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p2</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>has_interpt_sl</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p1</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p1</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>has_interpt_sl</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p2</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p2</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>has_interpt_sl</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p1</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p1</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>has_interpt_sl</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* if we dropped through, no intersection */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------
 * The following routines define a data type and operator class for
 * POLYGONS .... Part of which (the polygon's bounding box) is built on
 * top of the BOX data type.
 *
 * make_bound_box - create the bounding box for the input polygon
 *------------------------------------------------------------------*/</comment>

<comment type="block">/*---------------------------------------------------------------------
 * Make the smallest bounding box for the given polygon.
 *---------------------------------------------------------------------*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_bound_box</name><parameter_list>(<parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>poly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>x1</name></decl>,
                <decl><type ref="prev"/><name>y1</name></decl>,
                <decl><type ref="prev"/><name>x2</name></decl>,
                <decl><type ref="prev"/><name>y2</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>x2</name> <operator>=</operator> <name>x1</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>y2</name> <operator>=</operator> <name>y1</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>&lt;</operator> <name>x1</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>x1</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>&gt;</operator> <name>x2</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>x2</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>&lt;</operator> <name>y1</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>y1</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>&gt;</operator> <name>y2</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>y2</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>box_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>poly</name><operator>-&gt;</operator><name>boundbox</name></name><operator>)</operator></expr></argument>, <argument><expr><name>x1</name></expr></argument>, <argument><expr><name>x2</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>, <argument><expr><name>y2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create bounding box for empty polygon"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------
 * poly_in - read in the polygon from a string specification
 *
 *        External format:
 *                "((x0,y0),...,(xn,yn))"
 *                "x0,y0,...,xn,yn"
 *                also supports the older style "(x1,...,xn,y1,...yn)"
 *------------------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>npts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>base_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isopen</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>npts</name> <operator>=</operator> <call><name>pair_count</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
                        <argument><expr><literal type="string">"polygon"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>base_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>npts</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>POLYGON</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>base_size</name></expr>;</expr_stmt>

    <comment type="block">/* Check for integer overflow */</comment>
    <if_stmt><if>if <condition>(<expr><name>base_size</name> <operator>/</operator> <name>npts</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>||</operator> <name>size</name> <operator>&lt;=</operator> <name>base_size</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many points requested"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>poly</name> <operator>=</operator> <operator>(</operator><name>POLYGON</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* zero any holes */</comment>

    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>poly</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>=</operator> <name>npts</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>path_decode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>npts</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isopen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"polygon"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>make_bound_box</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POLYGON_P</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*---------------------------------------------------------------
 * poly_out - convert internal POLYGON representation to the
 *              character string format "((f8,f8),...,(f8,f8))"
 *---------------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>path_encode</name><argument_list>(<argument><expr><name>PATH_CLOSED</name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        poly_recv            - converts external binary format to polygon
 *
 * External representation is int32 number of points, and the points.
 * We recompute the bounding box on read, instead of trusting it to
 * be valid.  (Checking it would take just as long, so may as well
 * omit it from external representation.)
 */</comment>
<function><type><name>Datum</name></type>
<name>poly_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfo</name></type>    <name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>npts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>npts</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>npts</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>npts</name> <operator>&gt;=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>INT_MAX</name> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>POLYGON</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid number of points in external \"polygon\" value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>POLYGON</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>npts</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>poly</name> <operator>=</operator> <operator>(</operator><name>POLYGON</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* zero any holes */</comment>

    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>poly</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>=</operator> <name>npts</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>make_bound_box</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POLYGON_P</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        poly_send            - converts polygon to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>poly_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*-------------------------------------------------------
 * Is polygon A strictly left of polygon B? i.e. is
 * the right most point of A left of the left most point
 * of B?
 *-------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_left</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>&lt;</operator> <name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Avoid leaking memory for toasted inputs ... needed for rtree indexes
     */</comment>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------
 * Is polygon A overlapping or left of polygon B? i.e. is
 * the right most point of A at or left of the right most point
 * of B?
 *-------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_overleft</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>&lt;=</operator> <name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Avoid leaking memory for toasted inputs ... needed for rtree indexes
     */</comment>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------
 * Is polygon A strictly right of polygon B? i.e. is
 * the left most point of A right of the right most point
 * of B?
 *-------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_right</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>&gt;</operator> <name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Avoid leaking memory for toasted inputs ... needed for rtree indexes
     */</comment>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------
 * Is polygon A overlapping or right of polygon B? i.e. is
 * the left most point of A at or right of the left most point
 * of B?
 *-------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_overright</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>&gt;=</operator> <name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Avoid leaking memory for toasted inputs ... needed for rtree indexes
     */</comment>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------
 * Is polygon A strictly below polygon B? i.e. is
 * the upper most point of A below the lower most point
 * of B?
 *-------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_below</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>&lt;</operator> <name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Avoid leaking memory for toasted inputs ... needed for rtree indexes
     */</comment>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------
 * Is polygon A overlapping or below polygon B? i.e. is
 * the upper most point of A at or below the upper most point
 * of B?
 *-------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_overbelow</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>&lt;=</operator> <name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Avoid leaking memory for toasted inputs ... needed for rtree indexes
     */</comment>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------
 * Is polygon A strictly above polygon B? i.e. is
 * the lower most point of A above the upper most point
 * of B?
 *-------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_above</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>&gt;</operator> <name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Avoid leaking memory for toasted inputs ... needed for rtree indexes
     */</comment>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------
 * Is polygon A overlapping or above polygon B? i.e. is
 * the lower most point of A at or above the lower most point
 * of B?
 *-------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_overabove</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>&gt;=</operator> <name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Avoid leaking memory for toasted inputs ... needed for rtree indexes
     */</comment>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*-------------------------------------------------------
 * Is polygon A the same as polygon B? i.e. are all the
 * points the same?
 * Check all points for matches in both forward and reverse
 *    direction since polygons are non-directional and are
 *    closed shapes.
 *-------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_same</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>polya</name><operator>-&gt;</operator><name>npts</name></name> <operator>!=</operator> <name><name>polyb</name><operator>-&gt;</operator><name>npts</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>plist_same</name><argument_list>(<argument><expr><name><name>polya</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>polya</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>polyb</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Avoid leaking memory for toasted inputs ... needed for rtree indexes
     */</comment>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-----------------------------------------------------------------
 * Determine if polygon A overlaps polygon B
 *-----------------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_overlap</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* Quick check by bounding box */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>polya</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>polyb</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
              <call><name>box_ov</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polya</name><operator>-&gt;</operator><name>boundbox</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/*
     * Brute-force algorithm - try to find intersected edges, if so then
     * polygons are overlapped else check is one polygon inside other or not
     * by testing single point of them.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>ia</name></decl>,
                    <decl><type ref="prev"/><name>ib</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LSEG</name></type>        <name>sa</name></decl>,
                    <decl><type ref="prev"/><name>sb</name></decl>;</decl_stmt>

        <comment type="block">/* Init first of polya's edge with last point */</comment>
        <expr_stmt><expr><name><name>sa</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>p</name><index>[<expr><name><name>polya</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>ia</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ia</name> <operator>&lt;</operator> <name><name>polya</name><operator>-&gt;</operator><name>npts</name></name> <operator>&amp;&amp;</operator> <name>result</name> <operator>==</operator> <name>false</name></expr>;</condition> <incr><expr><name>ia</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* Second point of polya's edge is a current one */</comment>
            <expr_stmt><expr><name><name>sa</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>ia</name></expr>]</index></name></expr>;</expr_stmt>

            <comment type="block">/* Init first of polyb's edge with last point */</comment>
            <expr_stmt><expr><name><name>sb</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>polyb</name><operator>-&gt;</operator><name>p</name><index>[<expr><name><name>polyb</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>ib</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ib</name> <operator>&lt;</operator> <name><name>polyb</name><operator>-&gt;</operator><name>npts</name></name> <operator>&amp;&amp;</operator> <name>result</name> <operator>==</operator> <name>false</name></expr>;</condition> <incr><expr><name>ib</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>sb</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>polyb</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>ib</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lseg_intersect_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>sb</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>sb</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></for>

            <comment type="block">/*
             * move current endpoint to the first point of next edge
             */</comment>
            <expr_stmt><expr><name><name>sa</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>sa</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>false</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>point_inside</name><argument_list>(<argument><expr><name><name>polya</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>polyb</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>polyb</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call>
                      <operator>||</operator>
                      <call><name>point_inside</name><argument_list>(<argument><expr><name><name>polyb</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>polya</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>polya</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Avoid leaking memory for toasted inputs ... needed for rtree indexes
     */</comment>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Tests special kind of segment for in/out of polygon.
 * Special kind means:
 *    - point a should be on segment s
 *    - segment (a,b) should not be contained by s
 * Returns true if:
 *    - segment (a,b) is collinear to s and (a,b) is in polygon
 *    - segment (a,b) s not collinear to s. Note: that doesn't
 *      mean that segment is in polygon!
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>touched_lseg_inside_poly</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>poly</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* point a is on s, b is not */</comment>
    <decl_stmt><decl><type><name>LSEG</name></type>        <name>t</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>t</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>a</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>b</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POINTEQ</name><parameter_list>(<parameter><type><name>pt1</name></type></parameter>, <parameter><type><name>pt2</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>(FPeq((pt1)-&gt;x, (pt2)-&gt;x) &amp;&amp; FPeq((pt1)-&gt;y, (pt2)-&gt;y))</cpp:value></cpp:define>
    <if_stmt><if>if <condition>(<expr><call><name>POINTEQ</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>on_ps_internal</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>lseg_inside_poly</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>poly</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>POINTEQ</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>on_ps_internal</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>lseg_inside_poly</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>poly</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>on_ps_internal</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><call><name>lseg_inside_poly</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>poly</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>on_ps_internal</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><call><name>lseg_inside_poly</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>poly</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>                <comment type="block">/* may be not true, but that will check later */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if segment (a,b) is in polygon, option
 * start is used for optimization - function checks
 * polygon's edges started from start
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>lseg_inside_poly</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>poly</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>LSEG</name></type>        <name>s</name></decl>,
                <decl><type ref="prev"/><name>t</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>res</name> <init>= <expr><name>true</name></expr></init></decl>,
                <decl><type ref="prev"/><name>intersection</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>t</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>a</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><ternary><condition><expr><operator>(</operator><name>start</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>start</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr>]</index></name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>&amp;&amp;</operator> <name>res</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>interpt</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>s</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>on_ps_internal</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>on_ps_internal</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* t is contained by s */</comment>

            <comment type="block">/* Y-cross */</comment>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>touched_lseg_inside_poly</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>.</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>poly</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>on_ps_internal</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Y-cross */</comment>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>touched_lseg_inside_poly</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>t</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>poly</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name>interpt</name> <operator>=</operator> <call><name>lseg_interpt_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * segments are X-crossing, go to check each subsegment
             */</comment>

            <expr_stmt><expr><name>intersection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>lseg_inside_poly</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><name>interpt</name></expr></argument>, <argument><expr><name>poly</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>lseg_inside_poly</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>interpt</name></expr></argument>, <argument><expr><name>poly</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>interpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>s</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>res</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>intersection</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Point</name></type>        <name>p</name></decl>;</decl_stmt>

        <comment type="block">/*
         * if X-intersection wasn't found  then check central point of tested
         * segment. In opposite case we already check all subsegments
         */</comment>
        <expr_stmt><expr><name><name>p</name><operator>.</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><name><name>t</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>+</operator> <name><name>t</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>.</operator><name>y</name></name> <operator>=</operator> <operator>(</operator><name><name>t</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>+</operator> <name><name>t</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>point_inside</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*-----------------------------------------------------------------
 * Determine if polygon A contains polygon B.
 *-----------------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_contain</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Quick check to see if bounding box is contained.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>polya</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>polyb</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_contain</name></expr></argument>,
                                         <argument><expr><call><name>BoxPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polya</name><operator>-&gt;</operator><name>boundbox</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>BoxPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LSEG</name></type>        <name>s</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>s</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>polyb</name><operator>-&gt;</operator><name>p</name><index>[<expr><name><name>polyb</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>polyb</name><operator>-&gt;</operator><name>npts</name></name> <operator>&amp;&amp;</operator> <name>result</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>s</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>polyb</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lseg_inside_poly</name><argument_list>(<argument><expr><name><name>s</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Avoid leaking memory for toasted inputs ... needed for rtree indexes
     */</comment>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*-----------------------------------------------------------------
 * Determine if polygon A is contained by polygon B
 *-----------------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_contained</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>polya</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>polyb</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Just switch the arguments and pass it off to poly_contain */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>poly_contain</name></expr></argument>, <argument><expr><name>polyb</name></expr></argument>, <argument><expr><name>polya</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>poly_contain_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>point_inside</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pt_contained_poly</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>point_inside</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>poly_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"poly_distance\" not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 **
 **        Routines for 2D points.
 **
 ***********************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>construct_point</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>float8</name></type>        <name>x</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>y</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><call><name>point_construct</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_add</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name><name>p2</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <name><name>p2</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_sub</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <name><name>p2</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <name><name>p2</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_mul</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>x</name></name> <operator>*</operator> <name><name>p2</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator> <operator>-</operator> <operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>y</name></name> <operator>*</operator> <name><name>p2</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>x</name></name> <operator>*</operator> <name><name>p2</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>y</name></name> <operator>*</operator> <name><name>p2</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_div</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>div</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>div</name> <operator>=</operator> <operator>(</operator><name><name>p2</name><operator>-&gt;</operator><name>x</name></name> <operator>*</operator> <name><name>p2</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>p2</name><operator>-&gt;</operator><name>y</name></name> <operator>*</operator> <name><name>p2</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>div</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DIVISION_BY_ZERO</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"division by zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>x</name></name> <operator>*</operator> <name><name>p2</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>y</name></name> <operator>*</operator> <name><name>p2</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator><operator>)</operator> <operator>/</operator> <name>div</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>p2</name><operator>-&gt;</operator><name>x</name></name> <operator>*</operator> <name><name>p1</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator> <operator>-</operator> <operator>(</operator><name><name>p2</name><operator>-&gt;</operator><name>y</name></name> <operator>*</operator> <name><name>p1</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator><operator>)</operator> <operator>/</operator> <name>div</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 **
 **        Routines for 2D boxes.
 **
 ***********************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>points_box</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><call><name>box_construct</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_add</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><call><name>box_construct</name><argument_list>(<argument><expr><operator>(</operator><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr></argument>,
                                  <argument><expr><operator>(</operator><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr></argument>,
                                  <argument><expr><operator>(</operator><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator></expr></argument>,
                                  <argument><expr><operator>(</operator><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_sub</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><call><name>box_construct</name><argument_list>(<argument><expr><operator>(</operator><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr></argument>,
                                  <argument><expr><operator>(</operator><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr></argument>,
                                  <argument><expr><operator>(</operator><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator></expr></argument>,
                                  <argument><expr><operator>(</operator><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_mul</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>high</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>low</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>high</name> <operator>=</operator> <call><name>DatumGetPointP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>point_mul</name></expr></argument>,
                                              <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>low</name> <operator>=</operator> <call><name>DatumGetPointP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>point_mul</name></expr></argument>,
                                             <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>box_construct</name><argument_list>(<argument><expr><name><name>high</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>low</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>high</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>low</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_div</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>high</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>low</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>high</name> <operator>=</operator> <call><name>DatumGetPointP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>point_div</name></expr></argument>,
                                              <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>low</name> <operator>=</operator> <call><name>DatumGetPointP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>point_div</name></expr></argument>,
                                             <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>box_construct</name><argument_list>(<argument><expr><name><name>high</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>low</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>high</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>low</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert point to empty box
 */</comment>
<function><type><name>Datum</name></type>
<name>point_box</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>box</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Smallest bounding box that includes both of the given boxes
 */</comment>
<function><type><name>Datum</name></type>
<name>boxes_bound_box</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>container</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>container</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>container</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>container</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>container</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>container</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 **
 **        Routines for 2D paths.
 **
 ***********************************************************************/</comment>

<comment type="block">/* path_add()
 * Concatenate two paths (only if they are both open).
 */</comment>
<function><type><name>Datum</name></type>
<name>path_add</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size</name></decl>,
                <decl><type ref="prev"/><name>base_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>closed</name></name> <operator>||</operator> <name><name>p2</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>base_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>+</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PATH</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>base_size</name></expr>;</expr_stmt>

    <comment type="block">/* Check for integer overflow */</comment>
    <if_stmt><if>if <condition>(<expr><name>base_size</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>!=</operator> <operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>+</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name><operator>)</operator> <operator>||</operator>
        <name>size</name> <operator>&lt;=</operator> <name>base_size</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many points requested"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PATH</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>npts</name></name> <operator>=</operator> <operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>+</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>closed</name></name></expr>;</expr_stmt>
    <comment type="block">/* prevent instability in unused pad bytes */</comment>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dummy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p1</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name> <operator>+</operator> <name><name>p1</name><operator>-&gt;</operator><name>npts</name></name></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name> <operator>+</operator> <name><name>p1</name><operator>-&gt;</operator><name>npts</name></name></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* path_add_pt()
 * Translation operators.
 */</comment>
<function><type><name>Datum</name></type>
<name>path_add_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>+=</operator> <name><name>point</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>+=</operator> <name><name>point</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_sub_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>-=</operator> <name><name>point</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>-=</operator> <name><name>point</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* path_mul_pt()
 * Rotation and scaling operators.
 */</comment>
<function><type><name>Datum</name></type>
<name>path_mul_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>DatumGetPointP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>point_mul</name></expr></argument>,
                                               <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                                               <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><name>point</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_div_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>DatumGetPointP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>point_div</name></expr></argument>,
                                               <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                                               <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><name>point</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>path_center</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"path_center\" not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_poly</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* This is not very consistent --- other similar cases return NULL ... */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>path</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"open path cannot be converted to polygon"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Never overflows: the old size fit in MaxAllocSize, and the new size is
     * just a small constant larger.
     */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>POLYGON</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>poly</name> <operator>=</operator> <operator>(</operator><name>POLYGON</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>poly</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>make_bound_box</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POLYGON_P</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 **
 **        Routines for 2D polygons.
 **
 ***********************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>poly_npoints</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>poly_center</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>circle</name> <operator>=</operator> <call><name>DatumGetCircleP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>poly_circle</name></expr></argument>,
                                                 <argument><expr><call><name>PolygonPGetDatum</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>circle_center</name></expr></argument>,
                                 <argument><expr><call><name>CirclePGetDatum</name><argument_list>(<argument><expr><name>circle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>poly_box</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>box</name> <operator>=</operator> <call><name>box_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poly</name><operator>-&gt;</operator><name>boundbox</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* box_poly()
 * Convert a box to a polygon.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_poly</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size</name></decl>;</decl_stmt>

    <comment type="block">/* map four corners of the box to a polygon */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>POLYGON</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>poly</name> <operator>=</operator> <operator>(</operator><name>POLYGON</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>poly</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>box_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poly</name><operator>-&gt;</operator><name>boundbox</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>,
             <argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POLYGON_P</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>poly_path</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PATH</name>       <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Never overflows: the old size fit in MaxAllocSize, and the new size is
     * smaller by a small constant.
     */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PATH</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>PATH</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>npts</name></name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <comment type="block">/* prevent instability in unused pad bytes */</comment>
    <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>dummy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 **
 **        Routines for circles.
 **
 ***********************************************************************/</comment>

<comment type="block">/*----------------------------------------------------------
 * Formatting and conversion routines.
 *---------------------------------------------------------*/</comment>

<comment type="block">/*        circle_in        -        convert a string to internal form.
 *
 *        External format: (center and radius of circle)
 *                "((f8,f8)&lt;f8&gt;)"
 *                also supports quick entry style "(f8,f8,f8)"
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name> <init>= <expr><operator>(</operator><name>CIRCLE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CIRCLE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>s</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>s</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <name>LDELIM_C</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <name>LDELIM</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>cp</name> <operator>=</operator> <operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <name>LDELIM</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>s</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pair_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"circle"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>DELIM</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name> <operator>=</operator> <call><name>single_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"circle"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
                        <argument><expr><literal type="string">"circle"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><name>depth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <name>RDELIM</name><operator>)</operator>
            <operator>||</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <name>RDELIM_C</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>depth</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>depth</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
            <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
                            <argument><expr><literal type="string">"circle"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
                        <argument><expr><literal type="string">"circle"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CIRCLE_P</name><argument_list>(<argument><expr><name>circle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        circle_out        -        convert a circle to external form.
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>LDELIM_C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>LDELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pair_encode</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>RDELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>single_encode</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>RDELIM_C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        circle_recv            - converts external binary format to circle
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfo</name></type>    <name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>circle</name> <operator>=</operator> <operator>(</operator><name>CIRCLE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CIRCLE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid radius in external \"circle\" value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CIRCLE_P</name><argument_list>(<argument><expr><name>circle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        circle_send            - converts circle to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *    Relational operators for CIRCLEs.
 *        &lt;, &gt;, &lt;=, &gt;=, and == are based on circle area.
 *---------------------------------------------------------*/</comment>

<comment type="block">/*        circles identical?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_same</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>, <argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FPeq</name><argument_list>(<argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FPeq</name><argument_list>(<argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        circle_overlap    -        does circle1 overlap circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_overlap</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle1</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle2</name><operator>-&gt;</operator><name>center</name></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name> <operator>+</operator> <name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        circle_overleft -        is the right edge of circle1 at or left of
 *                                the right edge of circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_overleft</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><operator>(</operator><name><name>circle1</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr></argument>,
                        <argument><expr><operator>(</operator><name><name>circle2</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        circle_left        -        is circle1 strictly left of circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_left</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPlt</name><argument_list>(<argument><expr><operator>(</operator><name><name>circle1</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr></argument>,
                        <argument><expr><operator>(</operator><name><name>circle2</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        circle_right    -        is circle1 strictly right of circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_right</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPgt</name><argument_list>(<argument><expr><operator>(</operator><name><name>circle1</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr></argument>,
                        <argument><expr><operator>(</operator><name><name>circle2</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        circle_overright    -    is the left edge of circle1 at or right of
 *                                the left edge of circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_overright</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPge</name><argument_list>(<argument><expr><operator>(</operator><name><name>circle1</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr></argument>,
                        <argument><expr><operator>(</operator><name><name>circle2</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        circle_contained        -        is circle1 contained by circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_contained</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><operator>(</operator><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle1</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle2</name><operator>-&gt;</operator><name>center</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        circle_contain    -        does circle1 contain circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_contain</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><operator>(</operator><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle1</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle2</name><operator>-&gt;</operator><name>center</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*        circle_below        -        is circle1 strictly below circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_below</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPlt</name><argument_list>(<argument><expr><operator>(</operator><name><name>circle1</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr></argument>,
                        <argument><expr><operator>(</operator><name><name>circle2</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        circle_above    -        is circle1 strictly above circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_above</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPgt</name><argument_list>(<argument><expr><operator>(</operator><name><name>circle1</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr></argument>,
                        <argument><expr><operator>(</operator><name><name>circle2</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        circle_overbelow -        is the upper edge of circle1 at or below
 *                                the upper edge of circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_overbelow</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><operator>(</operator><name><name>circle1</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr></argument>,
                        <argument><expr><operator>(</operator><name><name>circle2</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        circle_overabove    -    is the lower edge of circle1 at or above
 *                                the lower edge of circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_overabove</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPge</name><argument_list>(<argument><expr><operator>(</operator><name><name>circle1</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr></argument>,
                        <argument><expr><operator>(</operator><name><name>circle2</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*        circle_relop    -        is area(circle1) relop area(circle2), within
 *                                our accuracy constraint?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>circle_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPne</name><argument_list>(<argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>circle_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPlt</name><argument_list>(<argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>circle_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPgt</name><argument_list>(<argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>circle_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>circle_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPge</name><argument_list>(<argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *    "Arithmetic" operators on circles.
 *---------------------------------------------------------*/</comment>

<function><type><specifier>static</specifier> <name>CIRCLE</name> <modifier>*</modifier></type>
<name>circle_copy</name><parameter_list>(<parameter><decl><type><name>CIRCLE</name> <modifier>*</modifier></type><name>circle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>circle</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>CIRCLE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CIRCLE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>result</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>circle</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CIRCLE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* circle_add_pt()
 * Translation operator.
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_add_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>circle_copy</name><argument_list>(<argument><expr><name>circle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>+=</operator> <name><name>point</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>+=</operator> <name><name>point</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CIRCLE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>circle_sub_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>circle_copy</name><argument_list>(<argument><expr><name>circle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>-=</operator> <name><name>point</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>-=</operator> <name><name>point</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CIRCLE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* circle_mul_pt()
 * Rotation and scaling operators.
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_mul_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>circle_copy</name><argument_list>(<argument><expr><name>circle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>DatumGetPointP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>point_mul</name></expr></argument>,
                                           <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><name>point</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>radius</name></name> <operator>*=</operator> <call><name>HYPOT</name><argument_list>(<argument><expr><name><name>point</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>point</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CIRCLE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>circle_div_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>circle_copy</name><argument_list>(<argument><expr><name>circle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>DatumGetPointP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>point_div</name></expr></argument>,
                                           <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><name>point</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>radius</name></name> <operator>/=</operator> <call><name>HYPOT</name><argument_list>(<argument><expr><name><name>point</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>point</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CIRCLE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*        circle_area        -        returns the area of the circle.
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_area</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*        circle_diameter -        returns the diameter of the circle.
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_diameter</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*        circle_radius    -        returns the radius of the circle.
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_radius</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*        circle_distance -        returns the distance between
 *                                  two circles.
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle1</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle2</name><operator>-&gt;</operator><name>center</name></name></expr></argument>)</argument_list></call>
        <operator>-</operator> <operator>(</operator><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name> <operator>+</operator> <name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>circle_contain_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>d</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>d</name> <operator>&lt;=</operator> <name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>pt_contained_circle</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>d</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>d</name> <operator>&lt;=</operator> <name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*        dist_pc -        returns the distance between
 *                          a point and a circle.
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_pc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><name>point</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a circle to a point
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_cpoint</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><name>point</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        circle_center    -        returns the center point of the circle.
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_center</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*        circle_ar        -        returns the area of the circle.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>circle_ar</name><parameter_list>(<parameter><decl><type><name>CIRCLE</name> <modifier>*</modifier></type><name>circle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>M_PI</name> <operator>*</operator> <operator>(</operator><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name> <operator>*</operator> <name><name>circle</name><operator>-&gt;</operator><name>radius</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *    Conversion operators.
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>cr_circle</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>center</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type>        <name>radius</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>CIRCLE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CIRCLE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>center</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>center</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>radius</name></name> <operator>=</operator> <name>radius</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CIRCLE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>circle_box</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>delta</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>box</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>delta</name> <operator>=</operator> <name><name>circle</name><operator>-&gt;</operator><name>radius</name></name> <operator>/</operator> <call><name>sqrt</name><argument_list>(<argument><expr><literal type="number">2.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name>delta</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name>delta</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name>delta</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name>delta</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* box_circle()
 * Convert a box to a circle.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_circle</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>circle</name> <operator>=</operator> <operator>(</operator><name>CIRCLE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CIRCLE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>=</operator> <operator>(</operator><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name> <operator>=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CIRCLE_P</name><argument_list>(<argument><expr><name>circle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>circle_poly</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>npts</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>base_size</name></decl>,
                <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>angle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>anglestep</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert circle with radius zero to polygon"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>npts</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must request at least 2 points"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>base_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>npts</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>POLYGON</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>base_size</name></expr>;</expr_stmt>

    <comment type="block">/* Check for integer overflow */</comment>
    <if_stmt><if>if <condition>(<expr><name>base_size</name> <operator>/</operator> <name>npts</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>||</operator> <name>size</name> <operator>&lt;=</operator> <name>base_size</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many points requested"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>poly</name> <operator>=</operator> <operator>(</operator><name>POLYGON</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* zero any holes */</comment>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>poly</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>=</operator> <name>npts</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>anglestep</name> <operator>=</operator> <operator>(</operator><literal type="number">2.0</literal> <operator>*</operator> <name>M_PI</name><operator>)</operator> <operator>/</operator> <name>npts</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>angle</name> <operator>=</operator> <name>i</name> <operator>*</operator> <name>anglestep</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>-</operator> <operator>(</operator><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name> <operator>*</operator> <call><name>cos</name><argument_list>(<argument><expr><name>angle</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>+</operator> <operator>(</operator><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name> <operator>*</operator> <call><name>sin</name><argument_list>(<argument><expr><name>angle</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>make_bound_box</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POLYGON_P</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*        poly_circle        - convert polygon to circle
 *
 * XXX This algorithm should use weighted means of line segments
 *    rather than straight average values of points - tgl 97/01/21.
 */</comment>
<function><type><name>Datum</name></type>
<name>poly_circle</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>circle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert empty polygon to circle"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>circle</name> <operator>=</operator> <operator>(</operator><name>CIRCLE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CIRCLE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>+=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>+=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>/=</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>/=</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name> <operator>+=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name> <operator>/=</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CIRCLE_P</name><argument_list>(<argument><expr><name>circle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 **
 **        Private routines for multiple types.
 **
 ***********************************************************************/</comment>

<comment type="block">/*
 *    Test to see if the point is inside the polygon, returns 1/0, or 2 if
 *    the point is on the polygon.
 *    Code adapted but not copied from integer-based routines in WN: A
 *    Server for the HTTP
 *    version 1.15.1, file wn/image.c
 *    http://hopf.math.northwestern.edu/index.html
 *    Description of algorithm:  http://www.linuxjournal.com/article/2197
 *                               http://www.linuxjournal.com/article/2029
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POINT_ON_POLYGON</name></cpp:macro> <cpp:value>INT_MAX</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>point_inside</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>npts</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>plist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>x0</name></decl>,
                <decl><type ref="prev"/><name>y0</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>prev_x</name></decl>,
                <decl><type ref="prev"/><name>prev_y</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>x</name></decl>,
                <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>cross</name></decl>,
                <decl><type ref="prev"/><name>total_cross</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>npts</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* compute first polygon point relative to single point */</comment>
    <expr_stmt><expr><name>x0</name> <operator>=</operator> <name><name>plist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>y0</name> <operator>=</operator> <name><name>plist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>prev_x</name> <operator>=</operator> <name>x0</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prev_y</name> <operator>=</operator> <name>y0</name></expr>;</expr_stmt>
    <comment type="block">/* loop over polygon points and aggregate total_cross */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* compute next polygon point relative to single point */</comment>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>plist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>y</name> <operator>=</operator> <name><name>plist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>

        <comment type="block">/* compute previous to current point crossing */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cross</name> <operator>=</operator> <call><name>lseg_crossing</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>prev_x</name></expr></argument>, <argument><expr><name>prev_y</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>POINT_ON_POLYGON</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>total_cross</name> <operator>+=</operator> <name>cross</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>prev_x</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>prev_y</name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* now do the first point */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cross</name> <operator>=</operator> <call><name>lseg_crossing</name><argument_list>(<argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>prev_x</name></expr></argument>, <argument><expr><name>prev_y</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>POINT_ON_POLYGON</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>total_cross</name> <operator>+=</operator> <name>cross</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>total_cross</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* lseg_crossing()
 * Returns +/-2 if line segment crosses the positive X-axis in a +/- direction.
 * Returns +/-1 if one point is on the positive X-axis.
 * Returns 0 if both points are on the positive X-axis, or there is no crossing.
 * Returns POINT_ON_POLYGON if the segment contains (0,0).
 * Wow, that is one confusing API, but it is used above, and when summed,
 * can tell is if a point is in a polygon.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>lseg_crossing</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>prev_x</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>prev_y</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>z</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>y_sign</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>                            <comment type="block">/* y == 0, on X axis */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>            <comment type="block">/* (x,y) is (0,0)? */</comment>
            <return>return <expr><name>POINT_ON_POLYGON</name></expr>;</return></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>FPgt</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>                        <comment type="block">/* x &gt; 0 */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name>prev_y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* y and prev_y are zero */</comment>
                <comment type="block">/* prev_x &gt; 0? */</comment>
                <return>return <expr><ternary><condition><expr><call><name>FPgt</name><argument_list>(<argument><expr><name>prev_x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>POINT_ON_POLYGON</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><ternary><condition><expr><call><name>FPlt</name><argument_list>(<argument><expr><name>prev_y</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>                        <comment type="block">/* x &lt; 0, x not on positive X axis */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name>prev_y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <comment type="block">/* prev_x &lt; 0? */</comment>
                <return>return <expr><ternary><condition><expr><call><name>FPlt</name><argument_list>(<argument><expr><name>prev_x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>POINT_ON_POLYGON</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>                            <comment type="block">/* y != 0 */</comment>
        <comment type="block">/* compute y crossing direction from previous point */</comment>
        <expr_stmt><expr><name>y_sign</name> <operator>=</operator> <ternary><condition><expr><call><name>FPgt</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name>prev_y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <comment type="block">/* previous point was on X axis, so new point is either off or on */</comment>
            <return>return <expr><ternary><condition><expr><call><name>FPlt</name><argument_list>(<argument><expr><name>prev_x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>y_sign</name></expr></else></ternary></expr>;</return></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>FPgt</name><argument_list>(<argument><expr><name>y_sign</name> <operator>*</operator> <name>prev_y</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <comment type="block">/* both above or below X axis */</comment>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>            <comment type="block">/* same sign */</comment>
        <else>else
        <block>{<block_content>                        <comment type="block">/* y and prev_y cross X-axis */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>FPge</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FPgt</name><argument_list>(<argument><expr><name>prev_x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <comment type="block">/* both non-negative so cross positive X-axis */</comment>
                <return>return <expr><literal type="number">2</literal> <operator>*</operator> <name>y_sign</name></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>FPlt</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FPle</name><argument_list>(<argument><expr><name>prev_x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <comment type="block">/* both non-positive so do not cross positive X-axis */</comment>
                <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/* x and y cross axises, see URL above point_inside() */</comment>
            <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>-</operator> <name>prev_x</name><operator>)</operator> <operator>*</operator> <name>y</name> <operator>-</operator> <operator>(</operator><name>y</name> <operator>-</operator> <name>prev_y</name><operator>)</operator> <operator>*</operator> <name>x</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>POINT_ON_POLYGON</name></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><ternary><condition><expr><call><name>FPgt</name><argument_list>(<argument><expr><operator>(</operator><name>y_sign</name> <operator>*</operator> <name>z</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">2</literal> <operator>*</operator> <name>y_sign</name></expr></else></ternary></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>plist_same</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>npts</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>ii</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <comment type="block">/* find match for first point */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>FPeq</name><argument_list>(<argument><expr><name><name>p2</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>p1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call><operator>)</operator>
            <operator>&amp;&amp;</operator> <operator>(</operator><call><name>FPeq</name><argument_list>(<argument><expr><name><name>p2</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>p1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>

            <comment type="block">/* match found? then look forward through remaining points */</comment>
            <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>npts</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>npts</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>FPeq</name><argument_list>(<argument><expr><name><name>p2</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>p1</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call><operator>)</operator>
                    <operator>||</operator> <operator>(</operator><operator>!</operator><call><name>FPeq</name><argument_list>(<argument><expr><name><name>p2</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>p1</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
                <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
                    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"plist_same- %d failed forward match with %d\n"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"plist_same- ii = %d/%d after forward match\n"</literal></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><name>npts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if_stmt><if>if <condition>(<expr><name>ii</name> <operator>==</operator> <name>npts</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/* match not found forwards? then look backwards */</comment>
            <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>npts</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>--</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>j</name> <operator>=</operator> <operator>(</operator><name>npts</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>FPeq</name><argument_list>(<argument><expr><name><name>p2</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>p1</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call><operator>)</operator>
                    <operator>||</operator> <operator>(</operator><operator>!</operator><call><name>FPeq</name><argument_list>(<argument><expr><name><name>p2</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>p1</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
                <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
                    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"plist_same- %d failed reverse match with %d\n"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEODEBUG</name></cpp:ifdef>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"plist_same- ii = %d/%d after reverse match\n"</literal></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><name>npts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if_stmt><if>if <condition>(<expr><name>ii</name> <operator>==</operator> <name>npts</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-------------------------------------------------------------------------
 * Determine the hypotenuse.
 *
 * If required, x and y are swapped to make x the larger number. The
 * traditional formula of x^2+y^2 is rearranged to factor x outside the
 * sqrt. This allows computation of the hypotenuse for significantly
 * larger values, and with a higher precision than when using the naive
 * formula.  In particular, this cannot overflow unless the final result
 * would be out-of-range.
 *
 * sqrt( x^2 + y^2 ) = sqrt( x^2( 1 + y^2/x^2) )
 *                     = x * sqrt( 1 + y^2/x^2 )
 *                     = x * sqrt( 1 + y/x * y/x )
 *
 * It is expected that this routine will eventually be replaced with the
 * C99 hypot() function.
 *
 * This implementation conforms to IEEE Std 1003.1 and GLIBC, in that the
 * case of hypot(inf,nan) results in INF, and not NAN.
 *-----------------------------------------------------------------------
 */</comment>
<function><type><name>double</name></type>
<name>pg_hypot</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>yx</name></decl>;</decl_stmt>

    <comment type="block">/* Handle INF and NaN properly */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Else, drop any minus signs */</comment>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>fabs</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Swap x and y if needed to make x the larger one */</comment>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <name>y</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type>        <name>temp</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>x</name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>y</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If y is zero, the hypotenuse is x.  This test saves a few cycles in
     * such cases, but more importantly it also protects against
     * divide-by-zero errors, since now x &gt;= y.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>x</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Determine the hypotenuse */</comment>
    <expr_stmt><expr><name>yx</name> <operator>=</operator> <name>y</name> <operator>/</operator> <name>x</name></expr>;</expr_stmt>
    <return>return <expr><name>x</name> <operator>*</operator> <call><name>sqrt</name><argument_list>(<argument><expr><literal type="number">1.0</literal> <operator>+</operator> <operator>(</operator><name>yx</name> <operator>*</operator> <name>yx</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
