<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/adt/regexp.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * regexp.c
 *      Postgres' interface to the regular expression package.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/utils/adt/regexp.c
 *
 *        Alistair Crooks added the code for the regex caching
 *        agc - cached the regular expressions used - there's a good chance
 *        that we'll get a hit, so this saves a compile step for every
 *        attempted match. I haven't actually measured the speed improvement,
 *        but it `looks' a lot quicker visually when watching regression
 *        test output.
 *
 *        agc - incorporated Keith Bostic's Berkeley regex code into
 *        the tree for all ports. To distinguish this regex code from any that
 *        is existent on a platform, I've prepended the string "pg_" to
 *        the functions regcomp, regerror, regexec and regfree.
 *        Fixed a bug that was originally a typo by me, where `i' was used
 *        instead of `oldest' when compiling regular expressions - benign
 *        results mostly, although occasionally it bit you...
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regex/regex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_GETARG_TEXT_PP_IF_EXISTS</name><parameter_list>(<parameter><type><name>_n</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>(PG_NARGS() &gt; (_n) ? PG_GETARG_TEXT_PP(_n) : NULL)</cpp:value></cpp:define>


<comment type="block">/* all the options of interest for regex functions */</comment>
<typedef>typedef <type><struct>struct <name>pg_re_flags</name>
<block>{
    <decl_stmt><decl><type><name>int</name></type>            <name>cflags</name></decl>;</decl_stmt>            <comment type="block">/* compile flags for Spencer's regex code */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>glob</name></decl>;</decl_stmt>            <comment type="block">/* do it globally (for each occurrence) */</comment>
}</block></struct></type> <name>pg_re_flags</name>;</typedef>

<comment type="block">/* cross-call state for regexp_match and regexp_split functions */</comment>
<typedef>typedef <type><struct>struct <name>regexp_matches_ctx</name>
<block>{
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>orig_str</name></decl>;</decl_stmt>        <comment type="block">/* data string in original TEXT form */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>nmatches</name></decl>;</decl_stmt>        <comment type="block">/* number of places where pattern matched */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>npatterns</name></decl>;</decl_stmt>        <comment type="block">/* number of capturing subpatterns */</comment>
    <comment type="block">/* We store start char index and end+1 char index for each match */</comment>
    <comment type="block">/* so the number of entries in match_locs is nmatches * npatterns * 2 */</comment>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>match_locs</name></decl>;</decl_stmt>        <comment type="block">/* 0-based character indexes */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>next_match</name></decl>;</decl_stmt>        <comment type="block">/* 0-based index of next match to process */</comment>
    <comment type="block">/* workspace for build_regexp_match_result() */</comment>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>elems</name></decl>;</decl_stmt>            <comment type="block">/* has npatterns elements */</comment>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>            <comment type="block">/* has npatterns elements */</comment>
}</block></struct></type> <name>regexp_matches_ctx</name>;</typedef>

<comment type="block">/*
 * We cache precompiled regular expressions using a "self organizing list"
 * structure, in which recently-used items tend to be near the front.
 * Whenever we use an entry, it's moved up to the front of the list.
 * Over time, an item's average position corresponds to its frequency of use.
 *
 * When we first create an entry, it's inserted at the front of
 * the array, dropping the entry at the end of the array if necessary to
 * make room.  (This might seem to be weighting the new entry too heavily,
 * but if we insert new entries further back, we'll be unable to adjust to
 * a sudden shift in the query mix where we are presented with MAX_CACHED_RES
 * never-before-seen items used circularly.  We ought to be able to handle
 * that case, so we have to insert at the front.)
 *
 * Knuth mentions a variant strategy in which a used item is moved up just
 * one place in the list.  Although he says this uses fewer comparisons on
 * average, it seems not to adapt very well to the situation where you have
 * both some reusable patterns and a steady stream of non-reusable patterns.
 * A reusable pattern that isn't used at least as often as non-reusable
 * patterns are seen will "fail to keep up" and will drop off the end of the
 * cache.  With move-to-front, a reusable pattern is guaranteed to stay in
 * the cache as long as it's used at least once in every MAX_CACHED_RES uses.
 */</comment>

<comment type="block">/* this is the maximum number of cached regular expressions */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MAX_CACHED_RES</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_CACHED_RES</name></cpp:macro>    <cpp:value>32</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* this structure describes one cached regular expression */</comment>
<typedef>typedef <type><struct>struct <name>cached_re_str</name>
<block>{
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cre_pat</name></decl>;</decl_stmt>        <comment type="block">/* original RE (not null terminated!) */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>cre_pat_len</name></decl>;</decl_stmt>    <comment type="block">/* length of original RE, in bytes */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>cre_flags</name></decl>;</decl_stmt>        <comment type="block">/* compile flags: extended,icase etc */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>cre_collation</name></decl>;</decl_stmt>    <comment type="block">/* collation to use */</comment>
    <decl_stmt><decl><type><name>regex_t</name></type>        <name>cre_re</name></decl>;</decl_stmt>            <comment type="block">/* the compiled regular expression */</comment>
}</block></struct></type> <name>cached_re_str</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>num_res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* # of cached re's */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>cached_re_str</name></type> <name><name>re_array</name><index>[<expr><name>MAX_CACHED_RES</name></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* cached re's */</comment>


<comment type="block">/* Local functions */</comment>
<function_decl><type><specifier>static</specifier> <name>regexp_matches_ctx</name> <modifier>*</modifier></type><name>setup_regexp_matches</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>orig_str</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>,
                     <parameter><decl><type><name>pg_re_flags</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>,
                     <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>use_subpatterns</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>ignore_degenerate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cleanup_regexp_matches</name><parameter_list>(<parameter><decl><type><name>regexp_matches_ctx</name> <modifier>*</modifier></type><name>matchctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ArrayType</name> <modifier>*</modifier></type><name>build_regexp_match_result</name><parameter_list>(<parameter><decl><type><name>regexp_matches_ctx</name> <modifier>*</modifier></type><name>matchctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>build_regexp_split_result</name><parameter_list>(<parameter><decl><type><name>regexp_matches_ctx</name> <modifier>*</modifier></type><name>splitctx</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * RE_compile_and_cache - compile a RE, caching if possible
 *
 * Returns regex_t *
 *
 *    text_re --- the pattern, expressed as a TEXT object
 *    cflags --- compile options for the pattern
 *    collation --- collation to use for LC_CTYPE-dependent behavior
 *
 * Pattern is given in the database encoding.  We internally convert to
 * an array of pg_wchar, which is what Spencer's regex package wants.
 */</comment>
<function><type><specifier>static</specifier> <name>regex_t</name> <modifier>*</modifier></type>
<name>RE_compile_and_cache</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>text_re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cflags</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>text_re_len</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>text_re</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>text_re_val</name> <init>= <expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>text_re</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_wchar</name>   <modifier>*</modifier></type><name>pattern</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>pattern_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>regcomp_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cached_re_str</name></type> <name>re_temp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>errMsg</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*
     * Look for a match among previously compiled REs.  Since the data
     * structure is self-organizing with most-used entries at the front, our
     * search strategy can just be to scan from the front.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_res</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>re_array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cre_pat_len</name> <operator>==</operator> <name>text_re_len</name> <operator>&amp;&amp;</operator>
            <name><name>re_array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cre_flags</name> <operator>==</operator> <name>cflags</name> <operator>&amp;&amp;</operator>
            <name><name>re_array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cre_collation</name> <operator>==</operator> <name>collation</name> <operator>&amp;&amp;</operator>
            <call><name>memcmp</name><argument_list>(<argument><expr><name><name>re_array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cre_pat</name></expr></argument>, <argument><expr><name>text_re_val</name></expr></argument>, <argument><expr><name>text_re_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Found a match; move it to front if not there already.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>re_temp</name> <operator>=</operator> <name><name>re_array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>re_array</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>re_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>cached_re_str</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>re_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>re_temp</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <return>return <expr><operator>&amp;</operator><name><name>re_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>cre_re</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Couldn't find it, so try to compile the new RE.  To avoid leaking
     * resources on failure, we build into the re_temp local.
     */</comment>

    <comment type="block">/* Convert pattern string to wide characters */</comment>
    <expr_stmt><expr><name>pattern</name> <operator>=</operator> <operator>(</operator><name>pg_wchar</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>text_re_len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_wchar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pattern_len</name> <operator>=</operator> <call><name>pg_mb2wchar_with_len</name><argument_list>(<argument><expr><name>text_re_val</name></expr></argument>,
                                       <argument><expr><name>pattern</name></expr></argument>,
                                       <argument><expr><name>text_re_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>regcomp_result</name> <operator>=</operator> <call><name>pg_regcomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>re_temp</name><operator>.</operator><name>cre_re</name></name></expr></argument>,
                                <argument><expr><name>pattern</name></expr></argument>,
                                <argument><expr><name>pattern_len</name></expr></argument>,
                                <argument><expr><name>cflags</name></expr></argument>,
                                <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>regcomp_result</name> <operator>!=</operator> <name>REG_OKAY</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* re didn't compile (no need for pg_regfree, if so) */</comment>

        <comment type="block">/*
         * Here and in other places in this file, do CHECK_FOR_INTERRUPTS
         * before reporting a regex error.  This is so that if the regex
         * library aborts and returns REG_CANCEL, we don't print an error
         * message that implies the regex was invalid.
         */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pg_regerror</name><argument_list>(<argument><expr><name>regcomp_result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>re_temp</name><operator>.</operator><name>cre_re</name></name></expr></argument>, <argument><expr><name>errMsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errMsg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_REGULAR_EXPRESSION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid regular expression: %s"</literal></expr></argument>, <argument><expr><name>errMsg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We use malloc/free for the cre_pat field because the storage has to
     * persist across transactions, and because we want to get control back on
     * out-of-memory.  The Max() is because some malloc implementations return
     * NULL for malloc(0).
     */</comment>
    <expr_stmt><expr><name><name>re_temp</name><operator>.</operator><name>cre_pat</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>Max</name><argument_list>(<argument><expr><name>text_re_len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>re_temp</name><operator>.</operator><name>cre_pat</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pg_regfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>re_temp</name><operator>.</operator><name>cre_re</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>re_temp</name><operator>.</operator><name>cre_pat</name></name></expr></argument>, <argument><expr><name>text_re_val</name></expr></argument>, <argument><expr><name>text_re_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>re_temp</name><operator>.</operator><name>cre_pat_len</name></name> <operator>=</operator> <name>text_re_len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>re_temp</name><operator>.</operator><name>cre_flags</name></name> <operator>=</operator> <name>cflags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>re_temp</name><operator>.</operator><name>cre_collation</name></name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Okay, we have a valid new item in re_temp; insert it into the storage
     * array.  Discard last entry if needed.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>num_res</name> <operator>&gt;=</operator> <name>MAX_CACHED_RES</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>--</operator><name>num_res</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_res</name> <operator>&lt;</operator> <name>MAX_CACHED_RES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pg_regfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>re_array</name><index>[<expr><name>num_res</name></expr>]</index></name><operator>.</operator><name>cre_re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>re_array</name><index>[<expr><name>num_res</name></expr>]</index></name><operator>.</operator><name>cre_pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>num_res</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>re_array</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>re_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>num_res</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>cached_re_str</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>re_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>re_temp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>num_res</name><operator>++</operator></expr>;</expr_stmt>

    <return>return <expr><operator>&amp;</operator><name><name>re_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>cre_re</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RE_wchar_execute - execute a RE on pg_wchar data
 *
 * Returns TRUE on match, FALSE on no match
 *
 *    re --- the compiled pattern as returned by RE_compile_and_cache
 *    data --- the data to match against (need not be null-terminated)
 *    data_len --- the length of the data string
 *    start_search -- the offset in the data to start searching
 *    nmatch, pmatch    --- optional return area for match details
 *
 * Data is given as array of pg_wchar which is what Spencer's regex package
 * wants.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RE_wchar_execute</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>pg_wchar</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>data_len</name></decl></parameter>,
                 <parameter><decl><type><name>int</name></type> <name>start_search</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nmatch</name></decl></parameter>, <parameter><decl><type><name>regmatch_t</name> <modifier>*</modifier></type><name>pmatch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>regexec_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>errMsg</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* Perform RE match and return result */</comment>
    <expr_stmt><expr><name>regexec_result</name> <operator>=</operator> <call><name>pg_regexec</name><argument_list>(<argument><expr><name>re</name></expr></argument>,
                                <argument><expr><name>data</name></expr></argument>,
                                <argument><expr><name>data_len</name></expr></argument>,
                                <argument><expr><name>start_search</name></expr></argument>,
                                <argument><expr><name>NULL</name></expr></argument>,    <comment type="block">/* no details */</comment>
                                <argument><expr><name>nmatch</name></expr></argument>,
                                <argument><expr><name>pmatch</name></expr></argument>,
                                <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>regexec_result</name> <operator>!=</operator> <name>REG_OKAY</name> <operator>&amp;&amp;</operator> <name>regexec_result</name> <operator>!=</operator> <name>REG_NOMATCH</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* re failed??? */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pg_regerror</name><argument_list>(<argument><expr><name>regexec_result</name></expr></argument>, <argument><expr><name>re</name></expr></argument>, <argument><expr><name>errMsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errMsg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_REGULAR_EXPRESSION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"regular expression failed: %s"</literal></expr></argument>, <argument><expr><name>errMsg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><operator>(</operator><name>regexec_result</name> <operator>==</operator> <name>REG_OKAY</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RE_execute - execute a RE
 *
 * Returns TRUE on match, FALSE on no match
 *
 *    re --- the compiled pattern as returned by RE_compile_and_cache
 *    dat --- the data to match against (need not be null-terminated)
 *    dat_len --- the length of the data string
 *    nmatch, pmatch    --- optional return area for match details
 *
 * Data is given in the database encoding.  We internally
 * convert to array of pg_wchar which is what Spencer's regex package wants.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RE_execute</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dat</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dat_len</name></decl></parameter>,
           <parameter><decl><type><name>int</name></type> <name>nmatch</name></decl></parameter>, <parameter><decl><type><name>regmatch_t</name> <modifier>*</modifier></type><name>pmatch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>pg_wchar</name>   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>data_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>match</name></decl>;</decl_stmt>

    <comment type="block">/* Convert data string to wide characters */</comment>
    <expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>pg_wchar</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>dat_len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_wchar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>data_len</name> <operator>=</operator> <call><name>pg_mb2wchar_with_len</name><argument_list>(<argument><expr><name>dat</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>dat_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Perform RE match and return result */</comment>
    <expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>RE_wchar_execute</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>data_len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nmatch</name></expr></argument>, <argument><expr><name>pmatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>match</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RE_compile_and_execute - compile and execute a RE
 *
 * Returns TRUE on match, FALSE on no match
 *
 *    text_re --- the pattern, expressed as a TEXT object
 *    dat --- the data to match against (need not be null-terminated)
 *    dat_len --- the length of the data string
 *    cflags --- compile options for the pattern
 *    collation --- collation to use for LC_CTYPE-dependent behavior
 *    nmatch, pmatch    --- optional return area for match details
 *
 * Both pattern and data are given in the database encoding.  We internally
 * convert to array of pg_wchar which is what Spencer's regex package wants.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RE_compile_and_execute</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>text_re</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dat</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dat_len</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>cflags</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>nmatch</name></decl></parameter>, <parameter><decl><type><name>regmatch_t</name> <modifier>*</modifier></type><name>pmatch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>regex_t</name>    <modifier>*</modifier></type><name>re</name></decl>;</decl_stmt>

    <comment type="block">/* Compile RE */</comment>
    <expr_stmt><expr><name>re</name> <operator>=</operator> <call><name>RE_compile_and_cache</name><argument_list>(<argument><expr><name>text_re</name></expr></argument>, <argument><expr><name>cflags</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>RE_execute</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>dat</name></expr></argument>, <argument><expr><name>dat_len</name></expr></argument>, <argument><expr><name>nmatch</name></expr></argument>, <argument><expr><name>pmatch</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * parse_re_flags - parse the options argument of regexp_match and friends
 *
 *    flags --- output argument, filled with desired options
 *    opts --- TEXT object, or NULL for defaults
 *
 * This accepts all the options allowed by any of the callers; callers that
 * don't want some have to reject them after the fact.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_re_flags</name><parameter_list>(<parameter><decl><type><name>pg_re_flags</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* regex flavor is always folded into the compile flags */</comment>
    <expr_stmt><expr><name><name>flags</name><operator>-&gt;</operator><name>cflags</name></name> <operator>=</operator> <name>REG_ADVANCED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>flags</name><operator>-&gt;</operator><name>glob</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>opts</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>opt_p</name> <init>= <expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>opt_len</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>opt_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <switch>switch <condition>(<expr><name><name>opt_p</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><literal type="char">'g'</literal></expr>:</case>
                    <expr_stmt><expr><name><name>flags</name><operator>-&gt;</operator><name>glob</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'b'</literal></expr>:</case>        <comment type="block">/* BREs (but why???) */</comment>
                    <expr_stmt><expr><name><name>flags</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>REG_ADVANCED</name> <operator>|</operator> <name>REG_EXTENDED</name> <operator>|</operator> <name>REG_QUOTE</name><operator>)</operator></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'c'</literal></expr>:</case>        <comment type="block">/* case sensitive */</comment>
                    <expr_stmt><expr><name><name>flags</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>REG_ICASE</name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'e'</literal></expr>:</case>        <comment type="block">/* plain EREs */</comment>
                    <expr_stmt><expr><name><name>flags</name><operator>-&gt;</operator><name>cflags</name></name> <operator>|=</operator> <name>REG_EXTENDED</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>flags</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>REG_ADVANCED</name> <operator>|</operator> <name>REG_QUOTE</name><operator>)</operator></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'i'</literal></expr>:</case>        <comment type="block">/* case insensitive */</comment>
                    <expr_stmt><expr><name><name>flags</name><operator>-&gt;</operator><name>cflags</name></name> <operator>|=</operator> <name>REG_ICASE</name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'m'</literal></expr>:</case>        <comment type="block">/* Perloid synonym for n */</comment>
                <case>case <expr><literal type="char">'n'</literal></expr>:</case>        <comment type="block">/* \n affects ^ $ . [^ */</comment>
                    <expr_stmt><expr><name><name>flags</name><operator>-&gt;</operator><name>cflags</name></name> <operator>|=</operator> <name>REG_NEWLINE</name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'p'</literal></expr>:</case>        <comment type="block">/* ~Perl, \n affects . [^ */</comment>
                    <expr_stmt><expr><name><name>flags</name><operator>-&gt;</operator><name>cflags</name></name> <operator>|=</operator> <name>REG_NLSTOP</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>flags</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>REG_NLANCH</name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'q'</literal></expr>:</case>        <comment type="block">/* literal string */</comment>
                    <expr_stmt><expr><name><name>flags</name><operator>-&gt;</operator><name>cflags</name></name> <operator>|=</operator> <name>REG_QUOTE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>flags</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>REG_ADVANCED</name> <operator>|</operator> <name>REG_EXTENDED</name><operator>)</operator></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'s'</literal></expr>:</case>        <comment type="block">/* single line, \n ordinary */</comment>
                    <expr_stmt><expr><name><name>flags</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>REG_NEWLINE</name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'t'</literal></expr>:</case>        <comment type="block">/* tight syntax */</comment>
                    <expr_stmt><expr><name><name>flags</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>REG_EXPANDED</name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'w'</literal></expr>:</case>        <comment type="block">/* weird, \n affects ^ $ only */</comment>
                    <expr_stmt><expr><name><name>flags</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>REG_NLSTOP</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>flags</name><operator>-&gt;</operator><name>cflags</name></name> <operator>|=</operator> <name>REG_NLANCH</name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'x'</literal></expr>:</case>        <comment type="block">/* expanded syntax */</comment>
                    <expr_stmt><expr><name><name>flags</name><operator>-&gt;</operator><name>cflags</name></name> <operator>|=</operator> <name>REG_EXPANDED</name></expr>;</expr_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid regexp option: \"%c\""</literal></expr></argument>,
                                    <argument><expr><name><name>opt_p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *    interface routines called by the function manager
 */</comment>

<function><type><name>Datum</name></type>
<name>nameregexeq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Name</name></type>        <name>n</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>RE_compile_and_execute</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
                                          <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>REG_ADVANCED</name></expr></argument>,
                                          <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>,
                                          <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>nameregexne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Name</name></type>        <name>n</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>!</operator><call><name>RE_compile_and_execute</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
                                           <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><name>REG_ADVANCED</name></expr></argument>,
                                           <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>,
                                           <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>textregexeq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>RE_compile_and_execute</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
                                          <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>REG_ADVANCED</name></expr></argument>,
                                          <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>,
                                          <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>textregexne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>!</operator><call><name>RE_compile_and_execute</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
                                           <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><name>REG_ADVANCED</name></expr></argument>,
                                           <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>,
                                           <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *    routines that use the regexp stuff, but ignore the case.
 *    for this, we use the REG_ICASE flag to pg_regcomp
 */</comment>


<function><type><name>Datum</name></type>
<name>nameicregexeq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Name</name></type>        <name>n</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>RE_compile_and_execute</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
                                          <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>REG_ADVANCED</name> <operator>|</operator> <name>REG_ICASE</name></expr></argument>,
                                          <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>,
                                          <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>nameicregexne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Name</name></type>        <name>n</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>!</operator><call><name>RE_compile_and_execute</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
                                           <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><name>REG_ADVANCED</name> <operator>|</operator> <name>REG_ICASE</name></expr></argument>,
                                           <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>,
                                           <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>texticregexeq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>RE_compile_and_execute</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
                                          <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>REG_ADVANCED</name> <operator>|</operator> <name>REG_ICASE</name></expr></argument>,
                                          <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>,
                                          <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>texticregexne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>!</operator><call><name>RE_compile_and_execute</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
                                           <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><name>REG_ADVANCED</name> <operator>|</operator> <name>REG_ICASE</name></expr></argument>,
                                           <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>,
                                           <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * textregexsubstr()
 *        Return a substring matched by a regular expression.
 */</comment>
<function><type><name>Datum</name></type>
<name>textregexsubstr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>regex_t</name>    <modifier>*</modifier></type><name>re</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>regmatch_t</name></type>    <name><name>pmatch</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>so</name></decl>,
                <decl><type ref="prev"/><name>eo</name></decl>;</decl_stmt>

    <comment type="block">/* Compile RE */</comment>
    <expr_stmt><expr><name>re</name> <operator>=</operator> <call><name>RE_compile_and_cache</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>REG_ADVANCED</name></expr></argument>, <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We pass two regmatch_t structs to get info about the overall match and
     * the match for the first parenthesized subexpression (if any). If there
     * is a parenthesized subexpression, we return what it matched; else
     * return what the whole regexp matched.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RE_execute</name><argument_list>(<argument><expr><name>re</name></expr></argument>,
                    <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>pmatch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>        <comment type="block">/* definitely no match */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>re_nsub</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* has parenthesized subexpressions, use the first one */</comment>
        <expr_stmt><expr><name>so</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>rm_so</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>eo</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* no parenthesized subexpression, use whole match */</comment>
        <expr_stmt><expr><name>so</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>eo</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * It is possible to have a match to the whole pattern but no match for a
     * subexpression; for example 'foo(bar)?' is considered to match 'foo' but
     * there is no subexpression match.  So this extra test for match failure
     * is not redundant.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>so</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>eo</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>text_substr</name></expr></argument>,
                               <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>so</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>eo</name> <operator>-</operator> <name>so</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * textregexreplace_noopt()
 *        Return a string matched by a regular expression, with replacement.
 *
 * This version doesn't have an option argument: we default to case
 * sensitive match, replace the first instance only.
 */</comment>
<function><type><name>Datum</name></type>
<name>textregexreplace_noopt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>regex_t</name>    <modifier>*</modifier></type><name>re</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>re</name> <operator>=</operator> <call><name>RE_compile_and_cache</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>REG_ADVANCED</name></expr></argument>, <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>replace_text_regexp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>re</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * textregexreplace()
 *        Return a string matched by a regular expression, with replacement.
 */</comment>
<function><type><name>Datum</name></type>
<name>textregexreplace</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>opt</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>regex_t</name>    <modifier>*</modifier></type><name>re</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_re_flags</name></type> <name>flags</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>parse_re_flags</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>re</name> <operator>=</operator> <call><name>RE_compile_and_cache</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>flags</name><operator>.</operator><name>cflags</name></name></expr></argument>, <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>replace_text_regexp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>re</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>flags</name><operator>.</operator><name>glob</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * similar_escape()
 * Convert a SQL:2008 regexp pattern to POSIX style, so it can be used by
 * our regexp engine.
 */</comment>
<function><type><name>Datum</name></type>
<name>similar_escape</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>pat_text</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>esc_text</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>p</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>plen</name></decl>,
                <decl><type ref="prev"/><name>elen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>afterescape</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>incharclass</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nquotes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* This function is not strict, so must test explicitly */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pat_text</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>pat_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>plen</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>pat_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* No ESCAPE clause provided; default to backslash as escape */</comment>
        <expr_stmt><expr><name>e</name> <operator>=</operator> <literal type="string">"\\"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>elen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>esc_text</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>esc_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>elen</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>esc_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>elen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>e</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>            <comment type="block">/* no escape character */</comment>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>escape_mblen</name> <init>= <expr><call><name>pg_mbstrlen_with_len</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>elen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>escape_mblen</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ESCAPE_SEQUENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid escape string"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Escape string must be empty or one character."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*----------
     * We surround the transformed input string with
     *            ^(?: ... )$
     * which requires some explanation.  We need "^" and "$" to force
     * the pattern to match the entire input string as per SQL99 spec.
     * The "(?:" and ")" are a non-capturing set of parens; we have to have
     * parens in case the string contains "|", else the "^" and "$" will
     * be bound into the first and last alternatives which is not what we
     * want, and the parens must be non capturing because we don't want them
     * to count when selecting output for SUBSTRING.
     *----------
     */</comment>

    <comment type="block">/*
     * We need room for the prefix/postfix plus as many as 3 output bytes per
     * input byte; since the input is at most 1GB this can't overflow
     */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>VARHDRSZ</name> <operator>+</operator> <literal type="number">6</literal> <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'^'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'('</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'?'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>plen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name>pchar</name> <init>= <expr><operator>*</operator><name>p</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If both the escape character and the current character from the
         * pattern are multi-byte, we need to take the slow path.
         *
         * But if one of them is single-byte, we can process the pattern one
         * byte at a time, ignoring multi-byte characters.  (This works
         * because all server-encodings have the property that a valid
         * multi-byte character representation cannot contain the
         * representation of a valid single-byte character.)
         */</comment>

        <if_stmt><if>if <condition>(<expr><name>elen</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>mblen</name> <init>= <expr><call><name>pg_mblen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>mblen</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* slow, multi-byte path */</comment>
                <if_stmt><if>if <condition>(<expr><name>afterescape</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>mblen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>r</name> <operator>+=</operator> <name>mblen</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>afterescape</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>e</name> <operator>&amp;&amp;</operator> <name>elen</name> <operator>==</operator> <name>mblen</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>mblen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* SQL99 escape character; do not send to output */</comment>
                    <expr_stmt><expr><name>afterescape</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/*
                     * We know it's a multi-byte character, so we don't need
                     * to do all the comparisons to single-byte characters
                     * that we do below.
                     */</comment>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>mblen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>r</name> <operator>+=</operator> <name>mblen</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>mblen</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>plen</name> <operator>-=</operator> <name>mblen</name></expr>;</expr_stmt>

                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* fast path */</comment>
        <if_stmt><if>if <condition>(<expr><name>afterescape</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>pchar</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>incharclass</name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* for SUBSTRING patterns */</comment>
                <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>nquotes</name><operator>++</operator> <operator>%</operator> <literal type="number">2</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'('</literal></expr> </then><else>: <expr><literal type="char">')'</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <name>pchar</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>afterescape</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>e</name> <operator>&amp;&amp;</operator> <name>pchar</name> <operator>==</operator> <operator>*</operator><name>e</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* SQL99 escape character; do not send to output */</comment>
            <expr_stmt><expr><name>afterescape</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>incharclass</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>pchar</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <name>pchar</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>pchar</name> <operator>==</operator> <literal type="char">']'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>incharclass</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>pchar</name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <name>pchar</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>incharclass</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>pchar</name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>pchar</name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>pchar</name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* convert to non-capturing parenthesis */</comment>
            <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'('</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'?'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>pchar</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>||</operator> <name>pchar</name> <operator>==</operator> <literal type="char">'.'</literal> <operator>||</operator>
                 <name>pchar</name> <operator>==</operator> <literal type="char">'^'</literal> <operator>||</operator> <name>pchar</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <name>pchar</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <name>pchar</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr><operator>,</operator> <expr><name>plen</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">')'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'$'</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>r</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>result</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * regexp_match()
 *        Return the first substring(s) matching a pattern within a string.
 */</comment>
<function><type><name>Datum</name></type>
<name>regexp_match</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>orig_str</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>pattern</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>flags</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP_IF_EXISTS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_re_flags</name></type> <name>re_flags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>regexp_matches_ctx</name> <modifier>*</modifier></type><name>matchctx</name></decl>;</decl_stmt>

    <comment type="block">/* Determine options */</comment>
    <expr_stmt><expr><call><name>parse_re_flags</name><argument_list>(<argument><expr><operator>&amp;</operator><name>re_flags</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* User mustn't specify 'g' */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>re_flags</name><operator>.</operator><name>glob</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"regexp_match does not support the global option"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the regexp_matches function instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>matchctx</name> <operator>=</operator> <call><name>setup_regexp_matches</name><argument_list>(<argument><expr><name>orig_str</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>re_flags</name></expr></argument>,
                                    <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>matchctx</name><operator>-&gt;</operator><name>nmatches</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>matchctx</name><operator>-&gt;</operator><name>nmatches</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create workspace that build_regexp_match_result needs */</comment>
    <expr_stmt><expr><name><name>matchctx</name><operator>-&gt;</operator><name>elems</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>matchctx</name><operator>-&gt;</operator><name>npatterns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>matchctx</name><operator>-&gt;</operator><name>nulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>matchctx</name><operator>-&gt;</operator><name>npatterns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>build_regexp_match_result</name><argument_list>(<argument><expr><name>matchctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This is separate to keep the opr_sanity regression test from complaining */</comment>
<function><type><name>Datum</name></type>
<name>regexp_match_no_flags</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>regexp_match</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * regexp_matches()
 *        Return a table of all matches of a pattern within a string.
 */</comment>
<function><type><name>Datum</name></type>
<name>regexp_matches</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>regexp_matches_ctx</name> <modifier>*</modifier></type><name>matchctx</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>pattern</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>flags</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP_IF_EXISTS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>pg_re_flags</name></type> <name>re_flags</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Determine options */</comment>
        <expr_stmt><expr><call><name>parse_re_flags</name><argument_list>(<argument><expr><operator>&amp;</operator><name>re_flags</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* be sure to copy the input string into the multi-call ctx */</comment>
        <expr_stmt><expr><name>matchctx</name> <operator>=</operator> <call><name>setup_regexp_matches</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pattern</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>re_flags</name></expr></argument>,
                                        <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>,
                                        <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Pre-create workspace that build_regexp_match_result needs */</comment>
        <expr_stmt><expr><name><name>matchctx</name><operator>-&gt;</operator><name>elems</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>matchctx</name><operator>-&gt;</operator><name>npatterns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>matchctx</name><operator>-&gt;</operator><name>nulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>matchctx</name><operator>-&gt;</operator><name>npatterns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>matchctx</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>matchctx</name> <operator>=</operator> <operator>(</operator><name>regexp_matches_ctx</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>matchctx</name><operator>-&gt;</operator><name>next_match</name></name> <operator>&lt;</operator> <name><name>matchctx</name><operator>-&gt;</operator><name>nmatches</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result_ary</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result_ary</name> <operator>=</operator> <call><name>build_regexp_match_result</name><argument_list>(<argument><expr><name>matchctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>matchctx</name><operator>-&gt;</operator><name>next_match</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>result_ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* release space in multi-call ctx to avoid intraquery memory leak */</comment>
    <expr_stmt><expr><call><name>cleanup_regexp_matches</name><argument_list>(<argument><expr><name>matchctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This is separate to keep the opr_sanity regression test from complaining */</comment>
<function><type><name>Datum</name></type>
<name>regexp_matches_no_flags</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>regexp_matches</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * setup_regexp_matches --- do the initial matching for regexp_match
 *        and regexp_split functions
 *
 * To avoid having to re-find the compiled pattern on each call, we do
 * all the matching in one swoop.  The returned regexp_matches_ctx contains
 * the locations of all the substrings matching the pattern.
 *
 * The two bool parameters have only two patterns (one for matching, one for
 * splitting) but it seems clearer to distinguish the functionality this way
 * than to key it all off one "is_split" flag.
 */</comment>
<function><type><specifier>static</specifier> <name>regexp_matches_ctx</name> <modifier>*</modifier></type>
<name>setup_regexp_matches</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>orig_str</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>pg_re_flags</name> <modifier>*</modifier></type><name>re_flags</name></decl></parameter>,
                     <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>use_subpatterns</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>ignore_degenerate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>regexp_matches_ctx</name> <modifier>*</modifier></type><name>matchctx</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>regexp_matches_ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>orig_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_wchar</name>   <modifier>*</modifier></type><name>wide_str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>wide_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>regex_t</name>    <modifier>*</modifier></type><name>cpattern</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>regmatch_t</name> <modifier>*</modifier></type><name>pmatch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>pmatch_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>array_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>array_idx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>prev_match_end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>start_search</name></decl>;</decl_stmt>

    <comment type="block">/* save original string --- we'll extract result substrings from it */</comment>
    <expr_stmt><expr><name><name>matchctx</name><operator>-&gt;</operator><name>orig_str</name></name> <operator>=</operator> <name>orig_str</name></expr>;</expr_stmt>

    <comment type="block">/* convert string to pg_wchar form for matching */</comment>
    <expr_stmt><expr><name>orig_len</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>orig_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>wide_str</name> <operator>=</operator> <operator>(</operator><name>pg_wchar</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pg_wchar</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>orig_len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>wide_len</name> <operator>=</operator> <call><name>pg_mb2wchar_with_len</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>orig_str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>wide_str</name></expr></argument>, <argument><expr><name>orig_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set up the compiled pattern */</comment>
    <expr_stmt><expr><name>cpattern</name> <operator>=</operator> <call><name>RE_compile_and_cache</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name><name>re_flags</name><operator>-&gt;</operator><name>cflags</name></name></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* do we want to remember subpatterns? */</comment>
    <if_stmt><if>if <condition>(<expr><name>use_subpatterns</name> <operator>&amp;&amp;</operator> <name><name>cpattern</name><operator>-&gt;</operator><name>re_nsub</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>matchctx</name><operator>-&gt;</operator><name>npatterns</name></name> <operator>=</operator> <name><name>cpattern</name><operator>-&gt;</operator><name>re_nsub</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pmatch_len</name> <operator>=</operator> <name><name>cpattern</name><operator>-&gt;</operator><name>re_nsub</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>use_subpatterns</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>matchctx</name><operator>-&gt;</operator><name>npatterns</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>pmatch_len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* temporary output space for RE package */</comment>
    <expr_stmt><expr><name>pmatch</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>regmatch_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>pmatch_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* the real output space (grown dynamically if needed) */</comment>
    <expr_stmt><expr><name>array_len</name> <operator>=</operator> <ternary><condition><expr><name><name>re_flags</name><operator>-&gt;</operator><name>glob</name></name></expr> ?</condition><then> <expr><literal type="number">256</literal></expr> </then><else>: <expr><literal type="number">32</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>matchctx</name><operator>-&gt;</operator><name>match_locs</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>array_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>array_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* search for the pattern, perhaps repeatedly */</comment>
    <expr_stmt><expr><name>prev_match_end</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>start_search</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>RE_wchar_execute</name><argument_list>(<argument><expr><name>cpattern</name></expr></argument>, <argument><expr><name>wide_str</name></expr></argument>, <argument><expr><name>wide_len</name></expr></argument>, <argument><expr><name>start_search</name></expr></argument>,
                            <argument><expr><name>pmatch_len</name></expr></argument>, <argument><expr><name>pmatch</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If requested, ignore degenerate matches, which are zero-length
         * matches occurring at the start or end of a string or just after a
         * previous match.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ignore_degenerate</name> <operator>||</operator>
            <operator>(</operator><name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>&lt;</operator> <name>wide_len</name> <operator>&amp;&amp;</operator>
             <name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name> <operator>&gt;</operator> <name>prev_match_end</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* enlarge output space if needed */</comment>
            <while>while <condition>(<expr><name>array_idx</name> <operator>+</operator> <name><name>matchctx</name><operator>-&gt;</operator><name>npatterns</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>&gt;</operator> <name>array_len</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>array_len</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>matchctx</name><operator>-&gt;</operator><name>match_locs</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>matchctx</name><operator>-&gt;</operator><name>match_locs</name></name></expr></argument>,
                                                        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>array_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>

            <comment type="block">/* save this match's locations */</comment>
            <if_stmt><if>if <condition>(<expr><name>use_subpatterns</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>matchctx</name><operator>-&gt;</operator><name>npatterns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>matchctx</name><operator>-&gt;</operator><name>match_locs</name><index>[<expr><name>array_idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rm_so</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>matchctx</name><operator>-&gt;</operator><name>match_locs</name><index>[<expr><name>array_idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>matchctx</name><operator>-&gt;</operator><name>match_locs</name><index>[<expr><name>array_idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>matchctx</name><operator>-&gt;</operator><name>match_locs</name><index>[<expr><name>array_idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name><name>matchctx</name><operator>-&gt;</operator><name>nmatches</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>prev_match_end</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr>;</expr_stmt>

        <comment type="block">/* if not glob, stop after one match */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>re_flags</name><operator>-&gt;</operator><name>glob</name></name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Advance search position.  Normally we start the next search at the
         * end of the previous match; but if the match was of zero length, we
         * have to advance by one character, or we'd just find the same match
         * again.
         */</comment>
        <expr_stmt><expr><name>start_search</name> <operator>=</operator> <name>prev_match_end</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>==</operator> <name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>start_search</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>start_search</name> <operator>&gt;</operator> <name>wide_len</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Clean up temp storage */</comment>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>wide_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pmatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>matchctx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cleanup_regexp_matches - release memory of a regexp_matches_ctx
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleanup_regexp_matches</name><parameter_list>(<parameter><decl><type><name>regexp_matches_ctx</name> <modifier>*</modifier></type><name>matchctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>matchctx</name><operator>-&gt;</operator><name>orig_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>matchctx</name><operator>-&gt;</operator><name>match_locs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>matchctx</name><operator>-&gt;</operator><name>elems</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>matchctx</name><operator>-&gt;</operator><name>elems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>matchctx</name><operator>-&gt;</operator><name>nulls</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>matchctx</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>matchctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * build_regexp_match_result - build output array for current match
 */</comment>
<function><type><specifier>static</specifier> <name>ArrayType</name> <modifier>*</modifier></type>
<name>build_regexp_match_result</name><parameter_list>(<parameter><decl><type><name>regexp_matches_ctx</name> <modifier>*</modifier></type><name>matchctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>elems</name> <init>= <expr><name><name>matchctx</name><operator>-&gt;</operator><name>elems</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name><name>matchctx</name><operator>-&gt;</operator><name>nulls</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name><name>dims</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name><name>lbs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>loc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Extract matching substrings from the original string */</comment>
    <expr_stmt><expr><name>loc</name> <operator>=</operator> <name><name>matchctx</name><operator>-&gt;</operator><name>next_match</name></name> <operator>*</operator> <name><name>matchctx</name><operator>-&gt;</operator><name>npatterns</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>matchctx</name><operator>-&gt;</operator><name>npatterns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>so</name> <init>= <expr><name><name>matchctx</name><operator>-&gt;</operator><name>match_locs</name><index>[<expr><name>loc</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>eo</name> <init>= <expr><name><name>matchctx</name><operator>-&gt;</operator><name>match_locs</name><index>[<expr><name>loc</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>so</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>eo</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>text_substr</name></expr></argument>,
                                           <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>matchctx</name><operator>-&gt;</operator><name>orig_str</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>so</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>eo</name> <operator>-</operator> <name>so</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* And form an array */</comment>
    <expr_stmt><expr><name><name>dims</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>matchctx</name><operator>-&gt;</operator><name>npatterns</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* XXX: this hardcodes assumptions about the text type */</comment>
    <return>return <expr><call><name>construct_md_array</name><argument_list>(<argument><expr><name>elems</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>lbs</name></expr></argument>,
                              <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * regexp_split_to_table()
 *        Split the string at matches of the pattern, returning the
 *        split-out substrings as a table.
 */</comment>
<function><type><name>Datum</name></type>
<name>regexp_split_to_table</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>regexp_matches_ctx</name> <modifier>*</modifier></type><name>splitctx</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>pattern</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>flags</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP_IF_EXISTS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>pg_re_flags</name></type> <name>re_flags</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Determine options */</comment>
        <expr_stmt><expr><call><name>parse_re_flags</name><argument_list>(<argument><expr><operator>&amp;</operator><name>re_flags</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* User mustn't specify 'g' */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>re_flags</name><operator>.</operator><name>glob</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"regexp_split_to_table does not support the global option"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* But we find all the matches anyway */</comment>
        <expr_stmt><expr><name><name>re_flags</name><operator>.</operator><name>glob</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <comment type="block">/* be sure to copy the input string into the multi-call ctx */</comment>
        <expr_stmt><expr><name>splitctx</name> <operator>=</operator> <call><name>setup_regexp_matches</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pattern</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>re_flags</name></expr></argument>,
                                        <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>,
                                        <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>splitctx</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>splitctx</name> <operator>=</operator> <operator>(</operator><name>regexp_matches_ctx</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>splitctx</name><operator>-&gt;</operator><name>next_match</name></name> <operator>&lt;=</operator> <name><name>splitctx</name><operator>-&gt;</operator><name>nmatches</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name> <init>= <expr><call><name>build_regexp_split_result</name><argument_list>(<argument><expr><name>splitctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>splitctx</name><operator>-&gt;</operator><name>next_match</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* release space in multi-call ctx to avoid intraquery memory leak */</comment>
    <expr_stmt><expr><call><name>cleanup_regexp_matches</name><argument_list>(<argument><expr><name>splitctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This is separate to keep the opr_sanity regression test from complaining */</comment>
<function><type><name>Datum</name></type>
<name>regexp_split_to_table_no_flags</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>regexp_split_to_table</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * regexp_split_to_array()
 *        Split the string at matches of the pattern, returning the
 *        split-out substrings as an array.
 */</comment>
<function><type><name>Datum</name></type>
<name>regexp_split_to_array</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>astate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_re_flags</name></type> <name>re_flags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>regexp_matches_ctx</name> <modifier>*</modifier></type><name>splitctx</name></decl>;</decl_stmt>

    <comment type="block">/* Determine options */</comment>
    <expr_stmt><expr><call><name>parse_re_flags</name><argument_list>(<argument><expr><operator>&amp;</operator><name>re_flags</name></expr></argument>, <argument><expr><call><name>PG_GETARG_TEXT_PP_IF_EXISTS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* User mustn't specify 'g' */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>re_flags</name><operator>.</operator><name>glob</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"regexp_split_to_array does not support the global option"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* But we find all the matches anyway */</comment>
    <expr_stmt><expr><name><name>re_flags</name><operator>.</operator><name>glob</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>splitctx</name> <operator>=</operator> <call><name>setup_regexp_matches</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>re_flags</name></expr></argument>,
                                    <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name><name>splitctx</name><operator>-&gt;</operator><name>next_match</name></name> <operator>&lt;=</operator> <name><name>splitctx</name><operator>-&gt;</operator><name>nmatches</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>accumArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>,
                                  <argument><expr><call><name>build_regexp_split_result</name><argument_list>(<argument><expr><name>splitctx</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>false</name></expr></argument>,
                                  <argument><expr><name>TEXTOID</name></expr></argument>,
                                  <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>splitctx</name><operator>-&gt;</operator><name>next_match</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * We don't call cleanup_regexp_matches here; it would try to pfree the
     * input string, which we didn't copy.  The space is not in a long-lived
     * memory context anyway.
     */</comment>

    <expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>makeArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This is separate to keep the opr_sanity regression test from complaining */</comment>
<function><type><name>Datum</name></type>
<name>regexp_split_to_array_no_flags</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>regexp_split_to_array</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * build_regexp_split_result - build output string for current match
 *
 * We return the string between the current match and the previous one,
 * or the string after the last match when next_match == nmatches.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>build_regexp_split_result</name><parameter_list>(<parameter><decl><type><name>regexp_matches_ctx</name> <modifier>*</modifier></type><name>splitctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>startpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>endpos</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>splitctx</name><operator>-&gt;</operator><name>next_match</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>startpos</name> <operator>=</operator> <name><name>splitctx</name><operator>-&gt;</operator><name>match_locs</name><index>[<expr><name><name>splitctx</name><operator>-&gt;</operator><name>next_match</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>startpos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>startpos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid match ending position"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>splitctx</name><operator>-&gt;</operator><name>next_match</name></name> <operator>&lt;</operator> <name><name>splitctx</name><operator>-&gt;</operator><name>nmatches</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>endpos</name> <operator>=</operator> <name><name>splitctx</name><operator>-&gt;</operator><name>match_locs</name><index>[<expr><name><name>splitctx</name><operator>-&gt;</operator><name>next_match</name></name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>endpos</name> <operator>&lt;</operator> <name>startpos</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid match starting position"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>text_substr</name></expr></argument>,
                                   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>splitctx</name><operator>-&gt;</operator><name>orig_str</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>startpos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>endpos</name> <operator>-</operator> <name>startpos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* no more matches, return rest of string */</comment>
        <return>return <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>text_substr_no_len</name></expr></argument>,
                                   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>splitctx</name><operator>-&gt;</operator><name>orig_str</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>startpos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * regexp_fixed_prefix - extract fixed prefix, if any, for a regexp
 *
 * The result is NULL if there is no fixed prefix, else a palloc'd string.
 * If it is an exact match, not just a prefix, *exact is returned as TRUE.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>regexp_fixed_prefix</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>text_re</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>case_insensitive</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
                    <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>exact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>regex_t</name>    <modifier>*</modifier></type><name>re</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>cflags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>re_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_wchar</name>   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>slen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>maxlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>errMsg</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>exact</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>                <comment type="block">/* default result */</comment>

    <comment type="block">/* Compile RE */</comment>
    <expr_stmt><expr><name>cflags</name> <operator>=</operator> <name>REG_ADVANCED</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>case_insensitive</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>cflags</name> <operator>|=</operator> <name>REG_ICASE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>re</name> <operator>=</operator> <call><name>RE_compile_and_cache</name><argument_list>(<argument><expr><name>text_re</name></expr></argument>, <argument><expr><name>cflags</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Examine it to see if there's a fixed prefix */</comment>
    <expr_stmt><expr><name>re_result</name> <operator>=</operator> <call><name>pg_regprefix</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>re_result</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>REG_NOMATCH</name></expr>:</case>
            <return>return <expr><name>NULL</name></expr>;</return>

        <case>case <expr><name>REG_PREFIX</name></expr>:</case>
            <comment type="block">/* continue with wchar conversion */</comment>
            <break>break;</break>

        <case>case <expr><name>REG_EXACT</name></expr>:</case>
            <expr_stmt><expr><operator>*</operator><name>exact</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <comment type="block">/* continue with wchar conversion */</comment>
            <break>break;</break>

        <default>default:</default>
            <comment type="block">/* re failed??? */</comment>
            <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pg_regerror</name><argument_list>(<argument><expr><name>re_result</name></expr></argument>, <argument><expr><name>re</name></expr></argument>, <argument><expr><name>errMsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errMsg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_REGULAR_EXPRESSION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"regular expression failed: %s"</literal></expr></argument>, <argument><expr><name>errMsg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* Convert pg_wchar result back to database encoding */</comment>
    <expr_stmt><expr><name>maxlen</name> <operator>=</operator> <call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>*</operator> <name>slen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>maxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>pg_wchar2mb_with_len</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slen</name> <operator>&lt;</operator> <name>maxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
