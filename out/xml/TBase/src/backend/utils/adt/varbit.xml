<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/adt/varbit.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * varbit.c
 *      Functions for the SQL datatypes BIT() and BIT VARYING().
 *
 * Code originally contributed by Adriaan Joubert.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *      src/backend/utils/adt/varbit.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varbit.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEXDIG</name><parameter_list>(<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro>     <cpp:value>((z)&lt;10 ? ((z)+'0') : ((z)-10+'A'))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>VarBit</name> <modifier>*</modifier></type><name>bit_catenate</name><parameter_list>(<parameter><decl><type><name>VarBit</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>VarBit</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>VarBit</name> <modifier>*</modifier></type><name>bitsubstring</name><parameter_list>(<parameter><decl><type><name>VarBit</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>l</name></decl></parameter>,
             <parameter><decl><type><name>bool</name></type> <name>length_not_specified</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>VarBit</name> <modifier>*</modifier></type><name>bit_overlay</name><parameter_list>(<parameter><decl><type><name>VarBit</name> <modifier>*</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><name>VarBit</name> <modifier>*</modifier></type><name>t2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sl</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * common code for bittypmodin and varbittypmodin
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>anybit_typmodin</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>ta</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>typmod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name>       <modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>n</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tl</name> <operator>=</operator> <call><name>ArrayGetIntegerTypmods</name><argument_list>(<argument><expr><name>ta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * we're not too tense about good error message here because grammar
     * shouldn't allow wrong number of modifiers for BIT
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid type modifier"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tl</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"length for type %s must be at least 1"</literal></expr></argument>,
                        <argument><expr><name>typename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tl</name> <operator>&gt;</operator> <operator>(</operator><name>MaxAttrSize</name> <operator>*</operator> <name>BITS_PER_BYTE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"length for type %s cannot exceed %d"</literal></expr></argument>,
                        <argument><expr><name>typename</name></expr></argument>, <argument><expr><name>MaxAttrSize</name> <operator>*</operator> <name>BITS_PER_BYTE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>typmod</name> <operator>=</operator> <operator>*</operator><name>tl</name></expr>;</expr_stmt>

    <return>return <expr><name>typmod</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * common code for bittypmodout and varbittypmodout
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>anybit_typmodout</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>res</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"(%d)"</literal></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*----------
 *    attypmod -- contains the length of the bit string in bits, or for
 *               varying bits the maximum length.
 *
 *    The data structure contains the following elements:
 *      header  -- length of the whole data structure (incl header)
 *                 in bytes. (as with all varying length datatypes)
 *      data section -- private data section for the bits data structures
 *        bitlength -- length of the bit string in bits
 *        bitdata   -- bit string, most significant byte first
 *
 *    The length of the bitdata vector should always be exactly as many
 *    bytes as are needed for the given bitlength.  If the bitlength is
 *    not a multiple of 8, the extra low-order padding bits of the last
 *    byte must be zeroes.
 *----------
 */</comment>

<comment type="block">/*
 * bit_in -
 *      converts a char string to the internal representation of a bitstring.
 *          The length is determined by the number of bits required plus
 *          VARHDRSZ bytes or from atttypmod.
 */</comment>
<function><type><name>Datum</name></type>
<name>bit_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>input_string</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>typelem</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int32</name></type>        <name>atttypmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>            <comment type="block">/* The resulting bit string              */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>                <comment type="block">/* pointer into the character string  */</comment>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>                <comment type="block">/* pointer into the result */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>,            <comment type="block">/* Length of the whole data structure */</comment>
                <decl><type ref="prev"/><name>bitlen</name></decl>,            <comment type="block">/* Number of bits in the bit string   */</comment>
                <decl><type ref="prev"/><name>slen</name></decl>;</decl_stmt>            <comment type="block">/* Length of the input string          */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>bit_not_hex</name></decl>;</decl_stmt>    <comment type="block">/* false = hex string  true = bit string */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>bc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name></type>        <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Check that the first character is a b or an x */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>input_string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'b'</literal> <operator>||</operator> <name><name>input_string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'B'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>bit_not_hex</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sp</name> <operator>=</operator> <name>input_string</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>input_string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal> <operator>||</operator> <name><name>input_string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'X'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>bit_not_hex</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sp</name> <operator>=</operator> <name>input_string</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Otherwise it's binary.  This allows things like cast('1001' as bit)
         * to work transparently.
         */</comment>
        <expr_stmt><expr><name>bit_not_hex</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sp</name> <operator>=</operator> <name>input_string</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Determine bitlength from input string.  MaxAllocSize ensures a regular
     * input is small enough, but we must check hex input.
     */</comment>
    <expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>bit_not_hex</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>bitlen</name> <operator>=</operator> <name>slen</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&gt;</operator> <name>VARBITMAXLEN</name> <operator>/</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bit string length exceeds the maximum allowed (%d)"</literal></expr></argument>,
                            <argument><expr><name>VARBITMAXLEN</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>bitlen</name> <operator>=</operator> <name>slen</name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Sometimes atttypmod is not supplied. If it is supplied we need to make
     * sure that the bitstring fits.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>atttypmod</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>atttypmod</name> <operator>=</operator> <name>bitlen</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>bitlen</name> <operator>!=</operator> <name>atttypmod</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STRING_DATA_LENGTH_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bit string length %d does not match type bit(%d)"</literal></expr></argument>,
                        <argument><expr><name>bitlen</name></expr></argument>, <argument><expr><name>atttypmod</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARBITTOTALLEN</name><argument_list>(<argument><expr><name>atttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* set to 0 so that *r is always initialised and string is zero-padded */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VarBit</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>atttypmod</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>bit_not_hex</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Parse the bit representation of the string */</comment>
        <comment type="block">/* We know it fits, as bitlen was compared to atttypmod */</comment>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <name>HIGHBIT</name></expr>;</expr_stmt>
        <for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>sp</name></expr>;</condition> <incr><expr><name>sp</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>sp</name> <operator>==</operator> <literal type="char">'1'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>r</name> <operator>|=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>*</operator><name>sp</name> <operator>!=</operator> <literal type="char">'0'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%c\" is not a valid binary digit"</literal></expr></argument>,
                                <argument><expr><operator>*</operator><name>sp</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>x</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>x</name> <operator>=</operator> <name>HIGHBIT</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Parse the hex representation of the string */</comment>
        <for>for <control>(<init><expr><name>bc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>sp</name></expr>;</condition> <incr><expr><name>sp</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>sp</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>sp</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>bits8</name><operator>)</operator> <operator>(</operator><operator>*</operator><name>sp</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>*</operator><name>sp</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>sp</name> <operator>&lt;=</operator> <literal type="char">'F'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>bits8</name><operator>)</operator> <operator>(</operator><operator>*</operator><name>sp</name> <operator>-</operator> <literal type="char">'A'</literal><operator>)</operator> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>*</operator><name>sp</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>sp</name> <operator>&lt;=</operator> <literal type="char">'f'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>bits8</name><operator>)</operator> <operator>(</operator><operator>*</operator><name>sp</name> <operator>-</operator> <literal type="char">'a'</literal><operator>)</operator> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%c\" is not a valid hexadecimal digit"</literal></expr></argument>,
                                <argument><expr><operator>*</operator><name>sp</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>bc</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>|=</operator> <name>x</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>bc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <name>x</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>bc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>bit_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
    <comment type="block">/* same as varbit output */</comment>
    <return>return <expr><call><name>varbit_out</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

    <comment type="block">/*
     * This is how one would print a hex string, in case someone wants to
     * write a formatting function.
     */</comment>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>len</name></decl>,
                <decl><type ref="prev"/><name>bitlen</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bitlen</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>bitlen</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator> <operator>/</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'X'</literal></expr>;</expr_stmt>
    <comment type="block">/* we cheat by knowing that we store full bytes zero padded */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr><operator>,</operator> <expr><name>sp</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <call><name>HEXDIG</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>sp</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <call><name>HEXDIG</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>sp</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Go back one step if we printed a hex number that was not part of the
     * bitstring anymore
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>r</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 *        bit_recv            - converts external binary format to bit
 */</comment>
<function><type><name>Datum</name></type>
<name>bit_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfo</name></type>    <name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>typelem</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int32</name></type>        <name>atttypmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>,
                <decl><type ref="prev"/><name>bitlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ipad</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name></type>        <name>mask</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bitlen</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>bitlen</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>bitlen</name></expr></argument> &gt;</argument_list></name> <name>VARBITMAXLEN</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid length in external bit string"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Sometimes atttypmod is not supplied. If it is supplied we need to make
     * sure that the bitstring fits.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>atttypmod</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bitlen</name> <operator>!=</operator> <name>atttypmod</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STRING_DATA_LENGTH_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bit string length %d does not match type bit(%d)"</literal></expr></argument>,
                        <argument><expr><name>bitlen</name></expr></argument>, <argument><expr><name>atttypmod</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARBITTOTALLEN</name><argument_list>(<argument><expr><name>bitlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VarBit</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>bitlen</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pq_copymsgbytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make sure last byte is zero-padded if needed */</comment>
    <expr_stmt><expr><name>ipad</name> <operator>=</operator> <call><name>VARBITPAD</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ipad</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>BITMASK</name> <operator>&lt;&lt;</operator> <name>ipad</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        bit_send            - converts bit to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>bit_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Exactly the same as varbit_send, so share code */</comment>
    <return>return <expr><call><name>varbit_send</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bit()
 * Converts a bit() type to a specific internal length.
 * len is the bitlength specified in the column definition.
 *
 * If doing implicit cast, raise error when source data is wrong length.
 * If doing explicit cast, silently truncate or zero-pad to specified length.
 */</comment>
<function><type><name>Datum</name></type>
<name>bit</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>len</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isExplicit</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ipad</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name></type>        <name>mask</name></decl>;</decl_stmt>

    <comment type="block">/* No work if typmod is invalid or supplied data matches it already */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>len</name> <operator>&gt;</operator> <name>VARBITMAXLEN</name> <operator>||</operator> <name>len</name> <operator>==</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isExplicit</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STRING_DATA_LENGTH_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bit string length %d does not match type bit(%d)"</literal></expr></argument>,
                        <argument><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rlen</name> <operator>=</operator> <call><name>VARBITTOTALLEN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* set to 0 so that string is zero-padded */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VarBit</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>rlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARBITS</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name>Min</name><argument_list>(<argument><expr><call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Make sure last byte is zero-padded if needed.  This is useless but safe
     * if source data was shorter than target length (we assume the last byte
     * of the source data was itself correctly zero-padded).
     */</comment>
    <expr_stmt><expr><name>ipad</name> <operator>=</operator> <call><name>VARBITPAD</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ipad</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>BITMASK</name> <operator>&lt;&lt;</operator> <name>ipad</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bittypmodin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>ta</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>anybit_typmodin</name><argument_list>(<argument><expr><name>ta</name></expr></argument>, <argument><expr><literal type="string">"bit"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bittypmodout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>anybit_typmodout</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * varbit_in -
 *      converts a string to the internal representation of a bitstring.
 *        This is the same as bit_in except that atttypmod is taken as
 *        the maximum length, not the exact length to force the bitstring to.
 */</comment>
<function><type><name>Datum</name></type>
<name>varbit_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>input_string</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>typelem</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int32</name></type>        <name>atttypmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>            <comment type="block">/* The resulting bit string              */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>                <comment type="block">/* pointer into the character string  */</comment>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>                <comment type="block">/* pointer into the result */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>,            <comment type="block">/* Length of the whole data structure */</comment>
                <decl><type ref="prev"/><name>bitlen</name></decl>,            <comment type="block">/* Number of bits in the bit string   */</comment>
                <decl><type ref="prev"/><name>slen</name></decl>;</decl_stmt>            <comment type="block">/* Length of the input string          */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>bit_not_hex</name></decl>;</decl_stmt>    <comment type="block">/* false = hex string  true = bit string */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>bc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name></type>        <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Check that the first character is a b or an x */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>input_string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'b'</literal> <operator>||</operator> <name><name>input_string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'B'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>bit_not_hex</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sp</name> <operator>=</operator> <name>input_string</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>input_string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal> <operator>||</operator> <name><name>input_string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'X'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>bit_not_hex</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sp</name> <operator>=</operator> <name>input_string</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>bit_not_hex</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sp</name> <operator>=</operator> <name>input_string</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Determine bitlength from input string.  MaxAllocSize ensures a regular
     * input is small enough, but we must check hex input.
     */</comment>
    <expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>bit_not_hex</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>bitlen</name> <operator>=</operator> <name>slen</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&gt;</operator> <name>VARBITMAXLEN</name> <operator>/</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bit string length exceeds the maximum allowed (%d)"</literal></expr></argument>,
                            <argument><expr><name>VARBITMAXLEN</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>bitlen</name> <operator>=</operator> <name>slen</name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Sometimes atttypmod is not supplied. If it is supplied we need to make
     * sure that the bitstring fits.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>atttypmod</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>atttypmod</name> <operator>=</operator> <name>bitlen</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>bitlen</name> <operator>&gt;</operator> <name>atttypmod</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STRING_DATA_RIGHT_TRUNCATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bit string too long for type bit varying(%d)"</literal></expr></argument>,
                        <argument><expr><name>atttypmod</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARBITTOTALLEN</name><argument_list>(<argument><expr><name>bitlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* set to 0 so that *r is always initialised and string is zero-padded */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VarBit</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>bitlen</name></expr></argument>, <argument><expr><name>atttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>bit_not_hex</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Parse the bit representation of the string */</comment>
        <comment type="block">/* We know it fits, as bitlen was compared to atttypmod */</comment>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <name>HIGHBIT</name></expr>;</expr_stmt>
        <for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>sp</name></expr>;</condition> <incr><expr><name>sp</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>sp</name> <operator>==</operator> <literal type="char">'1'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>r</name> <operator>|=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>*</operator><name>sp</name> <operator>!=</operator> <literal type="char">'0'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%c\" is not a valid binary digit"</literal></expr></argument>,
                                <argument><expr><operator>*</operator><name>sp</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>x</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>x</name> <operator>=</operator> <name>HIGHBIT</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Parse the hex representation of the string */</comment>
        <for>for <control>(<init><expr><name>bc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>sp</name></expr>;</condition> <incr><expr><name>sp</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>sp</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>sp</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>bits8</name><operator>)</operator> <operator>(</operator><operator>*</operator><name>sp</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>*</operator><name>sp</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>sp</name> <operator>&lt;=</operator> <literal type="char">'F'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>bits8</name><operator>)</operator> <operator>(</operator><operator>*</operator><name>sp</name> <operator>-</operator> <literal type="char">'A'</literal><operator>)</operator> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>*</operator><name>sp</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>sp</name> <operator>&lt;=</operator> <literal type="char">'f'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>bits8</name><operator>)</operator> <operator>(</operator><operator>*</operator><name>sp</name> <operator>-</operator> <literal type="char">'a'</literal><operator>)</operator> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%c\" is not a valid hexadecimal digit"</literal></expr></argument>,
                                <argument><expr><operator>*</operator><name>sp</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>bc</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>|=</operator> <name>x</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>bc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <name>x</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>bc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * varbit_out -
 *      Prints the string as bits to preserve length accurately
 *
 * XXX varbit_recv() and hex input to varbit_in() can load a value that this
 * cannot emit.  Consider using hex output for such values.
 */</comment>
<function><type><name>Datum</name></type>
<name>varbit_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name></type>        <name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>k</name></decl>,
                <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>len</name> <operator>-</operator> <name>BITS_PER_BYTE</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>BITS_PER_BYTE</name></expr><operator>,</operator> <expr><name>sp</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* print full bytes */</comment>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>*</operator><name>sp</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>BITS_PER_BYTE</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="char">'1'</literal></expr> </then><else>: <expr><literal type="char">'0'</literal></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>x</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* print the last partial byte */</comment>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>*</operator><name>sp</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="char">'1'</literal></expr> </then><else>: <expr><literal type="char">'0'</literal></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>x</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        varbit_recv            - converts external binary format to varbit
 *
 * External format is the bitlen as an int32, then the byte array.
 */</comment>
<function><type><name>Datum</name></type>
<name>varbit_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfo</name></type>    <name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>typelem</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int32</name></type>        <name>atttypmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>,
                <decl><type ref="prev"/><name>bitlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ipad</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name></type>        <name>mask</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bitlen</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>bitlen</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>bitlen</name></expr></argument> &gt;</argument_list></name> <name>VARBITMAXLEN</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid length in external bit string"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Sometimes atttypmod is not supplied. If it is supplied we need to make
     * sure that the bitstring fits.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>atttypmod</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bitlen</name> <operator>&gt;</operator> <name>atttypmod</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STRING_DATA_RIGHT_TRUNCATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bit string too long for type bit varying(%d)"</literal></expr></argument>,
                        <argument><expr><name>atttypmod</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARBITTOTALLEN</name><argument_list>(<argument><expr><name>bitlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VarBit</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>bitlen</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pq_copymsgbytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make sure last byte is zero-padded if needed */</comment>
    <expr_stmt><expr><name>ipad</name> <operator>=</operator> <call><name>VARBITPAD</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ipad</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>BITMASK</name> <operator>&lt;&lt;</operator> <name>ipad</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        varbit_send            - converts varbit to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>varbit_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * varbit_transform()
 * Flatten calls to varbit's length coercion function that set the new maximum
 * length &gt;= the previous maximum length.  We can ignore the isExplicit
 * argument, since that only affects truncation cases.
 */</comment>
<function><type><name>Datum</name></type>
<name>varbit_transform</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>typmod</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>typmod</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><operator>!</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>typmod</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>source</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>new_typmod</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>typmod</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>old_max</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>new_max</name> <init>= <expr><name>new_typmod</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Note: varbit() treats typmod 0 as invalid, so we do too */</comment>
        <if_stmt><if>if <condition>(<expr><name>new_max</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>old_max</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>old_max</name> <operator>&lt;=</operator> <name>new_max</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>relabel_to_typmod</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>new_typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * varbit()
 * Converts a varbit() type to a specific internal length.
 * len is the maximum bitlength specified in the column definition.
 *
 * If doing implicit cast, raise error when source data is too long.
 * If doing explicit cast, silently truncate to max length.
 */</comment>
<function><type><name>Datum</name></type>
<name>varbit</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>len</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isExplicit</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ipad</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name></type>        <name>mask</name></decl>;</decl_stmt>

    <comment type="block">/* No work if typmod is invalid or supplied data matches it already */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>len</name> <operator>&gt;=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isExplicit</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STRING_DATA_RIGHT_TRUNCATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bit string too long for type bit varying(%d)"</literal></expr></argument>,
                        <argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rlen</name> <operator>=</operator> <call><name>VARBITTOTALLEN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VarBit</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>rlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARBITS</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make sure last byte is zero-padded if needed */</comment>
    <expr_stmt><expr><name>ipad</name> <operator>=</operator> <call><name>VARBITPAD</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ipad</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>BITMASK</name> <operator>&lt;&lt;</operator> <name>ipad</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>varbittypmodin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>ta</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>anybit_typmodin</name><argument_list>(<argument><expr><name>ta</name></expr></argument>, <argument><expr><literal type="string">"varbit"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>varbittypmodout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>anybit_typmodout</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Comparison operators
 *
 * We only need one set of comparison operators for bitstrings, as the lengths
 * are stored in the same way for zero-padded and varying bit strings.
 *
 * Note that the standard is not unambiguous about the comparison between
 * zero-padded bit strings and varying bitstrings. If the same value is written
 * into a zero padded bitstring as into a varying bitstring, but the zero
 * padded bitstring has greater length, it will be bigger.
 *
 * Zeros from the beginning of a bitstring cannot simply be ignored, as they
 * may be part of a bit string and may be significant.
 *
 * Note: btree indexes need these routines not to leak memory; therefore,
 * be careful to free working copies of toasted datums.  Most places don't
 * need to be so careful.
 */</comment>

<comment type="block">/*
 * bit_cmp
 *
 * Compares two bitstrings and returns &lt;0, 0, &gt;0 depending on whether the first
 * string is smaller, equal, or bigger than the second. All bits are considered
 * and additional zero bits may make one string smaller/larger than the other,
 * even if their zero-padded values would be the same.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>bit_cmp</name><parameter_list>(<parameter><decl><type><name>VarBit</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>VarBit</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>bitlen1</name></decl>,
                <decl><type ref="prev"/><name>bytelen1</name></decl>,
                <decl><type ref="prev"/><name>bitlen2</name></decl>,
                <decl><type ref="prev"/><name>bytelen2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>cmp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bytelen1</name> <operator>=</operator> <call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bytelen2</name> <operator>=</operator> <call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><call><name>VARBITS</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARBITS</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>bytelen1</name></expr></argument>, <argument><expr><name>bytelen2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>bitlen1</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bitlen2</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>bitlen1</name> <operator>!=</operator> <name>bitlen2</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>cmp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>bitlen1</name> <operator>&lt;</operator> <name>bitlen2</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>cmp</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>biteq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>bitlen1</name></decl>,
                <decl><type ref="prev"/><name>bitlen2</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bitlen1</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bitlen2</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* fast path for different-length inputs */</comment>
    <if_stmt><if>if <condition>(<expr><name>bitlen1</name> <operator>!=</operator> <name>bitlen2</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>bit_cmp</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bitne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>bitlen1</name></decl>,
                <decl><type ref="prev"/><name>bitlen2</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bitlen1</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bitlen2</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* fast path for different-length inputs */</comment>
    <if_stmt><if>if <condition>(<expr><name>bitlen1</name> <operator>!=</operator> <name>bitlen2</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>bit_cmp</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bitlt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>bit_cmp</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bitle</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>bit_cmp</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bitgt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>bit_cmp</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bitge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>bit_cmp</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bitcmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bit_cmp</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bitcat
 * Concatenation of bit strings
 */</comment>
<function><type><name>Datum</name></type>
<name>bitcat</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><call><name>bit_catenate</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VarBit</name> <modifier>*</modifier></type>
<name>bit_catenate</name><parameter_list>(<parameter><decl><type><name>VarBit</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>VarBit</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>bitlen1</name></decl>,
                <decl><type ref="prev"/><name>bitlen2</name></decl>,
                <decl><type ref="prev"/><name>bytelen</name></decl>,
                <decl><type ref="prev"/><name>bit1pad</name></decl>,
                <decl><type ref="prev"/><name>bit2shift</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>pr</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>pa</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bitlen1</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bitlen2</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>bitlen1</name> <operator>&gt;</operator> <name>VARBITMAXLEN</name> <operator>-</operator> <name>bitlen2</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bit string length exceeds the maximum allowed (%d)"</literal></expr></argument>,
                        <argument><expr><name>VARBITMAXLEN</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>bytelen</name> <operator>=</operator> <call><name>VARBITTOTALLEN</name><argument_list>(<argument><expr><name>bitlen1</name> <operator>+</operator> <name>bitlen2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VarBit</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>bytelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>bytelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>bitlen1</name> <operator>+</operator> <name>bitlen2</name></expr>;</expr_stmt>

    <comment type="block">/* Copy the first bitstring in */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARBITS</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Copy the second bit string */</comment>
    <expr_stmt><expr><name>bit1pad</name> <operator>=</operator> <call><name>VARBITPAD</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>bit1pad</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARBITS</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>bitlen2</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We need to shift all the bits to fit */</comment>
        <expr_stmt><expr><name>bit2shift</name> <operator>=</operator> <name>BITS_PER_BYTE</name> <operator>-</operator> <name>bit1pad</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pr</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>pa</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pa</name> <operator>&lt;</operator> <call><name>VARBITEND</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>pa</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>pr</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>pa</name> <operator>&gt;&gt;</operator> <name>bit2shift</name><operator>)</operator> <operator>&amp;</operator> <name>BITMASK</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>pr</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>pr</name> <operator>&lt;</operator> <call><name>VARBITEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>pr</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>pa</name> <operator>&lt;&lt;</operator> <name>bit1pad</name><operator>)</operator> <operator>&amp;</operator> <name>BITMASK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bitsubstr
 * retrieve a substring from the bit string.
 * Note, s is 1-based.
 * SQL draft 6.10 9)
 */</comment>
<function><type><name>Datum</name></type>
<name>bitsubstr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><call><name>bitsubstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bitsubstr_no_len</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><call><name>bitsubstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VarBit</name> <modifier>*</modifier></type>
<name>bitsubstring</name><parameter_list>(<parameter><decl><type><name>VarBit</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>length_not_specified</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>bitlen</name></decl>,
                <decl><type ref="prev"/><name>rbitlen</name></decl>,
                <decl><type ref="prev"/><name>len</name></decl>,
                <decl><type ref="prev"/><name>ipad</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>ishift</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>e</name></decl>,
                <decl><type ref="prev"/><name>s1</name></decl>,
                <decl><type ref="prev"/><name>e1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name></type>        <name>mask</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>ps</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bitlen</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If we do not have an upper bound, use end of string */</comment>
    <if_stmt><if>if <condition>(<expr><name>length_not_specified</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>e1</name> <operator>=</operator> <name>bitlen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>e</name> <operator>=</operator> <name>s</name> <operator>+</operator> <name>l</name></expr>;</expr_stmt>

        <comment type="block">/*
         * A negative value for L is the only way for the end position to be
         * before the start. SQL99 says to throw an error.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>e</name> <operator>&lt;</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SUBSTRING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"negative substring length not allowed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>e1</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>bitlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>s1</name> <operator>&gt;</operator> <name>bitlen</name> <operator>||</operator> <name>e1</name> <operator>&lt;=</operator> <name>s1</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Need to return a zero-length bitstring */</comment>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARBITTOTALLEN</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VarBit</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * OK, we've got a true substring starting at position s1-1 and ending
         * at position e1-1
         */</comment>
        <expr_stmt><expr><name>rbitlen</name> <operator>=</operator> <name>e1</name> <operator>-</operator> <name>s1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARBITTOTALLEN</name><argument_list>(<argument><expr><name>rbitlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VarBit</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>rbitlen</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>-=</operator> <name>VARHDRSZ</name> <operator>+</operator> <name>VARBITHDRSZ</name></expr>;</expr_stmt>
        <comment type="block">/* Are we copying from a byte boundary? */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>s1</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>BITS_PER_BYTE</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Yep, we are copying bytes */</comment>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARBITS</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name>s1</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>BITS_PER_BYTE</name></expr></argument>,
                   <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Figure out how much we need to shift the sequence by */</comment>
            <expr_stmt><expr><name>ishift</name> <operator>=</operator> <operator>(</operator><name>s1</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ps</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name>s1</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>ps</name> <operator>&lt;&lt;</operator> <name>ishift</name><operator>)</operator> <operator>&amp;</operator> <name>BITMASK</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>++</operator><name>ps</name><operator>)</operator> <operator>&lt;</operator> <call><name>VARBITEND</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>r</name> <operator>|=</operator> <operator>*</operator><name>ps</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>BITS_PER_BYTE</name> <operator>-</operator> <name>ishift</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* Do we need to pad at the end? */</comment>
        <expr_stmt><expr><name>ipad</name> <operator>=</operator> <call><name>VARBITPAD</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ipad</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>BITMASK</name> <operator>&lt;&lt;</operator> <name>ipad</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bitoverlay
 *    Replace specified substring of first string with second
 *
 * The SQL standard defines OVERLAY() in terms of substring and concatenation.
 * This code is a direct implementation of what the standard says.
 */</comment>
<function><type><name>Datum</name></type>
<name>bitoverlay</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>t1</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>t2</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>sp</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>    <comment type="block">/* substring start position */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>sl</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>    <comment type="block">/* substring length */</comment>

    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><call><name>bit_overlay</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>sl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bitoverlay_no_len</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>t1</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>t2</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>sp</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>    <comment type="block">/* substring start position */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>sl</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>sl</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* defaults to length(t2) */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><call><name>bit_overlay</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>sl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VarBit</name> <modifier>*</modifier></type>
<name>bit_overlay</name><parameter_list>(<parameter><decl><type><name>VarBit</name> <modifier>*</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><name>VarBit</name> <modifier>*</modifier></type><name>t2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>s1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>sp_pl_sl</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Check for possible integer-overflow cases.  For negative sp, throw a
     * "substring length" error because that's what should be expected
     * according to the spec's definition of OVERLAY().
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>sp</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SUBSTRING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"negative substring length not allowed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>sp_pl_sl</name> <operator>=</operator> <name>sp</name> <operator>+</operator> <name>sl</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>sp_pl_sl</name> <operator>&lt;=</operator> <name>sl</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"integer out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>bitsubstring</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>sp</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>bitsubstring</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>sp_pl_sl</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bit_catenate</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bit_catenate</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bitlength, bitoctetlength
 * Return the length of a bit string
 */</comment>
<function><type><name>Datum</name></type>
<name>bitlength</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bitoctetlength</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bit_and
 * perform a logical AND on two bit strings.
 */</comment>
<function><type><name>Datum</name></type>
<name>bit_and</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>,
                <decl><type ref="prev"/><name>bitlen1</name></decl>,
                <decl><type ref="prev"/><name>bitlen2</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>p1</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>p2</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bitlen1</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bitlen2</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>bitlen1</name> <operator>!=</operator> <name>bitlen2</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STRING_DATA_LENGTH_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot AND bit strings of different sizes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VarBit</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>bitlen1</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>p1</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p2</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p1</name><operator>++</operator> <operator>&amp;</operator> <operator>*</operator><name>p2</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* Padding is not needed as &amp; of 0 pad is 0 */</comment>

    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bit_or
 * perform a logical OR on two bit strings.
 */</comment>
<function><type><name>Datum</name></type>
<name>bit_or</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>,
                <decl><type ref="prev"/><name>bitlen1</name></decl>,
                <decl><type ref="prev"/><name>bitlen2</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>p1</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>p2</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name></type>        <name>mask</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bitlen1</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bitlen2</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>bitlen1</name> <operator>!=</operator> <name>bitlen2</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STRING_DATA_LENGTH_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot OR bit strings of different sizes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VarBit</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>bitlen1</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>p1</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p2</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p1</name><operator>++</operator> <operator>|</operator> <operator>*</operator><name>p2</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* Pad the result */</comment>
    <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>BITMASK</name> <operator>&lt;&lt;</operator> <call><name>VARBITPAD</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>mask</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>r</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>r</name> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bitxor
 * perform a logical XOR on two bit strings.
 */</comment>
<function><type><name>Datum</name></type>
<name>bitxor</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>,
                <decl><type ref="prev"/><name>bitlen1</name></decl>,
                <decl><type ref="prev"/><name>bitlen2</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>p1</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>p2</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name></type>        <name>mask</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bitlen1</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bitlen2</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>bitlen1</name> <operator>!=</operator> <name>bitlen2</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STRING_DATA_LENGTH_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot XOR bit strings of different sizes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VarBit</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>bitlen1</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>p1</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p2</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p1</name><operator>++</operator> <operator>^</operator> <operator>*</operator><name>p2</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* Pad the result */</comment>
    <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>BITMASK</name> <operator>&lt;&lt;</operator> <call><name>VARBITPAD</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>mask</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>r</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>r</name> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bitnot
 * perform a logical NOT on a bit string.
 */</comment>
<function><type><name>Datum</name></type>
<name>bitnot</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>p</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name></type>        <name>mask</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VarBit</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <call><name>VARBITEND</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <operator>~</operator><operator>*</operator><name>p</name></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* Pad the result */</comment>
    <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>BITMASK</name> <operator>&lt;&lt;</operator> <call><name>VARBITPAD</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>mask</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>r</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>r</name> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bitshiftleft
 * do a left shift (i.e. towards the beginning of the string)
 */</comment>
<function><type><name>Datum</name></type>
<name>bitshiftleft</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>shft</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>byte_shift</name></decl>,
                <decl><type ref="prev"/><name>ishift</name></decl>,
                <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>p</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

    <comment type="block">/* Negative shift is a shift to the right */</comment>
    <if_stmt><if>if <condition>(<expr><name>shft</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Prevent integer overflow in negation */</comment>
        <if_stmt><if>if <condition>(<expr><name>shft</name> <operator>&lt;</operator> <operator>-</operator><name>VARBITMAXLEN</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>shft</name> <operator>=</operator> <operator>-</operator><name>VARBITMAXLEN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>bitshiftright</name></expr></argument>,
                                            <argument><expr><call><name>VarBitPGetDatum</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><name>shft</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VarBit</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If we shifted all the bits out, return an all-zero string */</comment>
    <if_stmt><if>if <condition>(<expr><name>shft</name> <operator>&gt;=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>byte_shift</name> <operator>=</operator> <name>shft</name> <operator>/</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ishift</name> <operator>=</operator> <name>shft</name> <operator>%</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>byte_shift</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>ishift</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Special case: we can do a memcpy */</comment>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>byte_shift</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>r</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>byte_shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <for>for <control>(<init>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <call><name>VARBITEND</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>r</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <operator>*</operator><name>p</name> <operator>&lt;&lt;</operator> <name>ishift</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>++</operator><name>p</name><operator>)</operator> <operator>&lt;</operator> <call><name>VARBITEND</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>r</name> <operator>|=</operator> <operator>*</operator><name>p</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>BITS_PER_BYTE</name> <operator>-</operator> <name>ishift</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <for>for <control>(<init>;</init> <condition><expr><name>r</name> <operator>&lt;</operator> <call><name>VARBITEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>r</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bitshiftright
 * do a right shift (i.e. towards the end of the string)
 */</comment>
<function><type><name>Datum</name></type>
<name>bitshiftright</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>shft</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>byte_shift</name></decl>,
                <decl><type ref="prev"/><name>ishift</name></decl>,
                <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>p</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

    <comment type="block">/* Negative shift is a shift to the left */</comment>
    <if_stmt><if>if <condition>(<expr><name>shft</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Prevent integer overflow in negation */</comment>
        <if_stmt><if>if <condition>(<expr><name>shft</name> <operator>&lt;</operator> <operator>-</operator><name>VARBITMAXLEN</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>shft</name> <operator>=</operator> <operator>-</operator><name>VARBITMAXLEN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>bitshiftleft</name></expr></argument>,
                                            <argument><expr><call><name>VarBitPGetDatum</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><name>shft</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VarBit</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If we shifted all the bits out, return an all-zero string */</comment>
    <if_stmt><if>if <condition>(<expr><name>shft</name> <operator>&gt;=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>byte_shift</name> <operator>=</operator> <name>shft</name> <operator>/</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ishift</name> <operator>=</operator> <name>shft</name> <operator>%</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set the first part of the result to 0 */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>byte_shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> <operator>+=</operator> <name>byte_shift</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>ishift</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Special case: we can do a memcpy */</comment>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>byte_shift</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <call><name>VARBITEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>                <comment type="block">/* initialize first byte */</comment>
        <for>for <control>(<init>;</init> <condition><expr><name>r</name> <operator>&lt;</operator> <call><name>VARBITEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>r</name> <operator>|=</operator> <operator>*</operator><name>p</name> <operator>&gt;&gt;</operator> <name>ishift</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>++</operator><name>r</name><operator>)</operator> <operator>&lt;</operator> <call><name>VARBITEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>BITS_PER_BYTE</name> <operator>-</operator> <name>ishift</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <name>BITMASK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This is not defined in any standard. We retain the natural ordering of
 * bits here, as it just seems more intuitive.
 */</comment>
<function><type><name>Datum</name></type>
<name>bitfromint4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int32</name></type>        <name>a</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>destbitsleft</name></decl>,
                <decl><type ref="prev"/><name>srcbitsleft</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>typmod</name> <operator>&gt;</operator> <name>VARBITMAXLEN</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>typmod</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>                <comment type="block">/* default bit length */</comment>

    <expr_stmt><expr><name>rlen</name> <operator>=</operator> <call><name>VARBITTOTALLEN</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VarBit</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>rlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>destbitsleft</name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>srcbitsleft</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
    <comment type="block">/* drop any input bits that don't fit */</comment>
    <expr_stmt><expr><name>srcbitsleft</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>srcbitsleft</name></expr></argument>, <argument><expr><name>destbitsleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* sign-fill any excess bytes in output */</comment>
    <while>while <condition>(<expr><name>destbitsleft</name> <operator>&gt;=</operator> <name>srcbitsleft</name> <operator>+</operator> <literal type="number">8</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>bits8</name><operator>)</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>a</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>BITMASK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>destbitsleft</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <comment type="block">/* store first fractional byte */</comment>
    <if_stmt><if>if <condition>(<expr><name>destbitsleft</name> <operator>&gt;</operator> <name>srcbitsleft</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>val</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>a</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>destbitsleft</name> <operator>-</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Force sign-fill in case the compiler implements &gt;&gt; as zero-fill */</comment>
        <if_stmt><if>if <condition>(<expr><name>a</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>val</name> <operator>|=</operator> <operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>srcbitsleft</name> <operator>+</operator> <literal type="number">8</literal> <operator>-</operator> <name>destbitsleft</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>bits8</name><operator>)</operator> <operator>(</operator><name>val</name> <operator>&amp;</operator> <name>BITMASK</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>destbitsleft</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Now srcbitsleft and destbitsleft are the same, need not track both */</comment>
    <comment type="block">/* store whole bytes */</comment>
    <while>while <condition>(<expr><name>destbitsleft</name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>bits8</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>a</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>destbitsleft</name> <operator>-</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <name>BITMASK</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>destbitsleft</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <comment type="block">/* store last fractional byte */</comment>
    <if_stmt><if>if <condition>(<expr><name>destbitsleft</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <operator>(</operator><name>bits8</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>a</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">8</literal> <operator>-</operator> <name>destbitsleft</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <name>BITMASK</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bittoint4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

    <comment type="block">/* Check that the bit string is not too long */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>BITS_PER_BYTE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"integer out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>r</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>r</name> <operator>&lt;</operator> <call><name>VARBITEND</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>r</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>&lt;&lt;=</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>|=</operator> <operator>*</operator><name>r</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* Now shift the result to take account of the padding at the end */</comment>
    <expr_stmt><expr><name>result</name> <operator>&gt;&gt;=</operator> <call><name>VARBITPAD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bitfromint8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>a</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>destbitsleft</name></decl>,
                <decl><type ref="prev"/><name>srcbitsleft</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>typmod</name> <operator>&gt;</operator> <name>VARBITMAXLEN</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>typmod</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>                <comment type="block">/* default bit length */</comment>

    <expr_stmt><expr><name>rlen</name> <operator>=</operator> <call><name>VARBITTOTALLEN</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VarBit</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>rlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>destbitsleft</name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>srcbitsleft</name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
    <comment type="block">/* drop any input bits that don't fit */</comment>
    <expr_stmt><expr><name>srcbitsleft</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>srcbitsleft</name></expr></argument>, <argument><expr><name>destbitsleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* sign-fill any excess bytes in output */</comment>
    <while>while <condition>(<expr><name>destbitsleft</name> <operator>&gt;=</operator> <name>srcbitsleft</name> <operator>+</operator> <literal type="number">8</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>bits8</name><operator>)</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>a</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>BITMASK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>destbitsleft</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <comment type="block">/* store first fractional byte */</comment>
    <if_stmt><if>if <condition>(<expr><name>destbitsleft</name> <operator>&gt;</operator> <name>srcbitsleft</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>val</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>a</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>destbitsleft</name> <operator>-</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Force sign-fill in case the compiler implements &gt;&gt; as zero-fill */</comment>
        <if_stmt><if>if <condition>(<expr><name>a</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>val</name> <operator>|=</operator> <operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>srcbitsleft</name> <operator>+</operator> <literal type="number">8</literal> <operator>-</operator> <name>destbitsleft</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>bits8</name><operator>)</operator> <operator>(</operator><name>val</name> <operator>&amp;</operator> <name>BITMASK</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>destbitsleft</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Now srcbitsleft and destbitsleft are the same, need not track both */</comment>
    <comment type="block">/* store whole bytes */</comment>
    <while>while <condition>(<expr><name>destbitsleft</name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>bits8</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>a</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>destbitsleft</name> <operator>-</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <name>BITMASK</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>destbitsleft</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <comment type="block">/* store last fractional byte */</comment>
    <if_stmt><if>if <condition>(<expr><name>destbitsleft</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <operator>(</operator><name>bits8</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>a</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">8</literal> <operator>-</operator> <name>destbitsleft</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <name>BITMASK</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bittoint8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

    <comment type="block">/* Check that the bit string is not too long */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>BITS_PER_BYTE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bigint out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>r</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>r</name> <operator>&lt;</operator> <call><name>VARBITEND</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>r</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>&lt;&lt;=</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>|=</operator> <operator>*</operator><name>r</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* Now shift the result to take account of the padding at the end */</comment>
    <expr_stmt><expr><name>result</name> <operator>&gt;&gt;=</operator> <call><name>VARBITPAD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Determines the position of S2 in the bitstring S1 (1-based string).
 * If S2 does not appear in S1 this function returns 0.
 * If S2 is of length 0 this function returns 1.
 * Compatible in usage with POSITION() functions for other data types.
 */</comment>
<function><type><name>Datum</name></type>
<name>bitposition</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>substr</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>substr_length</name></decl>,
                <decl><type ref="prev"/><name>str_length</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>,
                <decl><type ref="prev"/><name>is</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>s</name></decl>,                <comment type="block">/* pointer into substring */</comment>
               <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                <comment type="block">/* pointer into str */</comment>
    <decl_stmt><decl><type><name>bits8</name></type>        <name>cmp</name></decl>,            <comment type="block">/* shifted substring byte to compare */</comment>
                <decl><type ref="prev"/><name>mask1</name></decl>,            <comment type="block">/* mask for substring byte shifted right */</comment>
                <decl><type ref="prev"/><name>mask2</name></decl>,            <comment type="block">/* mask for substring byte shifted left */</comment>
                <decl><type ref="prev"/><name>end_mask</name></decl>,        <comment type="block">/* pad mask for last substring byte */</comment>
                <decl><type ref="prev"/><name>str_mask</name></decl>;</decl_stmt>        <comment type="block">/* pad mask for last string byte */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_match</name></decl>;</decl_stmt>

    <comment type="block">/* Get the substring length */</comment>
    <expr_stmt><expr><name>substr_length</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>substr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>str_length</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* String has zero length or substring longer than string, return 0 */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>str_length</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>substr_length</name> <operator>&gt;</operator> <name>str_length</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* zero-length substring means return 1 */</comment>
    <if_stmt><if>if <condition>(<expr><name>substr_length</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Initialise the padding masks */</comment>
    <expr_stmt><expr><name>end_mask</name> <operator>=</operator> <name>BITMASK</name> <operator>&lt;&lt;</operator> <call><name>VARBITPAD</name><argument_list>(<argument><expr><name>substr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>str_mask</name> <operator>=</operator> <name>BITMASK</name> <operator>&lt;&lt;</operator> <call><name>VARBITPAD</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>substr</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>is</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>is</name> <operator>&lt;</operator> <name>BITS_PER_BYTE</name></expr>;</condition> <incr><expr><name>is</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>is_match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>mask1</name> <operator>=</operator> <name>BITMASK</name> <operator>&gt;&gt;</operator> <name>is</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>mask2</name> <operator>=</operator> <operator>~</operator><name>mask1</name></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>substr</name></expr></argument>)</argument_list></call></expr>;</init>
                 <condition><expr><name>is_match</name> <operator>&amp;&amp;</operator> <name>s</name> <operator>&lt;</operator> <call><name>VARBITEND</name><argument_list>(<argument><expr><name>substr</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>*</operator><name>s</name> <operator>&gt;&gt;</operator> <name>is</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <call><name>VARBITEND</name><argument_list>(<argument><expr><name>substr</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>mask1</name> <operator>&amp;=</operator> <name>end_mask</name> <operator>&gt;&gt;</operator> <name>is</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <call><name>VARBITEND</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Check that there is enough of str left */</comment>
                        <if_stmt><if>if <condition>(<expr><name>mask1</name> <operator>&amp;</operator> <operator>~</operator><name>str_mask</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>is_match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><name>mask1</name> <operator>&amp;=</operator> <name>str_mask</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>is_match</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>cmp</name> <operator>^</operator> <operator>*</operator><name>p</name><operator>)</operator> <operator>&amp;</operator> <name>mask1</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_match</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
                <comment type="block">/* Move on to the next byte */</comment>
                <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <call><name>VARBITEND</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>mask2</name> <operator>=</operator> <name>end_mask</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>BITS_PER_BYTE</name> <operator>-</operator> <name>is</name><operator>)</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>is_match</name> <operator>=</operator> <name>mask2</name> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
                    elog(DEBUG4, "S. %d %d em=%2x sm=%2x r=%d",
                         i, is, end_mask, mask2, is_match);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>*</operator><name>s</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>BITS_PER_BYTE</name> <operator>-</operator> <name>is</name><operator>)</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <call><name>VARBITEND</name><argument_list>(<argument><expr><name>substr</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>mask2</name> <operator>&amp;=</operator> <name>end_mask</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>BITS_PER_BYTE</name> <operator>-</operator> <name>is</name><operator>)</operator></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <call><name>VARBITEND</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>mask2</name> <operator>&amp;</operator> <operator>~</operator><name>str_mask</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>is_match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><name>mask2</name> <operator>&amp;=</operator> <name>str_mask</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>is_match</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>cmp</name> <operator>^</operator> <operator>*</operator><name>p</name><operator>)</operator> <operator>&amp;</operator> <name>mask2</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></for>
            <comment type="block">/* Have we found a match? */</comment>
            <if_stmt><if>if <condition>(<expr><name>is_match</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>i</name> <operator>*</operator> <name>BITS_PER_BYTE</name> <operator>+</operator> <name>is</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * bitsetbit
 *
 * Given an instance of type 'bit' creates a new one with
 * the Nth bit set to the given value.
 *
 * The bit location is specified left-to-right in a zero-based fashion
 * consistent with the other get_bit and set_bit functions, but
 * inconsistent with the standard substring, position, overlay functions
 */</comment>
<function><type><name>Datum</name></type>
<name>bitsetbit</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>n</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>newBit</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>,
                <decl><type ref="prev"/><name>bitlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>r</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>byteNo</name></decl>,
                <decl><type ref="prev"/><name>bitNo</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bitlen</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&gt;=</operator> <name>bitlen</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bit index %d out of valid range (0..%d)"</literal></expr></argument>,
                        <argument><expr><name>n</name></expr></argument>, <argument><expr><name>bitlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * sanity check!
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>newBit</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>newBit</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new bit must be 0 or 1"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VarBit</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VARBITLEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>bitlen</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>byteNo</name> <operator>=</operator> <name>n</name> <operator>/</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bitNo</name> <operator>=</operator> <name>BITS_PER_BYTE</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name>n</name> <operator>%</operator> <name>BITS_PER_BYTE</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * Update the byte.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>newBit</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>r</name><index>[<expr><name>byteNo</name></expr>]</index></name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitNo</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>r</name><index>[<expr><name>byteNo</name></expr>]</index></name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitNo</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VARBIT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bitgetbit
 *
 * returns the value of the Nth bit of a bit array (0 or 1).
 *
 * The bit location is specified left-to-right in a zero-based fashion
 * consistent with the other get_bit and set_bit functions, but
 * inconsistent with the standard substring, position, overlay functions
 */</comment>
<function><type><name>Datum</name></type>
<name>bitgetbit</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VarBit</name>       <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>n</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>bitlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>byteNo</name></decl>,
                <decl><type ref="prev"/><name>bitNo</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bitlen</name> <operator>=</operator> <call><name>VARBITLEN</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&gt;=</operator> <name>bitlen</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bit index %d out of valid range (0..%d)"</literal></expr></argument>,
                        <argument><expr><name>n</name></expr></argument>, <argument><expr><name>bitlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>VARBITS</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>byteNo</name> <operator>=</operator> <name>n</name> <operator>/</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bitNo</name> <operator>=</operator> <name>BITS_PER_BYTE</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name>n</name> <operator>%</operator> <name>BITS_PER_BYTE</name><operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><name>byteNo</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitNo</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bithash</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VarBit</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_VARBIT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	
	<return>return <expr><call><name>hash_any</name><argument_list>(<argument><expr><call><name>VARBITS</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARBITBYTES</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
