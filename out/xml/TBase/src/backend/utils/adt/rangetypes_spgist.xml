<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/utils/adt/rangetypes_spgist.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * rangetypes_spgist.c
 *      implementation of quad tree over ranges mapped to 2d-points for SP-GiST.
 *
 * Quad tree is a data structure similar to a binary tree, but is adapted to
 * 2d data. Each inner node of a quad tree contains a point (centroid) which
 * divides the 2d-space into 4 quadrants. Each quadrant is associated with a
 * child node.
 *
 * Ranges are mapped to 2d-points so that the lower bound is one dimension,
 * and the upper bound is another. By convention, we visualize the lower bound
 * to be the horizontal axis, and upper bound the vertical axis.
 *
 * One quirk with this mapping is the handling of empty ranges. An empty range
 * doesn't have lower and upper bounds, so it cannot be mapped to 2d space in
 * a straightforward way. To cope with that, the root node can have a 5th
 * quadrant, which is reserved for empty ranges. Furthermore, there can be
 * inner nodes in the tree with no centroid. They contain only two child nodes,
 * one for empty ranges and another for non-empty ones. Such a node can appear
 * as the root node, or in the tree under the 5th child of the root node (in
 * which case it will only contain empty nodes).
 *
 * The SP-GiST picksplit function uses medians along both axes as the centroid.
 * This implementation only uses the comparison function of the range element
 * datatype, therefore it works for any range type.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *            src/backend/utils/adt/rangetypes_spgist.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/spgist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/stratnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rangetypes.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>int16</name></type> <name>getQuadrant</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>centroid</name></decl></parameter>,
            <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>tst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>bound_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>adjacent_inner_consistent</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>,
                          <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>centroid</name></decl></parameter>,
                          <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>prev</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>adjacent_cmp_bounds</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>,
                    <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>centroid</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * SP-GiST 'config' interface function.
 */</comment>
<function><type><name>Datum</name></type>
<name>spg_range_quad_config</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* spgConfigIn *cfgin = (spgConfigIn *) PG_GETARG_POINTER(0); */</comment>
    <decl_stmt><decl><type><name>spgConfigOut</name> <modifier>*</modifier></type><name>cfg</name> <init>= <expr><operator>(</operator><name>spgConfigOut</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>prefixType</name></name> <operator>=</operator> <name>ANYRANGEOID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>labelType</name></name> <operator>=</operator> <name>VOIDOID</name></expr>;</expr_stmt>    <comment type="block">/* we don't need node labels */</comment>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>canReturnData</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>longValuesOK</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*----------
 * Determine which quadrant a 2d-mapped range falls into, relative to the
 * centroid.
 *
 * Quadrants are numbered like this:
 *
 *     4    |  1
 *    ----+----
 *     3    |  2
 *
 * Where the lower bound of range is the horizontal axis and upper bound the
 * vertical axis.
 *
 * Ranges on one of the axes are taken to lie in the quadrant with higher value
 * along perpendicular axis. That is, a value on the horizontal axis is taken
 * to belong to quadrant 1 or 4, and a value on the vertical axis is taken to
 * belong to quadrant 1 or 2. A range equal to centroid is taken to lie in
 * quadrant 1.
 *
 * Empty ranges are taken to lie in the special quadrant 5.
 *----------
 */</comment>
<function><type><specifier>static</specifier> <name>int16</name></type>
<name>getQuadrant</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>centroid</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>tst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RangeBound</name></type>    <name>centroidLower</name></decl>,
                <decl><type ref="prev"/><name>centroidUpper</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>centroidEmpty</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeBound</name></type>    <name>lower</name></decl>,
                <decl><type ref="prev"/><name>upper</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>empty</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>centroid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>centroidLower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>centroidUpper</name></expr></argument>,
                      <argument><expr><operator>&amp;</operator><name>centroidEmpty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>tst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">5</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>centroidLower</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>centroidUpper</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>centroidUpper</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">4</literal></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><literal type="number">3</literal></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Choose SP-GiST function: choose path for addition of new range.
 */</comment>
<function><type><name>Datum</name></type>
<name>spg_range_quad_choose</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>spgChooseIn</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>spgChooseIn</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>spgChooseOut</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>spgChooseOut</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>inRange</name> <init>= <expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>datum</name></name></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>centroid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>        <name>quadrant</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>in</name><operator>-&gt;</operator><name>allTheSame</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>resultType</name></name> <operator>=</operator> <name>spgMatchNode</name></expr>;</expr_stmt>
        <comment type="block">/* nodeN will be set by core */</comment>
        <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>matchNode</name><operator>.</operator><name>levelAdd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>matchNode</name><operator>.</operator><name>restDatum</name></name> <operator>=</operator> <call><name>RangeTypeGetDatum</name><argument_list>(<argument><expr><name>inRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>inRange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * A node with no centroid divides ranges purely on whether they're empty
     * or not. All empty ranges go to child node 0, all non-empty ranges go to
     * node 1.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>in</name><operator>-&gt;</operator><name>hasPrefix</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>resultType</name></name> <operator>=</operator> <name>spgMatchNode</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>RangeIsEmpty</name><argument_list>(<argument><expr><name>inRange</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>matchNode</name><operator>.</operator><name>nodeN</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>matchNode</name><operator>.</operator><name>nodeN</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>matchNode</name><operator>.</operator><name>levelAdd</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>matchNode</name><operator>.</operator><name>restDatum</name></name> <operator>=</operator> <call><name>RangeTypeGetDatum</name><argument_list>(<argument><expr><name>inRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>centroid</name> <operator>=</operator> <call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>prefixDatum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>quadrant</name> <operator>=</operator> <call><name>getQuadrant</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>centroid</name></expr></argument>, <argument><expr><name>inRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>quadrant</name> <operator>&lt;=</operator> <name><name>in</name><operator>-&gt;</operator><name>nNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Select node matching to quadrant number */</comment>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>resultType</name></name> <operator>=</operator> <name>spgMatchNode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>matchNode</name><operator>.</operator><name>nodeN</name></name> <operator>=</operator> <name>quadrant</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>matchNode</name><operator>.</operator><name>levelAdd</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>matchNode</name><operator>.</operator><name>restDatum</name></name> <operator>=</operator> <call><name>RangeTypeGetDatum</name><argument_list>(<argument><expr><name>inRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Bound comparison for sorting.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bound_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>ba</name> <init>= <expr><operator>(</operator><name>RangeBound</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>bb</name> <init>= <expr><operator>(</operator><name>RangeBound</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name> <init>= <expr><operator>(</operator><name>TypeCacheEntry</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>ba</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Picksplit SP-GiST function: split ranges into nodes. Select "centroid"
 * range and distribute ranges according to quadrants.
 */</comment>
<function><type><name>Datum</name></type>
<name>spg_range_quad_picksplit</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>spgPickSplitIn</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>spgPickSplitIn</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>spgPickSplitOut</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>spgPickSplitOut</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nonEmptyCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>centroid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>empty</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

    <comment type="block">/* Use the median values of lower and upper bounds as the centroid range */</comment>
    <decl_stmt><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>lowerBounds</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>upperBounds</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>,
                                  <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>datums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Allocate memory for bounds */</comment>
    <expr_stmt><expr><name>lowerBounds</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RangeBound</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>upperBounds</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RangeBound</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Deserialize bounds of ranges, count non-empty ranges */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name><name>lowerBounds</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>upperBounds</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>empty</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>nonEmptyCount</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

    <comment type="block">/*
     * All the ranges are empty. The best we can do is to construct an inner
     * node with no centroid, and put all ranges into node 0. If non-empty
     * ranges are added later, they will be routed to node 1.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>nonEmptyCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>hasPrefix</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <comment type="block">/* Prefix is empty */</comment>
        <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>prefixDatum</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nodeLabels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>mapTuplesToNodes</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>leafTupleDatums</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Place all ranges into node 0 */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name> <init>= <expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>leafTupleDatums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>RangeTypeGetDatum</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>mapTuplesToNodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Sort range bounds in order to find medians */</comment>
    <expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name>lowerBounds</name></expr></argument>, <argument><expr><name>nonEmptyCount</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RangeBound</name></expr></argument>)</argument_list></sizeof></expr></argument>,
              <argument><expr><name>bound_cmp</name></expr></argument>, <argument><expr><name>typcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name>upperBounds</name></expr></argument>, <argument><expr><name>nonEmptyCount</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RangeBound</name></expr></argument>)</argument_list></sizeof></expr></argument>,
              <argument><expr><name>bound_cmp</name></expr></argument>, <argument><expr><name>typcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Construct "centroid" range from medians of lower and upper bounds */</comment>
    <expr_stmt><expr><name>centroid</name> <operator>=</operator> <call><name>range_serialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lowerBounds</name><index>[<expr><name>nonEmptyCount</name> <operator>/</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name><name>upperBounds</name><index>[<expr><name>nonEmptyCount</name> <operator>/</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>hasPrefix</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>prefixDatum</name></name> <operator>=</operator> <call><name>RangeTypeGetDatum</name><argument_list>(<argument><expr><name>centroid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create node for empty ranges only if it is a root node */</comment>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">5</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nodeLabels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* we don't need node labels */</comment>

    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>mapTuplesToNodes</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>leafTupleDatums</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Assign ranges to corresponding nodes according to quadrants relative to
     * "centroid" range.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name> <init>= <expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int16</name></type>        <name>quadrant</name> <init>= <expr><call><name>getQuadrant</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>centroid</name></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>leafTupleDatums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>RangeTypeGetDatum</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>mapTuplesToNodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>quadrant</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SP-GiST consistent function for inner nodes: check which nodes are
 * consistent with given set of queries.
 */</comment>
<function><type><name>Datum</name></type>
<name>spg_range_quad_inner_consistent</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>spgInnerConsistentIn</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>spgInnerConsistentIn</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>spgInnerConsistentOut</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>spgInnerConsistentOut</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>which</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name></decl>;</decl_stmt>

    <comment type="block">/*
     * For adjacent search we need also previous centroid (if any) to improve
     * the precision of the consistent check. In this case needPrevious flag
     * is set and centroid is passed into traversalValue.
     */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>needPrevious</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>in</name><operator>-&gt;</operator><name>allTheSame</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Report that all nodes should be visited */</comment>
        <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>=</operator> <name><name>in</name><operator>-&gt;</operator><name>nNodes</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nodeNumbers</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>in</name><operator>-&gt;</operator><name>nNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in</name><operator>-&gt;</operator><name>nNodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nodeNumbers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>in</name><operator>-&gt;</operator><name>hasPrefix</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * No centroid on this inner node. Such a node has two child nodes,
         * the first for empty ranges, and the second for non-empty ones.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Nth bit of which variable means that (N - 1)th node should be
         * visited. Initially all bits are set. Bits of nodes which should be
         * skipped will be unset.
         */</comment>
        <expr_stmt><expr><name>which</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name> <init>= <expr><name><name>in</name><operator>-&gt;</operator><name>scankeys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_strategy</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>empty</name></decl>;</decl_stmt>

            <comment type="block">/*
             * The only strategy when second argument of operator is not range
             * is RANGESTRAT_CONTAINS_ELEM.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>!=</operator> <name>RANGESTRAT_CONTAINS_ELEM</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>empty</name> <operator>=</operator> <call><name>RangeIsEmpty</name><argument_list>(
                                     <argument><expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>scankeys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>empty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>RANGESTRAT_BEFORE</name></expr>:</case>
                <case>case <expr><name>RANGESTRAT_OVERLEFT</name></expr>:</case>
                <case>case <expr><name>RANGESTRAT_OVERLAPS</name></expr>:</case>
                <case>case <expr><name>RANGESTRAT_OVERRIGHT</name></expr>:</case>
                <case>case <expr><name>RANGESTRAT_AFTER</name></expr>:</case>
                <case>case <expr><name>RANGESTRAT_ADJACENT</name></expr>:</case>
                    <comment type="block">/* These strategies return false if any argument is empty */</comment>
                    <if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>which</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    <break>break;</break>

                <case>case <expr><name>RANGESTRAT_CONTAINS</name></expr>:</case>

                    <comment type="block">/*
                     * All ranges contain an empty range. Only non-empty
                     * ranges can contain a non-empty range.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>empty</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <break>break;</break>

                <case>case <expr><name>RANGESTRAT_CONTAINED_BY</name></expr>:</case>

                    <comment type="block">/*
                     * Only an empty range is contained by an empty range.
                     * Both empty and non-empty ranges can be contained by a
                     * non-empty range.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <break>break;</break>

                <case>case <expr><name>RANGESTRAT_CONTAINS_ELEM</name></expr>:</case>
                    <expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>RANGESTRAT_EQ</name></expr>:</case>
                    <if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    <break>break;</break>

                <default>default:</default>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized range strategy: %d"</literal></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>
            <if_stmt><if>if <condition>(<expr><name>which</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>            <comment type="block">/* no need to consider remaining conditions */</comment>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeBound</name></type>    <name>centroidLower</name></decl>,
                    <decl><type ref="prev"/><name>centroidUpper</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>centroidEmpty</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>centroid</name></decl>;</decl_stmt>

        <comment type="block">/* This node has a centroid. Fetch it. */</comment>
        <expr_stmt><expr><name>centroid</name> <operator>=</operator> <call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>prefixDatum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>,
                                      <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name>centroid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>centroid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>centroidLower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>centroidUpper</name></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name>centroidEmpty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>==</operator> <literal type="number">4</literal> <operator>||</operator> <name><name>in</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>==</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Nth bit of which variable means that (N - 1)th node (Nth quadrant)
         * should be visited. Initially all bits are set. Bits of nodes which
         * can be skipped will be unset.
         */</comment>
        <expr_stmt><expr><name>which</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RangeBound</name></type>    <name>lower</name></decl>,
                        <decl><type ref="prev"/><name>upper</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>empty</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>prevCentroid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RangeBound</name></type>    <name>prevLower</name></decl>,
                        <decl><type ref="prev"/><name>prevUpper</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>prevEmpty</name></decl>;</decl_stmt>

            <comment type="block">/* Restrictions on range bounds according to scan strategy */</comment>
            <decl_stmt><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>minLower</name> <init>= <expr><name>NULL</name></expr></init></decl>,
                       <decl><type ref="prev"><modifier>*</modifier></type><name>maxLower</name> <init>= <expr><name>NULL</name></expr></init></decl>,
                       <decl><type ref="prev"><modifier>*</modifier></type><name>minUpper</name> <init>= <expr><name>NULL</name></expr></init></decl>,
                       <decl><type ref="prev"><modifier>*</modifier></type><name>maxUpper</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Are the restrictions on range bounds inclusive? */</comment>
            <decl_stmt><decl><type><name>bool</name></type>        <name>inclusive</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>strictEmpty</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>cmp</name></decl>,
                        <decl><type ref="prev"/><name>which1</name></decl>,
                        <decl><type ref="prev"/><name>which2</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>strategy</name> <operator>=</operator> <name><name>in</name><operator>-&gt;</operator><name>scankeys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_strategy</name></expr>;</expr_stmt>

            <comment type="block">/*
             * RANGESTRAT_CONTAINS_ELEM is just like RANGESTRAT_CONTAINS, but
             * the argument is a single element. Expand the single element to
             * a range containing only the element, and treat it like
             * RANGESTRAT_CONTAINS.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>RANGESTRAT_CONTAINS_ELEM</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>lower</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>lower</name><operator>.</operator><name>infinite</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>lower</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>lower</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name><name>in</name><operator>-&gt;</operator><name>scankeys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>upper</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>upper</name><operator>.</operator><name>infinite</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>upper</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>upper</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name><name>in</name><operator>-&gt;</operator><name>scankeys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>empty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>RANGESTRAT_CONTAINS</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>range</name> <operator>=</operator> <call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>scankeys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * Most strategies are handled by forming a bounding box from the
             * search key, defined by a minLower, maxLower, minUpper,
             * maxUpper. Some modify 'which' directly, to specify exactly
             * which quadrants need to be visited.
             *
             * For most strategies, nothing matches an empty search key, and
             * an empty range never matches a non-empty key. If a strategy
             * does not behave like that wrt. empty ranges, set strictEmpty to
             * false.
             */</comment>
            <switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>RANGESTRAT_BEFORE</name></expr>:</case>

                    <comment type="block">/*
                     * Range A is before range B if upper bound of A is lower
                     * than lower bound of B.
                     */</comment>
                    <expr_stmt><expr><name>maxUpper</name> <operator>=</operator> <operator>&amp;</operator><name>lower</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>inclusive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>RANGESTRAT_OVERLEFT</name></expr>:</case>

                    <comment type="block">/*
                     * Range A is overleft to range B if upper bound of A is
                     * less or equal to upper bound of B.
                     */</comment>
                    <expr_stmt><expr><name>maxUpper</name> <operator>=</operator> <operator>&amp;</operator><name>upper</name></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>RANGESTRAT_OVERLAPS</name></expr>:</case>

                    <comment type="block">/*
                     * Non-empty ranges overlap, if lower bound of each range
                     * is lower or equal to upper bound of the other range.
                     */</comment>
                    <expr_stmt><expr><name>maxLower</name> <operator>=</operator> <operator>&amp;</operator><name>upper</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>minUpper</name> <operator>=</operator> <operator>&amp;</operator><name>lower</name></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>RANGESTRAT_OVERRIGHT</name></expr>:</case>

                    <comment type="block">/*
                     * Range A is overright to range B if lower bound of A is
                     * greater or equal to lower bound of B.
                     */</comment>
                    <expr_stmt><expr><name>minLower</name> <operator>=</operator> <operator>&amp;</operator><name>lower</name></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>RANGESTRAT_AFTER</name></expr>:</case>

                    <comment type="block">/*
                     * Range A is after range B if lower bound of A is greater
                     * than upper bound of B.
                     */</comment>
                    <expr_stmt><expr><name>minLower</name> <operator>=</operator> <operator>&amp;</operator><name>upper</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>inclusive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>RANGESTRAT_ADJACENT</name></expr>:</case>
                    <if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>    <comment type="block">/* Skip to strictEmpty check. */</comment>

                    <comment type="block">/*
                     * Previously selected quadrant could exclude possibility
                     * for lower or upper bounds to be adjacent. Deserialize
                     * previous centroid range if present for checking this.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>in</name><operator>-&gt;</operator><name>traversalValue</name></name> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>prevCentroid</name> <operator>=</operator> <call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>traversalValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>prevCentroid</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>prevLower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prevUpper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prevEmpty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * For a range's upper bound to be adjacent to the
                     * argument's lower bound, it will be found along the line
                     * adjacent to (and just below) Y=lower. Therefore, if the
                     * argument's lower bound is less than the centroid's
                     * upper bound, the line falls in quadrants 2 and 3; if
                     * greater, the line falls in quadrants 1 and 4. (see
                     * adjacent_cmp_bounds for description of edge cases).
                     */</comment>
                    <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>adjacent_inner_consistent</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>,
                                                    <argument><expr><operator>&amp;</operator><name>centroidUpper</name></expr></argument>,
                                                    <argument><expr><ternary><condition><expr><name>prevCentroid</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>prevUpper</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>which1</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>which1</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>which1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

                    <comment type="block">/*
                     * Also search for ranges's adjacent to argument's upper
                     * bound. They will be found along the line adjacent to
                     * (and just right of) X=upper, which falls in quadrants 3
                     * and 4, or 1 and 2.
                     */</comment>
                    <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>adjacent_inner_consistent</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>,
                                                    <argument><expr><operator>&amp;</operator><name>centroidLower</name></expr></argument>,
                                                    <argument><expr><ternary><condition><expr><name>prevCentroid</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>prevLower</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>which2</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>which2</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>which2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

                    <comment type="block">/* We must chase down ranges adjacent to either bound. */</comment>
                    <expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <name>which1</name> <operator>|</operator> <name>which2</name></expr>;</expr_stmt>

                    <expr_stmt><expr><name>needPrevious</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>RANGESTRAT_CONTAINS</name></expr>:</case>

                    <comment type="block">/*
                     * Non-empty range A contains non-empty range B if lower
                     * bound of A is lower or equal to lower bound of range B
                     * and upper bound of range A is greater or equal to upper
                     * bound of range A.
                     *
                     * All non-empty ranges contain an empty range.
                     */</comment>
                    <expr_stmt><expr><name>strictEmpty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>empty</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
                        <expr_stmt><expr><name>maxLower</name> <operator>=</operator> <operator>&amp;</operator><name>lower</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>minUpper</name> <operator>=</operator> <operator>&amp;</operator><name>upper</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <break>break;</break>

                <case>case <expr><name>RANGESTRAT_CONTAINED_BY</name></expr>:</case>
                    <comment type="block">/* The opposite of contains. */</comment>
                    <expr_stmt><expr><name>strictEmpty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* An empty range is only contained by an empty range */</comment>
                        <expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>minLower</name> <operator>=</operator> <operator>&amp;</operator><name>lower</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>maxUpper</name> <operator>=</operator> <operator>&amp;</operator><name>upper</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <break>break;</break>

                <case>case <expr><name>RANGESTRAT_EQ</name></expr>:</case>

                    <comment type="block">/*
                     * Equal range can be only in the same quadrant where
                     * argument would be placed to.
                     */</comment>
                    <expr_stmt><expr><name>strictEmpty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>getQuadrant</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>centroid</name></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
                    <break>break;</break>

                <default>default:</default>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized range strategy: %d"</literal></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>

            <if_stmt><if>if <condition>(<expr><name>strictEmpty</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Scan key is empty, no branches are satisfying */</comment>
                    <expr_stmt><expr><name>which</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Shouldn't visit tree branch with empty ranges */</comment>
                    <expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Using the bounding box, see which quadrants we have to descend
             * into.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>minLower</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * If the centroid's lower bound is less than or equal to the
                 * minimum lower bound, anything in the 3rd and 4th quadrants
                 * will have an even smaller lower bound, and thus can't
                 * match.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>centroidLower</name></expr></argument>, <argument><expr><name>minLower</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>maxLower</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * If the centroid's lower bound is greater than the maximum
                 * lower bound, anything in the 1st and 2nd quadrants will
                 * also have a greater than or equal lower bound, and thus
                 * can't match. If the centroid's lower bound is equal to the
                 * maximum lower bound, we can still exclude the 1st and 2nd
                 * quadrants if we're looking for a value strictly greater
                 * than the maximum.
                 */</comment>
                <decl_stmt><decl><type><name>int</name></type>            <name>cmp</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>centroidLower</name></expr></argument>, <argument><expr><name>maxLower</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><operator>!</operator><name>inclusive</name> <operator>&amp;&amp;</operator> <name>cmp</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>minUpper</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * If the centroid's upper bound is less than or equal to the
                 * minimum upper bound, anything in the 2nd and 3rd quadrants
                 * will have an even smaller upper bound, and thus can't
                 * match.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>centroidUpper</name></expr></argument>, <argument><expr><name>minUpper</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>maxUpper</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * If the centroid's upper bound is greater than the maximum
                 * upper bound, anything in the 1st and 4th quadrants will
                 * also have a greater than or equal upper bound, and thus
                 * can't match. If the centroid's upper bound is equal to the
                 * maximum upper bound, we can still exclude the 1st and 4th
                 * quadrants if we're looking for a value strictly greater
                 * than the maximum.
                 */</comment>
                <decl_stmt><decl><type><name>int</name></type>            <name>cmp</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>centroidUpper</name></expr></argument>, <argument><expr><name>maxUpper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><operator>!</operator><name>inclusive</name> <operator>&amp;&amp;</operator> <name>cmp</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>which</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>            <comment type="block">/* no need to consider remaining conditions */</comment>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* We must descend into the quadrant(s) identified by 'which' */</comment>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nodeNumbers</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>in</name><operator>-&gt;</operator><name>nNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>needPrevious</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>traversalValues</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>in</name><operator>-&gt;</operator><name>nNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Elements of traversalValues should be allocated in
     * traversalMemoryContext
     */</comment>
    <expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>traversalMemoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>in</name><operator>-&gt;</operator><name>nNodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>which</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>i</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Save previous prefix if needed */</comment>
            <if_stmt><if>if <condition>(<expr><name>needPrevious</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Datum</name></type>        <name>previousCentroid</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * We know, that in-&gt;prefixDatum in this place is varlena,
                 * because it's range
                 */</comment>
                <expr_stmt><expr><name>previousCentroid</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>prefixDatum</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>traversalValues</name><index>[<expr><name><name>out</name><operator>-&gt;</operator><name>nNodes</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>previousCentroid</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nodeNumbers</name><index>[<expr><name><name>out</name><operator>-&gt;</operator><name>nNodes</name></name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nNodes</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * adjacent_cmp_bounds
 *
 * Given an argument and centroid bound, this function determines if any
 * bounds that are adjacent to the argument are smaller than, or greater than
 * or equal to centroid. For brevity, we call the arg &lt; centroid "left", and
 * arg &gt;= centroid case "right". This corresponds to how the quadrants are
 * arranged, if you imagine that "left" is equivalent to "down" and "right"
 * is equivalent to "up".
 *
 * For the "left" case, returns -1, and for the "right" case, returns 1.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>adjacent_cmp_bounds</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>,
                    <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>centroid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>cmp</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>lower</name></name> <operator>!=</operator> <name><name>centroid</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>centroid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>centroid</name><operator>-&gt;</operator><name>lower</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*------
         * The argument is an upper bound, we are searching for adjacent lower
         * bounds. A matching adjacent lower bound must be *larger* than the
         * argument, but only just.
         *
         * The following table illustrates the desired result with a fixed
         * argument bound, and different centroids. The CMP column shows
         * the value of 'cmp' variable, and ADJ shows whether the argument
         * and centroid are adjacent, per bounds_adjacent(). (N) means we
         * don't need to check for that case, because it's implied by CMP.
         * With the argument range [..., 500), the adjacent range we're
         * searching for is [500, ...):
         *
         *    ARGUMENT   CENTROID        CMP   ADJ
         *    [..., 500) [498, ...)     &gt;      (N)    [500, ...) is to the right
         *    [..., 500) [499, ...)     =      (N)    [500, ...) is to the right
         *    [..., 500) [500, ...)     &lt;       Y    [500, ...) is to the right
         *    [..., 500) [501, ...)     &lt;       N    [500, ...) is to the left
         *
         * So, we must search left when the argument is smaller than, and not
         * adjacent, to the centroid. Otherwise search right.
         *------
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bounds_adjacent</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><operator>*</operator><name>centroid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*------
         * The argument is a lower bound, we are searching for adjacent upper
         * bounds. A matching adjacent upper bound must be *smaller* than the
         * argument, but only just.
         *
         *    ARGUMENT   CENTROID        CMP   ADJ
         *    [500, ...) [..., 499)     &gt;      (N)    [..., 500) is to the right
         *    [500, ...) [..., 500)     &gt;      (Y)    [..., 500) is to the right
         *    [500, ...) [..., 501)     =      (N)    [..., 500) is to the left
         *    [500, ...) [..., 502)     &lt;      (N)    [..., 500) is to the left
         *
         * We must search left when the argument is smaller than or equal to
         * the centroid. Otherwise search right. We don't need to check
         * whether the argument is adjacent with the centroid, because it
         * doesn't matter.
         *------
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*----------
 * adjacent_inner_consistent
 *
 * Like adjacent_cmp_bounds, but also takes into account the previous
 * level's centroid. We might've traversed left (or right) at the previous
 * node, in search for ranges adjacent to the other bound, even though we
 * already ruled out the possibility for any matches in that direction for
 * this bound. By comparing the argument with the previous centroid, and
 * the previous centroid with the current centroid, we can determine which
 * direction we should've moved in at previous level, and which direction we
 * actually moved.
 *
 * If there can be any matches to the left, returns -1. If to the right,
 * returns 1. If there can be no matches below this centroid, because we
 * already ruled them out at the previous level, returns 0.
 *
 * XXX: Comparing just the previous and current level isn't foolproof; we
 * might still search some branches unnecessarily. For example, imagine that
 * we are searching for value 15, and we traverse the following centroids
 * (only considering one bound for the moment):
 *
 * Level 1: 20
 * Level 2: 50
 * Level 3: 25
 *
 * At this point, previous centroid is 50, current centroid is 25, and the
 * target value is to the left. But because we already moved right from
 * centroid 20 to 50 in the first level, there cannot be any values &lt; 20 in
 * the current branch. But we don't know that just by looking at the previous
 * and current centroid, so we traverse left, unnecessarily. The reason we are
 * down this branch is that we're searching for matches with the *other*
 * bound. If we kept track of which bound we are searching for explicitly,
 * instead of deducing that from the previous and current centroid, we could
 * avoid some unnecessary work.
 *----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>adjacent_inner_consistent</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>,
                          <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>centroid</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>prev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>prev</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>prevcmp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>cmp</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Which direction were we supposed to traverse at previous level,
         * left or right?
         */</comment>
        <expr_stmt><expr><name>prevcmp</name> <operator>=</operator> <call><name>adjacent_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* and which direction did we actually go? */</comment>
        <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>centroid</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* if the two don't agree, there's nothing to see here */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>prevcmp</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cmp</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>prevcmp</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><call><name>adjacent_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>centroid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SP-GiST consistent function for leaf nodes: check leaf value against query
 * using corresponding function.
 */</comment>
<function><type><name>Datum</name></type>
<name>spg_range_quad_leaf_consistent</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>spgLeafConsistentIn</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>spgLeafConsistentIn</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>spgLeafConsistentOut</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>spgLeafConsistentOut</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>leafRange</name> <init>= <expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>leafDatum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* all tests are exact */</comment>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>recheck</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* leafDatum is what it is... */</comment>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>leafValue</name></name> <operator>=</operator> <name><name>in</name><operator>-&gt;</operator><name>leafDatum</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>leafRange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Perform the required comparison(s) */</comment>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>keyDatum</name> <init>= <expr><name><name>in</name><operator>-&gt;</operator><name>scankeys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Call the function corresponding to the scan strategy */</comment>
        <switch>switch <condition>(<expr><name><name>in</name><operator>-&gt;</operator><name>scankeys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_strategy</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>RANGESTRAT_BEFORE</name></expr>:</case>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>range_before_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>leafRange</name></expr></argument>,
                                            <argument><expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name>keyDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>RANGESTRAT_OVERLEFT</name></expr>:</case>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>range_overleft_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>leafRange</name></expr></argument>,
                                              <argument><expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name>keyDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>RANGESTRAT_OVERLAPS</name></expr>:</case>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>range_overlaps_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>leafRange</name></expr></argument>,
                                              <argument><expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name>keyDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>RANGESTRAT_OVERRIGHT</name></expr>:</case>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>range_overright_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>leafRange</name></expr></argument>,
                                               <argument><expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name>keyDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>RANGESTRAT_AFTER</name></expr>:</case>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>range_after_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>leafRange</name></expr></argument>,
                                           <argument><expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name>keyDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>RANGESTRAT_ADJACENT</name></expr>:</case>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>range_adjacent_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>leafRange</name></expr></argument>,
                                              <argument><expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name>keyDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>RANGESTRAT_CONTAINS</name></expr>:</case>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>range_contains_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>leafRange</name></expr></argument>,
                                              <argument><expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name>keyDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>RANGESTRAT_CONTAINED_BY</name></expr>:</case>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>range_contained_by_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>leafRange</name></expr></argument>,
                                                  <argument><expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name>keyDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>RANGESTRAT_CONTAINS_ELEM</name></expr>:</case>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>range_contains_elem_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>leafRange</name></expr></argument>,
                                                   <argument><expr><name>keyDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>RANGESTRAT_EQ</name></expr>:</case>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>range_eq_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>leafRange</name></expr></argument>,
                                        <argument><expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name>keyDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized range strategy: %d"</literal></expr></argument>,
                     <argument><expr><name><name>in</name><operator>-&gt;</operator><name>scankeys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>

        <comment type="block">/*
         * If leaf datum doesn't match to a query key, no need to check
         * subsequent keys.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
