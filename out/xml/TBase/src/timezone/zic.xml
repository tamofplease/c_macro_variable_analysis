<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/timezone/zic.c"><comment type="block">/*
 * This file is in the public domain, so clarified as of
 * 2006-07-17 by Arthur David Olson.
 *
 * IDENTIFICATION
 *      src/timezone/zic.c
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_getopt.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tzfile.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIC_VERSION_PRE_2013</name></cpp:macro> <cpp:value>'2'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIC_VERSION</name></cpp:macro> <cpp:value>'3'</cpp:value></cpp:define>

<typedef>typedef <type><name>int64</name></type> <name>zic_t</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIC_MIN</name></cpp:macro> <cpp:value>PG_INT64_MIN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIC_MAX</name></cpp:macro> <cpp:value>PG_INT64_MAX</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZIC_MAX_ABBR_LEN_WO_WARN</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIC_MAX_ABBR_LEN_WO_WARN</name></cpp:macro>      <cpp:value>6</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* !defined ZIC_MAX_ABBR_LEN_WO_WARN */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>S_IRUSR</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MKDIR_UMASK</name></cpp:macro> <cpp:value>(S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MKDIR_UMASK</name></cpp:macro> <cpp:value>0755</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AT_SYMLINK_FOLLOW</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>linkat</name><parameter_list>(<parameter><type><name>fromdir</name></type></parameter>, <parameter><type><name>from</name></type></parameter>, <parameter><type><name>todir</name></type></parameter>, <parameter><type><name>to</name></type></parameter>, <parameter><type><name>flag</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>(itssymlink(from) ? (errno = ENOTSUP, -1) : link(from, to))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* The maximum ptrdiff_t value, for pre-C99 platforms.  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PTRDIFF_MAX</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>static</specifier> <name>ptrdiff_t</name> <specifier>const</specifier></type> <name>PTRDIFF_MAX</name> <init>= <expr><call><name>MAXVAL</name><argument_list>(<argument><expr><name>ptrdiff_t</name></expr></argument>, <argument><expr><call><name>TYPE_BIT</name><argument_list>(<argument><expr><name>ptrdiff_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* The type and printf format for line numbers.  */</comment>
<typedef>typedef <type><name>int</name></type> <name>lineno_t</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRIdLINENO</name></cpp:macro> <cpp:value>"d"</cpp:value></cpp:define>

<struct>struct <name>rule</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>r_filename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lineno_t</name></type>    <name>r_linenum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>r_name</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>zic_t</name></type>        <name>r_loyear</name></decl>;</decl_stmt>        <comment type="block">/* for example, 1986 */</comment>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>r_hiyear</name></decl>;</decl_stmt>        <comment type="block">/* for example, 1986 */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>r_yrtype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>r_lowasnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>r_hiwasnum</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type>            <name>r_month</name></decl>;</decl_stmt>        <comment type="block">/* 0..11 */</comment>

    <decl_stmt><decl><type><name>int</name></type>            <name>r_dycode</name></decl>;</decl_stmt>        <comment type="block">/* see below */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>r_dayofmonth</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>r_wday</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>zic_t</name></type>        <name>r_tod</name></decl>;</decl_stmt>            <comment type="block">/* time from midnight */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>r_todisstd</name></decl>;</decl_stmt>        <comment type="block">/* above is standard time if 1 or wall clock
                                 * time if 0 */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>r_todisgmt</name></decl>;</decl_stmt>        <comment type="block">/* above is GMT if 1 or local time if 0 */</comment>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>r_stdoff</name></decl>;</decl_stmt>        <comment type="block">/* offset from standard time */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>r_abbrvar</name></decl>;</decl_stmt>        <comment type="block">/* variable part of abbreviation */</comment>

    <decl_stmt><decl><type><name>bool</name></type>        <name>r_todo</name></decl>;</decl_stmt>            <comment type="block">/* a rule to do (used in outzone) */</comment>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>r_temp</name></decl>;</decl_stmt>            <comment type="block">/* used in outzone */</comment>
}</block>;</struct>

<comment type="block">/*
 *    r_dycode        r_dayofmonth    r_wday
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DC_DOM</name></cpp:macro>        <cpp:value>0</cpp:value></cpp:define>    <comment type="block">/* 1..31 */</comment> <comment type="block">/* unused */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DC_DOWGEQ</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>    <comment type="block">/* 1..31 */</comment> <comment type="block">/* 0..6 (Sun..Sat) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DC_DOWLEQ</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>    <comment type="block">/* 1..31 */</comment> <comment type="block">/* 0..6 (Sun..Sat) */</comment>

<struct>struct <name>zone</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z_filename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lineno_t</name></type>    <name>z_linenum</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>z_gmtoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z_rule</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z_format</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>z_format_specifier</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>zic_t</name></type>        <name>z_stdoff</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>z_rules</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type>    <name>z_nrules</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name></type> <name>z_untilrule</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>z_untiltime</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>extern</specifier> <name>int</name></type>    <name>link</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fromname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>toname</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>memory_exhausted</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list> pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>verror</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list> pg_attribute_printf<parameter_list>(</parameter_list>1<operator>,</operator> 0</function_decl>)<empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> pg_attribute_printf<parameter_list>(</parameter_list>1<operator>,</operator> 2</function_decl>)<empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>warning</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> pg_attribute_printf<parameter_list>(</parameter_list>1<operator>,</operator> 2</function_decl>)<empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list> pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addtt</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>starttime</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>addtype</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>bool</name></type></decl></parameter>, <parameter><decl><type><name>bool</name></type></decl></parameter>, <parameter><decl><type><name>bool</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>leapadd</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type></decl></parameter>, <parameter><decl><type><name>bool</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>adjleap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>associate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dolink</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>bool</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>getfields</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>zic_t</name></type> <name>gethms</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errstring</name></decl></parameter>,
       <parameter><decl><type><name>bool</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>infile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>inleap</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>inlink</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>inrule</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>inzcont</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>inzone</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>inzsub</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>bool</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>itsdir</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>itssymlink</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_alpha</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>a</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name></type> <name>lowerit</name><parameter_list>(<parameter><decl><type><name>char</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mkdirs</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>bool</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>newabbr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abbr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>zic_t</name></type> <name>oadd</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>t1</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>t2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>outzone</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>zone</name></name> <modifier>*</modifier></type><name>zp</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>ntzones</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>zic_t</name></type> <name>rpytime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>wantedy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rulesub</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>loyearp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hiyearp</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typep</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>monthp</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dayp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>timep</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>zic_t</name></type> <name>tadd</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>t1</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>t2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>yearistype</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>year</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Bound on length of what %z can expand to.  */</comment>
<enum>enum
<block>{
<decl><name>PERCENT_Z_LEN_BOUND</name> <init>= <expr><sizeof>sizeof <name/></sizeof>"+995959" <operator>-</operator> <literal type="number">1</literal></expr></init></decl>}</block>;</enum>

<comment type="block">/* If true, work around a bug in Qt 5.6.1 and earlier, which mishandles
   tz binary files whose POSIX-TZ-style strings contain '&lt;'; see
   QTBUG-53071 &lt;https://bugreports.qt.io/browse/QTBUG-53071&gt;.  This
   workaround will no longer be needed when Qt 5.6.1 and earlier are
   obsolete, say in the year 2021.  */</comment>
<enum>enum
<block>{
<decl><name>WORK_AROUND_QTBUG_53071</name> <init>= <expr><name>true</name></expr></init></decl>}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>charcnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>errors</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>warnings</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>leapcnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>leapseen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type> <name>leapminyear</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type> <name>leapmaxyear</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>lineno_t</name></type> <name>linenum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>max_abbrvar_len</name> <init>= <expr><name>PERCENT_Z_LEN_BOUND</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>max_format_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type> <name>max_year</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type> <name>min_year</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>noise</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>print_abbrevs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type> <name>print_cutoff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rfilename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>lineno_t</name></type> <name>rlinenum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ptrdiff_t</name></type> <name>timecnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ptrdiff_t</name></type> <name>timecnt_alloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>typecnt</name></decl>;</decl_stmt>

<comment type="block">/*
 * Line codes.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LC_RULE</name></cpp:macro>        <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LC_ZONE</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LC_LINK</name></cpp:macro>        <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LC_LEAP</name></cpp:macro>        <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/*
 * Which fields are which on a Zone line.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZF_NAME</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZF_GMTOFF</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZF_RULE</name></cpp:macro>        <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZF_FORMAT</name></cpp:macro>    <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZF_TILYEAR</name></cpp:macro>    <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZF_TILMONTH</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZF_TILDAY</name></cpp:macro>    <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZF_TILTIME</name></cpp:macro>    <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZONE_MINFIELDS</name></cpp:macro>    <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZONE_MAXFIELDS</name></cpp:macro>    <cpp:value>9</cpp:value></cpp:define>

<comment type="block">/*
 * Which fields are which on a Zone continuation line.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZFC_GMTOFF</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZFC_RULE</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZFC_FORMAT</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZFC_TILYEAR</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZFC_TILMONTH</name></cpp:macro>    <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZFC_TILDAY</name></cpp:macro>    <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZFC_TILTIME</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZONEC_MINFIELDS</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZONEC_MAXFIELDS</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>

<comment type="block">/*
 * Which files are which on a Rule line.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RF_NAME</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RF_LOYEAR</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RF_HIYEAR</name></cpp:macro>    <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RF_COMMAND</name></cpp:macro>    <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RF_MONTH</name></cpp:macro>    <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RF_DAY</name></cpp:macro>        <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RF_TOD</name></cpp:macro>        <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RF_STDOFF</name></cpp:macro>    <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RF_ABBRVAR</name></cpp:macro>    <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULE_FIELDS</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="block">/*
 * Which fields are which on a Link line.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LF_FROM</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LF_TO</name></cpp:macro>        <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LINK_FIELDS</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/*
 * Which fields are which on a Leap line.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_YEAR</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_MONTH</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_DAY</name></cpp:macro>        <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_TIME</name></cpp:macro>        <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_CORR</name></cpp:macro>        <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ROLL</name></cpp:macro>        <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAP_FIELDS</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>

<comment type="block">/*
 * Year synonyms.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YR_MINIMUM</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YR_MAXIMUM</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YR_ONLY</name></cpp:macro>        <cpp:value>2</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rules</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ptrdiff_t</name></type> <name>nrules</name></decl>;</decl_stmt>        <comment type="block">/* number of rules */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ptrdiff_t</name></type> <name>nrules_alloc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>zone</name></name> <modifier>*</modifier></type><name>zones</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ptrdiff_t</name></type> <name>nzones</name></decl>;</decl_stmt>        <comment type="block">/* number of zones */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ptrdiff_t</name></type> <name>nzones_alloc</name></decl>;</decl_stmt>

<struct>struct <name>link</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>l_filename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lineno_t</name></type>    <name>l_linenum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>l_from</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>l_to</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>link</name></name> <modifier>*</modifier></type><name>links</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ptrdiff_t</name></type> <name>nlinks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ptrdiff_t</name></type> <name>nlinks_alloc</name></decl>;</decl_stmt>

<struct>struct <name>lookup</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>l_word</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>    <name>l_value</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>byword</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>,
       <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>lookup</name></name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier></type> <name><name>line_codes</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><literal type="string">"Rule"</literal></expr>, <expr><name>LC_RULE</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"Zone"</literal></expr>, <expr><name>LC_ZONE</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"Link"</literal></expr>, <expr><name>LC_LINK</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"Leap"</literal></expr>, <expr><name>LC_LEAP</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier></type> <name><name>mon_names</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><literal type="string">"January"</literal></expr>, <expr><name>TM_JANUARY</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"February"</literal></expr>, <expr><name>TM_FEBRUARY</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"March"</literal></expr>, <expr><name>TM_MARCH</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"April"</literal></expr>, <expr><name>TM_APRIL</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"May"</literal></expr>, <expr><name>TM_MAY</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"June"</literal></expr>, <expr><name>TM_JUNE</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"July"</literal></expr>, <expr><name>TM_JULY</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"August"</literal></expr>, <expr><name>TM_AUGUST</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"September"</literal></expr>, <expr><name>TM_SEPTEMBER</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"October"</literal></expr>, <expr><name>TM_OCTOBER</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"November"</literal></expr>, <expr><name>TM_NOVEMBER</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"December"</literal></expr>, <expr><name>TM_DECEMBER</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier></type> <name><name>wday_names</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><literal type="string">"Sunday"</literal></expr>, <expr><name>TM_SUNDAY</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"Monday"</literal></expr>, <expr><name>TM_MONDAY</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"Tuesday"</literal></expr>, <expr><name>TM_TUESDAY</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"Wednesday"</literal></expr>, <expr><name>TM_WEDNESDAY</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"Thursday"</literal></expr>, <expr><name>TM_THURSDAY</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"Friday"</literal></expr>, <expr><name>TM_FRIDAY</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"Saturday"</literal></expr>, <expr><name>TM_SATURDAY</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier></type> <name><name>lasts</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><literal type="string">"last-Sunday"</literal></expr>, <expr><name>TM_SUNDAY</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"last-Monday"</literal></expr>, <expr><name>TM_MONDAY</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"last-Tuesday"</literal></expr>, <expr><name>TM_TUESDAY</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"last-Wednesday"</literal></expr>, <expr><name>TM_WEDNESDAY</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"last-Thursday"</literal></expr>, <expr><name>TM_THURSDAY</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"last-Friday"</literal></expr>, <expr><name>TM_FRIDAY</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"last-Saturday"</literal></expr>, <expr><name>TM_SATURDAY</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier></type> <name><name>begin_years</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><literal type="string">"minimum"</literal></expr>, <expr><name>YR_MINIMUM</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"maximum"</literal></expr>, <expr><name>YR_MAXIMUM</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier></type> <name><name>end_years</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><literal type="string">"minimum"</literal></expr>, <expr><name>YR_MINIMUM</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"maximum"</literal></expr>, <expr><name>YR_MAXIMUM</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"only"</literal></expr>, <expr><name>YR_ONLY</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier></type> <name><name>leap_types</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><literal type="string">"Rolling"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"Stationary"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>len_months</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>MONSPERYEAR</name></expr>]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><literal type="number">31</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="number">31</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>len_years</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{
    <expr><name>DAYSPERNYEAR</name></expr>, <expr><name>DAYSPERLYEAR</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<struct><specifier>static</specifier> struct <name>attype</name>
<block>{
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>at</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>dontmerge</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>type</name></decl>;</decl_stmt>
}</block>           <decl><modifier>*</modifier><name>attypes</name></decl>;</struct>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type> <name><name>gmtoffs</name><index>[<expr><name>TZ_MAX_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>isdsts</name><index>[<expr><name>TZ_MAX_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name><name>abbrinds</name><index>[<expr><name>TZ_MAX_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name><name>ttisstds</name><index>[<expr><name>TZ_MAX_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name><name>ttisgmts</name><index>[<expr><name>TZ_MAX_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>chars</name><index>[<expr><name>TZ_MAX_CHARS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type> <name><name>trans</name><index>[<expr><name>TZ_MAX_LEAPS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type> <name><name>corr</name><index>[<expr><name>TZ_MAX_LEAPS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>roll</name><index>[<expr><name>TZ_MAX_LEAPS</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/*
 * Memory allocation.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>memory_exhausted</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Memory exhausted: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>size_product</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>nitems</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>itemsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>SIZE_MAX</name> <operator>/</operator> <name>itemsize</name> <operator>&lt;</operator> <name>nitems</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memory_exhausted</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"size overflow"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>nitems</name> <operator>*</operator> <name>itemsize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>memcheck</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memory_exhausted</name><argument_list>(<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>emalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>memcheck</name><argument_list>(<argument><expr><call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>erealloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>memcheck</name><argument_list>(<argument><expr><call><name>realloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ecpyalloc</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>memcheck</name><argument_list>(<argument><expr><call><name>strdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>growalloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>itemsize</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>nitems</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name> <modifier>*</modifier></type><name>nitems_alloc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&lt;</operator> <operator>*</operator><name>nitems_alloc</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>ptr</name></expr>;</return></block_content></block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>ptrdiff_t</name></type>    <name>amax</name> <init>= <expr><name>PTRDIFF_MAX</name> <operator>-</operator> <name>WORK_AROUND_QTBUG_53071</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>amax</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">3</literal> <operator>*</operator> <literal type="number">2</literal> <operator>&lt;</operator> <operator>*</operator><name>nitems_alloc</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>memory_exhausted</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"integer overflow"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>nitems_alloc</name> <operator>+=</operator> <operator>(</operator><operator>*</operator><name>nitems_alloc</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><call><name>erealloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>size_product</name><argument_list>(<argument><expr><operator>*</operator><name>nitems_alloc</name></expr></argument>, <argument><expr><name>itemsize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Error handling.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>eats</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>lineno_t</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>rname</name></decl></parameter>, <parameter><decl><type><name>lineno_t</name></type> <name>rnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>filename</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>linenum</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rfilename</name> <operator>=</operator> <name>rname</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rlinenum</name> <operator>=</operator> <name>rnum</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>eat</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>lineno_t</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>eats</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>verror</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Match the format of "cc" to allow sh users to  zic ... 2&gt;&amp;1 | error -t
     * "*" -v on BSD systems.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\", line %"</literal> <name>PRIdLINENO</name> <literal type="string">": "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>linenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rfilename</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" (rule from \"%s\", line %"</literal> <name>PRIdLINENO</name> <literal type="string">")"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>rfilename</name></expr></argument>, <argument><expr><name>rlinenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>va_list</name></type>        <name>args</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>verror</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>errors</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>warning</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>va_list</name></type>        <name>args</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"warning: "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>verror</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>warnings</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>close_file</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><ternary><condition><expr><call><name>ferror</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"I/O error"</literal></expr></argument>)</argument_list></call></expr>
                     </then><else>: <expr><ternary><condition><expr><call><name>fclose</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>e</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: %s%s%s%s%s\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>,
                <argument><expr><ternary><condition><expr><name>dir</name></expr> ?</condition><then> <expr><name>dir</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>dir</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                <argument><expr><ternary><condition><expr><name>name</name></expr> ?</condition><then> <expr><name>name</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>name</name></expr> ?</condition><then> <expr><literal type="string">": "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>,
            <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: usage is %s [ --version ] [ --help ] [ -v ] [ -P ] \\\n"</literal>
              <literal type="string">"\t[ -l localtime ] [ -p posixrules ] [ -d directory ] \\\n"</literal>
              <literal type="string">"\t[ -L leapseconds ] [ filename ... ]\n\n"</literal>
              <literal type="string">"Report bugs to %s.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>PACKAGE_BUGREPORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>EXIT_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>close_file</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Change the working directory to DIR, possibly creating DIR and its
   ancestors.  After this is done, all files are accessed with names
   relative to DIR.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>change_directory</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>chdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>chdir_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>chdir_errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>mkdirs</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>chdir_errno</name> <operator>=</operator> <ternary><condition><expr><call><name>chdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>errno</name></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>chdir_errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Can't chdir to %s: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>chdir_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>psxrules</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lcltime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>directory</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>leapsec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>yitcommand</name></decl>;</decl_stmt>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>c</name></decl>,
                <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type>    <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
    <expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><call><name>umask</name><argument_list>(<argument><expr><name>S_IWGRP</name> <operator>|</operator> <name>S_IWOTH</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><name>S_IWGRP</name> <operator>|</operator> <name>S_IWOTH</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* !WIN32 */</comment>
    <expr_stmt><expr><name>progname</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>TYPE_BIT</name><argument_list>(<argument><expr><name>zic_t</name></expr></argument>)</argument_list></call> <operator>&lt;</operator><literal type="number">64</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"wild compilation-time specification of zic_t"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"zic %s\n"</literal></expr></argument>, <argument><expr><name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close_file</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>EXIT_SUCCESS</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt></block_content></block></for>
    <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"d:l:p:L:vPsy:"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
        <block>{<block_content>
            <default>default:</default>
                <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <case>case <expr><literal type="char">'d'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>directory</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>directory</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: More than one -d option specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
                </block_content>}</block></else></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'l'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>lcltime</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>lcltime</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: More than one -l option specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
                </block_content>}</block></else></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'p'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>psxrules</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>psxrules</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: More than one -p option specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
                </block_content>}</block></else></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'y'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>yitcommand</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>yitcommand</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: More than one -y option specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
                </block_content>}</block></else></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'L'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>leapsec</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>leapsec</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: More than one -L option specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
                </block_content>}</block></else></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'v'</literal></expr>:</case>
                <expr_stmt><expr><name>noise</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'P'</literal></expr>:</case>
                <expr_stmt><expr><name>print_abbrevs</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>print_cutoff</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'s'</literal></expr>:</case>
                <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"-s ignored"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><name>optind</name> <operator>==</operator> <name>argc</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* usage message by request */</comment>
    <if_stmt><if>if <condition>(<expr><name>directory</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>directory</name> <operator>=</operator> <literal type="string">"data"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>yitcommand</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>yitcommand</name> <operator>=</operator> <literal type="string">"yearistype"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name> <operator>&amp;&amp;</operator> <name>leapsec</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>infile</name><argument_list>(<argument><expr><name>leapsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>adjleap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name>optind</name></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>infile</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <if_stmt><if>if <condition>(<expr><name>errors</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>EXIT_FAILURE</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>associate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>change_directory</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nzones</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <name>j</name></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * Find the next non-continuation zone entry.
         */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nzones</name> <operator>&amp;&amp;</operator> <name><name>zones</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>z_name</name> <operator>==</operator> <name>NULL</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></for>
        <expr_stmt><expr><call><name>outzone</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zones</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Make links.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nlinks</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>eat</name><argument_list>(<argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_filename</name></expr></argument>, <argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_linenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dolink</name><argument_list>(<argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_from</name></expr></argument>, <argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_to</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>noise</name></expr>)</condition><block type="pseudo"><block_content>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nlinks</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_to</name></expr></argument>,
                           <argument><expr><name><name>links</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>l_from</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"link to link"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>lcltime</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>eat</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"command line"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dolink</name><argument_list>(<argument><expr><name>lcltime</name></expr></argument>, <argument><expr><name>TZDEFAULT</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>psxrules</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>eat</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"command line"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dolink</name><argument_list>(<argument><expr><name>psxrules</name></expr></argument>, <argument><expr><name>TZDEFRULES</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>warnings</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ferror</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>fclose</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>EXIT_FAILURE</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><ternary><condition><expr><name>errors</name></expr> ?</condition><then> <expr><name>EXIT_FAILURE</name></expr> </then><else>: <expr><name>EXIT_SUCCESS</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>componentcheck</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>component</name></decl></parameter>,
               <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>component_end</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <enum>enum
    <block>{
    <decl><name>component_len_max</name> <init>= <expr><literal type="number">14</literal></expr></init></decl>}</block>;</enum>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type>    <name>component_len</name> <init>= <expr><name>component_end</name> <operator>-</operator> <name>component</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>component_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"empty file name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><ternary><condition><expr><name>component</name> <operator>==</operator> <name>name</name></expr>
                    ?</condition><then> <expr><literal type="string">"file name '%s' begins with '/'"</literal></expr>
                    </then><else>: <expr><ternary><condition><expr><operator>*</operator><name>component_end</name></expr>
                    ?</condition><then> <expr><literal type="string">"file name '%s' contains '//'"</literal></expr>
                    </then><else>: <expr><literal type="string">"file name '%s' ends with '/'"</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>component_len</name> <operator>&amp;&amp;</operator> <name>component_len</name> <operator>&lt;=</operator> <literal type="number">2</literal>
        <operator>&amp;&amp;</operator> <name><name>component</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name><name>component_end</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>len</name> <init>= <expr><name>component_len</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"file name '%s' contains '%.*s' component"</literal></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>component</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>noise</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>component_len</name> <operator>&amp;&amp;</operator> <name><name>component</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"file name '%s' component contains leading '-'"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>component_len_max</name> <operator>&lt;</operator> <name>component_len</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"file name '%s' contains overlength component"</literal>
                      <literal type="string">" '%.*s...'"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>name</name></expr></argument>, <argument><expr><name>component_len_max</name></expr></argument>, <argument><expr><name>component</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>namecheck</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

    <comment type="block">/* Benign characters in a portable file name.  */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier></type> <name><name>benign</name><index>[]</index></name> <init>=
    <expr><literal type="string">"-/_"</literal>
    <literal type="string">"abcdefghijklmnopqrstuvwxyz"</literal>
    <literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Non-control chars in the POSIX portable character set, excluding the
     * benign characters.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier></type> <name><name>printable_and_not_benign</name><index>[]</index></name> <init>=
    <expr><literal type="string">" !\"#$%&amp;'()*+,.0123456789:;&lt;=&gt;?@[\\]^`{|}~"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>component</name> <init>= <expr><name>name</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>name</name></expr>;</init> <condition><expr><operator>*</operator><name>cp</name></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>cp</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>noise</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strchr</name><argument_list>(<argument><expr><name>benign</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><call><name>strchr</name><argument_list>(<argument><expr><name>printable_and_not_benign</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>
                     ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"file name '%s' contains byte '%c'"</literal></expr></argument>)</argument_list></call></expr>
                     </then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"file name '%s' contains byte '\\%o'"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>,
                    <argument><expr><name>name</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>componentcheck</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>component</name> <operator>=</operator> <name>cp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><call><name>componentcheck</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create symlink contents suitable for symlinking FROM to TO, as a
 * freshly allocated string.  FROM should be a relative file name, and
 * is relative to the global variable DIRECTORY.  TO can be either
 * relative or absolute.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYMLINK</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>relname</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>i</name></decl>,
                <decl><type ref="prev"/><name>taillen</name></decl>,
                <decl><type ref="prev"/><name>dotdotetcsize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>dir_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>dotdots</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>linksize</name> <init>= <expr><name>SIZE_MAX</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>f</name> <init>= <expr><name>from</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>to</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Make F absolute too.  */</comment>
        <decl_stmt><decl><type><name>size_t</name></type>        <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>needslash</name> <init>= <expr><name>len</name> <operator>&amp;&amp;</operator> <name><name>directory</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>linksize</name> <operator>=</operator> <name>len</name> <operator>+</operator> <name>needslash</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>f</name> <operator>=</operator> <name>result</name> <operator>=</operator> <call><name>emalloc</name><argument_list>(<argument><expr><name>linksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name> <operator>+</operator> <name>needslash</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>f</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>f</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>to</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>f</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>dir_len</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    <for>for <control>(<init>;</init> <condition><expr><name><name>to</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>dotdots</name> <operator>+=</operator> <name><name>to</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>to</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name>taillen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>f</name> <operator>+</operator> <name>dir_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dotdotetcsize</name> <operator>=</operator> <literal type="number">3</literal> <operator>*</operator> <name>dotdots</name> <operator>+</operator> <name>taillen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dotdotetcsize</name> <operator>&lt;=</operator> <name>linksize</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>emalloc</name><argument_list>(<argument><expr><name>dotdotetcsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dotdots</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <name>i</name></expr></argument>, <argument><expr><literal type="string">"../"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <name>dotdots</name></expr></argument>, <argument><expr><name>f</name> <operator>+</operator> <name>dir_len</name></expr></argument>, <argument><expr><name>taillen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* HAVE_SYMLINK */</comment>

<comment type="block">/* Hard link FROM to TO, following any symbolic links.
   Return 0 if successful, an error number otherwise.  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>hardlinkerr</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>r</name> <init>= <expr><call><name>linkat</name><argument_list>(<argument><expr><name>AT_FDCWD</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>AT_FDCWD</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>AT_SYMLINK_FOLLOW</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><ternary><condition><expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>errno</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dolink</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>fromfield</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>tofield</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>staysymlink</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>todirs_made</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>link_errno</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We get to be careful here since there's a fair chance of root running
     * us.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>itsdir</name><argument_list>(<argument><expr><name>fromfield</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: link from %s/%s failed: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>fromfield</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>EPERM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>staysymlink</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>staysymlink</name> <operator>=</operator> <call><name>itssymlink</name><argument_list>(<argument><expr><name>tofield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>remove</name><argument_list>(<argument><expr><name>tofield</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>todirs_made</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Can't remove %s/%s: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>tofield</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>link_errno</name> <operator>=</operator> <ternary><condition><expr><name>staysymlink</name></expr> ?</condition><then> <expr><name>ENOTSUP</name></expr> </then><else>: <expr><call><name>hardlinkerr</name><argument_list>(<argument><expr><name>fromfield</name></expr></argument>, <argument><expr><name>tofield</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>link_errno</name> <operator>==</operator> <name>ENOENT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>todirs_made</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mkdirs</name><argument_list>(<argument><expr><name>tofield</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>todirs_made</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>link_errno</name> <operator>=</operator> <call><name>hardlinkerr</name><argument_list>(<argument><expr><name>fromfield</name></expr></argument>, <argument><expr><name>tofield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>link_errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYMLINK</name></cpp:ifdef>
        <decl_stmt><decl><type><name>bool</name></type>        <name>absolute</name> <init>= <expr><operator>*</operator><name>fromfield</name> <operator>==</operator> <literal type="char">'/'</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>linkalloc</name> <init>= <expr><ternary><condition><expr><name>absolute</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>relname</name><argument_list>(<argument><expr><name>fromfield</name></expr></argument>, <argument><expr><name>tofield</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>contents</name> <init>= <expr><ternary><condition><expr><name>absolute</name></expr> ?</condition><then> <expr><name>fromfield</name></expr> </then><else>: <expr><name>linkalloc</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>symlink_errno</name> <init>= <expr><ternary><condition><expr><call><name>symlink</name><argument_list>(<argument><expr><name>contents</name></expr></argument>, <argument><expr><name>tofield</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>errno</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>symlink_errno</name> <operator>==</operator> <name>ENOENT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>todirs_made</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>mkdirs</name><argument_list>(<argument><expr><name>tofield</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>symlink_errno</name> <operator>=</operator> <ternary><condition><expr><call><name>symlink</name><argument_list>(<argument><expr><name>contents</name></expr></argument>, <argument><expr><name>tofield</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>errno</name></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>linkalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>symlink_errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>link_errno</name> <operator>!=</operator> <name>ENOTSUP</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"symbolic link used because hard link failed: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>link_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* HAVE_SYMLINK */</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fp</name></decl>,
                       <decl><type ref="prev"><modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>c</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>fromfield</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Can't read %s/%s: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>fromfield</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>tofield</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tp</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Can't create %s/%s: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>tofield</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
            <expr_stmt><expr><call><name>close_file</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>fromfield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close_file</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>tofield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>link_errno</name> <operator>!=</operator> <name>ENOTSUP</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"copy used because hard link failed: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>link_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYMLINK</name></cpp:ifdef>
            <if type="elseif">else if <condition>(<expr><name>symlink_errno</name> <operator>!=</operator> <name>ENOTSUP</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"copy used because symbolic link failed: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>symlink_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_T_BITS_IN_FILE</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name> <specifier>const</specifier></type> <name>min_time</name> <init>= <expr><call><name>MINVAL</name><argument_list>(<argument><expr><name>zic_t</name></expr></argument>, <argument><expr><name>TIME_T_BITS_IN_FILE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name> <specifier>const</specifier></type> <name>max_time</name> <init>= <expr><call><name>MAXVAL</name><argument_list>(<argument><expr><name>zic_t</name></expr></argument>, <argument><expr><name>TIME_T_BITS_IN_FILE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Estimated time of the Big Bang, in seconds since the POSIX epoch.
 * rounded downward to the negation of a power of two that is
 * comfortably outside the error bounds.
 *
 * For the time of the Big Bang, see:
 *
 * Ade PAR, Aghanim N, Armitage-Caplan C et al.  Planck 2013 results.
 * I. Overview of products and scientific results.
 * arXiv:1303.5062 2013-03-20 20:10:01 UTC
 * &lt;http://arxiv.org/pdf/1303.5062v1&gt; [PDF]
 *
 * Page 36, Table 9, row Age/Gyr, column Planck+WP+highL+BAO 68% limits
 * gives the value 13.798 plus-or-minus 0.037 billion years.
 * Multiplying this by 1000000000 and then by 31557600 (the number of
 * seconds in an astronomical year) gives a value that is comfortably
 * less than 2**59, so BIG_BANG is - 2**59.
 *
 * BIG_BANG is approximate, and may change in future versions.
 * Please do not rely on its exact value.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BIG_BANG</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIG_BANG</name></cpp:macro> <cpp:value>(- (((zic_t) 1) &lt;&lt; 59))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* If true, work around GNOME bug 730332
   &lt;https://bugzilla.gnome.org/show_bug.cgi?id=730332&gt;
   by refusing to output time stamps before BIG_BANG.
   Such time stamps are physically suspect anyway.

   The GNOME bug is scheduled to be fixed in GNOME 3.22, and if so
   this workaround will no longer be needed when GNOME 3.21 and
   earlier are obsolete, say in the year 2021.  */</comment>
<enum>enum
<block>{
<decl><name>WORK_AROUND_GNOME_BUG_730332</name> <init>= <expr><name>true</name></expr></init></decl>}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>zic_t</name></type> <name>early_time</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>WORK_AROUND_GNOME_BUG_730332</name></expr>
                                 ?</condition><then> <expr><name>BIG_BANG</name></expr>
                                 </then><else>: <expr><call><name>MINVAL</name><argument_list>(<argument><expr><name>zic_t</name></expr></argument>, <argument><expr><name>TIME_T_BITS_IN_FILE</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<comment type="block">/* Return true if NAME is a directory.  */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>itsdir</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>res</name> <init>= <expr><call><name>stat</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>S_ISDIR</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EOVERFLOW</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type>        <name>n</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nameslashdot</name> <init>= <expr><call><name>emalloc</name><argument_list>(<argument><expr><name>n</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>dir</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nameslashdot</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nameslashdot</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><literal type="string">"/."</literal><index>[<expr><operator>!</operator><operator>(</operator><name>n</name> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal><operator>)</operator></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>stat</name><argument_list>(<argument><expr><name>nameslashdot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EOVERFLOW</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>nameslashdot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>dir</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return true if NAME is a symbolic link.  */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>itssymlink</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYMLINK</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name></type>        <name>c</name></decl>;</decl_stmt>

    <return>return <expr><literal type="number">0</literal> <operator>&lt;=</operator> <call><name>readlink</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Associate sets of rules with zones.
 */</comment>

<comment type="block">/*
 * Sort by rule name.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rcomp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>cp1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>cp2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>rule</name> <operator>*</operator><operator>)</operator> <name>cp1</name><operator>)</operator><operator>-&gt;</operator><name>r_name</name></expr></argument>,
                  <argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>rule</name> <operator>*</operator><operator>)</operator> <name>cp2</name><operator>)</operator><operator>-&gt;</operator><name>r_name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>associate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>zone</name></name> <modifier>*</modifier></type><name>zp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type>    <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>,
                <decl><type ref="prev"/><name>base</name></decl>,
                <decl><type ref="prev"/><name>out</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>nrules</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>rules</name></expr></argument>, <argument><expr><name>nrules</name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>rules</name></expr></argument>, <argument><expr><name>rcomp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrules</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rules</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>r_name</name></expr></argument>,
                       <argument><expr><name><name>rules</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>r_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rules</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>r_filename</name></expr></argument>,
                       <argument><expr><name><name>rules</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>r_filename</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>eat</name><argument_list>(<argument><expr><name><name>rules</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>r_filename</name></expr></argument>, <argument><expr><name><name>rules</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>r_linenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"same rule name in multiple files"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>eat</name><argument_list>(<argument><expr><name><name>rules</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>r_filename</name></expr></argument>, <argument><expr><name><name>rules</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>r_linenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"same rule name in multiple files"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nrules</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rules</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>r_name</name></expr></argument>,
                           <argument><expr><name><name>rules</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>r_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rules</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>r_filename</name></expr></argument>,
                           <argument><expr><name><name>rules</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>r_filename</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rules</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>r_filename</name></expr></argument>,
                           <argument><expr><name><name>rules</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>r_filename</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block></for>
            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nzones</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>zp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zones</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>z_rules</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init><expr><name>base</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>base</name> <operator>&lt;</operator> <name>nrules</name></expr>;</condition> <incr><expr><name>base</name> <operator>=</operator> <name>out</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>rp</name> <operator>=</operator> <operator>&amp;</operator><name><name>rules</name><index>[<expr><name>base</name></expr>]</index></name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>out</name> <operator>=</operator> <name>base</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>out</name> <operator>&lt;</operator> <name>nrules</name></expr>;</condition> <incr><expr><operator>++</operator><name>out</name></expr></incr>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_name</name></name></expr></argument>, <argument><expr><name><name>rules</name><index>[<expr><name>out</name></expr>]</index></name><operator>.</operator><name>r_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nzones</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>zp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zones</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_rule</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_name</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>z_rules</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name> <operator>=</operator> <name>out</name> <operator>-</operator> <name>base</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nzones</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>zp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zones</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Maybe we have a local standard time offset.
             */</comment>
            <expr_stmt><expr><call><name>eat</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_filename</name></name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_linenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>z_stdoff</name></name> <operator>=</operator> <call><name>gethms</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_rule</name></name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unruly zone"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Note, though, that if there's no rule, a '%s' in the format is
             * a bad thing.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>zp</name><operator>-&gt;</operator><name>z_format_specifier</name></name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s in ruleless zone"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>errors</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>infile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>lookup</name></name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nfields</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>wantcont</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lineno_t</name></type>    <name>num</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>buf</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"standard input"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>fp</name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Cannot open %s: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>wantcont</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>num</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init><condition>;</condition> <incr><expr><operator>++</operator><name>num</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>eat</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <name>buf</name></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>buf</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"line too long"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>fields</name> <operator>=</operator> <call><name>getfields</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nfields</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><name><name>fields</name><index>[<expr><name>nfields</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name>nada</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>nfields</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>fields</name><index>[<expr><name>nfields</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name>nada</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><operator>++</operator><name>nfields</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* nothing to do */</comment>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>wantcont</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>wantcont</name> <operator>=</operator> <call><name>inzcont</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>byword</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>line_codes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>lp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"input line of unknown type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <switch>switch <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>LC_RULE</name></expr>:</case>
                        <expr_stmt><expr><call><name>inrule</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>wantcont</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LC_ZONE</name></expr>:</case>
                        <expr_stmt><expr><name>wantcont</name> <operator>=</operator> <call><name>inzone</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LC_LINK</name></expr>:</case>
                        <expr_stmt><expr><call><name>inlink</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>wantcont</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LC_LEAP</name></expr>:</case>
                        <if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>leapsec</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Leap line in non leap"</literal>
                                      <literal type="string">" seconds file %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>inleap</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                        <expr_stmt><expr><name>wantcont</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <default>default:</default>    <comment type="block">/* "cannot happen" */</comment>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: panic: Invalid l_value %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></switch></block_content></block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>close_file</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>wantcont</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"expected continuation line not found"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a string of one of the forms
 *    h    -h    hh:mm    -hh:mm    hh:mm:ss    -hh:mm:ss
 * into a number of seconds.
 * A null string maps to zero.
 * Call error with errstring and return zero on errors.
 */</comment>
<function><type><specifier>static</specifier> <name>zic_t</name></type>
<name>gethms</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>errstring</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>signable</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* PG: make hh be int not zic_t to avoid sscanf portability issues */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>hh</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>mm</name></decl>,
                <decl><type ref="prev"/><name>ss</name></decl>,
                <decl><type ref="prev"/><name>sign</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>xs</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>string</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>string</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>signable</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>*</operator><name>string</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name>string</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">"%d%c"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>mm</name> <operator>=</operator> <name>ss</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">"%d:%d%c"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ss</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">"%d:%d:%d%c"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ss</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xs</name></expr></argument>)</argument_list></call>
             <operator>!=</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>hh</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
        <name>mm</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>mm</name> <operator>&gt;=</operator> <name>MINSPERHOUR</name> <operator>||</operator>
        <name><name>ss</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>ss</name></expr></argument> &gt;</argument_list></name> <name>SECSPERMIN</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Some compilers warn that this test is unsatisfiable for 32-bit ints */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>INT_MAX</name> <operator>&gt;</operator> <name>PG_INT32_MAX</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>ZIC_MAX</name> <operator>/</operator> <name>SECSPERHOUR</name> <operator>&lt;</operator> <name>hh</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"time overflow"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>noise</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>hh</name> <operator>&gt;</operator> <name>HOURSPERDAY</name> <operator>||</operator>
                  <operator>(</operator><name>hh</name> <operator>==</operator> <name>HOURSPERDAY</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>mm</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>ss</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"values over 24 hours not handled by pre-2007 versions of zic"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><call><name>oadd</name><argument_list>(<argument><expr><name>sign</name> <operator>*</operator> <operator>(</operator><name>zic_t</name><operator>)</operator> <name>hh</name> <operator>*</operator> <name>SECSPERHOUR</name></expr></argument>,
                <argument><expr><name>sign</name> <operator>*</operator> <operator>(</operator><name>mm</name> <operator>*</operator> <name>SECSPERMIN</name> <operator>+</operator> <name>ss</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>inrule</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>rule</name></name></type> <name>r</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>!=</operator> <name>RULE_FIELDS</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"wrong number of fields on Rule line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>fields</name><index>[<expr><name>RF_NAME</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"nameless rule"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>r_filename</name></name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>r_linenum</name></name> <operator>=</operator> <name>linenum</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>r_stdoff</name></name> <operator>=</operator> <call><name>gethms</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>RF_STDOFF</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid saved time"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rulesub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name><name>fields</name><index>[<expr><name>RF_LOYEAR</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>fields</name><index>[<expr><name>RF_HIYEAR</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>fields</name><index>[<expr><name>RF_COMMAND</name></expr>]</index></name></expr></argument>,
            <argument><expr><name><name>fields</name><index>[<expr><name>RF_MONTH</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>fields</name><index>[<expr><name>RF_DAY</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>fields</name><index>[<expr><name>RF_TOD</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>r_name</name></name> <operator>=</operator> <call><name>ecpyalloc</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>RF_NAME</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>r_abbrvar</name></name> <operator>=</operator> <call><name>ecpyalloc</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>RF_ABBRVAR</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>max_abbrvar_len</name> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>r_abbrvar</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>max_abbrvar_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>r_abbrvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rules</name> <operator>=</operator> <call><name>growalloc</name><argument_list>(<argument><expr><name>rules</name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>rules</name></expr></argument>, <argument><expr><name>nrules</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nrules_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rules</name><index>[<expr><name>nrules</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>inzone</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type>    <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>nfields</name> <argument_list type="generic">&lt; <argument><expr><name>ZONE_MINFIELDS</name> <operator>||</operator> <name>nfields</name></expr></argument> &gt;</argument_list></name> <name>ZONE_MAXFIELDS</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"wrong number of fields on Zone line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>ZF_NAME</name></expr>]</index></name></expr></argument>, <argument><expr><name>TZDEFAULT</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>lcltime</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(
              <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"Zone %s\" line and -l option are mutually exclusive"</literal></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><name>TZDEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>ZF_NAME</name></expr>]</index></name></expr></argument>, <argument><expr><name>TZDEFRULES</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>psxrules</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(
              <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"Zone %s\" line and -p option are mutually exclusive"</literal></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><name>TZDEFRULES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nzones</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>zones</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
            <call><name>strcmp</name><argument_list>(<argument><expr><name><name>zones</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z_name</name></expr></argument>, <argument><expr><name><name>fields</name><index>[<expr><name>ZF_NAME</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"duplicate zone name %s"</literal>
                    <literal type="string">" (file \"%s\", line %"</literal> <name>PRIdLINENO</name> <literal type="string">")"</literal></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><name><name>fields</name><index>[<expr><name>ZF_NAME</name></expr>]</index></name></expr></argument>,
                  <argument><expr><name><name>zones</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z_filename</name></expr></argument>,
                  <argument><expr><name><name>zones</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z_linenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt></block_content></block></for>
    <return>return <expr><call><name>inzsub</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>inzcont</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>nfields</name> <argument_list type="generic">&lt; <argument><expr><name>ZONEC_MINFIELDS</name> <operator>||</operator> <name>nfields</name></expr></argument> &gt;</argument_list></name> <name>ZONEC_MAXFIELDS</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"wrong number of fields on Zone continuation line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>inzsub</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>inzsub</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iscont</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cp1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>zone</name></name></type> <name>z</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i_gmtoff</name></decl>,
                <decl><type ref="prev"/><name>i_rule</name></decl>,
                <decl><type ref="prev"/><name>i_format</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i_untilyear</name></decl>,
                <decl><type ref="prev"/><name>i_untilmonth</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i_untilday</name></decl>,
                <decl><type ref="prev"/><name>i_untiltime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>hasuntil</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>iscont</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>i_gmtoff</name> <operator>=</operator> <name>ZFC_GMTOFF</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i_rule</name> <operator>=</operator> <name>ZFC_RULE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i_format</name> <operator>=</operator> <name>ZFC_FORMAT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i_untilyear</name> <operator>=</operator> <name>ZFC_TILYEAR</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i_untilmonth</name> <operator>=</operator> <name>ZFC_TILMONTH</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i_untilday</name> <operator>=</operator> <name>ZFC_TILDAY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i_untiltime</name> <operator>=</operator> <name>ZFC_TILTIME</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>namecheck</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>ZF_NAME</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>i_gmtoff</name> <operator>=</operator> <name>ZF_GMTOFF</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i_rule</name> <operator>=</operator> <name>ZF_RULE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i_format</name> <operator>=</operator> <name>ZF_FORMAT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i_untilyear</name> <operator>=</operator> <name>ZF_TILYEAR</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i_untilmonth</name> <operator>=</operator> <name>ZF_TILMONTH</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i_untilday</name> <operator>=</operator> <name>ZF_TILDAY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i_untiltime</name> <operator>=</operator> <name>ZF_TILTIME</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_name</name></name> <operator>=</operator> <call><name>ecpyalloc</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>ZF_NAME</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_filename</name></name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_linenum</name></name> <operator>=</operator> <name>linenum</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_gmtoff</name></name> <operator>=</operator> <call><name>gethms</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>i_gmtoff</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid UT offset"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>i_format</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><operator>++</operator><name>cp</name> <operator>!=</operator> <literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'z'</literal><operator>)</operator> <operator>||</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call>
            <operator>||</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>i_format</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid abbreviation format"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_rule</name></name> <operator>=</operator> <call><name>ecpyalloc</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>i_rule</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_format</name></name> <operator>=</operator> <name>cp1</name> <operator>=</operator> <call><name>ecpyalloc</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>i_format</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_format_specifier</name></name> <operator>=</operator> <ternary><condition><expr><name>cp</name></expr> ?</condition><then> <expr><operator>*</operator><name>cp</name></expr> </then><else>: <expr><literal type="char">'\0'</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>z</name><operator>.</operator><name>z_format_specifier</name></name> <operator>==</operator> <literal type="char">'z'</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>noise</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"format '%s' not handled by pre-2015 versions of zic"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name><name>z</name><operator>.</operator><name>z_format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>cp1</name><index>[<expr><name>cp</name> <operator>-</operator> <name><name>fields</name><index>[<expr><name>i_format</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <literal type="char">'s'</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>max_format_len</name> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>z</name><operator>.</operator><name>z_format</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>max_format_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>z</name><operator>.</operator><name>z_format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>hasuntil</name> <operator>=</operator> <name>nfields</name> <operator>&gt;</operator> <name>i_untilyear</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>hasuntil</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_untilrule</name><operator>.</operator><name>r_filename</name></name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_untilrule</name><operator>.</operator><name>r_linenum</name></name> <operator>=</operator> <name>linenum</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>rulesub</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><operator>.</operator><name>z_untilrule</name></name></expr></argument>,
                <argument><expr><name><name>fields</name><index>[<expr><name>i_untilyear</name></expr>]</index></name></expr></argument>,
                <argument><expr><literal type="string">"only"</literal></expr></argument>,
                <argument><expr><literal type="string">""</literal></expr></argument>,
                <argument><expr><ternary><condition><expr><operator>(</operator><name>nfields</name> <operator>&gt;</operator> <name>i_untilmonth</name><operator>)</operator></expr> ?</condition><then>
                <expr><name><name>fields</name><index>[<expr><name>i_untilmonth</name></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"Jan"</literal></expr></else></ternary></expr></argument>,
                <argument><expr><ternary><condition><expr><operator>(</operator><name>nfields</name> <operator>&gt;</operator> <name>i_untilday</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>fields</name><index>[<expr><name>i_untilday</name></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"1"</literal></expr></else></ternary></expr></argument>,
                <argument><expr><ternary><condition><expr><operator>(</operator><name>nfields</name> <operator>&gt;</operator> <name>i_untiltime</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>fields</name><index>[<expr><name>i_untiltime</name></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"0"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_untiltime</name></name> <operator>=</operator> <call><name>rpytime</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><operator>.</operator><name>z_untilrule</name></name></expr></argument>,
                                <argument><expr><name><name>z</name><operator>.</operator><name>z_untilrule</name><operator>.</operator><name>r_loyear</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>iscont</name> <operator>&amp;&amp;</operator> <name>nzones</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name><name>z</name><operator>.</operator><name>z_untiltime</name></name> <operator>&gt;</operator> <name>min_time</name> <operator>&amp;&amp;</operator>
            <name><name>z</name><operator>.</operator><name>z_untiltime</name></name> <operator>&lt;</operator> <name>max_time</name> <operator>&amp;&amp;</operator>
            <name><name>zones</name><index>[<expr><name>nzones</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z_untiltime</name> <operator>&gt;</operator> <name>min_time</name> <operator>&amp;&amp;</operator>
            <name><name>zones</name><index>[<expr><name>nzones</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z_untiltime</name> <operator>&lt;</operator> <name>max_time</name> <operator>&amp;&amp;</operator>
            <name><name>zones</name><index>[<expr><name>nzones</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z_untiltime</name> <operator>&gt;=</operator> <name><name>z</name><operator>.</operator><name>z_untiltime</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Zone continuation line end time is not after end time of previous line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zones</name> <operator>=</operator> <call><name>growalloc</name><argument_list>(<argument><expr><name>zones</name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>zones</name></expr></argument>, <argument><expr><name>nzones</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nzones_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zones</name><index>[<expr><name>nzones</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If there was an UNTIL field on this line, there's more information
     * about the zone on the next line.
     */</comment>
    <return>return <expr><name>hasuntil</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>inleap</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>lookup</name></name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <comment type="block">/* PG: make year be int not zic_t to avoid sscanf portability issues */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>year</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>month</name></decl>,
                <decl><type ref="prev"/><name>day</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>dayoff</name></decl>,
                <decl><type ref="prev"/><name>tod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>t</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>xs</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>!=</operator> <name>LEAP_FIELDS</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"wrong number of fields on Leap line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>dayoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>cp</name> <operator>=</operator> <name><name>fields</name><index>[<expr><name>LP_YEAR</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%d%c"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>year</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Leapin' Lizards!
         */</comment>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid leaping year"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>leapseen</name> <operator>||</operator> <name>leapmaxyear</name> <operator>&lt;</operator> <name>year</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>leapmaxyear</name> <operator>=</operator> <name>year</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>leapseen</name> <operator>||</operator> <name>leapminyear</name> <operator>&gt;</operator> <name>year</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>leapminyear</name> <operator>=</operator> <name>year</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>leapseen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <name>EPOCH_YEAR</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>j</name> <operator>!=</operator> <name>year</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>year</name> <operator>&gt;</operator> <name>j</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>len_years</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><operator>--</operator><name>j</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><name><name>len_years</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>dayoff</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>dayoff</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>lp</name> <operator>=</operator> <call><name>byword</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>LP_MONTH</name></expr>]</index></name></expr></argument>, <argument><expr><name>mon_names</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid month name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>month</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <name>TM_JANUARY</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>j</name> <operator>!=</operator> <name>month</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>len_months</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>year</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dayoff</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>dayoff</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>cp</name> <operator>=</operator> <name><name>fields</name><index>[<expr><name>LP_DAY</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%d%c"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>day</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
        <name>day</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>day</name> <operator>&gt;</operator> <name><name>len_months</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>year</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name>month</name></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid day of month"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>dayoff</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>dayoff</name></expr></argument>, <argument><expr><name>day</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dayoff</name> <operator>&lt;</operator> <name>min_time</name> <operator>/</operator> <name>SECSPERDAY</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"time too small"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dayoff</name> <operator>&gt;</operator> <name>max_time</name> <operator>/</operator> <name>SECSPERDAY</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"time too large"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <name>dayoff</name> <operator>*</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tod</name> <operator>=</operator> <call><name>gethms</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>LP_TIME</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid time of day"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cp</name> <operator>=</operator> <name><name>fields</name><index>[<expr><name>LP_CORR</name></expr>]</index></name></expr>;</expr_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>positive</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>count</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>                        <comment type="block">/* infile() turns "-" into "" */</comment>
            <expr_stmt><expr><name>positive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>positive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>positive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"++"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>positive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"illegal CORRECTION field on Leap line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>lp</name> <operator>=</operator> <call><name>byword</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>LP_ROLL</name></expr>]</index></name></expr></argument>, <argument><expr><name>leap_types</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"illegal Rolling/Stationary field on Leap line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>tadd</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>tod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <name>early_time</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"leap second precedes Big Bang"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>leapadd</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>positive</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>inlink</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>link</name></name></type> <name>l</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>!=</operator> <name>LINK_FIELDS</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"wrong number of fields on Link line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>fields</name><index>[<expr><name>LF_FROM</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"blank FROM field on Link line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>namecheck</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>LF_TO</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>l</name><operator>.</operator><name>l_filename</name></name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>l</name><operator>.</operator><name>l_linenum</name></name> <operator>=</operator> <name>linenum</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>l</name><operator>.</operator><name>l_from</name></name> <operator>=</operator> <call><name>ecpyalloc</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>LF_FROM</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>l</name><operator>.</operator><name>l_to</name></name> <operator>=</operator> <call><name>ecpyalloc</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>LF_TO</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>links</name> <operator>=</operator> <call><name>growalloc</name><argument_list>(<argument><expr><name>links</name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>links</name></expr></argument>, <argument><expr><name>nlinks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlinks_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>links</name><index>[<expr><name>nlinks</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rulesub</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>loyearp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hiyearp</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typep</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>monthp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dayp</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>timep</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>lookup</name></name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>xs</name></decl>;</decl_stmt>

    <comment type="block">/* PG: year_tmp is to avoid sscanf portability issues */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>year_tmp</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>lp</name> <operator>=</operator> <call><name>byword</name><argument_list>(<argument><expr><name>monthp</name></expr></argument>, <argument><expr><name>mon_names</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid month name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_month</name></name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisstd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisgmt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>ecpyalloc</name><argument_list>(<argument><expr><name>timep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>dp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ep</name> <operator>=</operator> <name>dp</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><call><name>lowerit</name><argument_list>(<argument><expr><operator>*</operator><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'s'</literal></expr>:</case>            <comment type="block">/* Standard */</comment>
                <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisstd</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisgmt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>ep</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'w'</literal></expr>:</case>            <comment type="block">/* Wall */</comment>
                <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisstd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisgmt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>ep</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'g'</literal></expr>:</case>            <comment type="block">/* Greenwich */</comment>
            <case>case <expr><literal type="char">'u'</literal></expr>:</case>            <comment type="block">/* Universal */</comment>
            <case>case <expr><literal type="char">'z'</literal></expr>:</case>            <comment type="block">/* Zulu */</comment>
                <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisstd</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisgmt</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>ep</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_tod</name></name> <operator>=</operator> <call><name>gethms</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid time of day"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Year work.
     */</comment>
    <expr_stmt><expr><name>cp</name> <operator>=</operator> <name>loyearp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>byword</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>begin_years</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_lowasnum</name></name> <operator>=</operator> <name>lp</name> <operator>==</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rp</name><operator>-&gt;</operator><name>r_lowasnum</name></name></expr>)</condition><block type="pseudo"><block_content>
        <switch>switch <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>YR_MINIMUM</name></expr>:</case>
                <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_loyear</name></name> <operator>=</operator> <name>ZIC_MIN</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>YR_MAXIMUM</name></expr>:</case>
                <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_loyear</name></name> <operator>=</operator> <name>ZIC_MAX</name></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>            <comment type="block">/* "cannot happen" */</comment>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                        <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: panic: Invalid l_value %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%d%c"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>year_tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_loyear</name></name> <operator>=</operator> <name>year_tmp</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid starting year"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>cp</name> <operator>=</operator> <name>hiyearp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>byword</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>end_years</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_hiwasnum</name></name> <operator>=</operator> <name>lp</name> <operator>==</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rp</name><operator>-&gt;</operator><name>r_hiwasnum</name></name></expr>)</condition><block type="pseudo"><block_content>
        <switch>switch <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>YR_MINIMUM</name></expr>:</case>
                <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>=</operator> <name>ZIC_MIN</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>YR_MAXIMUM</name></expr>:</case>
                <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>=</operator> <name>ZIC_MAX</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>YR_ONLY</name></expr>:</case>
                <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_loyear</name></name></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>            <comment type="block">/* "cannot happen" */</comment>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                        <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: panic: Invalid l_value %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%d%c"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>year_tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>=</operator> <name>year_tmp</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid ending year"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_loyear</name></name> <operator>&gt;</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"starting year greater than ending year"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>typep</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_yrtype</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_loyear</name></name> <operator>==</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"typed single year"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_yrtype</name></name> <operator>=</operator> <call><name>ecpyalloc</name><argument_list>(<argument><expr><name>typep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Day work. Accept things such as:  1    last-Sunday  Sun&lt;=20  Sun&gt;=7
     */</comment>
    <expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>ecpyalloc</name><argument_list>(<argument><expr><name>dayp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>lp</name> <operator>=</operator> <call><name>byword</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>lasts</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>=</operator> <name>DC_DOWLEQ</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_wday</name></name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>=</operator> <name><name>len_months</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name><name>rp</name><operator>-&gt;</operator><name>r_month</name></name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ep</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>=</operator> <name>DC_DOWLEQ</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name>ep</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>=</operator> <name>DC_DOWGEQ</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>ep</name> <operator>=</operator> <name>dp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>=</operator> <name>DC_DOM</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>!=</operator> <name>DC_DOM</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>ep</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ep</name><operator>++</operator> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid day of month"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>lp</name> <operator>=</operator> <call><name>byword</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>wday_names</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid weekday name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_wday</name></name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><literal type="string">"%d%c"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
            <name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
            <operator>(</operator><name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>&gt;</operator> <name><name>len_months</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name><name>rp</name><operator>-&gt;</operator><name>r_month</name></name></expr>]</index></name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid day of month"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>convert</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int32</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>shift</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>b</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>shift</name> <operator>=</operator> <literal type="number">24</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><name>shift</name> <operator>-=</operator> <literal type="number">8</literal></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>val</name> <operator>&gt;&gt;</operator> <name>shift</name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>convert64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>zic_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>shift</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>b</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>shift</name> <operator>=</operator> <literal type="number">56</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><name>shift</name> <operator>-=</operator> <literal type="number">8</literal></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>val</name> <operator>&gt;&gt;</operator> <name>shift</name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>puttzcode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int32</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>convert</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <name>buf</name></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>puttzcode64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>zic_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>buf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>convert64</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <name>buf</name></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>atcomp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>avp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>bvp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>zic_t</name></type> <name>a</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>attype</name> <operator>*</operator><operator>)</operator> <name>avp</name><operator>)</operator><operator>-&gt;</operator><name>at</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>zic_t</name></type> <name>b</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>attype</name> <operator>*</operator><operator>)</operator> <name>bvp</name><operator>)</operator><operator>-&gt;</operator><name>at</name></expr></init></decl>;</decl_stmt>

    <return>return <expr><ternary><condition><expr><operator>(</operator><name>a</name> <operator>&lt;</operator> <name>b</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><name>a</name> <operator>&gt;</operator> <name>b</name><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>zic_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>x</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>zic_t</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>int32</name><operator>)</operator> <name>x</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>writezone</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>string</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type>    <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>leapcnt32</name></decl>,
                <decl><type ref="prev"/><name>leapi32</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type>    <name>timecnt32</name></decl>,
                <decl><type ref="prev"/><name>timei32</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>pass</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>tzhead</name></name></type> <name>tzh0</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>tzhead</name></name></type> <name>tzh</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>dir_checked</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>one</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>y2038_boundary</name> <init>= <expr><name>one</name> <operator>&lt;&lt;</operator> <literal type="number">31</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type>    <name>nats</name> <init>= <expr><name>timecnt</name> <operator>+</operator> <name>WORK_AROUND_QTBUG_53071</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zic_t</name>       <modifier>*</modifier></type><name>ats</name> <init>= <expr><call><name>emalloc</name><argument_list>(<argument><expr><call><name>size_product</name><argument_list>(<argument><expr><name>nats</name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>ats</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>typesptr</name> <init>= <expr><name>ats</name> <operator>+</operator> <name>nats</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><name>typesptr</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Sort.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>timecnt</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>attypes</name></expr></argument>, <argument><expr><name>timecnt</name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>attypes</name></expr></argument>, <argument><expr><name>atcomp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Optimize.
     */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ptrdiff_t</name></type>    <name>fromi</name></decl>,
                    <decl><type ref="prev"/><name>toi</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>toi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>fromi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>fromi</name> <operator>&lt;</operator> <name>timecnt</name> <operator>&amp;&amp;</operator> <name><name>attypes</name><index>[<expr><name>fromi</name></expr>]</index></name><operator>.</operator><name>at</name> <operator>&lt;</operator> <name>early_time</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>++</operator><name>fromi</name></expr>;</expr_stmt></block_content></block></while>
        <for>for <control>(<init>;</init> <condition><expr><name>fromi</name> <operator>&lt;</operator> <name>timecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>fromi</name></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>toi</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>attypes</name><index>[<expr><name>fromi</name></expr>]</index></name><operator>.</operator><name>at</name> <operator>+</operator>
                             <name><name>gmtoffs</name><index>[<expr><name><name>attypes</name><index>[<expr><name>toi</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>type</name></expr>]</index></name><operator>)</operator> <operator>&lt;=</operator>
                            <operator>(</operator><name><name>attypes</name><index>[<expr><name>toi</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>at</name> <operator>+</operator>
                             <name><name>gmtoffs</name><index>[<expr><name><name>attypes</name><index>[<expr><name>toi</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>type</name></expr>]</index></name><operator>)</operator><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>attypes</name><index>[<expr><name>toi</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator>
                    <name><name>attypes</name><index>[<expr><name>fromi</name></expr>]</index></name><operator>.</operator><name>type</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>toi</name> <operator>==</operator> <literal type="number">0</literal>
                <operator>||</operator> <name><name>attypes</name><index>[<expr><name>fromi</name></expr>]</index></name><operator>.</operator><name>dontmerge</name>
                <operator>||</operator> <name><name>attypes</name><index>[<expr><name>toi</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>type</name> <operator>!=</operator> <name><name>attypes</name><index>[<expr><name>fromi</name></expr>]</index></name><operator>.</operator><name>type</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>attypes</name><index>[<expr><name>toi</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>attypes</name><index>[<expr><name>fromi</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>timecnt</name> <operator>=</operator> <name>toi</name></expr>;</expr_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><name>noise</name> <operator>&amp;&amp;</operator> <name>timecnt</name> <operator>&gt;</operator> <literal type="number">1200</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>timecnt</name> <operator>&gt;</operator> <name>TZ_MAX_TIMES</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"reference clients mishandle"</literal>
                      <literal type="string">" more than %d transition times"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>TZ_MAX_TIMES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"pre-2014 clients may mishandle"</literal>
                      <literal type="string">" more than 1200 transition times"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Transfer.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>timecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>ats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>attypes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>at</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>attypes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Work around QTBUG-53071 for time stamps less than y2038_boundary - 1,
     * by inserting a no-op transition at time y2038_boundary - 1. This works
     * only for timestamps before the boundary, which should be good enough in
     * practice as QTBUG-53071 should be long-dead by 2038.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>WORK_AROUND_QTBUG_53071</name> <operator>&amp;&amp;</operator> <name>timecnt</name> <operator>!=</operator> <literal type="number">0</literal>
        <operator>&amp;&amp;</operator> <name><name>ats</name><index>[<expr><name>timecnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name>y2038_boundary</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>ats</name><index>[<expr><name>timecnt</name></expr>]</index></name> <operator>=</operator> <name>y2038_boundary</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>types</name><index>[<expr><name>timecnt</name></expr>]</index></name> <operator>=</operator> <name><name>types</name><index>[<expr><name>timecnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>timecnt</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Correct for leap seconds.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>timecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <name>leapcnt</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>--</operator><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>ats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>trans</name><index>[<expr><name>j</name></expr>]</index></name> <operator>-</operator> <name><name>corr</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>ats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>tadd</name><argument_list>(<argument><expr><name><name>ats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>corr</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt></block_content></block></while>
    </block_content>}</block></for>

    <comment type="block">/*
     * Figure out 32-bit-limited starts and counts.
     */</comment>
    <expr_stmt><expr><name>timecnt32</name> <operator>=</operator> <name>timecnt</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>timei32</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>leapcnt32</name> <operator>=</operator> <name>leapcnt</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>leapi32</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>timecnt32</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is32</name><argument_list>(<argument><expr><name><name>ats</name><index>[<expr><name>timecnt32</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>--</operator><name>timecnt32</name></expr>;</expr_stmt></block_content></block></while>
    <while>while <condition>(<expr><name>timecnt32</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is32</name><argument_list>(<argument><expr><name><name>ats</name><index>[<expr><name>timei32</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>--</operator><name>timecnt32</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name>timei32</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Output an INT32_MIN "transition" if appropriate; see below.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>timei32</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>ats</name><index>[<expr><name>timei32</name></expr>]</index></name> <operator>&gt;</operator> <name>PG_INT32_MIN</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>--</operator><name>timei32</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name>timecnt32</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <while>while <condition>(<expr><name>leapcnt32</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is32</name><argument_list>(<argument><expr><name><name>trans</name><index>[<expr><name>leapcnt32</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>--</operator><name>leapcnt32</name></expr>;</expr_stmt></block_content></block></while>
    <while>while <condition>(<expr><name>leapcnt32</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is32</name><argument_list>(<argument><expr><name><name>trans</name><index>[<expr><name>leapi32</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>--</operator><name>leapcnt32</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name>leapi32</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Remove old file, if any, to snap links.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>remove</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>dir_checked</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Cannot remove %s/%s: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>fopen_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>fopen_errno</name> <operator>==</operator> <name>ENOENT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>dir_checked</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>mkdirs</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>fopen_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Cannot create %s/%s: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>fopen_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>pass</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>pass</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>pass</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ptrdiff_t</name></type>    <name>thistimei</name></decl>,
                    <decl><type ref="prev"/><name>thistimecnt</name></decl>,
                    <decl><type ref="prev"/><name>thistimelim</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>thisleapi</name></decl>,
                    <decl><type ref="prev"/><name>thisleapcnt</name></decl>,
                    <decl><type ref="prev"/><name>thisleaplim</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name><name>writetype</name><index>[<expr><name>TZ_MAX_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name><name>typemap</name><index>[<expr><name>TZ_MAX_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>thistypecnt</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>thischars</name><index>[<expr><name>TZ_MAX_CHARS</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>thischarcnt</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>toomanytimes</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name><name>indmap</name><index>[<expr><name>TZ_MAX_CHARS</name></expr>]</index></name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>pass</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>thistimei</name> <operator>=</operator> <name>timei32</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>thistimecnt</name> <operator>=</operator> <name>timecnt32</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>toomanytimes</name> <operator>=</operator> <name>thistimecnt</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal> <operator>&gt;&gt;</operator> <literal type="number">1</literal> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>thisleapi</name> <operator>=</operator> <name>leapi32</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>thisleapcnt</name> <operator>=</operator> <name>leapcnt32</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>thistimei</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>thistimecnt</name> <operator>=</operator> <name>timecnt</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>toomanytimes</name> <operator>=</operator> <name>thistimecnt</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal> <operator>&gt;&gt;</operator> <literal type="number">31</literal> <operator>&gt;&gt;</operator> <literal type="number">2</literal> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>thisleapi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>thisleapcnt</name> <operator>=</operator> <name>leapcnt</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>toomanytimes</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many transition times"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>thistimelim</name> <operator>=</operator> <name>thistimei</name> <operator>+</operator> <name>thistimecnt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>thisleaplim</name> <operator>=</operator> <name>thisleapi</name> <operator>+</operator> <name>thisleapcnt</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>typecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>writetype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>thistimecnt</name> <operator>==</operator> <name>timecnt</name></expr>;</expr_stmt></block_content></block></for>
        <if_stmt><if>if <condition>(<expr><name>thistimecnt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * No transition times fall in the current (32- or 64-bit) window.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>typecnt</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>writetype</name><index>[<expr><name>typecnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>thistimei</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>thistimelim</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>writetype</name><index>[<expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

            <comment type="block">/*
             * For America/Godthab and Antarctica/Palmer
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>thistimei</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>writetype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LEAVE_SOME_PRE_2011_SYSTEMS_IN_THE_LURCH</name></cpp:ifndef>

        <comment type="block">/*
         * For some pre-2011 systems: if the last-to-be-written standard (or
         * daylight) type has an offset different from the most recently used
         * offset, append an (unused) copy of the most recently used type (to
         * help get global "altzone" and "timezone" variables set correctly).
         */</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>mrudst</name></decl>,
                        <decl><type ref="prev"/><name>mrustd</name></decl>,
                        <decl><type ref="prev"/><name>hidst</name></decl>,
                        <decl><type ref="prev"/><name>histd</name></decl>,
                        <decl><type ref="prev"/><name>type</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>hidst</name> <operator>=</operator> <name>histd</name> <operator>=</operator> <name>mrudst</name> <operator>=</operator> <name>mrustd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>thistimei</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>thistimelim</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><name><name>isdsts</name><index>[<expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>mrudst</name> <operator>=</operator> <name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>mrustd</name> <operator>=</operator> <name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt></block_content></block></for>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>typecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><name><name>writetype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>isdsts</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>hidst</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>histd</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if></if_stmt></block_content></block></for>
            <if_stmt><if>if <condition>(<expr><name>hidst</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>mrudst</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>hidst</name> <operator>!=</operator> <name>mrudst</name> <operator>&amp;&amp;</operator>
                <name><name>gmtoffs</name><index>[<expr><name>hidst</name></expr>]</index></name> <operator>!=</operator> <name><name>gmtoffs</name><index>[<expr><name>mrudst</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>isdsts</name><index>[<expr><name>mrudst</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>addtype</name><argument_list>(<argument><expr><name><name>gmtoffs</name><index>[<expr><name>mrudst</name></expr>]</index></name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name><name>chars</name><index>[<expr><name><name>abbrinds</name><index>[<expr><name>mrudst</name></expr>]</index></name></expr>]</index></name></expr></argument>,
                               <argument><expr><name>true</name></expr></argument>,
                               <argument><expr><name><name>ttisstds</name><index>[<expr><name>mrudst</name></expr>]</index></name></expr></argument>,
                               <argument><expr><name><name>ttisgmts</name><index>[<expr><name>mrudst</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>isdsts</name><index>[<expr><name>mrudst</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>writetype</name><index>[<expr><name>type</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>histd</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>mrustd</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>histd</name> <operator>!=</operator> <name>mrustd</name> <operator>&amp;&amp;</operator>
                <name><name>gmtoffs</name><index>[<expr><name>histd</name></expr>]</index></name> <operator>!=</operator> <name><name>gmtoffs</name><index>[<expr><name>mrustd</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>isdsts</name><index>[<expr><name>mrustd</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>addtype</name><argument_list>(<argument><expr><name><name>gmtoffs</name><index>[<expr><name>mrustd</name></expr>]</index></name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name><name>chars</name><index>[<expr><name><name>abbrinds</name><index>[<expr><name>mrustd</name></expr>]</index></name></expr>]</index></name></expr></argument>,
                               <argument><expr><name>false</name></expr></argument>,
                               <argument><expr><name><name>ttisstds</name><index>[<expr><name>mrustd</name></expr>]</index></name></expr></argument>,
                               <argument><expr><name><name>ttisgmts</name><index>[<expr><name>mrustd</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>isdsts</name><index>[<expr><name>mrustd</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>writetype</name><index>[<expr><name>type</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* !defined
                                 * LEAVE_SOME_PRE_2011_SYSTEMS_IN_THE_LURCH */</comment>
        <expr_stmt><expr><name>thistypecnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>typecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>typemap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name><name>writetype</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name>thistypecnt</name><operator>++</operator></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></for>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof <name>indmap</name></sizeof> <operator>/</operator> <sizeof>sizeof <name><name>indmap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></sizeof></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>indmap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><name>thischarcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>typecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>thisabbr</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>writetype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>indmap</name><index>[<expr><name><name>abbrinds</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>thisabbr</name> <operator>=</operator> <operator>&amp;</operator><name><name>chars</name><index>[<expr><name><name>abbrinds</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>thischarcnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thischars</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>thisabbr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
            <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>thischarcnt</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thischars</name><index>[<expr><name>thischarcnt</name></expr>]</index></name></expr></argument>, <argument><expr><name>thisabbr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>thischarcnt</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>thisabbr</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>indmap</name><index>[<expr><name><name>abbrinds</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
        </block_content>}</block></for>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO</name><parameter_list>(<parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>fwrite(tzh.field, sizeof tzh.field, 1, fp)</cpp:value></cpp:define>
        <expr_stmt><expr><name>tzh</name> <operator>=</operator> <name>tzh0</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>tzh</name><operator>.</operator><name>tzh_magic</name></name></expr></argument>, <argument><expr><name>TZ_MAGIC</name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>tzh</name><operator>.</operator><name>tzh_magic</name></name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tzh</name><operator>.</operator><name>tzh_version</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>version</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>convert</name><argument_list>(<argument><expr><name>thistypecnt</name></expr></argument>, <argument><expr><name><name>tzh</name><operator>.</operator><name>tzh_ttisgmtcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>convert</name><argument_list>(<argument><expr><name>thistypecnt</name></expr></argument>, <argument><expr><name><name>tzh</name><operator>.</operator><name>tzh_ttisstdcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>convert</name><argument_list>(<argument><expr><name>thisleapcnt</name></expr></argument>, <argument><expr><name><name>tzh</name><operator>.</operator><name>tzh_leapcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>convert</name><argument_list>(<argument><expr><name>thistimecnt</name></expr></argument>, <argument><expr><name><name>tzh</name><operator>.</operator><name>tzh_timecnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>convert</name><argument_list>(<argument><expr><name>thistypecnt</name></expr></argument>, <argument><expr><name><name>tzh</name><operator>.</operator><name>tzh_typecnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>convert</name><argument_list>(<argument><expr><name>thischarcnt</name></expr></argument>, <argument><expr><name><name>tzh</name><operator>.</operator><name>tzh_charcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DO</name><argument_list>(<argument><expr><name>tzh_magic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DO</name><argument_list>(<argument><expr><name>tzh_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DO</name><argument_list>(<argument><expr><name>tzh_reserved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DO</name><argument_list>(<argument><expr><name>tzh_ttisgmtcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DO</name><argument_list>(<argument><expr><name>tzh_ttisstdcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DO</name><argument_list>(<argument><expr><name>tzh_leapcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DO</name><argument_list>(<argument><expr><name>tzh_timecnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DO</name><argument_list>(<argument><expr><name>tzh_typecnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DO</name><argument_list>(<argument><expr><name>tzh_charcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DO</name></cpp:undef>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>thistimei</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>thistimelim</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name>pass</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

                <comment type="block">/*
                 * Output an INT32_MIN "transition" if appropriate; see above.
                 */</comment>
                <expr_stmt><expr><call><name>puttzcode</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>ats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name>PG_INT32_MIN</name><operator>)</operator></expr> ?</condition><then>
                           <expr><name>PG_INT32_MIN</name></expr> </then><else>: <expr><name><name>ats</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>puttzcode64</name><argument_list>(<argument><expr><name><name>ats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Print current timezone abbreviations if requested */</comment>
                <if_stmt><if>if <condition>(<expr><name>print_abbrevs</name> <operator>&amp;&amp;</operator>
                    <operator>(</operator><name>i</name> <operator>==</operator> <name>thistimelim</name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>ats</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <name>print_cutoff</name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>tm</name> <init>= <expr><name><name>typemap</name><index>[<expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>thisabbrev</name> <init>= <expr><operator>&amp;</operator><name><name>thischars</name><index>[<expr><name><name>indmap</name><index>[<expr><name><name>abbrinds</name><index>[<expr><name>tm</name></expr>]</index></name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                    <comment type="block">/* filter out assorted junk entries */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>thisabbrev</name></expr></argument>, <argument><expr><name>GRANDPARENTED</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                        <call><name>strcmp</name><argument_list>(<argument><expr><name>thisabbrev</name></expr></argument>, <argument><expr><literal type="string">"zzz"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%s\t"</literal> <name>INT64_FORMAT</name> <literal type="string">"%s\n"</literal></expr></argument>,
                                <argument><expr><name>thisabbrev</name></expr></argument>,
                                <argument><expr><name><name>gmtoffs</name><index>[<expr><name>tm</name></expr>]</index></name></expr></argument>,
                                <argument><expr><ternary><condition><expr><name><name>isdsts</name><index>[<expr><name>tm</name></expr>]</index></name></expr> ?</condition><then> <expr><literal type="string">"\tD"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt></block_content></block></for>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>thistimei</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>thistimelim</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>uc</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>uc</name> <operator>=</operator> <name><name>typemap</name><index>[<expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uc</name></expr></argument>, <argument><expr><sizeof>sizeof <name>uc</name></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>typecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>writetype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>puttzcode</name><argument_list>(<argument><expr><name><name>gmtoffs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>isdsts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>indmap</name><index>[<expr><name><name>abbrinds</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt></block_content></block></for>
        <if_stmt><if>if <condition>(<expr><name>thischarcnt</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>thischars</name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>thischars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></sizeof></expr></argument>,
                   <argument><expr><name>thischarcnt</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>thisleapi</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>thisleaplim</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>zic_t</name></type>        <name>todo</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>roll</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>timecnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <while>while <condition>(<expr><name><name>isdsts</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                        <if_stmt><if>if <condition>(<expr><operator>++</operator><name>j</name> <operator>&gt;=</operator> <name>typecnt</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt></block_content></block></while>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <while>while <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>timecnt</name> <operator>&amp;&amp;</operator>
                           <name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name><name>ats</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt></block_content></block></while>
                    <expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>types</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>todo</name> <operator>=</operator> <call><name>tadd</name><argument_list>(<argument><expr><name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><name><name>gmtoffs</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>todo</name> <operator>=</operator> <name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>pass</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>puttzcode</name><argument_list>(<argument><expr><name>todo</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>puttzcode64</name><argument_list>(<argument><expr><name>todo</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>puttzcode</name><argument_list>(<argument><expr><name><name>corr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>typecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>writetype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>ttisstds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>typecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>writetype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>ttisgmts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n%s\n"</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>close_file</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type>
<name>abbroffset</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name>sign</name> <init>= <expr><literal type="char">'+'</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>seconds</name></decl>,
                <decl><type ref="prev"/><name>minutes</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>-</operator><name>offset</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>seconds</name> <operator>=</operator> <name>offset</name> <operator>%</operator> <name>SECSPERMIN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>/=</operator> <name>SECSPERMIN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>minutes</name> <operator>=</operator> <name>offset</name> <operator>%</operator> <name>MINSPERHOUR</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>/=</operator> <name>MINSPERHOUR</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">100</literal> <operator>&lt;=</operator> <name>offset</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%%z UTC offset magnitude exceeds 99:59:59"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="string">"%z"</literal></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>p</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>sign</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal> <operator>+</operator> <name>offset</name> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal> <operator>+</operator> <name>offset</name> <operator>%</operator> <literal type="number">10</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>minutes</name> <operator>|</operator> <name>seconds</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal> <operator>+</operator> <name>minutes</name> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal> <operator>+</operator> <name>minutes</name> <operator>%</operator> <literal type="number">10</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>seconds</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal> <operator>+</operator> <name>seconds</name> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal> <operator>+</operator> <name>seconds</name> <operator>%</operator> <literal type="number">10</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <return>return <expr><name>buf</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>doabbr</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>abbr</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>zone</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>zp</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>letters</name></decl></parameter>,
       <parameter><decl><type><name>zic_t</name></type> <name>stdoff</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>doquotes</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>slashp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>format</name> <init>= <expr><name><name>zp</name><operator>-&gt;</operator><name>z_format</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>slashp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>slashp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>letterbuf</name><index>[<expr><name>PERCENT_Z_LEN_BOUND</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>zp</name><operator>-&gt;</operator><name>z_format_specifier</name></name> <operator>==</operator> <literal type="char">'z'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>letters</name> <operator>=</operator> <call><name>abbroffset</name><argument_list>(<argument><expr><name>letterbuf</name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_gmtoff</name></name> <operator>+</operator> <name>stdoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><name>letters</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>letters</name> <operator>=</operator> <literal type="string">"%s"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>abbr</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>letters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>stdoff</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>abbr</name></expr></argument>, <argument><expr><name>slashp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>abbr</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>slashp</name> <operator>-</operator> <name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>abbr</name><index>[<expr><name>slashp</name> <operator>-</operator> <name>format</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>abbr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>doquotes</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>
    <for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>abbr</name></expr>;</init> <condition><expr><call><name>is_alpha</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <continue>continue;</continue></block_content></block></for>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>abbr</name><index>[<expr><name>len</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>abbr</name><index>[<expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'&gt;'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>abbr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>abbr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>abbr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'&lt;'</literal></expr>;</expr_stmt>
    <return>return <expr><name>len</name> <operator>+</operator> <literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>updateminmax</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>zic_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>min_year</name> <operator>&gt;</operator> <name>x</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>min_year</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>max_year</name> <operator>&lt;</operator> <name>x</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>max_year</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>stringoffset</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>hours</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>minutes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>seconds</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>negative</name> <init>= <expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name> <init>= <expr><name>negative</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>negative</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>-</operator><name>offset</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>seconds</name> <operator>=</operator> <name>offset</name> <operator>%</operator> <name>SECSPERMIN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>/=</operator> <name>SECSPERMIN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>minutes</name> <operator>=</operator> <name>offset</name> <operator>%</operator> <name>MINSPERHOUR</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>/=</operator> <name>MINSPERHOUR</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>hours</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>hours</name> <operator>&gt;=</operator> <name>HOURSPERDAY</name> <operator>*</operator> <name>DAYSPERWEEK</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>hours</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>minutes</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>seconds</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><literal type="string">":%02d"</literal></expr></argument>, <argument><expr><name>minutes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>seconds</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><literal type="string">":%02d"</literal></expr></argument>, <argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>stringrule</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rule</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>rp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>zic_t</name></type> <name>dstoff</name></decl></parameter>,
           <parameter><decl><type><specifier>const</specifier> <name>zic_t</name></type> <name>gmtoff</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>tod</name> <init>= <expr><name><name>rp</name><operator>-&gt;</operator><name>r_tod</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>compat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>==</operator> <name>DC_DOM</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>month</name></decl>,
                    <decl><type ref="prev"/><name>total</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>==</operator> <literal type="number">29</literal> <operator>&amp;&amp;</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_month</name></name> <operator>==</operator> <name>TM_FEBRUARY</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>total</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>month</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>month</name> <operator>&lt;</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_month</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>month</name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name>total</name> <operator>+=</operator> <name><name>len_months</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>month</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
        <comment type="block">/* Omit the "J" in Jan and Feb, as that's shorter.  */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_month</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>total</name> <operator>+</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"J%d"</literal></expr></argument>, <argument><expr><name>total</name> <operator>+</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>week</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>wday</name> <init>= <expr><name><name>rp</name><operator>-&gt;</operator><name>r_wday</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>wdayoff</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>==</operator> <name>DC_DOWGEQ</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>wdayoff</name> <operator>=</operator> <operator>(</operator><name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>wdayoff</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>compat</name> <operator>=</operator> <literal type="number">2013</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>wday</name> <operator>-=</operator> <name>wdayoff</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>tod</name> <operator>+=</operator> <name>wdayoff</name> <operator>*</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>week</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>==</operator> <name>DC_DOWLEQ</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>==</operator> <name><name>len_months</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name><name>rp</name><operator>-&gt;</operator><name>r_month</name></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>week</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>wdayoff</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>%</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>wdayoff</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>compat</name> <operator>=</operator> <literal type="number">2013</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>wday</name> <operator>-=</operator> <name>wdayoff</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>tod</name> <operator>+=</operator> <name>wdayoff</name> <operator>*</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>week</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>/</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>            <comment type="block">/* "cannot happen" */</comment>
        <if_stmt><if>if <condition>(<expr><name>wday</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>wday</name> <operator>+=</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"M%d.%d.%d"</literal></expr></argument>,
                          <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_month</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>week</name></expr></argument>, <argument><expr><name>wday</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisgmt</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>tod</name> <operator>+=</operator> <name>gmtoff</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisstd</name></name> <operator>&amp;&amp;</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_stdoff</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>tod</name> <operator>+=</operator> <name>dstoff</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>tod</name> <operator>!=</operator> <literal type="number">2</literal> <operator>*</operator> <name>SECSPERMIN</name> <operator>*</operator> <name>MINSPERHOUR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>result</name><operator>++</operator> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>stringoffset</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>tod</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>tod</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>compat</name> <operator>&lt;</operator> <literal type="number">2013</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>compat</name> <operator>=</operator> <literal type="number">2013</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>SECSPERDAY</name> <operator>&lt;=</operator> <name>tod</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>compat</name> <operator>&lt;</operator> <literal type="number">1994</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>compat</name> <operator>=</operator> <literal type="number">1994</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>compat</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rule_cmp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rule</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rule</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>a</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><operator>!</operator><operator>!</operator><name>b</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>b</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>r_hiyear</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><ternary><condition><expr><name><name>a</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>r_hiyear</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>r_month</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>r_month</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>a</name><operator>-&gt;</operator><name>r_month</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>r_month</name></name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name><name>a</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>r_dayofmonth</name></name></expr>;</return>
</block_content>}</block></function>

<enum>enum
<block>{
<decl><name>YEAR_BY_YEAR_ZONE</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>}</block>;</enum>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>stringzone</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>zone</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>zpfirst</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>zonecount</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>zone</name></name> <modifier>*</modifier></type><name>zp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>stdrp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>dstrp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type>    <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abbrvar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>compat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>offsetlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name></type> <name>stdr</name></decl>,
                <decl><type ref="prev"/><name>dstr</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zp</name> <operator>=</operator> <name>zpfirst</name> <operator>+</operator> <name>zonecount</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>stdrp</name> <operator>=</operator> <name>dstrp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>rp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z_rules</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_hiwasnum</name></name> <operator>||</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>!=</operator> <name>ZIC_MAX</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_yrtype</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_stdoff</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>stdrp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>stdrp</name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>dstrp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>dstrp</name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>stdrp</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>dstrp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * There are no rules running through "max". Find the latest std rule
         * in stdabbrrp and latest rule of any type in stdrp.
         */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>stdabbrrp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>rp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z_rules</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_stdoff</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>rule_cmp</name><argument_list>(<argument><expr><name>stdabbrrp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>stdabbrrp</name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>rule_cmp</name><argument_list>(<argument><expr><name>stdrp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>stdrp</name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * Horrid special case: if year is 2037, presume this is a zone
         * handled on a year-by-year basis; do not try to apply a rule to the
         * zone.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>stdrp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>stdrp</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>==</operator> <literal type="number">2037</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>YEAR_BY_YEAR_ZONE</name></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>stdrp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>stdrp</name><operator>-&gt;</operator><name>r_stdoff</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Perpetual DST.  */</comment>
            <expr_stmt><expr><name><name>dstr</name><operator>.</operator><name>r_month</name></name> <operator>=</operator> <name>TM_JANUARY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dstr</name><operator>.</operator><name>r_dycode</name></name> <operator>=</operator> <name>DC_DOM</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dstr</name><operator>.</operator><name>r_dayofmonth</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dstr</name><operator>.</operator><name>r_tod</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dstr</name><operator>.</operator><name>r_todisstd</name></name> <operator>=</operator> <name><name>dstr</name><operator>.</operator><name>r_todisgmt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dstr</name><operator>.</operator><name>r_stdoff</name></name> <operator>=</operator> <name><name>stdrp</name><operator>-&gt;</operator><name>r_stdoff</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dstr</name><operator>.</operator><name>r_abbrvar</name></name> <operator>=</operator> <name><name>stdrp</name><operator>-&gt;</operator><name>r_abbrvar</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stdr</name><operator>.</operator><name>r_month</name></name> <operator>=</operator> <name>TM_DECEMBER</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stdr</name><operator>.</operator><name>r_dycode</name></name> <operator>=</operator> <name>DC_DOM</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stdr</name><operator>.</operator><name>r_dayofmonth</name></name> <operator>=</operator> <literal type="number">31</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stdr</name><operator>.</operator><name>r_tod</name></name> <operator>=</operator> <name>SECSPERDAY</name> <operator>+</operator> <name><name>stdrp</name><operator>-&gt;</operator><name>r_stdoff</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stdr</name><operator>.</operator><name>r_todisstd</name></name> <operator>=</operator> <name><name>stdr</name><operator>.</operator><name>r_todisgmt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stdr</name><operator>.</operator><name>r_stdoff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stdr</name><operator>.</operator><name>r_abbrvar</name></name>
                <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>stdabbrrp</name></expr> ?</condition><then> <expr><name><name>stdabbrrp</name><operator>-&gt;</operator><name>r_abbrvar</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>dstrp</name> <operator>=</operator> <operator>&amp;</operator><name>dstr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>stdrp</name> <operator>=</operator> <operator>&amp;</operator><name>stdr</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>stdrp</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_stdoff</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>abbrvar</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>stdrp</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><name><name>stdrp</name><operator>-&gt;</operator><name>r_abbrvar</name></name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>doabbr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>zp</name></expr></argument>, <argument><expr><name>abbrvar</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>offsetlen</name> <operator>=</operator> <call><name>stringoffset</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><operator>-</operator><name><name>zp</name><operator>-&gt;</operator><name>z_gmtoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>offsetlen</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>len</name> <operator>+=</operator> <name>offsetlen</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dstrp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>compat</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>doabbr</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>zp</name></expr></argument>, <argument><expr><name><name>dstrp</name><operator>-&gt;</operator><name>r_abbrvar</name></name></expr></argument>, <argument><expr><name><name>dstrp</name><operator>-&gt;</operator><name>r_stdoff</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dstrp</name><operator>-&gt;</operator><name>r_stdoff</name></name> <operator>!=</operator> <name>SECSPERMIN</name> <operator>*</operator> <name>MINSPERHOUR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>offsetlen</name> <operator>=</operator> <call><name>stringoffset</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>,
                                 <argument><expr><operator>-</operator><operator>(</operator><name><name>zp</name><operator>-&gt;</operator><name>z_gmtoff</name></name> <operator>+</operator> <name><name>dstrp</name><operator>-&gt;</operator><name>r_stdoff</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>offsetlen</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <name>offsetlen</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>result</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">','</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>stringrule</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>dstrp</name></expr></argument>, <argument><expr><name><name>dstrp</name><operator>-&gt;</operator><name>r_stdoff</name></name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_gmtoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>compat</name> <operator>&lt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>compat</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">','</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>stringrule</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>stdrp</name></expr></argument>, <argument><expr><name><name>dstrp</name><operator>-&gt;</operator><name>r_stdoff</name></name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_gmtoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>compat</name> <operator>&lt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>compat</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>compat</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>outzone</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>zone</name></name> <modifier>*</modifier></type><name>zpfirst</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>zonecount</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>zone</name></name> <modifier>*</modifier></type><name>zp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type>    <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>usestart</name></decl>,
                <decl><type ref="prev"/><name>useuntil</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>starttime</name></decl>,
                <decl><type ref="prev"/><name>untiltime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>gmtoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>stdoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>year</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>startoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>startttisstd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>startttisgmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>startbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ab</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>envvar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>max_abbr_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>max_envvar_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>prodstic</name></decl>;</decl_stmt>        <comment type="block">/* all rules are min to max */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>compat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>do_extend</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>version</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type>    <name>lastatmax</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>one</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>y2038_boundary</name> <init>= <expr><name>one</name> <operator>&lt;&lt;</operator> <literal type="number">31</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>max_year0</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>max_abbr_len</name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <name>max_format_len</name> <operator>+</operator> <name>max_abbrvar_len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>max_envvar_len</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>max_abbr_len</name> <operator>+</operator> <literal type="number">5</literal> <operator>*</operator> <literal type="number">9</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>startbuf</name> <operator>=</operator> <call><name>emalloc</name><argument_list>(<argument><expr><name>max_abbr_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ab</name> <operator>=</operator> <call><name>emalloc</name><argument_list>(<argument><expr><name>max_abbr_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>envvar</name> <operator>=</operator> <call><name>emalloc</name><argument_list>(<argument><expr><name>max_envvar_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INITIALIZE</name><argument_list>(<argument><expr><name>untiltime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INITIALIZE</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now. . .finally. . .generate some useful data!
     */</comment>
    <expr_stmt><expr><name>timecnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>typecnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>charcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>prodstic</name> <operator>=</operator> <name>zonecount</name> <operator>==</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Thanks to Earl Chew for noting the need to unconditionally initialize
     * startttisstd.
     */</comment>
    <expr_stmt><expr><name>startttisstd</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>startttisgmt</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>min_year</name> <operator>=</operator> <name>max_year</name> <operator>=</operator> <name>EPOCH_YEAR</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>leapseen</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>updateminmax</name><argument_list>(<argument><expr><name>leapminyear</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>updateminmax</name><argument_list>(<argument><expr><name>leapmaxyear</name> <operator>+</operator> <operator>(</operator><name>leapmaxyear</name> <operator>&lt;</operator> <name>ZIC_MAX</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zonecount</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>zp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zpfirst</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>zonecount</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>updateminmax</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_untilrule</name><operator>.</operator><name>r_loyear</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>rp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z_rules</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_lowasnum</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>updateminmax</name><argument_list>(<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_loyear</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_hiwasnum</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>updateminmax</name><argument_list>(<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_lowasnum</name></name> <operator>||</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_hiwasnum</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>prodstic</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <comment type="block">/*
     * Generate lots of data if a rule can't cover all future times.
     */</comment>
    <expr_stmt><expr><name>compat</name> <operator>=</operator> <call><name>stringzone</name><argument_list>(<argument><expr><name>envvar</name></expr></argument>, <argument><expr><name>zpfirst</name></expr></argument>, <argument><expr><name>zonecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>version</name> <operator>=</operator> <ternary><condition><expr><name>compat</name> <operator>&lt;</operator> <literal type="number">2013</literal></expr> ?</condition><then> <expr><name>ZIC_VERSION_PRE_2013</name></expr> </then><else>: <expr><name>ZIC_VERSION</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>do_extend</name> <operator>=</operator> <name>compat</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>compat</name> <operator>==</operator> <name>YEAR_BY_YEAR_ZONE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>noise</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>envvar</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no POSIX environment variable for zone"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name><name>zpfirst</name><operator>-&gt;</operator><name>z_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>compat</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>compat</name> <operator>!=</operator> <name>YEAR_BY_YEAR_ZONE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Circa-COMPAT clients, and earlier clients, might not work for
             * this zone when given dates before 1970 or after 2038.
             */</comment>
            <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: pre-%d clients may mishandle"</literal>
                      <literal type="string">" distant timestamps"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name><name>zpfirst</name><operator>-&gt;</operator><name>z_name</name></name></expr></argument>, <argument><expr><name>compat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>do_extend</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Search through a couple of extra years past the obvious 400, to
         * avoid edge cases.  For example, suppose a non-POSIX rule applies
         * from 2012 onwards and has transitions in March and September, plus
         * some one-off transitions in November 2013.  If zic looked only at
         * the last 400 years, it would set max_year=2413, with the intent
         * that the 400 years 2014 through 2413 will be repeated.  The last
         * transition listed in the tzfile would be in 2413-09, less than 400
         * years after the last one-off transition in 2013-11.  Two years
         * might be overkill, but with the kind of edge cases available we're
         * not sure that one year would suffice.
         */</comment>
        <enum>enum
        <block>{
        <decl><name>years_of_observations</name> <init>= <expr><name>YEARSPERREPEAT</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>}</block>;</enum>

        <if_stmt><if>if <condition>(<expr><name>min_year</name> <operator>&gt;=</operator> <name>ZIC_MIN</name> <operator>+</operator> <name>years_of_observations</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>min_year</name> <operator>-=</operator> <name>years_of_observations</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>min_year</name> <operator>=</operator> <name>ZIC_MIN</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>max_year</name> <operator>&lt;=</operator> <name>ZIC_MAX</name> <operator>-</operator> <name>years_of_observations</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>max_year</name> <operator>+=</operator> <name>years_of_observations</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>max_year</name> <operator>=</operator> <name>ZIC_MAX</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * Regardless of any of the above, for a "proDSTic" zone which
         * specifies that its rules always have and always will be in effect,
         * we only need one cycle to define the zone.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>prodstic</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>min_year</name> <operator>=</operator> <literal type="number">1900</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>max_year</name> <operator>=</operator> <name>min_year</name> <operator>+</operator> <name>years_of_observations</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * For the benefit of older systems, generate data from 1900 through 2038.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>min_year</name> <operator>&gt;</operator> <literal type="number">1900</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>min_year</name> <operator>=</operator> <literal type="number">1900</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>max_year0</name> <operator>=</operator> <name>max_year</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>max_year</name> <operator>&lt;</operator> <literal type="number">2038</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>max_year</name> <operator>=</operator> <literal type="number">2038</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zonecount</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * A guess that may well be corrected later.
         */</comment>
        <expr_stmt><expr><name>stdoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>zp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zpfirst</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>usestart</name> <operator>=</operator> <name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>zp</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>z_untiltime</name> <operator>&gt;</operator> <name>early_time</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>useuntil</name> <operator>=</operator> <name>i</name> <operator>&lt;</operator> <operator>(</operator><name>zonecount</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>useuntil</name> <operator>&amp;&amp;</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_untiltime</name></name> <operator>&lt;=</operator> <name>early_time</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>gmtoff</name> <operator>=</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_gmtoff</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>eat</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_filename</name></name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_linenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>startbuf</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>startoff</name> <operator>=</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_gmtoff</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>stdoff</name> <operator>=</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_stdoff</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>doabbr</name><argument_list>(<argument><expr><name>startbuf</name></expr></argument>, <argument><expr><name>zp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>stdoff</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>addtype</name><argument_list>(<argument><expr><call><name>oadd</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_gmtoff</name></name></expr></argument>, <argument><expr><name>stdoff</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>startbuf</name></expr></argument>, <argument><expr><name>stdoff</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>startttisstd</name></expr></argument>,
                           <argument><expr><name>startttisgmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>usestart</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>addtt</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>usestart</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>addtt</name><argument_list>(<argument><expr><name>early_time</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <for>for <control>(<init><expr><name>year</name> <operator>=</operator> <name>min_year</name></expr>;</init> <condition><expr><name>year</name> <operator>&lt;=</operator> <name>max_year</name></expr>;</condition> <incr><expr><operator>++</operator><name>year</name></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>useuntil</name> <operator>&amp;&amp;</operator> <name>year</name> <operator>&gt;</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_untilrule</name><operator>.</operator><name>r_hiyear</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * Mark which rules to do in the current year. For those to
                 * do, calculate rpytime(rp, year);
                 */</comment>
                <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><name>rp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z_rules</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>eats</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_filename</name></name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_linenum</name></name></expr></argument>,
                         <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_filename</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_linenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todo</name></name> <operator>=</operator> <name>year</name> <operator>&gt;=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_loyear</name></name> <operator>&amp;&amp;</operator>
                        <name>year</name> <operator>&lt;=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>&amp;&amp;</operator>
                        <call><name>yearistype</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_yrtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_todo</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_temp</name></name> <operator>=</operator> <call><name>rpytime</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>year</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todo</name></name>
                            <operator>=</operator> <operator>(</operator><name><name>rp</name><operator>-&gt;</operator><name>r_temp</name></name> <operator>&lt;</operator> <name>y2038_boundary</name>
                               <operator>||</operator> <name>year</name> <operator>&lt;=</operator> <name>max_year0</name><operator>)</operator></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
                <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ptrdiff_t</name></type>    <name>k</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>zic_t</name></type>        <name>jtime</name></decl>,
                                <decl><type ref="prev"/><name>ktime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>zic_t</name></type>        <name>offset</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>useuntil</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * Turn untiltime into UT assuming the current gmtoff
                         * and stdoff values.
                         */</comment>
                        <expr_stmt><expr><name>untiltime</name> <operator>=</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_untiltime</name></name></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>zp</name><operator>-&gt;</operator><name>z_untilrule</name><operator>.</operator><name>r_todisgmt</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>untiltime</name> <operator>=</operator> <call><name>tadd</name><argument_list>(<argument><expr><name>untiltime</name></expr></argument>,
                                             <argument><expr><operator>-</operator><name>gmtoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>zp</name><operator>-&gt;</operator><name>z_untilrule</name><operator>.</operator><name>r_todisstd</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>untiltime</name> <operator>=</operator> <call><name>tadd</name><argument_list>(<argument><expr><name>untiltime</name></expr></argument>,
                                             <argument><expr><operator>-</operator><name>stdoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * Find the rule (of those to do, if any) that takes
                     * effect earliest in the year.
                     */</comment>
                    <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
                    <block>{<block_content>
                        <expr_stmt><expr><name>rp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z_rules</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rp</name><operator>-&gt;</operator><name>r_todo</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <continue>continue;</continue></block_content></block></if></if_stmt>
                        <expr_stmt><expr><call><name>eats</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_filename</name></name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_linenum</name></name></expr></argument>,
                             <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_filename</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_linenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>offset</name> <operator>=</operator> <ternary><condition><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisgmt</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>gmtoff</name></expr></else></ternary></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rp</name><operator>-&gt;</operator><name>r_todisstd</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>stdoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name>jtime</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_temp</name></name></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>jtime</name> <operator>==</operator> <name>min_time</name> <operator>||</operator>
                            <name>jtime</name> <operator>==</operator> <name>max_time</name></expr>)</condition><block type="pseudo"><block_content>
                            <continue>continue;</continue></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name>jtime</name> <operator>=</operator> <call><name>tadd</name><argument_list>(<argument><expr><name>jtime</name></expr></argument>, <argument><expr><operator>-</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>jtime</name> <operator>&lt;</operator> <name>ktime</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>k</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>ktime</name> <operator>=</operator> <name>jtime</name></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><name>jtime</name> <operator>==</operator> <name>ktime</name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>dup_rules_msg</name> <init>=
                            <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"two rules for same instant"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <expr_stmt><expr><call><name>eats</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_filename</name></name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_linenum</name></name></expr></argument>,
                                 <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_filename</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_linenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>dup_rules_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>rp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z_rules</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>eats</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_filename</name></name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_linenum</name></name></expr></argument>,
                                 <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_filename</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_linenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>dup_rules_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                    <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>    <comment type="block">/* go on to next year */</comment>
                    <expr_stmt><expr><name>rp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z_rules</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todo</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>useuntil</name> <operator>&amp;&amp;</operator> <name>ktime</name> <operator>&gt;=</operator> <name>untiltime</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>stdoff</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_stdoff</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>usestart</name> <operator>&amp;&amp;</operator> <name>ktime</name> <operator>==</operator> <name>starttime</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>usestart</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name>usestart</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>ktime</name> <operator>&lt;</operator> <name>starttime</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>startoff</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_gmtoff</name></name></expr></argument>,
                                            <argument><expr><name>stdoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>doabbr</name><argument_list>(<argument><expr><name>startbuf</name></expr></argument>, <argument><expr><name>zp</name></expr></argument>,
                                   <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_abbrvar</name></name></expr></argument>,
                                   <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_stdoff</name></name></expr></argument>,
                                   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>startbuf</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
                            <name>startoff</name> <operator>==</operator> <call><name>oadd</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_gmtoff</name></name></expr></argument>, <argument><expr><name>stdoff</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>doabbr</name><argument_list>(<argument><expr><name>startbuf</name></expr></argument>,
                                   <argument><expr><name>zp</name></expr></argument>,
                                   <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_abbrvar</name></name></expr></argument>,
                                   <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_stdoff</name></name></expr></argument>,
                                   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>eats</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_filename</name></name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_linenum</name></name></expr></argument>,
                         <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_filename</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_linenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>doabbr</name><argument_list>(<argument><expr><name>ab</name></expr></argument>, <argument><expr><name>zp</name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_abbrvar</name></name></expr></argument>,
                           <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_stdoff</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_gmtoff</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_stdoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>addtype</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>ab</name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_stdoff</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>,
                                   <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisstd</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisgmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>==</operator> <name>ZIC_MAX</name>
                        <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><literal type="number">0</literal> <operator>&lt;=</operator> <name>lastatmax</name>
                             <operator>&amp;&amp;</operator> <name>ktime</name> <operator>&lt;</operator> <name><name>attypes</name><index>[<expr><name>lastatmax</name></expr>]</index></name><operator>.</operator><name>at</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>lastatmax</name> <operator>=</operator> <name>timecnt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>addtt</name><argument_list>(<argument><expr><name>ktime</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></for></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>usestart</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>startbuf</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
                <name><name>zp</name><operator>-&gt;</operator><name>z_format</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                <call><name>strchr</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_format</name></name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                <call><name>strchr</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_format</name></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>startbuf</name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>eat</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_filename</name></name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_linenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>startbuf</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot determine time zone abbreviation to use just after until time"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>addtt</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>,
                      <argument><expr><call><name>addtype</name><argument_list>(<argument><expr><name>startoff</name></expr></argument>, <argument><expr><name>startbuf</name></expr></argument>,
                              <argument><expr><name>startoff</name> <operator>!=</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_gmtoff</name></name></expr></argument>,
                              <argument><expr><name>startttisstd</name></expr></argument>,
                              <argument><expr><name>startttisgmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Now we may get to set starttime for the next zone line.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>useuntil</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>startttisstd</name> <operator>=</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_untilrule</name><operator>.</operator><name>r_todisstd</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>startttisgmt</name> <operator>=</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_untilrule</name><operator>.</operator><name>r_todisgmt</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>starttime</name> <operator>=</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_untiltime</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>startttisstd</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>starttime</name> <operator>=</operator> <call><name>tadd</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>, <argument><expr><operator>-</operator><name>stdoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>startttisgmt</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>starttime</name> <operator>=</operator> <call><name>tadd</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>, <argument><expr><operator>-</operator><name>gmtoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>lastatmax</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>attypes</name><index>[<expr><name>lastatmax</name></expr>]</index></name><operator>.</operator><name>dontmerge</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>do_extend</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If we're extending the explicitly listed observations for 400 years
         * because we can't fill the POSIX-TZ field, check whether we actually
         * ended up explicitly listing observations through that period.  If
         * there aren't any near the end of the 400-year period, add a
         * redundant one at the end of the final year, to make it clear that
         * we are claiming to have definite knowledge of the lack of
         * transitions up to that point.
         */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name></type> <name>xr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>attype</name></name> <modifier>*</modifier></type><name>lastat</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>xr</name><operator>.</operator><name>r_month</name></name> <operator>=</operator> <name>TM_JANUARY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xr</name><operator>.</operator><name>r_dycode</name></name> <operator>=</operator> <name>DC_DOM</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xr</name><operator>.</operator><name>r_dayofmonth</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xr</name><operator>.</operator><name>r_tod</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>lastat</name> <operator>=</operator> <operator>&amp;</operator><name><name>attypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>timecnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>attypes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>at</name> <operator>&gt;</operator> <name><name>lastat</name><operator>-&gt;</operator><name>at</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>lastat</name> <operator>=</operator> <operator>&amp;</operator><name><name>attypes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
        <if_stmt><if>if <condition>(<expr><name><name>lastat</name><operator>-&gt;</operator><name>at</name></name> <operator>&lt;</operator> <call><name>rpytime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xr</name></expr></argument>, <argument><expr><name>max_year</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>addtt</name><argument_list>(<argument><expr><call><name>rpytime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xr</name></expr></argument>, <argument><expr><name>max_year</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>typecnt</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>attypes</name><index>[<expr><name>timecnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>dontmerge</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>writezone</name><argument_list>(<argument><expr><name><name>zpfirst</name><operator>-&gt;</operator><name>z_name</name></name></expr></argument>, <argument><expr><name>envvar</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>startbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>envvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>addtt</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>starttime</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>starttime</name> <operator>&lt;=</operator> <name>early_time</name>
        <operator>||</operator> <operator>(</operator><name>timecnt</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>attypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>at</name> <operator>&lt;</operator> <name>early_time</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>gmtoffs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>gmtoffs</name><index>[<expr><name>type</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>isdsts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>isdsts</name><index>[<expr><name>type</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ttisstds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ttisstds</name><index>[<expr><name>type</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ttisgmts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ttisgmts</name><index>[<expr><name>type</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>abbrinds</name><index>[<expr><name>type</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>chars</name><index>[<expr><name><name>abbrinds</name><index>[<expr><name>type</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>abbrinds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>charcnt</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>chars</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>typecnt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>timecnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>attypes</name> <operator>=</operator> <call><name>growalloc</name><argument_list>(<argument><expr><name>attypes</name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>attypes</name></expr></argument>, <argument><expr><name>timecnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timecnt_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attypes</name><index>[<expr><name>timecnt</name></expr>]</index></name><operator>.</operator><name>at</name> <operator>=</operator> <name>starttime</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attypes</name><index>[<expr><name>timecnt</name></expr>]</index></name><operator>.</operator><name>dontmerge</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attypes</name><index>[<expr><name>timecnt</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>++</operator><name>timecnt</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>addtype</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>gmtoff</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>abbr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdst</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ttisstd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ttisgmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <comment type="block">/*
     * See if there's already an entry for this zone type. If so, just return
     * its index.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>typecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>gmtoff</name> <operator>==</operator> <name><name>gmtoffs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name>isdst</name> <operator>==</operator> <name><name>isdsts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator>
            <call><name>strcmp</name><argument_list>(<argument><expr><name>abbr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>chars</name><index>[<expr><name><name>abbrinds</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name>ttisstd</name> <operator>==</operator> <name><name>ttisstds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator>
            <name>ttisgmt</name> <operator>==</operator> <name><name>ttisgmts</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * There isn't one; add a new one, unless there are already too many.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>typecnt</name> <operator>&gt;=</operator> <name>TZ_MAX_TYPES</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many local time types"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>-</operator><literal type="number">1L</literal> <operator>-</operator> <literal type="number">2147483647L</literal> <operator>&lt;=</operator> <name>gmtoff</name> <operator>&amp;&amp;</operator> <name>gmtoff</name> <operator>&lt;=</operator> <literal type="number">2147483647L</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"UT offset out of range"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>gmtoffs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>gmtoff</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>isdsts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>isdst</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ttisstds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ttisstd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ttisgmts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ttisgmt</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>charcnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chars</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>abbr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
    <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>charcnt</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>newabbr</name><argument_list>(<argument><expr><name>abbr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>abbrinds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>++</operator><name>typecnt</name></expr>;</expr_stmt>
    <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>leapadd</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>positive</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rolling</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>leapcnt</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>positive</name></expr> ?</condition><then> <expr><name>count</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator> <operator>&gt;</operator> <name>TZ_MAX_LEAPS</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many leap seconds"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>leapcnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;=</operator> <name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"repeated leap second moment"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt></block_content></block></for>
    <do>do
    <block>{<block_content>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>leapcnt</name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <name>i</name></expr>;</condition> <incr><expr><operator>--</operator><name>j</name></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>trans</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>trans</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>corr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>corr</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>roll</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>roll</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>corr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>positive</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><name>count</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>roll</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>rolling</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name>leapcnt</name></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name>positive</name> <operator>&amp;&amp;</operator> <operator>--</operator><name>count</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>adjleap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * propagate leap seconds forward
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>leapcnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>tadd</name><argument_list>(<argument><expr><name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>corr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name>last</name></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>shellquote</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>b</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>b</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr><operator>,</operator> <expr><operator>*</operator><name>b</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr><operator>,</operator> <expr><operator>*</operator><name>b</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>b</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><operator>*</operator><name>b</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
    <return>return <expr><name>b</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>yearistype</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>year</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>type</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>emalloc</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">4</literal> <operator>*</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>yitcommand</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal>
                  <operator>+</operator> <call><name>INT_STRLEN_MAXIMUM</name><argument_list>(<argument><expr><name>zic_t</name></expr></argument>)</argument_list></call> <operator>+</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">4</literal> <operator>*</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>shellquote</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>yitcommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>b</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>year</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>b</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>shellquote</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>b</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>system</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>status</name> <init>= <expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>status</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>status</name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Wild result from command execution"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: command was '%s', result was %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Is A a space character in the C locale?    */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_space</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>a</name></expr>)</condition>
    <block>{<block_content>
        <default>default:</default>
            <return>return <expr><name>false</name></expr>;</return>
        <case>case <expr><literal type="char">' '</literal></expr>:</case>
        <case>case <expr><literal type="char">'\f'</literal></expr>:</case>
        <case>case <expr><literal type="char">'\n'</literal></expr>:</case>
        <case>case <expr><literal type="char">'\r'</literal></expr>:</case>
        <case>case <expr><literal type="char">'\t'</literal></expr>:</case>
        <case>case <expr><literal type="char">'\v'</literal></expr>:</case>
            <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Is A an alphabetic character in the C locale?  */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_alpha</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <switch>switch <condition>(<expr><name>a</name></expr>)</condition>
    <block>{<block_content>
        <default>default:</default>
            <return>return <expr><name>false</name></expr>;</return>
        <case>case <expr><literal type="char">'A'</literal></expr>:</case>
        <case>case <expr><literal type="char">'B'</literal></expr>:</case>
        <case>case <expr><literal type="char">'C'</literal></expr>:</case>
        <case>case <expr><literal type="char">'D'</literal></expr>:</case>
        <case>case <expr><literal type="char">'E'</literal></expr>:</case>
        <case>case <expr><literal type="char">'F'</literal></expr>:</case>
        <case>case <expr><literal type="char">'G'</literal></expr>:</case>
        <case>case <expr><literal type="char">'H'</literal></expr>:</case>
        <case>case <expr><literal type="char">'I'</literal></expr>:</case>
        <case>case <expr><literal type="char">'J'</literal></expr>:</case>
        <case>case <expr><literal type="char">'K'</literal></expr>:</case>
        <case>case <expr><literal type="char">'L'</literal></expr>:</case>
        <case>case <expr><literal type="char">'M'</literal></expr>:</case>
        <case>case <expr><literal type="char">'N'</literal></expr>:</case>
        <case>case <expr><literal type="char">'O'</literal></expr>:</case>
        <case>case <expr><literal type="char">'P'</literal></expr>:</case>
        <case>case <expr><literal type="char">'Q'</literal></expr>:</case>
        <case>case <expr><literal type="char">'R'</literal></expr>:</case>
        <case>case <expr><literal type="char">'S'</literal></expr>:</case>
        <case>case <expr><literal type="char">'T'</literal></expr>:</case>
        <case>case <expr><literal type="char">'U'</literal></expr>:</case>
        <case>case <expr><literal type="char">'V'</literal></expr>:</case>
        <case>case <expr><literal type="char">'W'</literal></expr>:</case>
        <case>case <expr><literal type="char">'X'</literal></expr>:</case>
        <case>case <expr><literal type="char">'Y'</literal></expr>:</case>
        <case>case <expr><literal type="char">'Z'</literal></expr>:</case>
        <case>case <expr><literal type="char">'a'</literal></expr>:</case>
        <case>case <expr><literal type="char">'b'</literal></expr>:</case>
        <case>case <expr><literal type="char">'c'</literal></expr>:</case>
        <case>case <expr><literal type="char">'d'</literal></expr>:</case>
        <case>case <expr><literal type="char">'e'</literal></expr>:</case>
        <case>case <expr><literal type="char">'f'</literal></expr>:</case>
        <case>case <expr><literal type="char">'g'</literal></expr>:</case>
        <case>case <expr><literal type="char">'h'</literal></expr>:</case>
        <case>case <expr><literal type="char">'i'</literal></expr>:</case>
        <case>case <expr><literal type="char">'j'</literal></expr>:</case>
        <case>case <expr><literal type="char">'k'</literal></expr>:</case>
        <case>case <expr><literal type="char">'l'</literal></expr>:</case>
        <case>case <expr><literal type="char">'m'</literal></expr>:</case>
        <case>case <expr><literal type="char">'n'</literal></expr>:</case>
        <case>case <expr><literal type="char">'o'</literal></expr>:</case>
        <case>case <expr><literal type="char">'p'</literal></expr>:</case>
        <case>case <expr><literal type="char">'q'</literal></expr>:</case>
        <case>case <expr><literal type="char">'r'</literal></expr>:</case>
        <case>case <expr><literal type="char">'s'</literal></expr>:</case>
        <case>case <expr><literal type="char">'t'</literal></expr>:</case>
        <case>case <expr><literal type="char">'u'</literal></expr>:</case>
        <case>case <expr><literal type="char">'v'</literal></expr>:</case>
        <case>case <expr><literal type="char">'w'</literal></expr>:</case>
        <case>case <expr><literal type="char">'x'</literal></expr>:</case>
        <case>case <expr><literal type="char">'y'</literal></expr>:</case>
        <case>case <expr><literal type="char">'z'</literal></expr>:</case>
            <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* If A is an uppercase character in the C locale, return its lowercase
 * counterpart.  Otherwise, return A.  */</comment>
<function><type><specifier>static</specifier> <name>char</name></type>
<name>lowerit</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <switch>switch <condition>(<expr><name>a</name></expr>)</condition>
    <block>{<block_content>
        <default>default:</default>
            <return>return <expr><name>a</name></expr>;</return>
        <case>case <expr><literal type="char">'A'</literal></expr>:</case>
            <return>return <expr><literal type="char">'a'</literal></expr>;</return>
        <case>case <expr><literal type="char">'B'</literal></expr>:</case>
            <return>return <expr><literal type="char">'b'</literal></expr>;</return>
        <case>case <expr><literal type="char">'C'</literal></expr>:</case>
            <return>return <expr><literal type="char">'c'</literal></expr>;</return>
        <case>case <expr><literal type="char">'D'</literal></expr>:</case>
            <return>return <expr><literal type="char">'d'</literal></expr>;</return>
        <case>case <expr><literal type="char">'E'</literal></expr>:</case>
            <return>return <expr><literal type="char">'e'</literal></expr>;</return>
        <case>case <expr><literal type="char">'F'</literal></expr>:</case>
            <return>return <expr><literal type="char">'f'</literal></expr>;</return>
        <case>case <expr><literal type="char">'G'</literal></expr>:</case>
            <return>return <expr><literal type="char">'g'</literal></expr>;</return>
        <case>case <expr><literal type="char">'H'</literal></expr>:</case>
            <return>return <expr><literal type="char">'h'</literal></expr>;</return>
        <case>case <expr><literal type="char">'I'</literal></expr>:</case>
            <return>return <expr><literal type="char">'i'</literal></expr>;</return>
        <case>case <expr><literal type="char">'J'</literal></expr>:</case>
            <return>return <expr><literal type="char">'j'</literal></expr>;</return>
        <case>case <expr><literal type="char">'K'</literal></expr>:</case>
            <return>return <expr><literal type="char">'k'</literal></expr>;</return>
        <case>case <expr><literal type="char">'L'</literal></expr>:</case>
            <return>return <expr><literal type="char">'l'</literal></expr>;</return>
        <case>case <expr><literal type="char">'M'</literal></expr>:</case>
            <return>return <expr><literal type="char">'m'</literal></expr>;</return>
        <case>case <expr><literal type="char">'N'</literal></expr>:</case>
            <return>return <expr><literal type="char">'n'</literal></expr>;</return>
        <case>case <expr><literal type="char">'O'</literal></expr>:</case>
            <return>return <expr><literal type="char">'o'</literal></expr>;</return>
        <case>case <expr><literal type="char">'P'</literal></expr>:</case>
            <return>return <expr><literal type="char">'p'</literal></expr>;</return>
        <case>case <expr><literal type="char">'Q'</literal></expr>:</case>
            <return>return <expr><literal type="char">'q'</literal></expr>;</return>
        <case>case <expr><literal type="char">'R'</literal></expr>:</case>
            <return>return <expr><literal type="char">'r'</literal></expr>;</return>
        <case>case <expr><literal type="char">'S'</literal></expr>:</case>
            <return>return <expr><literal type="char">'s'</literal></expr>;</return>
        <case>case <expr><literal type="char">'T'</literal></expr>:</case>
            <return>return <expr><literal type="char">'t'</literal></expr>;</return>
        <case>case <expr><literal type="char">'U'</literal></expr>:</case>
            <return>return <expr><literal type="char">'u'</literal></expr>;</return>
        <case>case <expr><literal type="char">'V'</literal></expr>:</case>
            <return>return <expr><literal type="char">'v'</literal></expr>;</return>
        <case>case <expr><literal type="char">'W'</literal></expr>:</case>
            <return>return <expr><literal type="char">'w'</literal></expr>;</return>
        <case>case <expr><literal type="char">'X'</literal></expr>:</case>
            <return>return <expr><literal type="char">'x'</literal></expr>;</return>
        <case>case <expr><literal type="char">'Y'</literal></expr>:</case>
            <return>return <expr><literal type="char">'y'</literal></expr>;</return>
        <case>case <expr><literal type="char">'Z'</literal></expr>:</case>
            <return>return <expr><literal type="char">'z'</literal></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* case-insensitive equality */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ciequal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ap</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <while>while <condition>(<expr><call><name>lowerit</name><argument_list>(<argument><expr><operator>*</operator><name>ap</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>lowerit</name><argument_list>(<argument><expr><operator>*</operator><name>bp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ap</name><operator>++</operator> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></while>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>itsabbr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abbr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>lowerit</name><argument_list>(<argument><expr><operator>*</operator><name>abbr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>lowerit</name><argument_list>(<argument><expr><operator>*</operator><name>word</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>++</operator><name>word</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>*</operator><operator>++</operator><name>abbr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <do>do
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>word</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block> while <condition>(<expr><call><name>lowerit</name><argument_list>(<argument><expr><operator>*</operator><name>word</name><operator>++</operator></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>lowerit</name><argument_list>(<argument><expr><operator>*</operator><name>abbr</name></expr></argument>)</argument_list></call></expr>)</condition>;</do></block_content></block></while>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>lookup</name></name> <modifier>*</modifier></type>
<name>byword</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>lookup</name></name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>lookup</name></name> <modifier>*</modifier></type><name>foundlp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>lookup</name></name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>word</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>table</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Look for exact match.
     */</comment>
    <for>for <control>(<init><expr><name>lp</name> <operator>=</operator> <name>table</name></expr>;</init> <condition><expr><name><name>lp</name><operator>-&gt;</operator><name>l_word</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><operator>++</operator><name>lp</name></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>ciequal</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>l_word</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>lp</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

    <comment type="block">/*
     * Look for inexact match.
     */</comment>
    <expr_stmt><expr><name>foundlp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>lp</name> <operator>=</operator> <name>table</name></expr>;</init> <condition><expr><name><name>lp</name><operator>-&gt;</operator><name>l_word</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><operator>++</operator><name>lp</name></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>itsabbr</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>l_word</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>foundlp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>foundlp</name> <operator>=</operator> <name>lp</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>    <comment type="block">/* multiple inexact matches */</comment>
        </block_content>}</block></if></if_stmt></block_content></block></for>
    <return>return <expr><name>foundlp</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>getfields</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nsubs</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>cp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>emalloc</name><argument_list>(<argument><expr><call><name>size_product</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>array</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nsubs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <while>while <condition>(<expr><call><name>is_space</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>++</operator><name>cp</name></expr>;</expr_stmt></block_content></block></while>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>array</name><index>[<expr><name>nsubs</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>dp</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
        <do>do
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>dp</name> <operator>=</operator> <operator>*</operator><name>cp</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>++</operator><name>dp</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <while>while <condition>(<expr><operator>(</operator><operator>*</operator><name>dp</name> <operator>=</operator> <operator>*</operator><name>cp</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
                    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>dp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><operator>++</operator><name>dp</name></expr>;</expr_stmt></block_content></block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Odd number of quotation marks"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt></block_content></block></while></block_content></block></else></if_stmt>
        </block_content>}</block> while <condition>(<expr><operator>*</operator><name>cp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_space</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
        <if_stmt><if>if <condition>(<expr><call><name>is_space</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>++</operator><name>cp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>dp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>array</name><index>[<expr><name>nsubs</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>array</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>time_overflow</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"time overflow"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>zic_t</name></type>
<name>oadd</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>t1</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>t2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>t1</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>t2</name> <operator>&lt;</operator> <name>ZIC_MIN</name> <operator>-</operator> <name>t1</name></expr> </then><else>: <expr><name>ZIC_MAX</name> <operator>-</operator> <name>t1</name> <operator>&lt;</operator> <name>t2</name></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>time_overflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>t1</name> <operator>+</operator> <name>t2</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>zic_t</name></type>
<name>tadd</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>t1</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>t2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>t1</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>t2</name> <operator>&lt;</operator> <name>min_time</name> <operator>-</operator> <name>t1</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>t1</name> <operator>!=</operator> <name>min_time</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>time_overflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>min_time</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>max_time</name> <operator>-</operator> <name>t1</name> <operator>&lt;</operator> <name>t2</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>t1</name> <operator>!=</operator> <name>max_time</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>time_overflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>max_time</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>t1</name> <operator>+</operator> <name>t2</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a rule, and a year, compute the date (in seconds since January 1,
 * 1970, 00:00 LOCAL time) in that year that the rule refers to.
 */</comment>

<function><type><specifier>static</specifier> <name>zic_t</name></type>
<name>rpytime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>wantedy</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>m</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>dayoff</name></decl>;</decl_stmt>            <comment type="block">/* with a nod to Margaret O. */</comment>
    <decl_stmt><decl><type><name>zic_t</name></type>        <name>t</name></decl>,
                <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>wantedy</name> <operator>==</operator> <name>ZIC_MIN</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>min_time</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>wantedy</name> <operator>==</operator> <name>ZIC_MAX</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>max_time</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>dayoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>m</name> <operator>=</operator> <name>TM_JANUARY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>y</name> <operator>=</operator> <name>EPOCH_YEAR</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>wantedy</name> <operator>!=</operator> <name>y</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>wantedy</name> <operator>&gt;</operator> <name>y</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>len_years</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>++</operator><name>y</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><operator>--</operator><name>y</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><name><name>len_years</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>dayoff</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>dayoff</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <while>while <condition>(<expr><name>m</name> <operator>!=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_month</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>len_months</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name>m</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dayoff</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>dayoff</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name>m</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>m</name> <operator>==</operator> <name>TM_FEBRUARY</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <literal type="number">29</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isleap</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>==</operator> <name>DC_DOWLEQ</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>--</operator><name>i</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"use of 2/29 in non leap-year"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>--</operator><name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dayoff</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>dayoff</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>==</operator> <name>DC_DOWGEQ</name> <operator>||</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>==</operator> <name>DC_DOWLEQ</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>zic_t</name></type>        <name>wday</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAYSPERWEEK</name></cpp:macro>    <cpp:value>((zic_t) DAYSPERWEEK)</cpp:value></cpp:define>
        <expr_stmt><expr><name>wday</name> <operator>=</operator> <name>EPOCH_WDAY</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Don't trust mod of negative numbers.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>dayoff</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>wday</name> <operator>=</operator> <operator>(</operator><name>wday</name> <operator>+</operator> <name>dayoff</name><operator>)</operator> <operator>%</operator> <name>LDAYSPERWEEK</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>wday</name> <operator>-=</operator> <operator>(</operator><operator>(</operator><operator>-</operator><name>dayoff</name><operator>)</operator> <operator>%</operator> <name>LDAYSPERWEEK</name><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>wday</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>wday</name> <operator>+=</operator> <name>LDAYSPERWEEK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <while>while <condition>(<expr><name>wday</name> <operator>!=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_wday</name></name></expr>)</condition><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>==</operator> <name>DC_DOWGEQ</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>dayoff</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>dayoff</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>++</operator><name>wday</name> <operator>&gt;=</operator> <name>LDAYSPERWEEK</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>wday</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>dayoff</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>dayoff</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>--</operator><name>wday</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>wday</name> <operator>=</operator> <name>LDAYSPERWEEK</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><operator>--</operator><name>i</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt></block_content></block></while>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>i</name> <operator>&gt;=</operator> <name><name>len_months</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name>m</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>noise</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"rule goes past start/end of month; \
will not work with pre-2004 versions of zic"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dayoff</name> <operator>&lt;</operator> <name>min_time</name> <operator>/</operator> <name>SECSPERDAY</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>min_time</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dayoff</name> <operator>&gt;</operator> <name>max_time</name> <operator>/</operator> <name>SECSPERDAY</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>max_time</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>zic_t</name><operator>)</operator> <name>dayoff</name> <operator>*</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>

    <return>return <expr><call><name>tadd</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_tod</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>newabbr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>GRANDPARENTED</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mp</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>cp</name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>is_alpha</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><literal type="char">'0'</literal> <operator>&lt;=</operator> <operator>*</operator><name>cp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator>
               <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>++</operator><name>cp</name></expr>;</expr_stmt></block_content></block></while>
        <if_stmt><if>if <condition>(<expr><name>noise</name> <operator>&amp;&amp;</operator> <name>cp</name> <operator>-</operator> <name>string</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>mp</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"time zone abbreviation has fewer than 3 characters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>cp</name> <operator>-</operator> <name>string</name> <operator>&gt;</operator> <name>ZIC_MAX_ABBR_LEN_WO_WARN</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>mp</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"time zone abbreviation has too many characters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>mp</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"time zone abbreviation differs from POSIX standard"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>mp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><literal type="string">"%s (%s)"</literal></expr></argument>, <argument><expr><name>mp</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>charcnt</name> <operator>+</operator> <name>i</name> <operator>&gt;</operator> <name>TZ_MAX_CHARS</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many, or too long, time zone abbreviations"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chars</name><index>[<expr><name>charcnt</name></expr>]</index></name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>charcnt</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Ensure that the directories of ARGNAME exist, by making any missing
   ones.  If ANCESTORS, do this only for ARGNAME's ancestors; otherwise,
   do it for ARGNAME too.  Exit with failure if there is trouble.
   Do not consider an existing non-directory to be trouble.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mkdirs</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>argname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ancestors</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cp</name> <operator>=</operator> <name>name</name> <operator>=</operator> <call><name>ecpyalloc</name><argument_list>(<argument><expr><name>argname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Do not mkdir a root directory, as it must exist.  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>is_alpha</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>cp</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <while>while <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

    <while>while <condition>(<expr><name>cp</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>cp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>!</operator><name>ancestors</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>cp</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Try to create it.  It's OK if creation fails because the directory
         * already exists, perhaps because some other process just created it.
         * For simplicity do not check first whether it already exists, as
         * that is checked anyway if the mkdir fails.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>mkdir</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>MKDIR_UMASK</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * For speed, skip itsdir if errno == EEXIST.  Since mkdirs is
             * called only after open fails with ENOENT on a subfile, EEXIST
             * implies itsdir here.
             */</comment>
            <decl_stmt><decl><type><name>int</name></type>            <name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>EEXIST</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>itsdir</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Cannot create directory %s: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>cp</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<comment type="block">/*
 * To run on win32
 */</comment>
<function><type><name>int</name></type>
<name>link</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldpath</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CopyFile</name><argument_list>(<argument><expr><name>oldpath</name></expr></argument>, <argument><expr><name>newpath</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
