<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/fe_utils/print.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * Query-result printing support for frontend code
 *
 * This file used to be part of psql, but now it's separated out to allow
 * other frontend programs to use it.  Because the printing code needs
 * access to the cancel_pressed flag as well as SIGPIPE trapping and
 * pager open/close functions, all that stuff came with it.
 *
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/fe_utils/print.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ioctl.h&gt;</cpp:file></cpp:include>            <comment type="block">/* for ioctl() */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TERMIOS_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;termios.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/print.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/mbprint.h"</cpp:file></cpp:include>


<comment type="block">/*
 * If the calling program doesn't have any mechanism for setting
 * cancel_pressed, it will have no effect.
 *
 * Note: print.c's general strategy for when to check cancel_pressed is to do
 * so at completion of each row of output.
 */</comment>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>cancel_pressed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>always_ignore_sigpipe</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* info for locale-aware numeric formatting; set up by setDecimalLocale() */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>decimal_point</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>groupdigits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>thousands_sep</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>default_footer</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>printTableFooter</name></type> <name>default_footer_cell</name> <init>= <expr><block>{<expr><name>default_footer</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Line style control structures */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>printTextFormat</name></type> <name>pg_asciiformat</name> <init>=
<expr><block>{
    <expr><literal type="string">"ascii"</literal></expr>,
    <expr><block>{
        <expr><block>{<expr><literal type="string">"-"</literal></expr>, <expr><literal type="string">"+"</literal></expr>, <expr><literal type="string">"+"</literal></expr>, <expr><literal type="string">"+"</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"-"</literal></expr>, <expr><literal type="string">"+"</literal></expr>, <expr><literal type="string">"+"</literal></expr>, <expr><literal type="string">"+"</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"-"</literal></expr>, <expr><literal type="string">"+"</literal></expr>, <expr><literal type="string">"+"</literal></expr>, <expr><literal type="string">"+"</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">""</literal></expr>, <expr><literal type="string">"|"</literal></expr>, <expr><literal type="string">"|"</literal></expr>, <expr><literal type="string">"|"</literal></expr>}</block></expr>
    }</block></expr>,
    <expr><literal type="string">"|"</literal></expr>,
    <expr><literal type="string">"|"</literal></expr>,
    <expr><literal type="string">"|"</literal></expr>,
    <expr><literal type="string">" "</literal></expr>,
    <expr><literal type="string">"+"</literal></expr>,
    <expr><literal type="string">" "</literal></expr>,
    <expr><literal type="string">"+"</literal></expr>,
    <expr><literal type="string">"."</literal></expr>,
    <expr><literal type="string">"."</literal></expr>,
    <expr><name>true</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>printTextFormat</name></type> <name>pg_asciiformat_old</name> <init>=
<expr><block>{
    <expr><literal type="string">"old-ascii"</literal></expr>,
    <expr><block>{
        <expr><block>{<expr><literal type="string">"-"</literal></expr>, <expr><literal type="string">"+"</literal></expr>, <expr><literal type="string">"+"</literal></expr>, <expr><literal type="string">"+"</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"-"</literal></expr>, <expr><literal type="string">"+"</literal></expr>, <expr><literal type="string">"+"</literal></expr>, <expr><literal type="string">"+"</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"-"</literal></expr>, <expr><literal type="string">"+"</literal></expr>, <expr><literal type="string">"+"</literal></expr>, <expr><literal type="string">"+"</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">""</literal></expr>, <expr><literal type="string">"|"</literal></expr>, <expr><literal type="string">"|"</literal></expr>, <expr><literal type="string">"|"</literal></expr>}</block></expr>
    }</block></expr>,
    <expr><literal type="string">":"</literal></expr>,
    <expr><literal type="string">";"</literal></expr>,
    <expr><literal type="string">" "</literal></expr>,
    <expr><literal type="string">"+"</literal></expr>,
    <expr><literal type="string">" "</literal></expr>,
    <expr><literal type="string">" "</literal></expr>,
    <expr><literal type="string">" "</literal></expr>,
    <expr><literal type="string">" "</literal></expr>,
    <expr><literal type="string">" "</literal></expr>,
    <expr><name>false</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Default unicode linestyle format */</comment>
<decl_stmt><decl><type><name>printTextFormat</name></type> <name>pg_utf8format</name></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>unicodeStyleRowFormat</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>horizontal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>vertical_and_right</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>vertical_and_left</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>unicodeStyleRowFormat</name>;</typedef>

<typedef>typedef <type><struct>struct <name>unicodeStyleColumnFormat</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vertical</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>vertical_and_horizontal</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>up_and_horizontal</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>down_and_horizontal</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>unicodeStyleColumnFormat</name>;</typedef>

<typedef>typedef <type><struct>struct <name>unicodeStyleBorderFormat</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>up_and_right</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vertical</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>down_and_right</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>horizontal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>down_and_left</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>left_and_right</name></decl>;</decl_stmt>
}</block></struct></type> <name>unicodeStyleBorderFormat</name>;</typedef>

<typedef>typedef <type><struct>struct <name>unicodeStyleFormat</name>
<block>{
    <decl_stmt><decl><type><name>unicodeStyleRowFormat</name></type> <name><name>row_style</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unicodeStyleColumnFormat</name></type> <name><name>column_style</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unicodeStyleBorderFormat</name></type> <name><name>border_style</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>header_nl_left</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>header_nl_right</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nl_left</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nl_right</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>wrap_left</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>wrap_right</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>wrap_right_border</name></decl>;</decl_stmt>
}</block></struct></type> <name>unicodeStyleFormat</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unicodeStyleFormat</name></type> <name>unicode_style</name> <init>= <expr><block>{
    <expr><block>{
        <expr><block>{
            <comment type="block">/* â */</comment>
            <expr><literal type="string">"\342\224\200"</literal></expr>,
            <comment type="block">/* ââ */</comment>
            <expr><block>{<expr><literal type="string">"\342\224\234"</literal></expr>, <expr><literal type="string">"\342\225\237"</literal></expr>}</block></expr>,
            <comment type="block">/* â¤â¢ */</comment>
            <expr><block>{<expr><literal type="string">"\342\224\244"</literal></expr>, <expr><literal type="string">"\342\225\242"</literal></expr>}</block></expr>,
        }</block></expr>,
        <expr><block>{
            <comment type="block">/* â */</comment>
            <expr><literal type="string">"\342\225\220"</literal></expr>,
            <comment type="block">/* ââ  */</comment>
            <expr><block>{<expr><literal type="string">"\342\225\236"</literal></expr>, <expr><literal type="string">"\342\225\240"</literal></expr>}</block></expr>,
            <comment type="block">/* â¡â£ */</comment>
            <expr><block>{<expr><literal type="string">"\342\225\241"</literal></expr>, <expr><literal type="string">"\342\225\243"</literal></expr>}</block></expr>,
        }</block></expr>,
    }</block></expr>,
    <expr><block>{
        <expr><block>{
            <comment type="block">/* â */</comment>
            <expr><literal type="string">"\342\224\202"</literal></expr>,
            <comment type="block">/* â¼âª */</comment>
            <expr><block>{<expr><literal type="string">"\342\224\274"</literal></expr>, <expr><literal type="string">"\342\225\252"</literal></expr>}</block></expr>,
            <comment type="block">/* â´â§ */</comment>
            <expr><block>{<expr><literal type="string">"\342\224\264"</literal></expr>, <expr><literal type="string">"\342\225\247"</literal></expr>}</block></expr>,
            <comment type="block">/* â¬â¤ */</comment>
            <expr><block>{<expr><literal type="string">"\342\224\254"</literal></expr>, <expr><literal type="string">"\342\225\244"</literal></expr>}</block></expr>,
        }</block></expr>,
        <expr><block>{
            <comment type="block">/* â */</comment>
            <expr><literal type="string">"\342\225\221"</literal></expr>,
            <comment type="block">/* â«â¬ */</comment>
            <expr><block>{<expr><literal type="string">"\342\225\253"</literal></expr>, <expr><literal type="string">"\342\225\254"</literal></expr>}</block></expr>,
            <comment type="block">/* â¨â© */</comment>
            <expr><block>{<expr><literal type="string">"\342\225\250"</literal></expr>, <expr><literal type="string">"\342\225\251"</literal></expr>}</block></expr>,
            <comment type="block">/* â¥â¦ */</comment>
            <expr><block>{<expr><literal type="string">"\342\225\245"</literal></expr>, <expr><literal type="string">"\342\225\246"</literal></expr>}</block></expr>,
        }</block></expr>,
    }</block></expr>,
    <expr><block>{
        <comment type="block">/* ââââââ */</comment>
        <expr><block>{<expr><literal type="string">"\342\224\224"</literal></expr>, <expr><literal type="string">"\342\224\202"</literal></expr>, <expr><literal type="string">"\342\224\214"</literal></expr>, <expr><literal type="string">"\342\224\200"</literal></expr>, <expr><literal type="string">"\342\224\220"</literal></expr>, <expr><literal type="string">"\342\224\230"</literal></expr>}</block></expr>,
        <comment type="block">/* ââââââ */</comment>
        <expr><block>{<expr><literal type="string">"\342\225\232"</literal></expr>, <expr><literal type="string">"\342\225\221"</literal></expr>, <expr><literal type="string">"\342\225\224"</literal></expr>, <expr><literal type="string">"\342\225\220"</literal></expr>, <expr><literal type="string">"\342\225\227"</literal></expr>, <expr><literal type="string">"\342\225\235"</literal></expr>}</block></expr>,
    }</block></expr>,
    <expr><literal type="string">" "</literal></expr>,
    <expr><literal type="string">"\342\206\265"</literal></expr>,                <comment type="block">/* âµ */</comment>
    <expr><literal type="string">" "</literal></expr>,
    <expr><literal type="string">"\342\206\265"</literal></expr>,                <comment type="block">/* âµ */</comment>
    <expr><literal type="string">"\342\200\246"</literal></expr>,                <comment type="block">/* â¦ */</comment>
    <expr><literal type="string">"\342\200\246"</literal></expr>,                <comment type="block">/* â¦ */</comment>
    <expr><name>true</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Local functions */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>strlen_max_width</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>target_width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>IsPagerNeeded</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableContent</name> <modifier>*</modifier></type><name>cont</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>extra_lines</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>expanded</name></decl></parameter>,
              <parameter><decl><type><name>FILE</name> <modifier>*</modifier><modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_pager</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_aligned_vertical</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableContent</name> <modifier>*</modifier></type><name>cont</name></decl></parameter>,
                       <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pager</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* Count number of digits in integral part of number */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>integer_digits</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* ignoring any sign ... */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>my_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>my_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>my_str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* ... count initial integral digits */</comment>
    <return>return <expr><call><name>strspn</name><argument_list>(<argument><expr><name>my_str</name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compute additional length required for locale-aware numeric output */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>additional_numeric_locale_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>int_len</name> <init>= <expr><call><name>integer_digits</name><argument_list>(<argument><expr><name>my_str</name></expr></argument>)</argument_list></call></expr></init></decl>,
                <decl><type ref="prev"/><name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Account for added thousands_sep instances */</comment>
    <if_stmt><if>if <condition>(<expr><name>int_len</name> <operator>&gt;</operator> <name>groupdigits</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>int_len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>groupdigits</name><operator>)</operator> <operator>*</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>thousands_sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Account for possible additional length of decimal_point */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>my_str</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>decimal_point</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Format a numeric value per current LC_NUMERIC locale setting
 *
 * Returns the appropriately formatted string in a new allocated block,
 * caller must free.
 *
 * setDecimalLocale() must have been called earlier.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>format_numeric_locale</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_str</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>new_str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>new_len</name></decl>,
                <decl><type ref="prev"/><name>int_len</name></decl>,
                <decl><type ref="prev"/><name>leading_digits</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>,
                <decl><type ref="prev"/><name>new_str_pos</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If the string doesn't look like a number, return it unchanged.  This
     * check is essential to avoid mangling already-localized "money" values.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name>my_str</name></expr></argument>, <argument><expr><literal type="string">"0123456789+-.eE"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>my_str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name>my_str</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>new_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>my_str</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>additional_numeric_locale_len</name><argument_list>(<argument><expr><name>my_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>new_str</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>new_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>new_str_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>int_len</name> <operator>=</operator> <call><name>integer_digits</name><argument_list>(<argument><expr><name>my_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* number of digits in first thousands group */</comment>
    <expr_stmt><expr><name>leading_digits</name> <operator>=</operator> <name>int_len</name> <operator>%</operator> <name>groupdigits</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>leading_digits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>leading_digits</name> <operator>=</operator> <name>groupdigits</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* process sign */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>my_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>my_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>new_str</name><index>[<expr><name>new_str_pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>my_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>my_str</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* process integer part of number */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>int_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* Time to insert separator? */</comment>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>--</operator><name>leading_digits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>new_str</name><index>[<expr><name>new_str_pos</name></expr>]</index></name></expr></argument>, <argument><expr><name>thousands_sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>new_str_pos</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>thousands_sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>leading_digits</name> <operator>=</operator> <name>groupdigits</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>new_str</name><index>[<expr><name>new_str_pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>my_str</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* handle decimal point if any */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>my_str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>new_str</name><index>[<expr><name>new_str_pos</name></expr>]</index></name></expr></argument>, <argument><expr><name>decimal_point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>new_str_pos</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>decimal_point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* copy the rest (fractional digits and/or exponent, and \0 terminator) */</comment>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>new_str</name><index>[<expr><name>new_str_pos</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* assert we didn't underestimate new_len (an overestimate is OK) */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>new_str</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>new_str</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * fputnbytes: print exactly N bytes to a file
 *
 * We avoid using %.*s here because it can misbehave if the data
 * is not valid in what libc thinks is the prevailing encoding.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fputnbytes</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <while>while <condition>(<expr><name>n</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>*</operator><name>str</name><operator>++</operator></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_separator</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>separator</name></name></type> <name>sep</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>sep</name><operator>.</operator><name>separator_zero</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\000'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>sep</name><operator>.</operator><name>separator</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>sep</name><operator>.</operator><name>separator</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Return the list of explicitly-requested footers or, when applicable, the
 * default "(xx rows)" footer.  Always omit the default footer when given
 * non-default footers, "\pset footer off", or a specific instruction to that
 * effect from a calling backslash command.  Vertical formats number each row,
 * making the default footer redundant; they do not call this function.
 *
 * The return value may point to static storage; do not keep it across calls.
 */</comment>
<function><type><specifier>static</specifier> <name>printTableFooter</name> <modifier>*</modifier></type>
<name>footers_with_default</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableContent</name> <modifier>*</modifier></type><name>cont</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>footers</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>default_footer</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>total_records</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>total_records</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>prior_records</name></name> <operator>+</operator> <name><name>cont</name><operator>-&gt;</operator><name>nrows</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>default_footer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>default_footer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                 <argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"(%lu row)"</literal></expr></argument>, <argument><expr><literal type="string">"(%lu rows)"</literal></expr></argument>, <argument><expr><name>total_records</name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><name>total_records</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><operator>&amp;</operator><name>default_footer_cell</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name><name>cont</name><operator>-&gt;</operator><name>footers</name></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************/</comment>
<comment type="block">/* Unaligned text         */</comment>
<comment type="block" format="doxygen">/*************************/</comment>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_unaligned_text</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableContent</name> <modifier>*</modifier></type><name>cont</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>opt_tuples_only</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>tuples_only</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_recordsep</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>start_table</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* print title */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>print_separator</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>recordSep</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* print headers */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>headers</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name><name>cont</name><operator>-&gt;</operator><name>headers</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>print_separator</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>fieldSep</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><name>need_recordsep</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <comment type="block">/* assume continuing printout */</comment>
        <expr_stmt><expr><name>need_recordsep</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* print cells */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>cells</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>need_recordsep</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>print_separator</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>recordSep</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>need_recordsep</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>print_separator</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>fieldSep</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>need_recordsep</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* print footers */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>stop_table</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>footers</name> <init>= <expr><call><name>footers_with_default</name><argument_list>(<argument><expr><name>cont</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name>footers</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cancel_pressed</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>f</name> <operator>=</operator> <name>footers</name></expr>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>need_recordsep</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>print_separator</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>recordSep</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>need_recordsep</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>need_recordsep</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * The last record is terminated by a newline, independent of the set
         * record separator.  But when the record separator is a zero byte, we
         * use that (compatible with find -print0 and xargs).
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>need_recordsep</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>recordSep</name><operator>.</operator><name>separator_zero</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>print_separator</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>recordSep</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_unaligned_vertical</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableContent</name> <modifier>*</modifier></type><name>cont</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>opt_tuples_only</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>tuples_only</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_recordsep</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>start_table</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* print title */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>need_recordsep</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <comment type="block">/* assume continuing printout */</comment>
        <expr_stmt><expr><name>need_recordsep</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* print records */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>cells</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>need_recordsep</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* record separator is 2 occurrences of recordsep in this mode */</comment>
            <expr_stmt><expr><call><name>print_separator</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>recordSep</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>print_separator</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>recordSep</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>need_recordsep</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>headers</name><index>[<expr><name>i</name> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>print_separator</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>fieldSep</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>print_separator</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>recordSep</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>need_recordsep</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>stop_table</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* print footers */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>footers</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cancel_pressed</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>print_separator</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>recordSep</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>f</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>footers</name></name></expr>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>print_separator</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>recordSep</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* see above in print_unaligned_text() */</comment>
        <if_stmt><if>if <condition>(<expr><name>need_recordsep</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>recordSep</name><operator>.</operator><name>separator_zero</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>print_separator</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>recordSep</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/********************/</comment>
<comment type="block">/* Aligned text        */</comment>
<comment type="block" format="doxygen">/********************/</comment>


<comment type="block">/* draw "line" */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_print_horizontal_line</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>ncolumns</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>widths</name></decl></parameter>,
                       <parameter><decl><type><name>unsigned</name> <name>short</name></type> <name>border</name></decl></parameter>, <parameter><decl><type><name>printTextRule</name></type> <name>pos</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>printTextFormat</name> <modifier>*</modifier></type><name>format</name></decl></parameter>,
                       <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>printTextLineFormat</name> <modifier>*</modifier></type><name>lformat</name> <init>= <expr><operator>&amp;</operator><name><name>format</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>border</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>lformat</name><operator>-&gt;</operator><name>hrule</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name><name>lformat</name><operator>-&gt;</operator><name>leftvrule</name></name></expr></argument>, <argument><expr><name><name>lformat</name><operator>-&gt;</operator><name>hrule</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncolumns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>widths</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>lformat</name><operator>-&gt;</operator><name>hrule</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>ncolumns</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>border</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s"</literal></expr></argument>, <argument><expr><name><name>lformat</name><operator>-&gt;</operator><name>hrule</name></name></expr></argument>,
                        <argument><expr><name><name>lformat</name><operator>-&gt;</operator><name>midvrule</name></name></expr></argument>, <argument><expr><name><name>lformat</name><operator>-&gt;</operator><name>hrule</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name><name>lformat</name><operator>-&gt;</operator><name>hrule</name></name></expr></argument>, <argument><expr><name><name>lformat</name><operator>-&gt;</operator><name>rightvrule</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>border</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>lformat</name><operator>-&gt;</operator><name>hrule</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *    Print pretty boxes around cells.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_aligned_text</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableContent</name> <modifier>*</modifier></type><name>cont</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pager</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>opt_tuples_only</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>tuples_only</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>encoding</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>encoding</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>opt_border</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>border</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>printTextFormat</name> <modifier>*</modifier></type><name>format</name> <init>= <expr><call><name>get_line_style</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>printTextLineFormat</name> <modifier>*</modifier></type><name>dformat</name> <init>= <expr><operator>&amp;</operator><name><name>format</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>PRINT_RULE_DATA</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>col_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>cell_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>width_header</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>max_width</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>width_wrap</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>width_average</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>max_nl_lines</name></decl>, <comment type="block">/* value split by newlines */</comment>
               <decl><type ref="prev"><modifier>*</modifier></type><name>curr_nl_line</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>max_bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>format_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>width_total</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>total_header_width</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>extra_row_output_lines</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>extra_output_lines</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>lineptr</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>col_lineptrs</name></decl>;</decl_stmt>    <comment type="block">/* pointers to line pointer per column */</comment>

    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>header_done</name></decl>;</decl_stmt>    <comment type="block">/* Have all header lines been output? */</comment>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>bytes_output</name></decl>;</decl_stmt>    <comment type="block">/* Bytes output for column value */</comment>
    <decl_stmt><decl><type><name>printTextLineWrap</name> <modifier>*</modifier></type><name>wrap</name></decl>;</decl_stmt>    <comment type="block">/* Wrap status for each column */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>output_columns</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Width of interactive console */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_local_pager</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>opt_border</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>col_count</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>width_header</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><name>col_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>width_header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>width_average</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><name>col_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>width_average</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>max_width</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><name>col_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>max_width</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>width_wrap</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><name>col_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>width_wrap</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>max_nl_lines</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><name>col_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>max_nl_lines</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>curr_nl_line</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><name>col_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>curr_nl_line</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>col_lineptrs</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><name>col_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>col_lineptrs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>max_bytes</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><name>col_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>max_bytes</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>format_buf</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><name>col_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>format_buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>header_done</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><name>col_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>header_done</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bytes_output</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><name>col_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>bytes_output</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>wrap</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><name>col_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>wrap</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>width_header</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>width_average</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>max_width</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>width_wrap</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>max_nl_lines</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>curr_nl_line</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>col_lineptrs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>max_bytes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>format_buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>header_done</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bytes_output</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>wrap</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* scan all column headers, find maximum width and max max_nl_lines */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>col_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>width</name></decl>,
                    <decl><type ref="prev"/><name>nl_lines</name></decl>,
                    <decl><type ref="prev"/><name>bytes_required</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>pg_wcssize</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>cont</name><operator>-&gt;</operator><name>headers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>headers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>width</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nl_lines</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_required</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>width</name> <operator>&gt;</operator> <name><name>max_width</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>max_width</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>width</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>nl_lines</name> <operator>&gt;</operator> <name><name>max_nl_lines</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>max_nl_lines</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>nl_lines</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>bytes_required</name> <operator>&gt;</operator> <name><name>max_bytes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>max_bytes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>bytes_required</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>nl_lines</name> <operator>&gt;</operator> <name>extra_row_output_lines</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>extra_row_output_lines</name> <operator>=</operator> <name>nl_lines</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>width_header</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>width</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* Add height of tallest header column */</comment>
    <expr_stmt><expr><name>extra_output_lines</name> <operator>+=</operator> <name>extra_row_output_lines</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>extra_row_output_lines</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* scan all cells, find maximum width, compute cell_count */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>cells</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>cell_count</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>width</name></decl>,
                    <decl><type ref="prev"/><name>nl_lines</name></decl>,
                    <decl><type ref="prev"/><name>bytes_required</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>pg_wcssize</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>encoding</name></expr></argument>,
                   <argument><expr><operator>&amp;</operator><name>width</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nl_lines</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_required</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>width</name> <operator>&gt;</operator> <name><name>max_width</name><index>[<expr><name>i</name> <operator>%</operator> <name>col_count</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>max_width</name><index>[<expr><name>i</name> <operator>%</operator> <name>col_count</name></expr>]</index></name> <operator>=</operator> <name>width</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>nl_lines</name> <operator>&gt;</operator> <name><name>max_nl_lines</name><index>[<expr><name>i</name> <operator>%</operator> <name>col_count</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>max_nl_lines</name><index>[<expr><name>i</name> <operator>%</operator> <name>col_count</name></expr>]</index></name> <operator>=</operator> <name>nl_lines</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>bytes_required</name> <operator>&gt;</operator> <name><name>max_bytes</name><index>[<expr><name>i</name> <operator>%</operator> <name>col_count</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>max_bytes</name><index>[<expr><name>i</name> <operator>%</operator> <name>col_count</name></expr>]</index></name> <operator>=</operator> <name>bytes_required</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>width_average</name><index>[<expr><name>i</name> <operator>%</operator> <name>col_count</name></expr>]</index></name> <operator>+=</operator> <name>width</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* If we have rows, compute average */</comment>
    <if_stmt><if>if <condition>(<expr><name>col_count</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cell_count</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>rows</name> <init>= <expr><name>cell_count</name> <operator>/</operator> <name>col_count</name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>col_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>width_average</name><index>[<expr><name>i</name></expr>]</index></name> <operator>/=</operator> <name>rows</name></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* adjust the total display width based on border style */</comment>
    <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>width_total</name> <operator>=</operator> <name>col_count</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>width_total</name> <operator>=</operator> <name>col_count</name> <operator>*</operator> <literal type="number">3</literal> <operator>-</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>col_count</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>width_total</name> <operator>=</operator> <name>col_count</name> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name>total_header_width</name> <operator>=</operator> <name>width_total</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>col_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>width_total</name> <operator>+=</operator> <name><name>max_width</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>total_header_width</name> <operator>+=</operator> <name><name>width_header</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * At this point: max_width[] contains the max width of each column,
     * max_nl_lines[] contains the max number of lines in each column,
     * max_bytes[] contains the maximum storage space for formatting strings,
     * width_total contains the giant width sum.  Now we allocate some memory
     * for line pointers.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>col_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* Add entry for ptr == NULL array termination */</comment>
        <expr_stmt><expr><name><name>col_lineptrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><operator>(</operator><name><name>max_nl_lines</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
                                     <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>col_lineptrs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>format_buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name><name>max_bytes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>col_lineptrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name> <operator>=</operator> <name><name>format_buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Default word wrap to the full width, i.e. no word wrap */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>col_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>width_wrap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>max_width</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/*
     * Choose target output width: \pset columns, or $COLUMNS, or ioctl
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>columns</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>output_columns</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>columns</name></name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name>fout</name> <operator>==</operator> <name>stdout</name> <operator>&amp;&amp;</operator> <call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <name>is_pager</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>env_columns</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>output_columns</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>env_columns</name></name></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TIOCGWINSZ</name></cpp:ifdef>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>winsize</name></name></type> <name>screen_size</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>ioctl</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TIOCGWINSZ</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>screen_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>output_columns</name> <operator>=</operator> <name><name>screen_size</name><operator>.</operator><name>ws_col</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>PRINT_WRAPPED</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Optional optimized word wrap. Shrink columns with a high max/avg
         * ratio.  Slightly bias against wider columns. (Increases chance a
         * narrow column will fit in its cell.)  If available columns is
         * positive...  and greater than the width of the unshrinkable column
         * headers
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>output_columns</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>output_columns</name> <operator>&gt;=</operator> <name>total_header_width</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* While there is still excess width... */</comment>
            <while>while <condition>(<expr><name>width_total</name> <operator>&gt;</operator> <name>output_columns</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>double</name></type>        <name>max_ratio</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>worst_col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

                <comment type="block">/*
                 * Find column that has the highest ratio of its maximum width
                 * compared to its average width.  This tells us which column
                 * will produce the fewest wrapped values if shortened.
                 * width_wrap starts as equal to max_width.
                 */</comment>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>col_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>width_average</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>width_wrap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>width_header</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Penalize wide columns by 1% of their width */</comment>
                        <decl_stmt><decl><type><name>double</name></type>        <name>ratio</name></decl>;</decl_stmt>

                        <expr_stmt><expr><name>ratio</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>width_wrap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>/</operator> <name><name>width_average</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator>
                            <name><name>max_width</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">0.01</literal></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>ratio</name> <operator>&gt;</operator> <name>max_ratio</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>max_ratio</name> <operator>=</operator> <name>ratio</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>worst_col</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>

                <comment type="block">/* Exit loop if we can't squeeze any more. */</comment>
                <if_stmt><if>if <condition>(<expr><name>worst_col</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <comment type="block">/* Decrease width of target column by one. */</comment>
                <expr_stmt><expr><name><name>width_wrap</name><index>[<expr><name>worst_col</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>width_total</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If in expanded auto mode, we have now calculated the expected width, so
     * we can now escape to vertical mode if necessary.  If the output has
     * only one column, the expanded format would be wider than the regular
     * format, so don't use it in that case.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>expanded</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>output_columns</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>output_columns</name> <operator>&lt;</operator> <name>total_header_width</name> <operator>||</operator> <name>output_columns</name> <operator>&lt;</operator> <name>width_total</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>print_aligned_vertical</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>, <argument><expr><name>is_pager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If we wrapped beyond the display width, use the pager */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_pager</name> <operator>&amp;&amp;</operator> <name>fout</name> <operator>==</operator> <name>stdout</name> <operator>&amp;&amp;</operator> <name>output_columns</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>output_columns</name> <operator>&lt;</operator> <name>total_header_width</name> <operator>||</operator> <name>output_columns</name> <operator>&lt;</operator> <name>width_total</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>fout</name> <operator>=</operator> <call><name>PageOutput</name><argument_list>(<argument><expr><name>INT_MAX</name></expr></argument>, <argument><expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* force pager */</comment>
        <expr_stmt><expr><name>is_pager</name> <operator>=</operator> <name>is_local_pager</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check if newlines or our wrapping now need the pager */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_pager</name> <operator>&amp;&amp;</operator> <name>fout</name> <operator>==</operator> <name>stdout</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* scan all cells, find maximum width, compute cell_count */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>cells</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr><operator>,</operator> <expr><name>cell_count</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>width</name></decl>,
                        <decl><type ref="prev"/><name>nl_lines</name></decl>,
                        <decl><type ref="prev"/><name>bytes_required</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>pg_wcssize</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>encoding</name></expr></argument>,
                       <argument><expr><operator>&amp;</operator><name>width</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nl_lines</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_required</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * A row can have both wrapping and newlines that cause it to
             * display across multiple lines.  We check for both cases below.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>width</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>width_wrap</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>extra_lines</name></decl>;</decl_stmt>

                <comment type="block">/* don't count the first line of nl_lines - it's not "extra" */</comment>
                <expr_stmt><expr><name>extra_lines</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>width</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name><name>width_wrap</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>+</operator> <name>nl_lines</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>extra_lines</name> <operator>&gt;</operator> <name>extra_row_output_lines</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>extra_row_output_lines</name> <operator>=</operator> <name>extra_lines</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* i is the current column number: increment with wrap */</comment>
            <if_stmt><if>if <condition>(<expr><operator>++</operator><name>i</name> <operator>&gt;=</operator> <name>col_count</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <comment type="block">/* At last column of each row, add tallest column height */</comment>
                <expr_stmt><expr><name>extra_output_lines</name> <operator>+=</operator> <name>extra_row_output_lines</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>extra_row_output_lines</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>IsPagerNeeded</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name>extra_output_lines</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_pager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>is_local_pager</name> <operator>=</operator> <name>is_pager</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* time to output */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>start_table</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* print title */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>opt_tuples_only</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>width</name></decl>,
                        <decl><type ref="prev"/><name>height</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>pg_wcssize</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>width</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>height</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>width</name> <operator>&gt;=</operator> <name>width_total</name></expr>)</condition><block type="pseudo"><block_content>
                <comment type="block">/* Aligned */</comment>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <comment type="block">/* Centered */</comment>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%-*s%s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>width_total</name> <operator>-</operator> <name>width</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
                        <argument><expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* print headers */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>more_col_wrapping</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>curr_nl_line</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>_print_horizontal_line</name><argument_list>(<argument><expr><name>col_count</name></expr></argument>, <argument><expr><name>width_wrap</name></expr></argument>, <argument><expr><name>opt_border</name></expr></argument>,
                                       <argument><expr><name>PRINT_RULE_TOP</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>col_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pg_wcsformat</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>cont</name><operator>-&gt;</operator><name>headers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                             <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>headers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>encoding</name></expr></argument>,
                             <argument><expr><name><name>col_lineptrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>max_nl_lines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

            <expr_stmt><expr><name>more_col_wrapping</name> <operator>=</operator> <name>col_count</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>curr_nl_line</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>header_done</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>col_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>more_col_wrapping</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>dformat</name><operator>-&gt;</operator><name>leftvrule</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>struct</name> <name>lineptr</name></name> <modifier>*</modifier></type><name>this_line</name> <init>= <expr><name><name>col_lineptrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>curr_nl_line</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nbspace</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
                        <operator>(</operator><operator>!</operator><name><name>format</name><operator>-&gt;</operator><name>wrap_right_border</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><ternary><condition><expr><name>curr_nl_line</name></expr> ?</condition><then> <expr><name><name>format</name><operator>-&gt;</operator><name>header_nl_left</name></name></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></argument>,
                              <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>header_done</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>nbspace</name> <operator>=</operator> <name><name>width_wrap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>this_line</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>

                        <comment type="block">/* centered */</comment>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%-*s%s%-*s"</literal></expr></argument>,
                                <argument><expr><name>nbspace</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>this_line</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>nbspace</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>this_line</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>ptr</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>more_col_wrapping</name><operator>--</operator></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>header_done</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name><name>width_wrap</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>format</name><operator>-&gt;</operator><name>wrap_right_border</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><ternary><condition><expr><operator>!</operator><name><name>header_done</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>format</name><operator>-&gt;</operator><name>header_nl_right</name></name></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></argument>,
                              <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>col_count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>col_count</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>dformat</name><operator>-&gt;</operator><name>midvrule</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><name>curr_nl_line</name><operator>++</operator></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>dformat</name><operator>-&gt;</operator><name>rightvrule</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>

            <expr_stmt><expr><call><name>_print_horizontal_line</name><argument_list>(<argument><expr><name>col_count</name></expr></argument>, <argument><expr><name>width_wrap</name></expr></argument>, <argument><expr><name>opt_border</name></expr></argument>,
                                   <argument><expr><name>PRINT_RULE_MIDDLE</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* print cells, one loop per row */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>cells</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>col_count</name></expr><operator>,</operator> <expr><name>ptr</name> <operator>+=</operator> <name>col_count</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>more_lines</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Format each cell.
         */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>col_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pg_wcsformat</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>ptr</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>ptr</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>encoding</name></expr></argument>,
                         <argument><expr><name><name>col_lineptrs</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>max_nl_lines</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>curr_nl_line</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bytes_output</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>col_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Each time through this loop, one display line is output. It can
         * either be a full value or a partial value if embedded newlines
         * exist or if 'format=wrapping' mode is enabled.
         */</comment>
        <do>do
        <block>{<block_content>
            <expr_stmt><expr><name>more_lines</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            <comment type="block">/* left border */</comment>
            <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>dformat</name><operator>-&gt;</operator><name>leftvrule</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* for each column */</comment>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>col_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <comment type="block">/* We have a valid array element, so index it */</comment>
                <decl_stmt><decl><type><name><name>struct</name> <name>lineptr</name></name> <modifier>*</modifier></type><name>this_line</name> <init>= <expr><operator>&amp;</operator><name><name>col_lineptrs</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><name><name>curr_nl_line</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>bytes_to_output</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>chars_to_output</name> <init>= <expr><name><name>width_wrap</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name>finalspaces</name> <init>= <expr><operator>(</operator><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal> <operator>||</operator>
                                           <operator>(</operator><name>col_count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>col_count</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

                <comment type="block">/* Print left-hand wrap or newline mark */</comment>
                <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>wrap</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>PRINT_LINE_WRAP_WRAP</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>format</name><operator>-&gt;</operator><name>wrap_left</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>wrap</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>PRINT_LINE_WRAP_NEWLINE</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>format</name><operator>-&gt;</operator><name>nl_left</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>this_line</name><operator>-&gt;</operator><name>ptr</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Past newline lines so just pad for other columns */</comment>
                    <if_stmt><if>if <condition>(<expr><name>finalspaces</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>chars_to_output</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Get strlen() of the characters up to width_wrap */</comment>
                    <expr_stmt><expr><name>bytes_to_output</name> <operator>=</operator>
                        <call><name>strlen_max_width</name><argument_list>(<argument><expr><name><name>this_line</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+</operator> <name><name>bytes_output</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>chars_to_output</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * If we exceeded width_wrap, it means the display width
                     * of a single character was wider than our target width.
                     * In that case, we have to pretend we are only printing
                     * the target display width and make the best of it.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>chars_to_output</name> <operator>&gt;</operator> <name><name>width_wrap</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>chars_to_output</name> <operator>=</operator> <name><name>width_wrap</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>aligns</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition> <comment type="block">/* Right aligned cell */</comment>
                    <block>{<block_content>
                        <comment type="block">/* spaces first */</comment>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name><name>width_wrap</name><index>[<expr><name>j</name></expr>]</index></name> <operator>-</operator> <name>chars_to_output</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>fputnbytes</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
                                   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>this_line</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+</operator> <name><name>bytes_output</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr></argument>,
                                   <argument><expr><name>bytes_to_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else        <comment type="block">/* Left aligned cell */</comment>
                    <block>{<block_content>
                        <comment type="block">/* spaces second */</comment>
                        <expr_stmt><expr><call><name>fputnbytes</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
                                   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>this_line</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+</operator> <name><name>bytes_output</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr></argument>,
                                   <argument><expr><name>bytes_to_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <expr_stmt><expr><name><name>bytes_output</name><index>[<expr><name>j</name></expr>]</index></name> <operator>+=</operator> <name>bytes_to_output</name></expr>;</expr_stmt>

                    <comment type="block">/* Do we have more text to wrap? */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name><name>this_line</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+</operator> <name><name>bytes_output</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>more_lines</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/* Advance to next newline line */</comment>
                        <expr_stmt><expr><name><name>curr_nl_line</name><index>[<expr><name>j</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>col_lineptrs</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><name><name>curr_nl_line</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>more_lines</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name><name>bytes_output</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>

                <comment type="block">/* Determine next line's wrap status for this column */</comment>
                <expr_stmt><expr><name><name>wrap</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>PRINT_LINE_WRAP_NONE</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>col_lineptrs</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><name><name>curr_nl_line</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>bytes_output</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>wrap</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>PRINT_LINE_WRAP_WRAP</name></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>curr_nl_line</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>wrap</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>PRINT_LINE_WRAP_NEWLINE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * If left-aligned, pad out remaining space if needed (not
                 * last column, and/or wrap marks required).
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>aligns</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'r'</literal></expr>)</condition> <comment type="block">/* Left aligned cell */</comment>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>finalspaces</name> <operator>||</operator>
                        <name><name>wrap</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>PRINT_LINE_WRAP_WRAP</name> <operator>||</operator>
                        <name><name>wrap</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>PRINT_LINE_WRAP_NEWLINE</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>,
                                <argument><expr><name><name>width_wrap</name><index>[<expr><name>j</name></expr>]</index></name> <operator>-</operator> <name>chars_to_output</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Print right-hand wrap or newline mark */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>wrap</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>PRINT_LINE_WRAP_WRAP</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>format</name><operator>-&gt;</operator><name>wrap_right</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name><name>wrap</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>PRINT_LINE_WRAP_NEWLINE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>format</name><operator>-&gt;</operator><name>nl_right</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal> <operator>||</operator> <operator>(</operator><name>col_count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>col_count</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* Print column divider, if not the last column */</comment>
                <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>col_count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>col_count</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>wrap</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>PRINT_LINE_WRAP_WRAP</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>format</name><operator>-&gt;</operator><name>midvrule_wrap</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>wrap</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>PRINT_LINE_WRAP_NEWLINE</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>format</name><operator>-&gt;</operator><name>midvrule_nl</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>col_lineptrs</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name><name>curr_nl_line</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>format</name><operator>-&gt;</operator><name>midvrule_blank</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>dformat</name><operator>-&gt;</operator><name>midvrule</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="block">/* end-of-row border */</comment>
            <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>dformat</name><operator>-&gt;</operator><name>rightvrule</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        </block_content>}</block> while <condition>(<expr><name>more_lines</name></expr>)</condition>;</do>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>stop_table</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>footers</name> <init>= <expr><call><name>footers_with_default</name><argument_list>(<argument><expr><name>cont</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>_print_horizontal_line</name><argument_list>(<argument><expr><name>col_count</name></expr></argument>, <argument><expr><name>width_wrap</name></expr></argument>, <argument><expr><name>opt_border</name></expr></argument>,
                                   <argument><expr><name>PRINT_RULE_BOTTOM</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* print footers */</comment>
        <if_stmt><if>if <condition>(<expr><name>footers</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cancel_pressed</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>f</name> <operator>=</operator> <name>footers</name></expr>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<label><name>cleanup</name>:</label>
    <comment type="block">/* clean up */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>col_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>col_lineptrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>format_buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>width_header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>width_average</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>max_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>width_wrap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>max_nl_lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>curr_nl_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>col_lineptrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>max_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>format_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>header_done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bytes_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wrap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>is_local_pager</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ClosePager</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_aligned_vertical_line</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTextFormat</name> <modifier>*</modifier></type><name>format</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>short</name></type> <name>opt_border</name></decl></parameter>,
                            <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>record</name></decl></parameter>,
                            <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hwidth</name></decl></parameter>,
                            <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>dwidth</name></decl></parameter>,
                            <parameter><decl><type><name>printTextRule</name></type> <name>pos</name></decl></parameter>,
                            <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>printTextLineFormat</name> <modifier>*</modifier></type><name>lformat</name> <init>= <expr><operator>&amp;</operator><name><name>format</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>reclen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name><name>lformat</name><operator>-&gt;</operator><name>leftvrule</name></name></expr></argument>, <argument><expr><name><name>lformat</name><operator>-&gt;</operator><name>hrule</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>lformat</name><operator>-&gt;</operator><name>hrule</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>record</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>reclen</name> <operator>=</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"* Record %lu"</literal></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>reclen</name> <operator>=</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"[ RECORD %lu ]"</literal></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>reclen</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>reclen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>reclen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>reclen</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>hwidth</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><ternary><condition><expr><name>opt_border</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>lformat</name><operator>-&gt;</operator><name>hrule</name></name></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name>reclen</name> <operator>-=</operator> <name>hwidth</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>reclen</name><operator>--</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>lformat</name><operator>-&gt;</operator><name>hrule</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>reclen</name><operator>--</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>lformat</name><operator>-&gt;</operator><name>midvrule</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>reclen</name><operator>--</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>lformat</name><operator>-&gt;</operator><name>hrule</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>reclen</name><operator>--</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>reclen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>reclen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>reclen</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dwidth</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><ternary><condition><expr><name>opt_border</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>lformat</name><operator>-&gt;</operator><name>hrule</name></name></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name><name>lformat</name><operator>-&gt;</operator><name>hrule</name></name></expr></argument>, <argument><expr><name><name>lformat</name><operator>-&gt;</operator><name>rightvrule</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_aligned_vertical</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableContent</name> <modifier>*</modifier></type><name>cont</name></decl></parameter>,
                       <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pager</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>opt_tuples_only</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>tuples_only</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>opt_border</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>border</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>printTextFormat</name> <modifier>*</modifier></type><name>format</name> <init>= <expr><call><name>get_line_style</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>printTextLineFormat</name> <modifier>*</modifier></type><name>dformat</name> <init>= <expr><operator>&amp;</operator><name><name>format</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>PRINT_RULE_DATA</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>encoding</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>encoding</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>record</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>prior_records</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>,
                <decl><type ref="prev"/><name>hwidth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>dwidth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>hheight</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>dheight</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>hformatsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>dformatsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>lineptr</name></name> <modifier>*</modifier></type><name>hlineptr</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>dlineptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_local_pager</name> <init>= <expr><name>false</name></expr></init></decl>,
                <decl><type ref="prev"/><name>hmultiline</name> <init>= <expr><name>false</name></expr></init></decl>,
                <decl><type ref="prev"/><name>dmultiline</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>output_columns</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Width of interactive console */</comment>

    <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>opt_border</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>cells</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>start_table</name></name> <operator>&amp;&amp;</operator>
        <name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>stop_table</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>footers</name> <init>= <expr><call><name>footers_with_default</name><argument_list>(<argument><expr><name>cont</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cancel_pressed</name> <operator>&amp;&amp;</operator> <name>footers</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>f</name> <operator>=</operator> <name>footers</name></expr>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Deal with the pager here instead of in printTable(), because we could
     * get here via print_aligned_text() in expanded auto mode, and so we have
     * to recalculate the pager requirement based on vertical output.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_pager</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>IsPagerNeeded</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_pager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>is_local_pager</name> <operator>=</operator> <name>is_pager</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Find the maximum dimensions for the headers */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>width</name></decl>,
                    <decl><type ref="prev"/><name>height</name></decl>,
                    <decl><type ref="prev"/><name>fs</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>pg_wcssize</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>cont</name><operator>-&gt;</operator><name>headers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>headers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>width</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>height</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>width</name> <operator>&gt;</operator> <name>hwidth</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>hwidth</name> <operator>=</operator> <name>width</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>height</name> <operator>&gt;</operator> <name>hheight</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>hheight</name> <operator>=</operator> <name>height</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>hmultiline</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>fs</name> <operator>&gt;</operator> <name>hformatsize</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>hformatsize</name> <operator>=</operator> <name>fs</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* find longest data cell */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>cells</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>width</name></decl>,
                    <decl><type ref="prev"/><name>height</name></decl>,
                    <decl><type ref="prev"/><name>fs</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>pg_wcssize</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>encoding</name></expr></argument>,
                   <argument><expr><operator>&amp;</operator><name>width</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>height</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>width</name> <operator>&gt;</operator> <name>dwidth</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>dwidth</name> <operator>=</operator> <name>width</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>height</name> <operator>&gt;</operator> <name>dheight</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>dheight</name> <operator>=</operator> <name>height</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>dmultiline</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>fs</name> <operator>&gt;</operator> <name>dformatsize</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>dformatsize</name> <operator>=</operator> <name>fs</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * We now have all the information we need to setup the formatting
     * structures
     */</comment>
    <expr_stmt><expr><name>dlineptr</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>dlineptr</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>*</operator> <operator>(</operator><name>dheight</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hlineptr</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>hlineptr</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>*</operator> <operator>(</operator><name>hheight</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>dlineptr</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>dformatsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hlineptr</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>hformatsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>start_table</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* print title */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Choose target output width: \pset columns, or $COLUMNS, or ioctl
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>columns</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>output_columns</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>columns</name></name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name>fout</name> <operator>==</operator> <name>stdout</name> <operator>&amp;&amp;</operator> <call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <name>is_pager</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>env_columns</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>output_columns</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>env_columns</name></name></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TIOCGWINSZ</name></cpp:ifdef>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>winsize</name></name></type> <name>screen_size</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>ioctl</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TIOCGWINSZ</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>screen_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>output_columns</name> <operator>=</operator> <name><name>screen_size</name><operator>.</operator><name>ws_col</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Calculate available width for data in wrapped mode
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>PRINT_WRAPPED</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>swidth</name></decl>,
                    <decl><type ref="prev"/><name>rwidth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                    <decl><type ref="prev"/><name>newdwidth</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * For border = 0, one space in the middle.  (If we discover we
             * need to wrap, the spacer column will be replaced by a wrap
             * marker, and we'll make room below for another wrap marker at
             * the end of the line.  But for now, assume no wrap is needed.)
             */</comment>
            <expr_stmt><expr><name>swidth</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

            <comment type="block">/* We might need a column for header newline markers, too */</comment>
            <if_stmt><if>if <condition>(<expr><name>hmultiline</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>swidth</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * For border = 1, two spaces and a vrule in the middle.  (As
             * above, we might need one more column for a wrap marker.)
             */</comment>
            <expr_stmt><expr><name>swidth</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

            <comment type="block">/* We might need a column for left header newline markers, too */</comment>
            <if_stmt><if>if <condition>(<expr><name>hmultiline</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>format</name> <operator>==</operator> <operator>&amp;</operator><name>pg_asciiformat_old</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>swidth</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * For border = 2, two more for the vrules at the beginning and
             * end of the lines, plus spacer columns adjacent to these.  (We
             * won't need extra columns for wrap/newline markers, we'll just
             * repurpose the spacers.)
             */</comment>
            <expr_stmt><expr><name>swidth</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Reserve a column for data newline indicators, too, if needed */</comment>
        <if_stmt><if>if <condition>(<expr><name>dmultiline</name> <operator>&amp;&amp;</operator>
            <name>opt_border</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>format</name> <operator>!=</operator> <operator>&amp;</operator><name>pg_asciiformat_old</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>swidth</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Determine width required for record header lines */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>nrows</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>rwidth</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>log10</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>nrows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>rwidth</name> <operator>+=</operator> <literal type="number">9</literal></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* "* RECORD " */</comment>
            <if type="elseif">else if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>rwidth</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* "-[ RECORD  ]" */</comment>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>rwidth</name> <operator>+=</operator> <literal type="number">15</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>    <comment type="block">/* "+-[ RECORD  ]-+" */</comment>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* We might need to do the rest of the calculation twice */</comment>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>width</name></decl>;</decl_stmt>

            <comment type="block">/* Total width required to not wrap data */</comment>
            <expr_stmt><expr><name>width</name> <operator>=</operator> <name>hwidth</name> <operator>+</operator> <name>swidth</name> <operator>+</operator> <name>dwidth</name></expr>;</expr_stmt>
            <comment type="block">/* ... and not the header lines, either */</comment>
            <if_stmt><if>if <condition>(<expr><name>width</name> <operator>&lt;</operator> <name>rwidth</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>width</name> <operator>=</operator> <name>rwidth</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>output_columns</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>min_width</name></decl>;</decl_stmt>

                <comment type="block">/* Minimum acceptable width: room for just 3 columns of data */</comment>
                <expr_stmt><expr><name>min_width</name> <operator>=</operator> <name>hwidth</name> <operator>+</operator> <name>swidth</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
                <comment type="block">/* ... but not less than what the record header lines need */</comment>
                <if_stmt><if>if <condition>(<expr><name>min_width</name> <operator>&lt;</operator> <name>rwidth</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>min_width</name> <operator>=</operator> <name>rwidth</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>output_columns</name> <operator>&gt;=</operator> <name>width</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Plenty of room, use native data width */</comment>
                    <comment type="block">/* (but at least enough for the record header lines) */</comment>
                    <expr_stmt><expr><name>newdwidth</name> <operator>=</operator> <name>width</name> <operator>-</operator> <name>hwidth</name> <operator>-</operator> <name>swidth</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>output_columns</name> <operator>&lt;</operator> <name>min_width</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Set data width to match min_width */</comment>
                    <expr_stmt><expr><name>newdwidth</name> <operator>=</operator> <name>min_width</name> <operator>-</operator> <name>hwidth</name> <operator>-</operator> <name>swidth</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Set data width to match output_columns */</comment>
                    <expr_stmt><expr><name>newdwidth</name> <operator>=</operator> <name>output_columns</name> <operator>-</operator> <name>hwidth</name> <operator>-</operator> <name>swidth</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Don't know the wrap limit, so use native data width */</comment>
                <comment type="block">/* (but at least enough for the record header lines) */</comment>
                <expr_stmt><expr><name>newdwidth</name> <operator>=</operator> <name>width</name> <operator>-</operator> <name>hwidth</name> <operator>-</operator> <name>swidth</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * If we will need to wrap data and didn't already allocate a data
             * newline/wrap marker column, do so and recompute.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>newdwidth</name> <operator>&lt;</operator> <name>dwidth</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>dmultiline</name> <operator>&amp;&amp;</operator>
                <name>opt_border</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>format</name> <operator>!=</operator> <operator>&amp;</operator><name>pg_asciiformat_old</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>dmultiline</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>swidth</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <break>break;</break></block_content></block></else></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>dwidth</name> <operator>=</operator> <name>newdwidth</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* print records */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>cells</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>printTextRule</name></type> <name>pos</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>dline</name></decl>,
                    <decl><type ref="prev"/><name>hline</name></decl>,
                    <decl><type ref="prev"/><name>dcomplete</name></decl>,
                    <decl><type ref="prev"/><name>hcomplete</name></decl>,
                    <decl><type ref="prev"/><name>offset</name></decl>,
                    <decl><type ref="prev"/><name>chars_to_output</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>pos</name> <operator>=</operator> <name>PRINT_RULE_TOP</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>pos</name> <operator>=</operator> <name>PRINT_RULE_MIDDLE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* Print record header (e.g. "[ RECORD N ]") above each record */</comment>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>lhwidth</name> <init>= <expr><name>hwidth</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>opt_border</name> <operator>&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator>
                <operator>(</operator><name>hmultiline</name><operator>)</operator> <operator>&amp;&amp;</operator>
                <operator>(</operator><name>format</name> <operator>==</operator> <operator>&amp;</operator><name>pg_asciiformat_old</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>lhwidth</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>        <comment type="block">/* for newline indicators */</comment>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>print_aligned_vertical_line</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>opt_border</name></expr></argument>, <argument><expr><name>record</name><operator>++</operator></expr></argument>,
                                            <argument><expr><name>lhwidth</name></expr></argument>, <argument><expr><name>dwidth</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>start_table</name></name> <operator>||</operator> <name>opt_border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>print_aligned_vertical_line</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>opt_border</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lhwidth</name></expr></argument>,
                                            <argument><expr><name>dwidth</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Format the header */</comment>
        <expr_stmt><expr><call><name>pg_wcsformat</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>cont</name><operator>-&gt;</operator><name>headers</name><index>[<expr><name>i</name> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>]</index></name></expr></argument>,
                     <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>headers</name><index>[<expr><name>i</name> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>hlineptr</name></expr></argument>, <argument><expr><name>hheight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Format the data */</comment>
        <expr_stmt><expr><call><name>pg_wcsformat</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>encoding</name></expr></argument>,
                     <argument><expr><name>dlineptr</name></expr></argument>, <argument><expr><name>dheight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Loop through header and data in parallel dealing with newlines and
         * wrapped lines until they're both exhausted
         */</comment>
        <expr_stmt><expr><name>dline</name> <operator>=</operator> <name>hline</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>dcomplete</name> <operator>=</operator> <name>hcomplete</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>chars_to_output</name> <operator>=</operator> <name><name>dlineptr</name><index>[<expr><name>dline</name></expr>]</index></name><operator>.</operator><name>width</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>!</operator><name>dcomplete</name> <operator>||</operator> <operator>!</operator><name>hcomplete</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Left border */</comment>
            <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>dformat</name><operator>-&gt;</operator><name>leftvrule</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Header (never wrapped so just need to deal with newlines) */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>hcomplete</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>swidth</name> <init>= <expr><name>hwidth</name></expr></init></decl>,
                            <decl><type ref="prev"/><name>target_width</name> <init>= <expr><name>hwidth</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/*
                 * Left spacer or new line indicator
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator> <operator>||</operator>
                    <operator>(</operator><name>hmultiline</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>format</name> <operator>==</operator> <operator>&amp;</operator><name>pg_asciiformat_old</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><ternary><condition><expr><name>hline</name></expr> ?</condition><then> <expr><name><name>format</name><operator>-&gt;</operator><name>header_nl_left</name></name></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * Header text
                 */</comment>
                <expr_stmt><expr><call><name>strlen_max_width</name><argument_list>(<argument><expr><name><name>hlineptr</name><index>[<expr><name>hline</name></expr>]</index></name><operator>.</operator><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_width</name></expr></argument>,
                                 <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%-s"</literal></expr></argument>, <argument><expr><name><name>hlineptr</name><index>[<expr><name>hline</name></expr>]</index></name><operator>.</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Spacer
                 */</comment>
                <expr_stmt><expr><name>swidth</name> <operator>-=</operator> <name>target_width</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>swidth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>swidth</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * New line indicator or separator's space
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>hlineptr</name><index>[<expr><name>hline</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ptr</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* More lines after this one due to a newline */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>opt_border</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                        <operator>(</operator><name>hmultiline</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>format</name> <operator>!=</operator> <operator>&amp;</operator><name>pg_asciiformat_old</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>format</name><operator>-&gt;</operator><name>header_nl_right</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>hline</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* This was the last line of the header */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>opt_border</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                        <operator>(</operator><name>hmultiline</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>format</name> <operator>!=</operator> <operator>&amp;</operator><name>pg_asciiformat_old</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>hcomplete</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>swidth</name> <init>= <expr><name>hwidth</name> <operator>+</operator> <name>opt_border</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>opt_border</name> <operator>&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator>
                    <operator>(</operator><name>hmultiline</name><operator>)</operator> <operator>&amp;&amp;</operator>
                    <operator>(</operator><name>format</name> <operator>==</operator> <operator>&amp;</operator><name>pg_asciiformat_old</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>swidth</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>opt_border</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
                    <operator>(</operator><name>format</name> <operator>!=</operator> <operator>&amp;</operator><name>pg_asciiformat_old</name><operator>)</operator> <operator>&amp;&amp;</operator>
                    <operator>(</operator><name>hmultiline</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>swidth</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>swidth</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* Separator */</comment>
            <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>offset</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>format</name><operator>-&gt;</operator><name>midvrule_wrap</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name>dline</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>dformat</name><operator>-&gt;</operator><name>midvrule</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>format</name><operator>-&gt;</operator><name>midvrule_nl</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Data */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dcomplete</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>target_width</name> <init>= <expr><name>dwidth</name></expr></init></decl>,
                            <decl><type ref="prev"/><name>bytes_to_output</name></decl>,
                            <decl><type ref="prev"/><name>swidth</name> <init>= <expr><name>dwidth</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/*
                 * Left spacer or wrap indicator
                 */</comment>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><ternary><condition><expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><name><name>format</name><operator>-&gt;</operator><name>wrap_left</name></name></expr></else></ternary></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Data text
                 */</comment>
                <expr_stmt><expr><name>bytes_to_output</name> <operator>=</operator> <call><name>strlen_max_width</name><argument_list>(<argument><expr><name><name>dlineptr</name><index>[<expr><name>dline</name></expr>]</index></name><operator>.</operator><name>ptr</name> <operator>+</operator> <name>offset</name></expr></argument>,
                                                   <argument><expr><operator>&amp;</operator><name>target_width</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputnbytes</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>dlineptr</name><index>[<expr><name>dline</name></expr>]</index></name><operator>.</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>,
                           <argument><expr><name>bytes_to_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>chars_to_output</name> <operator>-=</operator> <name>target_width</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>bytes_to_output</name></expr>;</expr_stmt>

                <comment type="block">/* Spacer */</comment>
                <expr_stmt><expr><name>swidth</name> <operator>-=</operator> <name>target_width</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>chars_to_output</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* continuing a wrapped column */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>opt_border</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
                        <operator>(</operator><name>dmultiline</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>format</name> <operator>!=</operator> <operator>&amp;</operator><name>pg_asciiformat_old</name><operator>)</operator><operator>)</operator></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>swidth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>swidth</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>format</name><operator>-&gt;</operator><name>wrap_right</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name><name>dlineptr</name><index>[<expr><name>dline</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ptr</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* reached a newline in the column */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>opt_border</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
                        <operator>(</operator><name>dmultiline</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>format</name> <operator>!=</operator> <operator>&amp;</operator><name>pg_asciiformat_old</name><operator>)</operator><operator>)</operator></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>swidth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>swidth</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>format</name><operator>-&gt;</operator><name>nl_right</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>dline</name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>chars_to_output</name> <operator>=</operator> <name><name>dlineptr</name><index>[<expr><name>dline</name></expr>]</index></name><operator>.</operator><name>width</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* reached the end of the cell */</comment>
                    <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>swidth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>swidth</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>dcomplete</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <comment type="block">/* Right border */</comment>
                <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>dformat</name><operator>-&gt;</operator><name>rightvrule</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * data exhausted (this can occur if header is longer than the
                 * data due to newlines in the header)
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%*s  %s\n"</literal></expr></argument>, <argument><expr><name>dwidth</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>dformat</name><operator>-&gt;</operator><name>rightvrule</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>stop_table</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>print_aligned_vertical_line</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>opt_border</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hwidth</name></expr></argument>, <argument><expr><name>dwidth</name></expr></argument>,
                                        <argument><expr><name>PRINT_RULE_BOTTOM</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* print footers */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>footers</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cancel_pressed</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <for>for <control>(<init><expr><name>f</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>footers</name></name></expr>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>hlineptr</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dlineptr</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>hlineptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dlineptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>is_local_pager</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ClosePager</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************/</comment>
<comment type="block">/* HTML printing ******/</comment>
<comment type="block" format="doxygen">/**********************/</comment>


<function><type><name>void</name></type>
<name>html_escaped_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>leading_space</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>in</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'&amp;'</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&amp;amp;"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'&lt;'</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&amp;lt;"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'&gt;'</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&amp;gt;"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'\n'</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&lt;br /&gt;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'"'</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&amp;quot;"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">' '</literal></expr>:</case>
                <comment type="block">/* protect leading space, for EXPLAIN output */</comment>
                <if_stmt><if>if <condition>(<expr><name>leading_space</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&amp;nbsp;"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>leading_space</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_html_text</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableContent</name> <modifier>*</modifier></type><name>cont</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>opt_tuples_only</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>tuples_only</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>opt_border</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>border</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opt_table_attr</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>tableAttr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>start_table</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"&lt;table border=\"%d\""</literal></expr></argument>, <argument><expr><name>opt_border</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>opt_table_attr</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>opt_table_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&gt;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* print title */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"  &lt;caption&gt;"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>html_escaped_print</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&lt;/caption&gt;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* print headers */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"  &lt;tr&gt;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>headers</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"    &lt;th align=\"center\"&gt;"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>html_escaped_print</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&lt;/th&gt;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"  &lt;/tr&gt;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* print cells */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>cells</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"  &lt;tr valign=\"top\"&gt;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"    &lt;td align=\"%s\"&gt;"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>cont</name><operator>-&gt;</operator><name>aligns</name><index>[<expr><operator>(</operator><name>i</name><operator>)</operator> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr> ?</condition><then> <expr><literal type="string">"right"</literal></expr> </then><else>: <expr><literal type="string">"left"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* is string only whitespace? */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><index>[<expr><call><name>strspn</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="string">" \t"</literal></expr></argument>)</argument_list></call></expr>]</index> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&amp;nbsp; "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>html_escaped_print</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&lt;/td&gt;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"  &lt;/tr&gt;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>stop_table</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>footers</name> <init>= <expr><call><name>footers_with_default</name><argument_list>(<argument><expr><name>cont</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&lt;/table&gt;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* print footers */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name>footers</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cancel_pressed</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&lt;p&gt;"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>f</name> <operator>=</operator> <name>footers</name></expr>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>html_escaped_print</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&lt;br /&gt;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&lt;/p&gt;"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_html_vertical</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableContent</name> <modifier>*</modifier></type><name>cont</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>opt_tuples_only</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>tuples_only</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>opt_border</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>border</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opt_table_attr</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>tableAttr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>record</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>prior_records</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>start_table</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"&lt;table border=\"%d\""</literal></expr></argument>, <argument><expr><name>opt_border</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>opt_table_attr</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>opt_table_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&gt;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* print title */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"  &lt;caption&gt;"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>html_escaped_print</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&lt;/caption&gt;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* print records */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>cells</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
                        <argument><expr><literal type="string">"\n  &lt;tr&gt;&lt;td colspan=\"2\" align=\"center\"&gt;Record %lu&lt;/td&gt;&lt;/tr&gt;\n"</literal></expr></argument>,
                        <argument><expr><name>record</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n  &lt;tr&gt;&lt;td colspan=\"2\"&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"  &lt;tr valign=\"top\"&gt;\n"</literal>
              <literal type="string">"    &lt;th&gt;"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>html_escaped_print</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>headers</name><index>[<expr><name>i</name> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&lt;/th&gt;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"    &lt;td align=\"%s\"&gt;"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>cont</name><operator>-&gt;</operator><name>aligns</name><index>[<expr><name>i</name> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr> ?</condition><then> <expr><literal type="string">"right"</literal></expr> </then><else>: <expr><literal type="string">"left"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* is string only whitespace? */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><index>[<expr><call><name>strspn</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="string">" \t"</literal></expr></argument>)</argument_list></call></expr>]</index> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&amp;nbsp; "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>html_escaped_print</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&lt;/td&gt;\n  &lt;/tr&gt;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>stop_table</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&lt;/table&gt;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* print footers */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>footers</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cancel_pressed</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&lt;p&gt;"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>f</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>footers</name></name></expr>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>html_escaped_print</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&lt;br /&gt;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&lt;/p&gt;"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************/</comment>
<comment type="block">/* ASCIIDOC         */</comment>
<comment type="block" format="doxygen">/*************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>asciidoc_escaped_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>in</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'|'</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\|"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_asciidoc_text</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableContent</name> <modifier>*</modifier></type><name>cont</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>opt_tuples_only</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>tuples_only</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>opt_border</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>border</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>start_table</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* print table in new paragraph - enforce preliminary new line */</comment>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* print title */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* print table [] header definition */</comment>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"[%scols=\""</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>!</operator><name>opt_tuples_only</name></expr> ?</condition><then> <expr><literal type="string">"options=\"header\","</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>cont</name><operator>-&gt;</operator><name>aligns</name><index>[<expr><operator>(</operator><name>i</name><operator>)</operator> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr> ?</condition><then> <expr><literal type="string">"&gt;l"</literal></expr> </then><else>: <expr><literal type="string">"&lt;l"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>opt_border</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="number">0</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">",frame=\"none\",grid=\"none\""</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">1</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">",frame=\"none\""</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">2</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">",frame=\"all\",grid=\"all\""</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"]\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"|====\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* print headers */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>headers</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name><name>cont</name><operator>-&gt;</operator><name>headers</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"^l|"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>asciidoc_escaped_print</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* print cells */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>cells</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"|"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* protect against needless spaces */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><index>[<expr><call><name>strspn</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="string">" \t"</literal></expr></argument>)</argument_list></call></expr>]</index> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>asciidoc_escaped_print</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"|====\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>stop_table</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>footers</name> <init>= <expr><call><name>footers_with_default</name><argument_list>(<argument><expr><name>cont</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* print footers */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name>footers</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cancel_pressed</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n....\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>f</name> <operator>=</operator> <name>footers</name></expr>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"....\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_asciidoc_vertical</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableContent</name> <modifier>*</modifier></type><name>cont</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>opt_tuples_only</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>tuples_only</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>opt_border</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>border</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>record</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>prior_records</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>start_table</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* print table in new paragraph - enforce preliminary new line */</comment>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* print title */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* print table [] header definition */</comment>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"[cols=\"h,l\""</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>opt_border</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="number">0</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">",frame=\"none\",grid=\"none\""</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">1</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">",frame=\"none\""</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">2</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">",frame=\"all\",grid=\"all\""</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"]\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"|====\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* print records */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>cells</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
                        <argument><expr><literal type="string">"2+^|Record %lu\n"</literal></expr></argument>,
                        <argument><expr><name>record</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"2+|\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"&lt;l|"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>asciidoc_escaped_print</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>headers</name><index>[<expr><name>i</name> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">" %s|"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>cont</name><operator>-&gt;</operator><name>aligns</name><index>[<expr><name>i</name> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr> ?</condition><then> <expr><literal type="string">"&gt;l"</literal></expr> </then><else>: <expr><literal type="string">"&lt;l"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* is string only whitespace? */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><index>[<expr><call><name>strspn</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="string">" \t"</literal></expr></argument>)</argument_list></call></expr>]</index> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>asciidoc_escaped_print</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"|====\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>stop_table</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* print footers */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>footers</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cancel_pressed</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n....\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>f</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>footers</name></name></expr>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"....\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*************************/</comment>
<comment type="block">/* LaTeX                 */</comment>
<comment type="block" format="doxygen">/*************************/</comment>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>latex_escaped_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>in</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'&amp;'</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\&amp;"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'%'</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\%"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'$'</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\$"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'_'</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\_"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'{'</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\{"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'}'</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\}"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'\\'</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\backslash"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'\n'</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\\\"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch></block_content></block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_latex_text</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableContent</name> <modifier>*</modifier></type><name>cont</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>opt_tuples_only</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>tuples_only</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>opt_border</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>border</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>opt_border</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>start_table</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* print title */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\begin{center}\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>latex_escaped_print</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n\\end{center}\n\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* begin environment and set alignments and borders */</comment>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\begin{tabular}{"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"| "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name><name>cont</name><operator>-&gt;</operator><name>aligns</name></name> <operator>+</operator> <name>i</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" | "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" |"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"}\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name>opt_border</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\hline\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* print headers */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>headers</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" &amp; "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\textit{"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>latex_escaped_print</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'}'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" \\\\\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\hline\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* print cells */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>cells</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>latex_escaped_print</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" \\\\\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\hline\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" &amp; "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>stop_table</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>footers</name> <init>= <expr><call><name>footers_with_default</name><argument_list>(<argument><expr><name>cont</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\hline\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\end{tabular}\n\n\\noindent "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* print footers */</comment>
        <if_stmt><if>if <condition>(<expr><name>footers</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cancel_pressed</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>f</name> <operator>=</operator> <name>footers</name></expr>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>latex_escaped_print</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" \\\\\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_latex_longtable_text</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableContent</name> <modifier>*</modifier></type><name>cont</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>opt_tuples_only</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>tuples_only</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>opt_border</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>border</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opt_table_attr</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>tableAttr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next_opt_table_attr_char</name> <init>= <expr><name>opt_table_attr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>last_opt_table_attr_char</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>opt_border</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>start_table</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* begin environment and set alignments and borders */</comment>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\begin{longtable}{"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"| "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* longtable supports either a width (p) or an alignment (l/r) */</comment>
            <comment type="block">/* Are we left-justified and was a proportional width specified? */</comment>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name><name>cont</name><operator>-&gt;</operator><name>aligns</name></name> <operator>+</operator> <name>i</name><operator>)</operator> <operator>==</operator> <literal type="char">'l'</literal> <operator>&amp;&amp;</operator> <name>opt_table_attr</name></expr>)</condition>
            <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONGTABLE_WHITESPACE</name></cpp:macro>    <cpp:value>" \t\n"</cpp:value></cpp:define>

                <comment type="block">/* advance over whitespace */</comment>
                <expr_stmt><expr><name>next_opt_table_attr_char</name> <operator>+=</operator> <call><name>strspn</name><argument_list>(<argument><expr><name>next_opt_table_attr_char</name></expr></argument>,
                                                   <argument><expr><name>LONGTABLE_WHITESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* We have a value? */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>next_opt_table_attr_char</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"p{"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>next_opt_table_attr_char</name></expr></argument>, <argument><expr><call><name>strcspn</name><argument_list>(<argument><expr><name>next_opt_table_attr_char</name></expr></argument>,
                                                             <argument><expr><name>LONGTABLE_WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>last_opt_table_attr_char</name> <operator>=</operator> <name>next_opt_table_attr_char</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>next_opt_table_attr_char</name> <operator>+=</operator> <call><name>strcspn</name><argument_list>(<argument><expr><name>next_opt_table_attr_char</name></expr></argument>,
                                                        <argument><expr><name>LONGTABLE_WHITESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\textwidth}"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="block">/* use previous value */</comment>
                <if type="elseif">else if <condition>(<expr><name>last_opt_table_attr_char</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"p{"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>last_opt_table_attr_char</name></expr></argument>, <argument><expr><call><name>strcspn</name><argument_list>(<argument><expr><name>last_opt_table_attr_char</name></expr></argument>,
                                                             <argument><expr><name>LONGTABLE_WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\textwidth}"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'l'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name><name>cont</name><operator>-&gt;</operator><name>aligns</name></name> <operator>+</operator> <name>i</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" | "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" |"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"}\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* print headers */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* firsthead */</comment>
            <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\toprule\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>headers</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" &amp; "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\small\\textbf{\\textit{"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>latex_escaped_print</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"}}"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" \\\\\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\midrule\n\\endfirsthead\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* secondary heads */</comment>
            <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\toprule\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>headers</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" &amp; "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\small\\textbf{\\textit{"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>latex_escaped_print</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"}}"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" \\\\\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* If the line under the row already appeared, don't do another */</comment>
            <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\midrule\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\endhead\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* table name, caption? */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Don't output if we are printing a line under each row */</comment>
                <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\bottomrule\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\caption["</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>latex_escaped_print</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" (Continued)]{"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>latex_escaped_print</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"}\n\\endfoot\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\bottomrule\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\caption["</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>latex_escaped_print</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"]{"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>latex_escaped_print</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"}\n\\endlastfoot\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="block">/* output bottom table line? */</comment>
            <if type="elseif">else if <condition>(<expr><name>opt_border</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\bottomrule\n\\endfoot\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\bottomrule\n\\endlastfoot\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* print cells */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>cells</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* Add a line under each row? */</comment>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n&amp;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\raggedright{"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>latex_escaped_print</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'}'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" \\tabularnewline\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" \\hline\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>stop_table</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\end{longtable}\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_latex_vertical</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableContent</name> <modifier>*</modifier></type><name>cont</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>opt_tuples_only</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>tuples_only</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>opt_border</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>border</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>record</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>prior_records</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>opt_border</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>start_table</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* print title */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\begin{center}\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>latex_escaped_print</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n\\end{center}\n\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* begin environment and set alignments and borders */</comment>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\begin{tabular}{"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"cl"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"c|l"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"|c|l|"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"}\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* print records */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>cells</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* new record */</comment>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\hline\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"\\multicolumn{2}{|c|}{\\textit{Record %lu}} \\\\\n"</literal></expr></argument>, <argument><expr><name>record</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"\\multicolumn{2}{c}{\\textit{Record %lu}} \\\\\n"</literal></expr></argument>, <argument><expr><name>record</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\hline\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>latex_escaped_print</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>headers</name><index>[<expr><name>i</name> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" &amp; "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>latex_escaped_print</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" \\\\\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>stop_table</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\hline\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\end{tabular}\n\n\\noindent "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* print footers */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>footers</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cancel_pressed</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>f</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>footers</name></name></expr>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>latex_escaped_print</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" \\\\\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************/</comment>
<comment type="block">/* Troff -ms         */</comment>
<comment type="block" format="doxygen">/*************************/</comment>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>troff_ms_escaped_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>in</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'\\'</literal></expr>:</case>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\(rs"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch></block_content></block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_troff_ms_text</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableContent</name> <modifier>*</modifier></type><name>cont</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>opt_tuples_only</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>tuples_only</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>opt_border</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>border</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>opt_border</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>start_table</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* print title */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">".LP\n.DS C\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>troff_ms_escaped_print</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n.DE\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* begin environment and set alignments and borders */</comment>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">".LP\n.TS\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"center box;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"center;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name><name>cont</name><operator>-&gt;</operator><name>aligns</name></name> <operator>+</operator> <name>i</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" | "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">".\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* print headers */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>headers</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\t'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\fI"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>troff_ms_escaped_print</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\fP"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n_\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* print cells */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>cells</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>troff_ms_escaped_print</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\t'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>stop_table</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>footers</name> <init>= <expr><call><name>footers_with_default</name><argument_list>(<argument><expr><name>cont</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">".TE\n.DS L\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* print footers */</comment>
        <if_stmt><if>if <condition>(<expr><name>footers</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cancel_pressed</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>f</name> <operator>=</operator> <name>footers</name></expr>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>troff_ms_escaped_print</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">".DE\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_troff_ms_vertical</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableContent</name> <modifier>*</modifier></type><name>cont</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>opt_tuples_only</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>tuples_only</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>opt_border</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>border</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>record</name> <init>= <expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>prior_records</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>current_format</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* 0=none, 1=header, 2=body */</comment>

    <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>opt_border</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>start_table</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* print title */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">".LP\n.DS C\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>troff_ms_escaped_print</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n.DE\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* begin environment and set alignments and borders */</comment>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">".LP\n.TS\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"center box;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"center;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* basic format */</comment>
        <if_stmt><if>if <condition>(<expr><name>opt_tuples_only</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"c l;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>current_format</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>        <comment type="block">/* assume tuples printed already */</comment>

    <comment type="block">/* print records */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>cells</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* new record */</comment>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>current_format</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>record</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"_\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name>current_format</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">".T&amp;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"c s.\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>current_format</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"\\fIRecord %lu\\fP\n"</literal></expr></argument>, <argument><expr><name>record</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"_\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_tuples_only</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>current_format</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>current_format</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">".T&amp;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>opt_border</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"c l.\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"c | l.\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><name>current_format</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>troff_ms_escaped_print</name><argument_list>(<argument><expr><name><name>cont</name><operator>-&gt;</operator><name>headers</name><index>[<expr><name>i</name> <operator>%</operator> <name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\t'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>troff_ms_escaped_print</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>stop_table</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">".TE\n.DS L\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* print footers */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>footers</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>opt_tuples_only</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cancel_pressed</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>f</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>footers</name></name></expr>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>troff_ms_escaped_print</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">".DE\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/********************************/</comment>
<comment type="block">/* Public functions                */</comment>
<comment type="block" format="doxygen">/********************************/</comment>


<comment type="block">/*
 * disable_sigpipe_trap
 *
 * Turn off SIGPIPE interrupt --- call this before writing to a temporary
 * query output file that is a pipe.
 *
 * No-op on Windows, where there's no SIGPIPE interrupts.
 */</comment>
<function><type><name>void</name></type>
<name>disable_sigpipe_trap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * restore_sigpipe_trap
 *
 * Restore normal SIGPIPE interrupt --- call this when done writing to a
 * temporary query output file that was (or might have been) a pipe.
 *
 * Note: within psql, we enable SIGPIPE interrupts unless the permanent query
 * output file is a pipe, in which case they should be kept off.  This
 * approach works only because psql is not currently complicated enough to
 * have nested usages of short-lived output files.  Otherwise we'd probably
 * need a genuine save-and-restore-state approach; but for now, that would be
 * useless complication.  In non-psql programs, this always enables SIGPIPE.
 *
 * No-op on Windows, where there's no SIGPIPE interrupts.
 */</comment>
<function><type><name>void</name></type>
<name>restore_sigpipe_trap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><ternary><condition><expr><name>always_ignore_sigpipe</name></expr> ?</condition><then> <expr><name>SIG_IGN</name></expr> </then><else>: <expr><name>SIG_DFL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * set_sigpipe_trap_state
 *
 * Set the trap state that restore_sigpipe_trap should restore to.
 */</comment>
<function><type><name>void</name></type>
<name>set_sigpipe_trap_state</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>ignore</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>always_ignore_sigpipe</name> <operator>=</operator> <name>ignore</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PageOutput
 *
 * Tests if pager is needed and returns appropriate FILE pointer.
 *
 * If the topt argument is NULL no pager is used.
 */</comment>
<function><type><name>FILE</name> <modifier>*</modifier></type>
<name>PageOutput</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lines</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>printTableOpt</name> <modifier>*</modifier></type><name>topt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* check whether we need / can / are supposed to use pager */</comment>
    <if_stmt><if>if <condition>(<expr><name>topt</name> <operator>&amp;&amp;</operator> <name><name>topt</name><operator>-&gt;</operator><name>pager</name></name> <operator>&amp;&amp;</operator> <call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TIOCGWINSZ</name></cpp:ifdef>
        <decl_stmt><decl><type><name>unsigned</name> <name>short</name> <name>int</name></type> <name>pager</name> <init>= <expr><name><name>topt</name><operator>-&gt;</operator><name>pager</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>min_lines</name> <init>= <expr><name><name>topt</name><operator>-&gt;</operator><name>pager_min_lines</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>winsize</name></name></type> <name>screen_size</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ioctl</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TIOCGWINSZ</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>screen_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* &gt;= accounts for a one-line prompt */</comment>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal>
            <operator>||</operator> <operator>(</operator><name>lines</name> <operator>&gt;=</operator> <name><name>screen_size</name><operator>.</operator><name>ws_row</name></name> <operator>&amp;&amp;</operator> <name>lines</name> <operator>&gt;=</operator> <name>min_lines</name><operator>)</operator>
            <operator>||</operator> <name>pager</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pagerprog</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>pagerpipe</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>pagerprog</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PAGER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pagerprog</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>pagerprog</name> <operator>=</operator> <name>DEFAULT_PAGER</name></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* if PAGER is empty or all-white-space, don't use pager */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name>pagerprog</name></expr></argument>, <argument><expr><literal type="string">" \t\r\n"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pagerprog</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>stdout</name></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>disable_sigpipe_trap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pagerpipe</name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name>pagerprog</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>pagerpipe</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>pagerpipe</name></expr>;</return></block_content></block></if></if_stmt>
            <comment type="block">/* if popen fails, silently proceed without pager */</comment>
            <expr_stmt><expr><call><name>restore_sigpipe_trap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>stdout</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ClosePager
 *
 * Close previously opened pager pipe, if any
 */</comment>
<function><type><name>void</name></type>
<name>ClosePager</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pagerpipe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>pagerpipe</name> <operator>&amp;&amp;</operator> <name>pagerpipe</name> <operator>!=</operator> <name>stdout</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If printing was canceled midstream, warn about it.
         *
         * Some pagers like less use Ctrl-C as part of their command set. Even
         * so, we abort our processing and warn the user what we did.  If the
         * pager quit as a result of the SIGINT, this message won't go
         * anywhere ...
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pagerpipe</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Interrupted\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>pclose</name><argument_list>(<argument><expr><name>pagerpipe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>restore_sigpipe_trap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialise a table contents struct.
 *        Must be called before any other printTable method is used.
 *
 * The title is not duplicated; the caller must ensure that the buffer
 * is available for the lifetime of the printTableContent struct.
 *
 * If you call this, you must call printTableCleanup once you're done with the
 * table.
 */</comment>
<function><type><name>void</name></type>
<name>printTableInit</name><parameter_list>(<parameter><decl><type><name>printTableContent</name> <modifier>*</modifier><specifier>const</specifier></type> <name>content</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>printTableOpt</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
               <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>title</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>ncolumns</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>opt</name></name> <operator>=</operator> <name>opt</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>title</name></name> <operator>=</operator> <name>title</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>=</operator> <name>ncolumns</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>nrows</name></name> <operator>=</operator> <name>nrows</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>headers</name></name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><operator>(</operator><name>ncolumns</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>content</name><operator>-&gt;</operator><name>headers</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>cells</name></name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><operator>(</operator><name>ncolumns</name> <operator>*</operator> <name>nrows</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>content</name><operator>-&gt;</operator><name>cells</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>cellmustfree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>footers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>aligns</name></name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><operator>(</operator><name>ncolumns</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>content</name><operator>-&gt;</operator><name>align</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <name><name>content</name><operator>-&gt;</operator><name>headers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>cell</name></name> <operator>=</operator> <name><name>content</name><operator>-&gt;</operator><name>cells</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>footer</name></name> <operator>=</operator> <name><name>content</name><operator>-&gt;</operator><name>footers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>align</name></name> <operator>=</operator> <name><name>content</name><operator>-&gt;</operator><name>aligns</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>cellsadded</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a header to the table.
 *
 * Headers are not duplicated; you must ensure that the header string is
 * available for the lifetime of the printTableContent struct.
 *
 * If translate is true, the function will pass the header through gettext.
 * Otherwise, the header will not be translated.
 *
 * align is either 'l' or 'r', and specifies the alignment for cells in this
 * column.
 */</comment>
<function><type><name>void</name></type>
<name>printTableAddHeader</name><parameter_list>(<parameter><decl><type><name>printTableContent</name> <modifier>*</modifier><specifier>const</specifier></type> <name>content</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>header</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>translate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>align</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ENABLE_NLS</name></cpp:ifndef>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>translate</name></expr>;</expr_stmt>            <comment type="block">/* unused parameter */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name><name>content</name><operator>-&gt;</operator><name>header</name></name> <operator>&gt;=</operator> <name><name>content</name><operator>-&gt;</operator><name>headers</name></name> <operator>+</operator> <name><name>content</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Cannot add header to table content: "</literal>
                          <literal type="string">"column count of %d exceeded.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name><name>content</name><operator>-&gt;</operator><name>ncolumns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name><name>content</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>mbvalidate</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>header</name></expr></argument>,
                                           <argument><expr><name><name>content</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_NLS</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>translate</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name><name>content</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><operator>*</operator><name><name>content</name><operator>-&gt;</operator><name>header</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>header</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name><name>content</name><operator>-&gt;</operator><name>align</name></name> <operator>=</operator> <name>align</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>align</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a cell to the table.
 *
 * Cells are not duplicated; you must ensure that the cell string is available
 * for the lifetime of the printTableContent struct.
 *
 * If translate is true, the function will pass the cell through gettext.
 * Otherwise, the cell will not be translated.
 *
 * If mustfree is true, the cell string is freed by printTableCleanup().
 * Note: Automatic freeing of translatable strings is not supported.
 */</comment>
<function><type><name>void</name></type>
<name>printTableAddCell</name><parameter_list>(<parameter><decl><type><name>printTableContent</name> <modifier>*</modifier><specifier>const</specifier></type> <name>content</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cell</name></decl></parameter>,
                  <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>translate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>mustfree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ENABLE_NLS</name></cpp:ifndef>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>translate</name></expr>;</expr_stmt>            <comment type="block">/* unused parameter */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name><name>content</name><operator>-&gt;</operator><name>cellsadded</name></name> <operator>&gt;=</operator> <name><name>content</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>*</operator> <name><name>content</name><operator>-&gt;</operator><name>nrows</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Cannot add cell to table content: "</literal>
                          <literal type="string">"total cell count of %d exceeded.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name><name>content</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>*</operator> <name><name>content</name><operator>-&gt;</operator><name>nrows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name><name>content</name><operator>-&gt;</operator><name>cell</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>mbvalidate</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>cell</name></expr></argument>,
                                         <argument><expr><name><name>content</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_NLS</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>translate</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name><name>content</name><operator>-&gt;</operator><name>cell</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><operator>*</operator><name><name>content</name><operator>-&gt;</operator><name>cell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>mustfree</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>content</name><operator>-&gt;</operator><name>cellmustfree</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>cellmustfree</name></name> <operator>=</operator>
                <call><name>pg_malloc0</name><argument_list>(<argument><expr><operator>(</operator><name><name>content</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>*</operator> <name><name>content</name><operator>-&gt;</operator><name>nrows</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>cellmustfree</name><index>[<expr><name><name>content</name><operator>-&gt;</operator><name>cellsadded</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>cell</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>cellsadded</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a footer to the table.
 *
 * Footers are added as elements of a singly-linked list, and the content is
 * strdup'd, so there is no need to keep the original footer string around.
 *
 * Footers are never translated by the function.  If you want the footer
 * translated you must do so yourself, before calling printTableAddFooter.  The
 * reason this works differently to headers and cells is that footers tend to
 * be made of up individually translated components, rather than being
 * translated as a whole.
 */</comment>
<function><type><name>void</name></type>
<name>printTableAddFooter</name><parameter_list>(<parameter><decl><type><name>printTableContent</name> <modifier>*</modifier><specifier>const</specifier></type> <name>content</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>footer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>f</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>footer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>content</name><operator>-&gt;</operator><name>footers</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>footers</name></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>footer</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>footer</name></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Change the content of the last-added footer.
 *
 * The current contents of the last-added footer are freed, and replaced by the
 * content given in *footer.  If there was no previous footer, add a new one.
 *
 * The content is strdup'd, so there is no need to keep the original string
 * around.
 */</comment>
<function><type><name>void</name></type>
<name>printTableSetFooter</name><parameter_list>(<parameter><decl><type><name>printTableContent</name> <modifier>*</modifier><specifier>const</specifier></type> <name>content</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>footer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>content</name><operator>-&gt;</operator><name>footers</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>content</name><operator>-&gt;</operator><name>footer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>footer</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>footer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><name>footer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Free all memory allocated to this struct.
 *
 * Once this has been called, the struct is unusable unless you pass it to
 * printTableInit() again.
 */</comment>
<function><type><name>void</name></type>
<name>printTableCleanup</name><parameter_list>(<parameter><decl><type><name>printTableContent</name> <modifier>*</modifier><specifier>const</specifier></type> <name>content</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>content</name><operator>-&gt;</operator><name>cellmustfree</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>content</name><operator>-&gt;</operator><name>nrows</name></name> <operator>*</operator> <name><name>content</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>content</name><operator>-&gt;</operator><name>cellmustfree</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>content</name><operator>-&gt;</operator><name>cells</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>content</name><operator>-&gt;</operator><name>cellmustfree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>cellmustfree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>content</name><operator>-&gt;</operator><name>headers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>content</name><operator>-&gt;</operator><name>cells</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>content</name><operator>-&gt;</operator><name>aligns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>opt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>title</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>headers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>cells</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>aligns</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>cell</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>align</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>content</name><operator>-&gt;</operator><name>footers</name></name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name><name>content</name><operator>-&gt;</operator><name>footer</name></name> <operator>=</operator> <name><name>content</name><operator>-&gt;</operator><name>footers</name></name></expr>;</init> <condition><expr><name><name>content</name><operator>-&gt;</operator><name>footer</name></name></expr>;</condition><incr/>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>f</name> <operator>=</operator> <name><name>content</name><operator>-&gt;</operator><name>footer</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>footer</name></name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>footers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>footer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * IsPagerNeeded
 *
 * Setup pager if required
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>IsPagerNeeded</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableContent</name> <modifier>*</modifier></type><name>cont</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>extra_lines</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>expanded</name></decl></parameter>,
              <parameter><decl><type><name>FILE</name> <modifier>*</modifier><modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_pager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>fout</name> <operator>==</operator> <name>stdout</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>lines</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>expanded</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>lines</name> <operator>=</operator> <operator>(</operator><name><name>cont</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>cont</name><operator>-&gt;</operator><name>nrows</name></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>lines</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>nrows</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>tuples_only</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>printTableFooter</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

            <comment type="block">/*
             * FIXME -- this is slightly bogus: it counts the number of
             * footers, not the number of lines in them.
             */</comment>
            <for>for <control>(<init><expr><name>f</name> <operator>=</operator> <name><name>cont</name><operator>-&gt;</operator><name>footers</name></name></expr>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name>lines</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><operator>*</operator><name>fout</name> <operator>=</operator> <call><name>PageOutput</name><argument_list>(<argument><expr><name>lines</name> <operator>+</operator> <name>extra_lines</name></expr></argument>, <argument><expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>is_pager</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>fout</name> <operator>!=</operator> <name>stdout</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>is_pager</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Use this to print any table in the supported formats.
 *
 * cont: table data and formatting options
 * fout: where to print to
 * is_pager: true if caller has already redirected fout to be a pager pipe
 * flog: if not null, also print the table there (for --log-file option)
 */</comment>
<function><type><name>void</name></type>
<name>printTable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableContent</name> <modifier>*</modifier></type><name>cont</name></decl></parameter>,
           <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pager</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>flog</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_local_pager</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>PRINT_NOTHING</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* print_aligned_*() handle the pager themselves */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_pager</name> <operator>&amp;&amp;</operator>
        <name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>format</name></name> <operator>!=</operator> <name>PRINT_ALIGNED</name> <operator>&amp;&amp;</operator>
        <name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>format</name></name> <operator>!=</operator> <name>PRINT_WRAPPED</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>IsPagerNeeded</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>expanded</name></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_pager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>is_local_pager</name> <operator>=</operator> <name>is_pager</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* print the stuff */</comment>

    <if_stmt><if>if <condition>(<expr><name>flog</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>print_aligned_text</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name>flog</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <switch>switch <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>format</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PRINT_UNALIGNED</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>expanded</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>print_unaligned_vertical</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>print_unaligned_text</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>PRINT_ALIGNED</name></expr>:</case>
        <case>case <expr><name>PRINT_WRAPPED</name></expr>:</case>

            <comment type="block">/*
             * In expanded-auto mode, force vertical if a pager is passed in;
             * else we may make different decisions for different hunks of the
             * query result.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>expanded</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator>
                <operator>(</operator><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>expanded</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>is_pager</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>print_aligned_vertical</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>, <argument><expr><name>is_pager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>print_aligned_text</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>, <argument><expr><name>is_pager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>PRINT_HTML</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>expanded</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>print_html_vertical</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>print_html_text</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>PRINT_ASCIIDOC</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>expanded</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>print_asciidoc_vertical</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>print_asciidoc_text</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>PRINT_LATEX</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>expanded</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>print_latex_vertical</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>print_latex_text</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>PRINT_LATEX_LONGTABLE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>expanded</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>print_latex_vertical</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>print_latex_longtable_text</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>PRINT_TROFF_MS</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>expanded</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>print_troff_ms_vertical</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>print_troff_ms_text</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid output format (internal error): %d"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name><name>cont</name><operator>-&gt;</operator><name>opt</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name>is_local_pager</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ClosePager</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Use this to print query results
 *
 * result: result of a successful query
 * opt: formatting options
 * fout: where to print to
 * is_pager: true if caller has already redirected fout to be a pager pipe
 * flog: if not null, also print the data there (for --log-file option)
 */</comment>
<function><type><name>void</name></type>
<name>printQuery</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>printQueryOpt</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
           <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pager</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>flog</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>printTableContent</name></type> <name>cont</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>r</name></decl>,
                <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>printTableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>topt</name></name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>title</name></name></expr></argument>,
                   <argument><expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Assert caller supplied enough translate_columns[] entries */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>translate_columns</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
           <name><name>opt</name><operator>-&gt;</operator><name>n_translate_columns</name></name> <operator>&gt;=</operator> <name><name>cont</name><operator>.</operator><name>ncolumns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cont</name><operator>.</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQfname</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>translate_header</name></name></expr></argument>,
                            <argument><expr><call><name>column_type_alignment</name><argument_list>(<argument><expr><call><name>PQftype</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* set cells */</comment>
    <for>for <control>(<init><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>r</name> <operator>&lt;</operator> <name><name>cont</name><operator>.</operator><name>nrows</name></name></expr>;</condition> <incr><expr><name>r</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name><name>cont</name><operator>.</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>mustfree</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>translate</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>cell</name> <operator>=</operator> <ternary><condition><expr><name><name>opt</name><operator>-&gt;</operator><name>nullPrint</name></name></expr> ?</condition><then> <expr><name><name>opt</name><operator>-&gt;</operator><name>nullPrint</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>cell</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>.</operator><name>aligns</name><index>[<expr><name>c</name></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>topt</name><operator>.</operator><name>numericLocale</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>cell</name> <operator>=</operator> <call><name>format_numeric_locale</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>mustfree</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>translate</name> <operator>=</operator> <operator>(</operator><name><name>opt</name><operator>-&gt;</operator><name>translate_columns</name></name> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>translate_columns</name><index>[<expr><name>c</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>, <argument><expr><name>translate</name></expr></argument>, <argument><expr><name>mustfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <comment type="block">/* set footers */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>footers</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>footer</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>footer</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>footers</name></name></expr>;</init> <condition><expr><operator>*</operator><name>footer</name></expr>;</condition> <incr><expr><name>footer</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><operator>*</operator><name>footer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>printTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>, <argument><expr><name>is_pager</name></expr></argument>, <argument><expr><name>flog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printTableCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>char</name></type>
<name>column_type_alignment</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>ftype</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name>align</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>ftype</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>INT2OID</name></expr>:</case>
        <case>case <expr><name>INT4OID</name></expr>:</case>
        <case>case <expr><name>INT8OID</name></expr>:</case>
        <case>case <expr><name>FLOAT4OID</name></expr>:</case>
        <case>case <expr><name>FLOAT8OID</name></expr>:</case>
        <case>case <expr><name>NUMERICOID</name></expr>:</case>
        <case>case <expr><name>OIDOID</name></expr>:</case>
        <case>case <expr><name>XIDOID</name></expr>:</case>
        <case>case <expr><name>CIDOID</name></expr>:</case>
        <case>case <expr><name>CASHOID</name></expr>:</case>
            <expr_stmt><expr><name>align</name> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><name>align</name> <operator>=</operator> <literal type="char">'l'</literal></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><name>align</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>setDecimalLocale</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>lconv</name></name> <modifier>*</modifier></type><name>extlconv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>extlconv</name> <operator>=</operator> <call><name>localeconv</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Don't accept an empty decimal_point string */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>extlconv</name><operator>-&gt;</operator><name>decimal_point</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>decimal_point</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>extlconv</name><operator>-&gt;</operator><name>decimal_point</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>decimal_point</name> <operator>=</operator> <literal type="string">"."</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>    <comment type="block">/* SQL output standard */</comment>

    <comment type="block">/*
     * Although the Open Group standard allows locales to supply more than one
     * group width, we consider only the first one, and we ignore any attempt
     * to suppress grouping by specifying CHAR_MAX.  As in the backend's
     * cash.c, we must apply a range check to avoid being fooled by variant
     * CHAR_MAX values.
     */</comment>
    <expr_stmt><expr><name>groupdigits</name> <operator>=</operator> <operator>*</operator><name><name>extlconv</name><operator>-&gt;</operator><name>grouping</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>groupdigits</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>groupdigits</name> <operator>&gt;</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>groupdigits</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>        <comment type="block">/* most common */</comment>

    <comment type="block">/* Don't accept an empty thousands_sep string, either */</comment>
    <comment type="block">/* similar code exists in formatting.c */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>extlconv</name><operator>-&gt;</operator><name>thousands_sep</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>thousands_sep</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>extlconv</name><operator>-&gt;</operator><name>thousands_sep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <comment type="block">/* Make sure thousands separator doesn't match decimal point symbol. */</comment>
    <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>decimal_point</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>thousands_sep</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>thousands_sep</name> <operator>=</operator> <literal type="string">"."</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* get selected or default line style */</comment>
<function><type><specifier>const</specifier> <name>printTextFormat</name> <modifier>*</modifier></type>
<name>get_line_style</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableOpt</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Note: this function mainly exists to preserve the convention that a
     * printTableOpt struct can be initialized to zeroes to get default
     * behavior.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>line_style</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>opt</name><operator>-&gt;</operator><name>line_style</name></name></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><operator>&amp;</operator><name>pg_asciiformat</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>refresh_utf8format</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>printTableOpt</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>printTextFormat</name> <modifier>*</modifier></type><name>popt</name> <init>= <expr><operator>&amp;</operator><name>pg_utf8format</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>unicodeStyleBorderFormat</name> <modifier>*</modifier></type><name>border</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unicodeStyleRowFormat</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unicodeStyleColumnFormat</name> <modifier>*</modifier></type><name>column</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <literal type="string">"unicode"</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>border</name> <operator>=</operator> <operator>&amp;</operator><name><name>unicode_style</name><operator>.</operator><name>border_style</name><index>[<expr><name><name>opt</name><operator>-&gt;</operator><name>unicode_border_linestyle</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>header</name> <operator>=</operator> <operator>&amp;</operator><name><name>unicode_style</name><operator>.</operator><name>row_style</name><index>[<expr><name><name>opt</name><operator>-&gt;</operator><name>unicode_header_linestyle</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>column</name> <operator>=</operator> <operator>&amp;</operator><name><name>unicode_style</name><operator>.</operator><name>column_style</name><index>[<expr><name><name>opt</name><operator>-&gt;</operator><name>unicode_column_linestyle</name></name></expr>]</index></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>PRINT_RULE_TOP</name></expr>]</index></name><operator>.</operator><name>hrule</name> <operator>=</operator> <name><name>border</name><operator>-&gt;</operator><name>horizontal</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>PRINT_RULE_TOP</name></expr>]</index></name><operator>.</operator><name>leftvrule</name> <operator>=</operator> <name><name>border</name><operator>-&gt;</operator><name>down_and_right</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>PRINT_RULE_TOP</name></expr>]</index></name><operator>.</operator><name>midvrule</name> <operator>=</operator> <name><name>column</name><operator>-&gt;</operator><name>down_and_horizontal</name><index>[<expr><name><name>opt</name><operator>-&gt;</operator><name>unicode_border_linestyle</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>PRINT_RULE_TOP</name></expr>]</index></name><operator>.</operator><name>rightvrule</name> <operator>=</operator> <name><name>border</name><operator>-&gt;</operator><name>down_and_left</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>PRINT_RULE_MIDDLE</name></expr>]</index></name><operator>.</operator><name>hrule</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>horizontal</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>PRINT_RULE_MIDDLE</name></expr>]</index></name><operator>.</operator><name>leftvrule</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>vertical_and_right</name><index>[<expr><name><name>opt</name><operator>-&gt;</operator><name>unicode_border_linestyle</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>PRINT_RULE_MIDDLE</name></expr>]</index></name><operator>.</operator><name>midvrule</name> <operator>=</operator> <name><name>column</name><operator>-&gt;</operator><name>vertical_and_horizontal</name><index>[<expr><name><name>opt</name><operator>-&gt;</operator><name>unicode_header_linestyle</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>PRINT_RULE_MIDDLE</name></expr>]</index></name><operator>.</operator><name>rightvrule</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>vertical_and_left</name><index>[<expr><name><name>opt</name><operator>-&gt;</operator><name>unicode_border_linestyle</name></name></expr>]</index></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>PRINT_RULE_BOTTOM</name></expr>]</index></name><operator>.</operator><name>hrule</name> <operator>=</operator> <name><name>border</name><operator>-&gt;</operator><name>horizontal</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>PRINT_RULE_BOTTOM</name></expr>]</index></name><operator>.</operator><name>leftvrule</name> <operator>=</operator> <name><name>border</name><operator>-&gt;</operator><name>up_and_right</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>PRINT_RULE_BOTTOM</name></expr>]</index></name><operator>.</operator><name>midvrule</name> <operator>=</operator> <name><name>column</name><operator>-&gt;</operator><name>up_and_horizontal</name><index>[<expr><name><name>opt</name><operator>-&gt;</operator><name>unicode_border_linestyle</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>PRINT_RULE_BOTTOM</name></expr>]</index></name><operator>.</operator><name>rightvrule</name> <operator>=</operator> <name><name>border</name><operator>-&gt;</operator><name>left_and_right</name></name></expr>;</expr_stmt>

    <comment type="block">/* N/A */</comment>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>PRINT_RULE_DATA</name></expr>]</index></name><operator>.</operator><name>hrule</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>PRINT_RULE_DATA</name></expr>]</index></name><operator>.</operator><name>leftvrule</name> <operator>=</operator> <name><name>border</name><operator>-&gt;</operator><name>vertical</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>PRINT_RULE_DATA</name></expr>]</index></name><operator>.</operator><name>midvrule</name> <operator>=</operator> <name><name>column</name><operator>-&gt;</operator><name>vertical</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>lrule</name><index>[<expr><name>PRINT_RULE_DATA</name></expr>]</index></name><operator>.</operator><name>rightvrule</name> <operator>=</operator> <name><name>border</name><operator>-&gt;</operator><name>vertical</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>midvrule_nl</name></name> <operator>=</operator> <name><name>column</name><operator>-&gt;</operator><name>vertical</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>midvrule_wrap</name></name> <operator>=</operator> <name><name>column</name><operator>-&gt;</operator><name>vertical</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>midvrule_blank</name></name> <operator>=</operator> <name><name>column</name><operator>-&gt;</operator><name>vertical</name></name></expr>;</expr_stmt>

    <comment type="block">/* Same for all unicode today */</comment>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>header_nl_left</name></name> <operator>=</operator> <name><name>unicode_style</name><operator>.</operator><name>header_nl_left</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>header_nl_right</name></name> <operator>=</operator> <name><name>unicode_style</name><operator>.</operator><name>header_nl_right</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>nl_left</name></name> <operator>=</operator> <name><name>unicode_style</name><operator>.</operator><name>nl_left</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>nl_right</name></name> <operator>=</operator> <name><name>unicode_style</name><operator>.</operator><name>nl_right</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>wrap_left</name></name> <operator>=</operator> <name><name>unicode_style</name><operator>.</operator><name>wrap_left</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>wrap_right</name></name> <operator>=</operator> <name><name>unicode_style</name><operator>.</operator><name>wrap_right</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>popt</name><operator>-&gt;</operator><name>wrap_right_border</name></name> <operator>=</operator> <name><name>unicode_style</name><operator>.</operator><name>wrap_right_border</name></name></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the byte distance to the end of the string or *target_width
 * display character positions, whichever comes first.  Update *target_width
 * to be the number of display character positions actually filled.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>strlen_max_width</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>target_width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>str</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>curr_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>str</name> <operator>&lt;</operator> <name>end</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>char_width</name> <init>= <expr><call><name>PQdsplen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>str</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If the display width of the new character causes the string to
         * exceed its target width, skip it and return.  However, if this is
         * the first character of the string (curr_width == 0), we have to
         * accept it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>target_width</name> <operator>&lt;</operator> <name>curr_width</name> <operator>+</operator> <name>char_width</name> <operator>&amp;&amp;</operator> <name>curr_width</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>curr_width</name> <operator>+=</operator> <name>char_width</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>str</name> <operator>+=</operator> <call><name>PQmblen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>str</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><operator>*</operator><name>target_width</name> <operator>=</operator> <name>curr_width</name></expr>;</expr_stmt>

    <return>return <expr><name>str</name> <operator>-</operator> <name>start</name></expr>;</return>
</block_content>}</block></function>
</unit>
