<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/port/path.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * path.c
 *      portable path handling routines
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/port/path.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRONTEND</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32_IE</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_WIN32_IE</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_WIN32_IE</name></cpp:macro> <cpp:value>0x0500</cpp:value></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>near</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>near</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>near</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;shlobj.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_config_paths.h"</cpp:file></cpp:include>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_PATH_VAR_SEP</name><parameter_list>(<parameter><type><name>ch</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((ch) == ':')</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_PATH_VAR_SEP</name><parameter_list>(<parameter><type><name>ch</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((ch) == ';')</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_relative_path</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target_path</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bin_path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_exec_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>trim_directory</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>trim_trailing_separator</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * skip_drive
 *
 * On Windows, a path may begin with "C:" or "//network/".  Advance over
 * this and point to the effective start of the path.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>skip_drive</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>path</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>*</operator><name>path</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><operator>*</operator><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>path</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>path</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>path</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>path</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>skip_drive</name><parameter_list>(<parameter><type><name>path</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>(path)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 *    has_drive_prefix
 *
 * Return true if the given pathname has a drive prefix.
 */</comment>
<function><type><name>bool</name></type>
<name>has_drive_prefix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <return>return <expr><call><name>skip_drive</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>path</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 *    first_dir_separator
 *
 * Find the location of the first directory separator, return
 * NULL if not found.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>first_dir_separator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <call><name>skip_drive</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    first_path_var_separator
 *
 * Find the location of the first path separator (i.e. ':' on
 * Unix, ';' on Windows), return NULL if not found.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>first_path_var_separator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <comment type="block">/* skip_drive is not needed */</comment>
    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>pathlist</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IS_PATH_VAR_SEP</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    last_dir_separator
 *
 * Find the location of the last directory separator, return
 * NULL if not found.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>last_dir_separator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <call><name>skip_drive</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    <return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ret</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *    make_native_path - on WIN32, change / to \ in the path
 *
 *    This effectively undoes canonicalize_path.
 *
 *    This is required because WIN32 COPY is an internal CMD.EXE
 *    command and doesn't process forward slashes in the same way
 *    as external commands.  Quoting the first argument to COPY
 *    does not convert forward to backward slashes, but COPY does
 *    properly process quoted forward slashes in the second argument.
 *
 *    COPY works with quoted forward slashes in the first argument
 *    only if the current directory is the same as the directory
 *    of the first argument.
 */</comment>
<function><type><name>void</name></type>
<name>make_native_path</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>filename</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * This function cleans up the paths for use with either cmd.exe or Msys
 * on Windows. We need them to use filenames without spaces, for which a
 * short filename is the safest equivalent, eg:
 *        C:/Progra~1/
 */</comment>
<function><type><name>void</name></type>
<name>cleanup_path</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

    <comment type="block">/*
     * GetShortPathName() will fail if the path does not exist, or short names
     * are disabled on this file system.  In both cases, we just return the
     * original path.  This is particularly useful for --sysconfdir, which
     * might not exist.
     */</comment>
    <expr_stmt><expr><call><name>GetShortPathName</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Replace '\' with '/' */</comment>
    <for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>path</name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * join_path_components - join two path components, inserting a slash
 *
 * We omit the slash if either given component is empty.
 *
 * ret_path is the output area (must be of size MAXPGPATH)
 *
 * ret_path can be the same as head, but not the same as tail.
 */</comment>
<function><type><name>void</name></type>
<name>join_path_components</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_path</name></decl></parameter>,
                     <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>head</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>ret_path</name> <operator>!=</operator> <name>head</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>head</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Remove any leading "." in the tail component.
     *
     * Note: we used to try to remove ".." as well, but that's tricky to get
     * right; now we just leave it to be done by canonicalize_path() later.
     */</comment>
    <while>while <condition>(<expr><name><name>tail</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><name><name>tail</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>tail</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tail</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* only separate with slash if head wasn't empty */</comment>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>ret_path</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAXPGPATH</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><literal type="string">"%s%s"</literal></expr></argument>,
                 <argument><expr><ternary><condition><expr><operator>(</operator><operator>*</operator><operator>(</operator><call><name>skip_drive</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                 <argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *    Clean up path by:
 *        o  make Win32 path use Unix slashes
 *        o  remove trailing quote on Win32
 *        o  remove trailing slash
 *        o  remove duplicate adjacent separators
 *        o  remove trailing '.'
 *        o  process trailing '..' ourselves
 */</comment>
<function><type><name>void</name></type>
<name>canonicalize_path</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>p</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>to_p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>spath</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>was_sep</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>pending_strips</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

    <comment type="block">/*
     * The Windows command processor will accept suitably quoted paths with
     * forward slashes, but barfs badly with mixed forward and back slashes.
     */</comment>
    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>path</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * In Win32, if you do: prog.exe "a b" "\c\d\" the system will pass \c\d"
     * as argv[2], so trim off trailing quote.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>path</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>p</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Removing the trailing slash on a path means we never get ugly double
     * trailing slashes. Also, Win32 can't stat() a directory with a trailing
     * slash. Don't remove a leading slash, though.
     */</comment>
    <expr_stmt><expr><call><name>trim_trailing_separator</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Remove duplicate adjacent separators
     */</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <comment type="block">/* Don't remove leading double-slash on Win32 */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>to_p</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr><operator>,</operator> <expr><name>to_p</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* Handle many adjacent slashes, like "/a///b" */</comment>
        <while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name>was_sep</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
        <if_stmt><if>if <condition>(<expr><name>to_p</name> <operator>!=</operator> <name>p</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>to_p</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>was_sep</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'/'</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><operator>*</operator><name>to_p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Remove any trailing uses of "." and process ".." ourselves
     *
     * Note that "/../.." should reduce to just "/", while "../.." has to be
     * kept as-is.  In the latter case we put back mistakenly trimmed ".."
     * components below.  Also note that we want a Windows drive spec to be
     * visible to trim_directory(), but it's not part of the logic that's
     * looking at the name components; hence distinction between path and
     * spath.
     */</comment>
    <expr_stmt><expr><name>spath</name> <operator>=</operator> <call><name>skip_drive</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pending_strips</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>spath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>spath</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"/."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>trim_directory</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>spath</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Want to leave "." alone, but "./.." has to become ".." */</comment>
            <if_stmt><if>if <condition>(<expr><name>pending_strips</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>spath</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name>len</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>spath</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"/.."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                 <call><name>strcmp</name><argument_list>(<argument><expr><name>spath</name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>trim_directory</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pending_strips</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>pending_strips</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>spath</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* trim a regular directory name canceled by ".." */</comment>
            <expr_stmt><expr><call><name>trim_directory</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pending_strips</name><operator>--</operator></expr>;</expr_stmt>
            <comment type="block">/* foo/.. should become ".", not empty */</comment>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>spath</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>spath</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <break>break;</break></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>pending_strips</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We could only get here if path is now totally empty (other than a
         * possible drive specifier on Windows). We have to put back one or
         * more ".."'s that we took off.
         */</comment>
        <while>while <condition>(<expr><operator>--</operator><name>pending_strips</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"../"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Detect whether a path contains any parent-directory references ("..")
 *
 * The input *must* have been put through canonicalize_path previously.
 *
 * This is a bit tricky because we mustn't be fooled by "..a.." (legal)
 * nor "C:.." (legal on Unix but not Windows).
 */</comment>
<function><type><name>bool</name></type>
<name>path_contains_parent_reference</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>path_len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>skip_drive</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* C: shouldn't affect our conclusion */</comment>

    <expr_stmt><expr><name>path_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * ".." could be the whole path; otherwise, if it's present it must be at
     * the beginning, in the middle, or at the end.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>strncmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"../"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>strstr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"/../"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
        <operator>(</operator><name>path_len</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>path</name> <operator>+</operator> <name>path_len</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"/.."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Detect whether a path is only in or below the current working directory.
 * An absolute path that matches the current working directory should
 * return false (we only want relative to the cwd).  We don't allow
 * "/../" even if that would keep us under the cwd (it is too hard to
 * track that).
 */</comment>
<function><type><name>bool</name></type>
<name>path_is_relative_and_below_cwd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>is_absolute_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if>
    <comment type="block">/* don't allow anything above the cwd */</comment>
    <if type="elseif">else if <condition>(<expr><call><name>path_contains_parent_reference</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

    <comment type="block">/*
     * On Win32, a drive letter _not_ followed by a slash, e.g. 'E:abc', is
     * relative to the cwd on that drive, or the drive's root directory if
     * that drive has no cwd.  Because the path itself cannot tell us which is
     * the case, we have to assume the worst, i.e. that it is not below the
     * cwd.  We could use GetFullPathName() to find the full path but that
     * could change if the current directory for the drive changes underneath
     * us, so we just disallow it.
     */</comment>
    <if type="elseif">else if <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>path</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator>
             <operator>!</operator><call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Detect whether path1 is a prefix of path2 (including equality).
 *
 * This is pretty trivial, but it seems better to export a function than
 * to export IS_DIR_SEP.
 */</comment>
<function><type><name>bool</name></type>
<name>path_is_prefix_of_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>path1_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>path1_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>(</operator><call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><name><name>path2</name><index>[<expr><name>path1_len</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>path2</name><index>[<expr><name>path1_len</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Extracts the actual name of the program as called -
 * stripped of .exe suffix if any
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_progname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodir_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>nodir_name</name> <operator>=</operator> <call><name>last_dir_separator</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nodir_name</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nodir_name</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>nodir_name</name> <operator>=</operator> <call><name>skip_drive</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Make a copy in case argv[0] is modified by ps_status. Leaks memory, but
     * called only once.
     */</comment>
    <expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>nodir_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>progname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: out of memory\n"</literal></expr></argument>, <argument><expr><name>nodir_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>                <comment type="block">/* This could exit the postmaster */</comment>
    </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* strip ".exe" suffix, regardless of case */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>EXE</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
        <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>progname</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>EXE</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>EXE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>progname</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>EXE</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>progname</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * dir_strcmp: strcmp except any two DIR_SEP characters are considered equal,
 * and we honor filesystem case insensitivity if known
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dir_strcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <while>while <condition>(<expr><operator>*</operator><name>s1</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s2</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
            <expr><operator>*</operator><name>s1</name> <operator>!=</operator> <operator>*</operator><name>s2</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="block">/* On windows, paths are case-insensitive */</comment>
            <call><name>pg_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>pg_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s2</name></expr></argument>)</argument_list></call>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><operator>*</operator><name>s1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><operator>*</operator><name>s2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>*</operator><name>s1</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>*</operator><name>s2</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>s1</name><operator>++</operator></expr><operator>,</operator> <expr><name>s2</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s1</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>                <comment type="block">/* s1 longer */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s2</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>                <comment type="block">/* s2 longer */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * make_relative_path - make a path relative to the actual binary location
 *
 * This function exists to support relocation of installation trees.
 *
 *    ret_path is the output area (must be of size MAXPGPATH)
 *    target_path is the compiled-in path to the directory we want to find
 *    bin_path is the compiled-in path to the directory of executables
 *    my_exec_path is the actual location of my executable
 *
 * We determine the common prefix of target_path and bin_path, then compare
 * the remainder of bin_path to the last directory component(s) of
 * my_exec_path.  If they match, build the result as the part of my_exec_path
 * preceding the match, joined to the remainder of target_path.  If no match,
 * return target_path as-is.
 *
 * For example:
 *        target_path  = '/usr/local/share/postgresql'
 *        bin_path     = '/usr/local/bin'
 *        my_exec_path = '/opt/pgsql/bin/postmaster'
 * Given these inputs, the common prefix is '/usr/local/', the tail of
 * bin_path is 'bin' which does match the last directory component of
 * my_exec_path, so we would return '/opt/pgsql/share/postgresql'
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_relative_path</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target_path</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bin_path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_exec_path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>prefix_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>tail_start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>tail_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Determine the common prefix --- note we require it to end on a
     * directory separator, consider eg '/usr/lib' and '/usr/libexec'.
     */</comment>
    <expr_stmt><expr><name>prefix_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>target_path</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>bin_path</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><name><name>target_path</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><name><name>bin_path</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>prefix_len</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>target_path</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>bin_path</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>prefix_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>no_match</name>;</goto></block_content></block></if></if_stmt>            <comment type="block">/* no common prefix? */</comment>
    <expr_stmt><expr><name>tail_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>bin_path</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>prefix_len</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Set up my_exec_path without the actual executable name, and
     * canonicalize to simplify comparison to bin_path.
     */</comment>
    <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>trim_directory</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* remove my executable name */</comment>
    <expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Tail match?
     */</comment>
    <expr_stmt><expr><name>tail_start</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>tail_len</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>tail_start</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><name><name>ret_path</name><index>[<expr><name>tail_start</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>dir_strcmp</name><argument_list>(<argument><expr><name>ret_path</name> <operator>+</operator> <name>tail_start</name></expr></argument>, <argument><expr><name>bin_path</name> <operator>+</operator> <name>prefix_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>ret_path</name><index>[<expr><name>tail_start</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>trim_trailing_separator</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>join_path_components</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>target_path</name> <operator>+</operator> <name>prefix_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

<label><name>no_match</name>:</label>
    <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * make_absolute_path
 *
 * If the given pathname isn't already absolute, make it so, interpreting
 * it relative to the current working directory.
 *
 * Also canonicalizes the path.  The result is always a malloc'd copy.
 *
 * In backend, failure cases result in ereport(ERROR); in frontend,
 * we write a complaint on stderr and return NULL.
 *
 * Note: interpretation of relative-path arguments during postmaster startup
 * should happen before doing ChangeToDataDir(), else the user will probably
 * not like the results.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>make_absolute_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>

    <comment type="block">/* Returning null for null input is convenient for some callers */</comment>
    <if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_absolute_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type>        <name>buflen</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>buflen</name> <operator>=</operator> <name>MAXPGPATH</name></expr>;</expr_stmt>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition>
            <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRONTEND</name></cpp:ifndef>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>getcwd</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>buflen</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRONTEND</name></cpp:ifndef>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not get current working directory: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not get current working directory: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>new</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRONTEND</name></cpp:ifndef>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>new</name></expr>)</condition>
        <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRONTEND</name></cpp:ifndef>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Make sure punctuation is canonical, too */</comment>
    <expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>new</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *    get_share_path
 */</comment>
<function><type><name>void</name></type>
<name>get_share_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_exec_path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>make_relative_path</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>PGSHAREDIR</name></expr></argument>, <argument><expr><name>PGBINDIR</name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    get_etc_path
 */</comment>
<function><type><name>void</name></type>
<name>get_etc_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_exec_path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>make_relative_path</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>SYSCONFDIR</name></expr></argument>, <argument><expr><name>PGBINDIR</name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    get_include_path
 */</comment>
<function><type><name>void</name></type>
<name>get_include_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_exec_path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>make_relative_path</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>INCLUDEDIR</name></expr></argument>, <argument><expr><name>PGBINDIR</name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    get_pkginclude_path
 */</comment>
<function><type><name>void</name></type>
<name>get_pkginclude_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_exec_path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>make_relative_path</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>PKGINCLUDEDIR</name></expr></argument>, <argument><expr><name>PGBINDIR</name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    get_includeserver_path
 */</comment>
<function><type><name>void</name></type>
<name>get_includeserver_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_exec_path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>make_relative_path</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>INCLUDEDIRSERVER</name></expr></argument>, <argument><expr><name>PGBINDIR</name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    get_lib_path
 */</comment>
<function><type><name>void</name></type>
<name>get_lib_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_exec_path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>make_relative_path</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>LIBDIR</name></expr></argument>, <argument><expr><name>PGBINDIR</name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    get_pkglib_path
 */</comment>
<function><type><name>void</name></type>
<name>get_pkglib_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_exec_path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>make_relative_path</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>PKGLIBDIR</name></expr></argument>, <argument><expr><name>PGBINDIR</name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    get_locale_path
 */</comment>
<function><type><name>void</name></type>
<name>get_locale_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_exec_path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>make_relative_path</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>LOCALEDIR</name></expr></argument>, <argument><expr><name>PGBINDIR</name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    get_doc_path
 */</comment>
<function><type><name>void</name></type>
<name>get_doc_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_exec_path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>make_relative_path</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>DOCDIR</name></expr></argument>, <argument><expr><name>PGBINDIR</name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    get_html_path
 */</comment>
<function><type><name>void</name></type>
<name>get_html_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_exec_path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>make_relative_path</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>HTMLDIR</name></expr></argument>, <argument><expr><name>PGBINDIR</name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    get_man_path
 */</comment>
<function><type><name>void</name></type>
<name>get_man_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_exec_path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>make_relative_path</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>MANDIR</name></expr></argument>, <argument><expr><name>PGBINDIR</name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *    get_home_path
 *
 * On Unix, this actually returns the user's home directory.  On Windows
 * it returns the PostgreSQL-specific application data folder.
 */</comment>
<function><type><name>bool</name></type>
<name>get_home_path</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>pwdbuf</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name></type> <name>pwdstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>pwd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pqGetpwuid</name><argument_list>(<argument><expr><call><name>geteuid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>pwdstr</name></expr></argument>, <argument><expr><name>pwdbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pwdbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>pwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>pwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name><name>pwd</name><operator>-&gt;</operator><name>pw_dir</name></name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>tmppath</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Note: We use getenv() here because the more modern SHGetFolderPath()
     * would force the backend to link with shell32.lib, which eats valuable
     * desktop heap.  XXX This function is used only in psql, which already
     * brings in shell32 via libpq.  Moving this function to its own file
     * would keep it out of the backend, freeing it from this concern.
     */</comment>
    <expr_stmt><expr><name>tmppath</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"APPDATA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmppath</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/postgresql"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * get_parent_directory
 *
 * Modify the given string in-place to name the parent directory of the
 * named file.
 *
 * If the input is just a file name with no directory part, the result is
 * an empty string, not ".".  This is appropriate when the next step is
 * join_path_components(), but might need special handling otherwise.
 *
 * Caution: this will not produce desirable results if the string ends
 * with "..".  For most callers this is not a problem since the string
 * is already known to name a regular file.  If in doubt, apply
 * canonicalize_path() first.
 */</comment>
<function><type><name>void</name></type>
<name>get_parent_directory</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>trim_directory</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *    trim_directory
 *
 *    Trim trailing directory from path, that is, remove any trailing slashes,
 *    the last pathname component, and the slash just ahead of it --- but never
 *    remove a leading slash.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>trim_directory</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>skip_drive</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* back up over trailing slash(es) */</comment>
    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>path</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>p</name> <operator>&gt;</operator> <name>path</name></expr>;</condition> <incr><expr><name>p</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <empty_stmt>;</empty_stmt></block_content></block></for>
    <comment type="block">/* back up over directory name */</comment>
    <for>for <control>(<init>;</init> <condition><expr><operator>!</operator><call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>p</name> <operator>&gt;</operator> <name>path</name></expr>;</condition> <incr><expr><name>p</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <empty_stmt>;</empty_stmt></block_content></block></for>
    <comment type="block">/* if multiple slashes before directory name, remove 'em all */</comment>
    <for>for <control>(<init>;</init> <condition><expr><name>p</name> <operator>&gt;</operator> <name>path</name> <operator>&amp;&amp;</operator> <call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>p</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>p</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <empty_stmt>;</empty_stmt></block_content></block></for>
    <comment type="block">/* don't erase a leading slash */</comment>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>path</name> <operator>&amp;&amp;</operator> <call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *    trim_trailing_separator
 *
 * trim off trailing slashes, but not a leading slash
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>trim_trailing_separator</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>skip_drive</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>path</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>path</name></expr>)</condition><block type="pseudo"><block_content>
        <for>for <control>(<init><expr><name>p</name><operator>--</operator></expr>;</init> <condition><expr><name>p</name> <operator>&gt;</operator> <name>path</name> <operator>&amp;&amp;</operator> <call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>p</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
