<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/interfaces/libpq/fe-auth-scram.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * fe-auth-scram.c
 *       The front-end (client) implementation of SCRAM authentication.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *      src/interfaces/libpq/fe-auth-scram.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/base64.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/saslprep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/scram-common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe-auth.h"</cpp:file></cpp:include>

<comment type="block">/* These are needed for getpid(), in the fallback implementation */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_STRONG_RANDOM</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Status of exchange messages used for SCRAM authentication via the
 * SASL protocol.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
    <decl><name>FE_SCRAM_INIT</name></decl>,
    <decl><name>FE_SCRAM_NONCE_SENT</name></decl>,
    <decl><name>FE_SCRAM_PROOF_SENT</name></decl>,
    <decl><name>FE_SCRAM_FINISHED</name></decl>
}</block></enum></type> <name>fe_scram_state_enum</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>fe_scram_state_enum</name></type> <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* These are supplied by the user */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>password</name></decl>;</decl_stmt>

    <comment type="block">/* We construct these */</comment>
    <decl_stmt><decl><type><name>uint8</name></type>        <name><name>SaltedPassword</name><index>[<expr><name>SCRAM_KEY_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>client_nonce</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>client_first_message_bare</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>client_final_message_without_proof</name></decl>;</decl_stmt>

    <comment type="block">/* These come from the server-first message */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>server_first_message</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>salt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>saltlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>iterations</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nonce</name></decl>;</decl_stmt>

    <comment type="block">/* These come from the server-final message */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>server_final_message</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>ServerSignature</name><index>[<expr><name>SCRAM_KEY_LEN</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>fe_scram_state</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>read_server_first_message</name><parameter_list>(<parameter><decl><type><name>fe_scram_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>,
                          <parameter><decl><type><name>PQExpBuffer</name></type> <name>errormessage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>read_server_final_message</name><parameter_list>(<parameter><decl><type><name>fe_scram_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>,
                          <parameter><decl><type><name>PQExpBuffer</name></type> <name>errormessage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>build_client_first_message</name><parameter_list>(<parameter><decl><type><name>fe_scram_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
                           <parameter><decl><type><name>PQExpBuffer</name></type> <name>errormessage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>build_client_final_message</name><parameter_list>(<parameter><decl><type><name>fe_scram_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
                           <parameter><decl><type><name>PQExpBuffer</name></type> <name>errormessage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>verify_server_signature</name><parameter_list>(<parameter><decl><type><name>fe_scram_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>calculate_client_proof</name><parameter_list>(<parameter><decl><type><name>fe_scram_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>client_final_message_without_proof</name></decl></parameter>,
                       <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pg_frontend_random</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Initialize SCRAM exchange status.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>pg_fe_scram_init</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>password</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>fe_scram_state</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>prep_password</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_saslprep_rc</name></type> <name>rc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>fe_scram_state</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fe_scram_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>state</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fe_scram_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>FE_SCRAM_INIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>username</name></name> <operator>=</operator> <name>username</name></expr>;</expr_stmt>

    <comment type="block">/* Normalize the password with SASLprep, if possible */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pg_saslprep</name><argument_list>(<argument><expr><name>password</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prep_password</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>SASLPREP_OOM</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>SASLPREP_SUCCESS</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>prep_password</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>password</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>prep_password</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>password</name></name> <operator>=</operator> <name>prep_password</name></expr>;</expr_stmt>

    <return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free SCRAM exchange status
 */</comment>
<function><type><name>void</name></type>
<name>pg_fe_scram_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaq</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>fe_scram_state</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>fe_scram_state</name> <operator>*</operator><operator>)</operator> <name>opaq</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>password</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>password</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* client messages */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>client_nonce</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>client_nonce</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>client_first_message_bare</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>client_first_message_bare</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>client_final_message_without_proof</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>client_final_message_without_proof</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* first message from server */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>server_first_message</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>server_first_message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>salt</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>salt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>nonce</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>nonce</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* final message from server */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>server_final_message</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>server_final_message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exchange a SCRAM message with backend.
 */</comment>
<function><type><name>void</name></type>
<name>pg_fe_scram_exchange</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaq</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>inputlen</name></decl></parameter>,
                     <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>output</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>outputlen</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>done</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>success</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>fe_scram_state</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>fe_scram_state</name> <operator>*</operator><operator>)</operator> <name>opaq</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>done</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>outputlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Check that the input length agrees with the string length of the input.
     * We can ignore inputlen after this.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>FE_SCRAM_INIT</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>inputlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
                              <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"malformed SCRAM message (empty message)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>inputlen</name> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
                              <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"malformed SCRAM message (length mismatch)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>FE_SCRAM_INIT</name></expr>:</case>
            <comment type="block">/* Begin the SCRAM handshake, by sending client nonce */</comment>
            <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>build_client_first_message</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>output</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

            <expr_stmt><expr><operator>*</operator><name>outputlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>done</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>FE_SCRAM_NONCE_SENT</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>FE_SCRAM_NONCE_SENT</name></expr>:</case>
            <comment type="block">/* Receive salt and server nonce, send response. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_server_first_message</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

            <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>build_client_final_message</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>output</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

            <expr_stmt><expr><operator>*</operator><name>outputlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>done</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>FE_SCRAM_PROOF_SENT</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>FE_SCRAM_PROOF_SENT</name></expr>:</case>
            <comment type="block">/* Receive server signature */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_server_final_message</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Verify server signature, to make sure we're talking to the
             * genuine server.  XXX: A fake server could simply not require
             * authentication, though.  There is currently no option in libpq
             * to reject a connection, if SCRAM authentication did not happen.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>verify_server_signature</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>success</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
                                  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid server signature\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><operator>*</operator><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>FE_SCRAM_FINISHED</name></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <comment type="block">/* shouldn't happen */</comment>
            <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
                              <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid SCRAM exchange state\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>error</name>;</goto>
    </block_content>}</block></switch>
    <return>return;</return>

<label><name>error</name>:</label>
    <expr_stmt><expr><operator>*</operator><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read value for an attribute part of a SASL message.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>read_attr_value</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>attr</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>begin</name> <init>= <expr><operator>*</operator><name>input</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>begin</name> <operator>!=</operator> <name>attr</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
                          <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"malformed SCRAM message (%c expected)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>begin</name><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>begin</name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
                          <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"malformed SCRAM message (expected = in attr '%c')\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>begin</name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>end</name> <operator>=</operator> <name>begin</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>*</operator><name>end</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>end</name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>end</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>end</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>input</name> <operator>=</operator> <name>end</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>input</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <return>return <expr><name>begin</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build the first exchange message sent by the client.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>build_client_first_message</name><parameter_list>(<parameter><decl><type><name>fe_scram_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>errormessage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>raw_nonce</name><index>[<expr><name>SCRAM_RAW_NONCE_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>buflen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>encoded_len</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Generate a "raw" nonce.  This is converted to ASCII-printable form by
     * base64-encoding it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_frontend_random</name><argument_list>(<argument><expr><name>raw_nonce</name></expr></argument>, <argument><expr><name>SCRAM_RAW_NONCE_LEN</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errormessage</name></expr></argument>,
                          <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not generate nonce\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>client_nonce</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>pg_b64_enc_len</name><argument_list>(<argument><expr><name>SCRAM_RAW_NONCE_LEN</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>client_nonce</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errormessage</name></expr></argument>,
                          <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>encoded_len</name> <operator>=</operator> <call><name>pg_b64_encode</name><argument_list>(<argument><expr><name>raw_nonce</name></expr></argument>, <argument><expr><name>SCRAM_RAW_NONCE_LEN</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>client_nonce</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>client_nonce</name><index>[<expr><name>encoded_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Generate message.  The username is left empty as the backend uses the
     * value provided by the startup packet.  Also, as this username is not
     * prepared with SASLprep, the message parsing would fail if it includes
     * '=' or ',' characters.
     */</comment>
    <expr_stmt><expr><name>buflen</name> <operator>=</operator> <literal type="number">8</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>client_nonce</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errormessage</name></expr></argument>,
                          <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><literal type="string">"n,,n=,r=%s"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>client_nonce</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>client_first_message_bare</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>client_first_message_bare</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errormessage</name></expr></argument>,
                          <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build the final exchange message sent from the client.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>build_client_final_message</name><parameter_list>(<parameter><decl><type><name>fe_scram_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>errormessage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name></type>        <name><name>client_proof</name><index>[<expr><name>SCRAM_KEY_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Construct client-final-message-without-proof.  We need to remember it
     * for verifying the server proof in the final step of authentication.
     */</comment>
    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"c=biws,r=%s"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>nonce</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PQExpBufferDataBroken</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>client_final_message_without_proof</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>client_final_message_without_proof</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Append proof to it, to form client-final-message. */</comment>
    <expr_stmt><expr><call><name>calculate_client_proof</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                           <argument><expr><name><name>state</name><operator>-&gt;</operator><name>client_final_message_without_proof</name></name></expr></argument>,
                           <argument><expr><name>client_proof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",p="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>enlargePQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>pg_b64_enc_len</name><argument_list>(<argument><expr><name>SCRAM_KEY_LEN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>+=</operator> <call><name>pg_b64_encode</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>client_proof</name></expr></argument>,
                             <argument><expr><name>SCRAM_KEY_LEN</name></expr></argument>,
                             <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>

<label><name>oom_error</name>:</label>
    <expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errormessage</name></expr></argument>,
                      <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read the first exchange message coming from the server.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>read_server_first_message</name><parameter_list>(<parameter><decl><type><name>fe_scram_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>,
                          <parameter><decl><type><name>PQExpBuffer</name></type> <name>errormessage</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>iterations_str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>encoded_salt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nonce</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>server_first_message</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>server_first_message</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errormessage</name></expr></argument>,
                          <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* parse the message */</comment>
    <expr_stmt><expr><name>nonce</name> <operator>=</operator> <call><name>read_attr_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><name>errormessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nonce</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* read_attr_value() has generated an error string */</comment>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Verify immediately that the server used our part of the nonce */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>nonce</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>client_nonce</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>memcmp</name><argument_list>(<argument><expr><name>nonce</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>client_nonce</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>client_nonce</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errormessage</name></expr></argument>,
                          <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid SCRAM response (nonce mismatch)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nonce</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>nonce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>nonce</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errormessage</name></expr></argument>,
                          <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>encoded_salt</name> <operator>=</operator> <call><name>read_attr_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><name>errormessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>encoded_salt</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* read_attr_value() has generated an error string */</comment>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>salt</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>pg_b64_dec_len</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>encoded_salt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>salt</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errormessage</name></expr></argument>,
                          <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>saltlen</name></name> <operator>=</operator> <call><name>pg_b64_decode</name><argument_list>(<argument><expr><name>encoded_salt</name></expr></argument>,
                                   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>encoded_salt</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>salt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>iterations_str</name> <operator>=</operator> <call><name>read_attr_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>, <argument><expr><name>errormessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>iterations_str</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* read_attr_value() has generated an error string */</comment>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>iterations</name></name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>iterations_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>iterations</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errormessage</name></expr></argument>,
                          <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"malformed SCRAM message (invalid iteration count)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errormessage</name></expr></argument>,
                          <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"malformed SCRAM message (garbage at end of server-first-message)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read the final exchange message coming from the server.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>read_server_final_message</name><parameter_list>(<parameter><decl><type><name>fe_scram_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>,
                          <parameter><decl><type><name>PQExpBuffer</name></type> <name>errormessage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>encoded_server_signature</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>server_signature_len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>server_final_message</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>server_final_message</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errormessage</name></expr></argument>,
                          <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check for error result. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'e'</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>errmsg</name> <init>= <expr><call><name>read_attr_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input</name></expr></argument>, <argument><expr><literal type="char">'e'</literal></expr></argument>, <argument><expr><name>errormessage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errormessage</name></expr></argument>,
                          <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"error received from server in SASL exchange: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Parse the message. */</comment>
    <expr_stmt><expr><name>encoded_server_signature</name> <operator>=</operator> <call><name>read_attr_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input</name></expr></argument>, <argument><expr><literal type="char">'v'</literal></expr></argument>, <argument><expr><name>errormessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>encoded_server_signature</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* read_attr_value() has generated an error message */</comment>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errormessage</name></expr></argument>,
                          <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"malformed SCRAM message (garbage at end of server-final-message)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>server_signature_len</name> <operator>=</operator> <call><name>pg_b64_decode</name><argument_list>(<argument><expr><name>encoded_server_signature</name></expr></argument>,
                                         <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>encoded_server_signature</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name><name>state</name><operator>-&gt;</operator><name>ServerSignature</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>server_signature_len</name> <operator>!=</operator> <name>SCRAM_KEY_LEN</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errormessage</name></expr></argument>,
                          <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"malformed SCRAM message (invalid server signature)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate the client proof, part of the final exchange message sent
 * by the client.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>calculate_client_proof</name><parameter_list>(<parameter><decl><type><name>fe_scram_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>client_final_message_without_proof</name></decl></parameter>,
                       <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint8</name></type>        <name><name>StoredKey</name><index>[<expr><name>SCRAM_KEY_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name></type>        <name><name>ClientKey</name><index>[<expr><name>SCRAM_KEY_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name></type>        <name><name>ClientSignature</name><index>[<expr><name>SCRAM_KEY_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>scram_HMAC_ctx</name></type> <name>ctx</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Calculate SaltedPassword, and store it in 'state' so that we can reuse
     * it later in verify_server_signature.
     */</comment>
    <expr_stmt><expr><call><name>scram_SaltedPassword</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>password</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>salt</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>saltlen</name></name></expr></argument>,
                         <argument><expr><name><name>state</name><operator>-&gt;</operator><name>iterations</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>SaltedPassword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>scram_ClientKey</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>SaltedPassword</name></name></expr></argument>, <argument><expr><name>ClientKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scram_H</name><argument_list>(<argument><expr><name>ClientKey</name></expr></argument>, <argument><expr><name>SCRAM_KEY_LEN</name></expr></argument>, <argument><expr><name>StoredKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>scram_HMAC_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name>StoredKey</name></expr></argument>, <argument><expr><name>SCRAM_KEY_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scram_HMAC_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>,
                      <argument><expr><name><name>state</name><operator>-&gt;</operator><name>client_first_message_bare</name></name></expr></argument>,
                      <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>client_first_message_bare</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scram_HMAC_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scram_HMAC_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>,
                      <argument><expr><name><name>state</name><operator>-&gt;</operator><name>server_first_message</name></name></expr></argument>,
                      <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>server_first_message</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scram_HMAC_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scram_HMAC_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>,
                      <argument><expr><name>client_final_message_without_proof</name></expr></argument>,
                      <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>client_final_message_without_proof</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scram_HMAC_final</name><argument_list>(<argument><expr><name>ClientSignature</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SCRAM_KEY_LEN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>ClientKey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>^</operator> <name><name>ClientSignature</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Validate the server signature, received as part of the final exchange
 * message received from the server.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>verify_server_signature</name><parameter_list>(<parameter><decl><type><name>fe_scram_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint8</name></type>        <name><name>expected_ServerSignature</name><index>[<expr><name>SCRAM_KEY_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name></type>        <name><name>ServerKey</name><index>[<expr><name>SCRAM_KEY_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>scram_HMAC_ctx</name></type> <name>ctx</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>scram_ServerKey</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>SaltedPassword</name></name></expr></argument>, <argument><expr><name>ServerKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* calculate ServerSignature */</comment>
    <expr_stmt><expr><call><name>scram_HMAC_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name>ServerKey</name></expr></argument>, <argument><expr><name>SCRAM_KEY_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scram_HMAC_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>,
                      <argument><expr><name><name>state</name><operator>-&gt;</operator><name>client_first_message_bare</name></name></expr></argument>,
                      <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>client_first_message_bare</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scram_HMAC_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scram_HMAC_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>,
                      <argument><expr><name><name>state</name><operator>-&gt;</operator><name>server_first_message</name></name></expr></argument>,
                      <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>server_first_message</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scram_HMAC_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scram_HMAC_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>,
                      <argument><expr><name><name>state</name><operator>-&gt;</operator><name>client_final_message_without_proof</name></name></expr></argument>,
                      <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>client_final_message_without_proof</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scram_HMAC_final</name><argument_list>(<argument><expr><name>expected_ServerSignature</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>expected_ServerSignature</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>ServerSignature</name></name></expr></argument>, <argument><expr><name>SCRAM_KEY_LEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build a new SCRAM verifier.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pg_fe_scram_build_verifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>password</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>prep_password</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_saslprep_rc</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>saltbuf</name><index>[<expr><name>SCRAM_DEFAULT_SALT_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Normalize the password with SASLprep.  If that doesn't work, because
     * the password isn't valid UTF-8 or contains prohibited characters, just
     * proceed with the original password.  (See comments at top of file.)
     */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pg_saslprep</name><argument_list>(<argument><expr><name>password</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prep_password</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>SASLPREP_OOM</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>SASLPREP_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>password</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>prep_password</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Generate a random salt */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_frontend_random</name><argument_list>(<argument><expr><name>saltbuf</name></expr></argument>, <argument><expr><name>SCRAM_DEFAULT_SALT_LEN</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>prep_password</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>prep_password</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>scram_build_verifier</name><argument_list>(<argument><expr><name>saltbuf</name></expr></argument>, <argument><expr><name>SCRAM_DEFAULT_SALT_LEN</name></expr></argument>,
                                  <argument><expr><name>SCRAM_DEFAULT_ITERATIONS</name></expr></argument>, <argument><expr><name>password</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>prep_password</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>prep_password</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Random number generator.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pg_frontend_random</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRONG_RANDOM</name></cpp:ifdef>
    <return>return <expr><call><name>pg_strong_random</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>end</name> <init>= <expr><name>dst</name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>short</name></type> <name><name>seed</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>mypid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pglock_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>mypid</name> <operator>!=</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>now</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>seed</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>now</name><operator>.</operator><name>tv_sec</name></name> <operator>^</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>seed</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator> <operator>(</operator><name><name>now</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>seed</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator> <operator>(</operator><name><name>now</name><operator>.</operator><name>tv_usec</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dst</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint32</name></type>        <name>r</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

        <comment type="block">/*
         * pg_jrand48 returns a 32-bit integer.  Fill the next 4 bytes from
         * it.
         */</comment>
        <expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <call><name>pg_jrand48</name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>dst</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>dst</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <operator>(</operator><name>r</name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>r</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>pgunlock_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
</unit>
