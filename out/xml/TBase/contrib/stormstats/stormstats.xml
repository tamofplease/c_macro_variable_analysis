<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/contrib/stormstats/stormstats.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/auth.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stormstats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxcnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>


<comment type="block">/* mark this dynamic library to be compatible with PG */</comment>
<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<comment type="block">/* Location of stats file */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORM_DUMP_FILE</name></cpp:macro>  <cpp:value>"global/storm.stat"</cpp:value></cpp:define>

<comment type="block">/* This constant defines the magic number in the stats file header */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32</name></type> <name>STORM_FILE_HEADER</name> <init>= <expr><literal type="number">0x20120229</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORM_STATS_COLS</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>ssHashKey</name>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>dbname_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname_ptr</name></decl>;</decl_stmt>
}</block></struct></type> <name>ssHashKey</name>;</typedef>

<typedef>typedef <type><struct>struct <name>EventCounters</name>
<block>{
    <decl_stmt><decl><type><name>int64</name></type>       <name>conn_cnt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>select_cnt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>insert_cnt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>update_cnt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>delete_cnt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>ddl_cnt</name></decl>;</decl_stmt>
}</block></struct></type> <name>EventCounters</name>;</typedef>

<typedef>typedef <type><struct>struct <name>StormStatsEntry</name>
<block>{
    <decl_stmt><decl><type><name>ssHashKey</name></type>       <name>key</name></decl>;</decl_stmt>         <comment type="block">/* hash key of entry - MUST BE FIRST */</comment>
    <decl_stmt><decl><type><name>EventCounters</name></type>   <name>counters</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>slock_t</name></type>         <name>mutex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>            <name><name>dbname</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* VARIABLE LENGTH ARRAY - MUST BE LAST */</comment>

}</block></struct></type> <name>StormStatsEntry</name>;</typedef>

<comment type="block">/* Local hash table entry, no mutex needed */</comment>
<typedef>typedef <type><struct>struct <name>LocalStatsEntry</name>
<block>{
    <decl_stmt><decl><type><name>ssHashKey</name></type>       <name>key</name></decl>;</decl_stmt>         <comment type="block">/* hash key of entry */</comment>
    <decl_stmt><decl><type><name>EventCounters</name></type>   <name>counters</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>            <name><name>dbname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>LocalStatsEntry</name>;</typedef>

<typedef>typedef <type><struct>struct <name>StormSharedState</name>
<block>{
    <decl_stmt><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
}</block></struct></type> <name>StormSharedState</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>sp_save</name></decl>;</decl_stmt>            <comment type="block">/* whether to save stats across shutdown */</comment>

<function_decl><type><specifier>extern</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type><name>planner_callback</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>auth_check</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sp_shmem_startup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sp_shmem_shutdown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>hash_memsize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>ss_hash_fn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ss_match_fn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>stats_store</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isConnEvent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isUtilEvent</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>StormStatsEntry</name> <modifier>*</modifier></type><name>alloc_event_entry</name><parameter_list>(<parameter><decl><type><name>ssHashKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Functions */</comment>
<function_decl><type><name>Datum</name></type> <name>storm_database_stats</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>storm_database_stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Shared Memory Objects */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>StatsEntryHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>StormSharedState</name> <modifier>*</modifier></type><name>shared_state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Session level objects */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>shmem_startup_hook_type</name></type> <name>prev_shmem_startup_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ClientAuthentication_hook_type</name></type> <name>original_client_auth_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ProcessUtility_hook_type</name></type> <name>prev_ProcessUtility</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>max_tracked_dbs</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessUtility_callback</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
                        <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
                        <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
                        <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>sentToRemote</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Node</name>   <modifier>*</modifier></type><name>parsetree</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>( <argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"STORMSTATS: using plugin."</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>standard_ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
                            <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>stats_store</name><argument_list>(<argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CMD_UNKNOWN</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>parsetree</name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Check if it's a CREATE/DROP DATABASE command. Update entries in the
     * shared hash table accordingly.
     */</comment>
    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ssHashKey</name></type>        <name>key</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>StormStatsEntry</name>  <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>CreatedbStmt</name>     <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreatedbStmt</name> <operator>*</operator><operator>)</operator><name>parsetree</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* Set up key for hashtable search */</comment>
                <expr_stmt><expr><name><name>key</name><operator>.</operator><name>dbname_len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>key</name><operator>.</operator><name>dbname_ptr</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Lookup the hash table entry with exclusive lock. We have to
                 * manipulate the entries immediately anyways..
                 */</comment>
                <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared_state</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>StormStatsEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>StatsEntryHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* What do we do if we find an entry already? We WARN for now */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>alloc_event_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"entry exists already for database %s!"</literal></expr></argument>,
                        <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared_state</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>T_DropdbStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ssHashKey</name></type>        <name>key</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>StormStatsEntry</name>  <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>DropdbStmt</name>         <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DropdbStmt</name> <operator>*</operator><operator>)</operator><name>parsetree</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* Set up key for hashtable search */</comment>
                <expr_stmt><expr><name><name>key</name><operator>.</operator><name>dbname_len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>key</name><operator>.</operator><name>dbname_ptr</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Lookup the hash table entry with exclusive lock. We have to
                 * manipulate the entries immediately anyways..
                 */</comment>
                <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared_state</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>StormStatsEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>StatsEntryHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* What do we do if we do not find an entry? We WARN for now */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"entry does not exist for database %s!"</literal></expr></argument>,
                        <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared_state</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <default>default:</default>
            <comment type="block">/* Nothing */</comment><empty_stmt>;</empty_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>process_shared_preload_libraries_in_progress</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>DefineCustomIntVariable</name><argument_list>(<argument><expr><literal type="string">"storm_stats.max_tracked_databases"</literal></expr></argument>,
                            <argument><expr><literal type="string">"Sets the maximum number of databases tracked."</literal></expr></argument>,
                            <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>max_tracked_dbs</name></expr></argument>,
                            <argument><expr><literal type="number">1000</literal></expr></argument>,
                            <argument><expr><literal type="number">1</literal></expr></argument>,
                            <argument><expr><name>INT_MAX</name></expr></argument>,
                            <argument><expr><name>PGC_POSTMASTER</name></expr></argument>,
                            <argument><expr><literal type="number">0</literal></expr></argument>,
                            <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(<argument><expr><literal type="string">"storm_stats.save"</literal></expr></argument>,
                             <argument><expr><literal type="string">"Save statistics across server shutdowns."</literal></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><operator>&amp;</operator><name>sp_save</name></expr></argument>,
                             <argument><expr><name>true</name></expr></argument>,
                             <argument><expr><name>PGC_SIGHUP</name></expr></argument>,
                             <argument><expr><literal type="number">0</literal></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EmitWarningsOnPlaceholders</name><argument_list>(<argument><expr><literal type="string">"storm_stats"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RequestAddinShmemSpace</name><argument_list>(<argument><expr><call><name>hash_memsize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RequestNamedLWLockTranche</name><argument_list>(<argument><expr><literal type="string">"storm_stats"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>prev_shmem_startup_hook</name> <operator>=</operator> <name>shmem_startup_hook</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>shmem_startup_hook</name> <operator>=</operator> <name>sp_shmem_startup</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>planner_hook</name> <operator>=</operator> <name>planner_callback</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>original_client_auth_hook</name> <operator>=</operator> <name>ClientAuthentication_hook</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ClientAuthentication_hook</name> <operator>=</operator> <name>auth_check</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>prev_ProcessUtility</name> <operator>=</operator> <name>ProcessUtility_hook</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ProcessUtility_hook</name> <operator>=</operator> <name>ProcessUtility_callback</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>( <argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"STORMSTATS: plugin loaded"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>_PG_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>shmem_startup_hook</name> <operator>=</operator> <name>prev_shmem_startup_hook</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>planner_hook</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ProcessUtility_hook</name> <operator>=</operator> <name>prev_ProcessUtility</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>( <argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"STORMSTATS: plugin unloaded."</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>sp_shmem_startup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>event_ctl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>           <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>num</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>buffer_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>           <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>prev_shmem_startup_hook</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>prev_shmem_startup_hook</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Create or attach to the shared memory state, including hash table
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AddinShmemInitLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>shared_state</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"storm_stats state"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StormSharedState</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>shared_state</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"out of shared memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>shared_state</name><operator>-&gt;</operator><name>lock</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><call><name>GetNamedLWLockTranche</name><argument_list>(<argument><expr><literal type="string">"storm_stats"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>lock</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>event_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>event_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>event_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ssHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>StormStatsEntry</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event_ctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>ss_hash_fn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event_ctl</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>ss_match_fn</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>StatsEntryHash</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"storm_stats event hash"</literal></expr></argument>, <argument><expr><name>max_tracked_dbs</name></expr></argument>,
                                   <argument><expr><name>max_tracked_dbs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>event_ctl</name></expr></argument>,
                                   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_COMPARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>StatsEntryHash</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"out of shared memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AddinShmemInitLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we're in the postmaster (or a standalone backend...), set up a shmem
     * exit hook to dump the statistics to disk.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>sp_shmem_shutdown</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Attempt to load old statistics from the dump file, if this is the first
     * time through and we weren't told not to.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>found</name> <operator>||</operator> <operator>!</operator><name>sp_save</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Note: we don't bother with locks here, because there should be no other
     * processes running when this code is reached.
     */</comment>
    <expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>STORM_DUMP_FILE</name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>                         <comment type="block">/* ignore not-found error */</comment>
        <goto>goto <name>error</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>buffer_size</name> <operator>=</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>buffer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
        <name>header</name> <operator>!=</operator> <name>STORM_FILE_HEADER</name> <operator>||</operator>
        <call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>StormStatsEntry</name></type>  <name>temp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>StormStatsEntry</name>  <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>StormStatsEntry</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>temp</name><operator>.</operator><name>key</name><operator>.</operator><name>dbname_len</name></name> <operator>&gt;=</operator> <name>buffer_size</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>temp</name><operator>.</operator><name>key</name><operator>.</operator><name>dbname_len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>buffer_size</name> <operator>=</operator> <name><name>temp</name><operator>.</operator><name>key</name><operator>.</operator><name>dbname_len</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>temp</name><operator>.</operator><name>key</name><operator>.</operator><name>dbname_len</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>temp</name><operator>.</operator><name>key</name><operator>.</operator><name>dbname_len</name></name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>temp</name><operator>.</operator><name>key</name><operator>.</operator><name>dbname_len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>temp</name><operator>.</operator><name>key</name><operator>.</operator><name>dbname_ptr</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>

        <comment type="block">/* make the hashtable entry (discards old entries if too many) */</comment>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>alloc_event_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>temp</name><operator>.</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* copy in the actual stats */</comment>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>counters</name></name> <operator>=</operator> <name><name>temp</name><operator>.</operator><name>counters</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>

<label><name>error</name>:</label>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read stormstats file \"%s\": %m"</literal></expr></argument>,
                    <argument><expr><name>STORM_DUMP_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>buffer</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>file</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* If possible, throw away the bogus file; ignore any error */</comment>
    <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>STORM_DUMP_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * shmem_shutdown hook: Dump statistics into file.
 *
 * Note: we don't bother with acquiring lock, because there should be no
 * other processes running when this is called.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sp_shmem_shutdown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>num_entries</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StormStatsEntry</name>  <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <comment type="block">/* Don't try to dump during a crash. */</comment>
    <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Safety check ... shouldn't get here unless shmem is set up. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>shared_state</name> <operator>||</operator> <operator>!</operator><name>StatsEntryHash</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Don't dump if told not to. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sp_save</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>STORM_DUMP_FILE</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>STORM_FILE_HEADER</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>num_entries</name> <operator>=</operator> <call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>StatsEntryHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num_entries</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>StatsEntryHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>len</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>dbname_len</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>StormStatsEntry</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
            <call><name>fwrite</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>file</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <goto>goto <name>error</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <return>return;</return>

<label><name>error</name>:</label>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write stormstats file \"%s\": %m"</literal></expr></argument>,
                    <argument><expr><name>STORM_DUMP_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>file</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>STORM_DUMP_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>planner_callback</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PlannedStmt</name>  <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>( <argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"STORMSTATS: using plugin."</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Generate a plan */</comment>
    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>standard_planner</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>stats_store</name><argument_list>(<argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>auth_check</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>( <argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"STORMSTATS: using plugin."</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Any other plugins which use ClientAuthentication_hook.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>original_client_auth_hook</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>original_client_auth_hook</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>STATUS_OK</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>stats_store</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>, <argument><expr><name>CMD_UNKNOWN</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type> <name>hash_memsize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>events_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>state_size</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>events_size</name> <operator>=</operator> <call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>max_tracked_dbs</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StormStatsEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>state_size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StormSharedState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>events_size</name></expr></argument>, <argument><expr><name>state_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>StormStatsEntry</name> <modifier>*</modifier></type><name>alloc_event_entry</name><parameter_list>(<parameter><decl><type><name>ssHashKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StormStatsEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>found</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>StatsEntryHash</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>max_tracked_dbs</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"STORMSTATS: The maximum number of tracked databases have been reached"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Find or create an entry with desired hash code */</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>StormStatsEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>StatsEntryHash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>dbname_ptr</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>dbname</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>counters</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EventCounters</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>dbname_ptr</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>dbname_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>dbname</name><index>[<expr><name><name>key</name><operator>-&gt;</operator><name>dbname_len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate hash value for a key
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>ss_hash_fn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ssHashKey</name> <modifier>*</modifier></type><name>k</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ssHashKey</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* we don't bother to include encoding in the hash */</comment>
    <return>return <expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>k</name><operator>-&gt;</operator><name>dbname_ptr</name></name></expr></argument>,
                                <argument><expr><name><name>k</name><operator>-&gt;</operator><name>dbname_len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compare two keys - zero means match
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ss_match_fn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ssHashKey</name> <modifier>*</modifier></type><name>k1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ssHashKey</name> <operator>*</operator><operator>)</operator> <name>key1</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ssHashKey</name> <modifier>*</modifier></type><name>k2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ssHashKey</name> <operator>*</operator><operator>)</operator> <name>key2</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>k1</name><operator>-&gt;</operator><name>dbname_len</name></name> <operator>==</operator> <name><name>k2</name><operator>-&gt;</operator><name>dbname_len</name></name> <operator>&amp;&amp;</operator>
        <call><name>memcmp</name><argument_list>(<argument><expr><name><name>k1</name><operator>-&gt;</operator><name>dbname_ptr</name></name></expr></argument>, <argument><expr><name><name>k2</name><operator>-&gt;</operator><name>dbname_ptr</name></name></expr></argument>, <argument><expr><name><name>k1</name><operator>-&gt;</operator><name>dbname_len</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>stats_store</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isConnEvent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isUtilEvent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ssHashKey</name></type>        <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StormStatsEntry</name>  <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>shared_state</name> <operator>||</operator> <operator>!</operator><name>StatsEntryHash</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Set up key for hashtable search */</comment>
    <expr_stmt><expr><name><name>key</name><operator>.</operator><name>dbname_len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>.</operator><name>dbname_ptr</name></name> <operator>=</operator> <name>dbname</name></expr>;</expr_stmt>

    <comment type="block">/* Lookup the hash table entry with shared lock. */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared_state</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>StormStatsEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>StatsEntryHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Must acquire exclusive lock to add a new entry. */</comment>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared_state</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared_state</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>alloc_event_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Grab the spinlock while updating the counters. */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>StormStatsEntry</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><specifier>volatile</specifier> <name>StormStatsEntry</name> <operator>*</operator><operator>)</operator> <name>entry</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>isConnEvent</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>conn_cnt</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>isUtilEvent</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>ddl_cnt</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>CMD_SELECT</name></expr>:</case>
                    <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>select_cnt</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>CMD_INSERT</name></expr>:</case>
                    <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>insert_cnt</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
                    <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>update_cnt</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>CMD_DELETE</name></expr>:</case>
                    <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>delete_cnt</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>CMD_UTILITY</name></expr>:</case>
                <case>case <expr><name>CMD_UNKNOWN</name></expr>:</case>
                <case>case <expr><name>CMD_NOTHING</name></expr>:</case>
                    <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared_state</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Gather statistics from remote coordinators
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>storm_gather_remote_coord_info</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EState</name>        <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>, <decl><type ref="prev"/><name>ncolumns</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HTAB</name>        <modifier>*</modifier></type><name>LocalStatsHash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>event_ctl</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We will sort output by database name, should make adding up info from
     * multiple remote coordinators easier
     */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><literal type="string">"SELECT * FROM storm_database_stats() ORDER BY datname"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Build up RemoteQuery */</comment>
    <expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <name>query</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>force_autocommit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>read_only</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_COORDS</name></expr>;</expr_stmt>

    <comment type="block">/* Build a local hash table to contain info from remote nodes */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>event_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>event_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>event_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ssHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LocalStatsEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event_ctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>ss_hash_fn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event_ctl</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>ss_match_fn</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>LocalStatsHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"storm_stats local hash"</literal></expr></argument>, <argument><expr><name>max_tracked_dbs</name></expr></argument>,
                                   <argument><expr><operator>&amp;</operator><name>event_ctl</name></expr></argument>,
                                   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_COMPARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>LocalStatsHash</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Add targetlist entries. We use the proc oid to get the tupledesc for
     * this. We could have hardcoded the types of existing set of columns, but
     * if we change the columns later for whatever reasons, this keeps us sane
     */</comment>
    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Build a tupdesc of all the OUT parameters */</comment>
    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>build_function_result_tupdesc_t</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ncolumns</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncolumns</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
                      <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attnum</name></expr></argument>,
                      <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr></argument>,
                      <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>atttypmod</name></expr></argument>,
                      <argument><expr><name>InvalidOid</name></expr></argument>,
                      <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attnum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Execute query on the data nodes */</comment>
    <expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>ExecInitRemoteQuery</name><argument_list>(<argument><expr><name>step</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* get ready to combine results */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>     <name>value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>    <name>isnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ssHashKey</name></type>        <name>key</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LocalStatsEntry</name>  <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>             <modifier>*</modifier></type><name>dbname</name></decl>;</decl_stmt>

        <comment type="block">/* Process statistics from the coordinator nodes */</comment>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* datname */</comment>
        <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database name must not be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>dbname</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Set up key for hashtable search */</comment>
        <expr_stmt><expr><name><name>key</name><operator>.</operator><name>dbname_len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>key</name><operator>.</operator><name>dbname_ptr</name></name> <operator>=</operator> <name>dbname</name></expr>;</expr_stmt>

        <comment type="block">/* Find or create an entry with desired hash code */</comment>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>LocalStatsEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>LocalStatsHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>dbname_ptr</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>dbname</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>counters</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EventCounters</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>dbname_ptr</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>dbname_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>dbname</name><index>[<expr><name><name>key</name><operator>.</operator><name>dbname_len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* conn_cnt */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>conn_cnt</name></name> <operator>+=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* select_cnt */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>select_cnt</name></name> <operator>+=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* insert_cnt */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>insert_cnt</name></name> <operator>+=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* update_cnt */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>update_cnt</name></name> <operator>+=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* delete_cnt */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>delete_cnt</name></name> <operator>+=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* ddl_cnt */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>ddl_cnt</name></name> <operator>+=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* fetch next */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>ExecEndRemoteQuery</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>LocalStatsHash</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>storm_database_stats</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReturnSetInfo</name>       <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>           <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Tuplestorestate</name>     <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>       <name>per_query_ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>       <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type>     <name>hash_seq</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StormStatsEntry</name>        <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HTAB</name>                <modifier>*</modifier></type><name>LocalStatsHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid invocation on data node"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>shared_state</name> <operator>||</operator> <operator>!</operator><name>StatsEntryHash</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"storm_stats must be loaded via shared_preload_libraries"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
    <if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
                        <literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Query the rest of the coordinators and get their stats. Do this only if
     * you are query originator. Otherwise just provide your local info and
     * return
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsConnFromApp</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>LocalStatsHash</name> <operator>=</operator> <call><name>storm_gather_remote_coord_info</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>STORM_STATS_COLS</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"dbname"</literal></expr></argument>,     <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"conn_cnt"</literal></expr></argument>,   <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"select_cnt"</literal></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"insert_cnt"</literal></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"update_cnt"</literal></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"delete_cnt"</literal></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"ddl_cnt"</literal></expr></argument>,    <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared_state</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>StatsEntryHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>           <name><name>values</name><index>[<expr><name>STORM_STATS_COLS</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>            <name><name>nulls</name><index>[<expr><name>STORM_STATS_COLS</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>             <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EventCounters</name></type>   <name>tmp</name></decl>, <decl><type ref="prev"/><name>lcl</name></decl>;</decl_stmt>

        <comment type="block">/* generate junk in short-term context */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lcl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lcl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* copy counters to a local variable to keep locking time short */</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>volatile</specifier> <name>StormStatsEntry</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><specifier>volatile</specifier> <name>StormStatsEntry</name> <operator>*</operator><operator>)</operator> <name>entry</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>counters</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/* See if LocalStatsHash has additional info to provide */</comment>
        <if_stmt><if>if <condition>(<expr><name>LocalStatsHash</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ssHashKey</name></type>        <name>key</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LocalStatsEntry</name>    <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>             <name>found</name></decl>;</decl_stmt>

            <comment type="block">/* Set up key for hashtable search */</comment>
            <expr_stmt><expr><name><name>key</name><operator>.</operator><name>dbname_len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>key</name><operator>.</operator><name>dbname_ptr</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>dbname</name></name></expr>;</expr_stmt>

            <comment type="block">/* Find an entry with desired hash code */</comment>
            <expr_stmt><expr><name>le</name> <operator>=</operator> <operator>(</operator><name>LocalStatsEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>LocalStatsHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * What should we do if entry is not found on the other
             * coordinators? WARN for now..
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no stats collected from remote coordinators for database %s!"</literal></expr></argument>,
                     <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>ddl_cnt</name></name> <operator>+=</operator> <name><name>le</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>ddl_cnt</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>conn_cnt</name></name> <operator>+=</operator> <name><name>le</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>conn_cnt</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>select_cnt</name></name> <operator>+=</operator> <name><name>le</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>select_cnt</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>insert_cnt</name></name> <operator>+=</operator> <name><name>le</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>insert_cnt</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>update_cnt</name></name> <operator>+=</operator> <name><name>le</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>update_cnt</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>delete_cnt</name></name> <operator>+=</operator> <name><name>le</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>delete_cnt</name></name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>conn_cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>select_cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>insert_cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>update_cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>delete_cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>ddl_cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>STORM_STATS_COLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* switch to appropriate context while storing the tuple */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared_state</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* clean up and return the tuplestore */</comment>
    <expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* destroy local hash table */</comment>
    <if_stmt><if>if <condition>(<expr><name>LocalStatsHash</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>LocalStatsHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
