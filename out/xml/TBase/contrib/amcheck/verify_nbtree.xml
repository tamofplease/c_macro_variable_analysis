<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/contrib/amcheck/verify_nbtree.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * verify_nbtree.c
 *        Verifies the integrity of nbtree indexes based on invariants.
 *
 * For B-Tree indexes, verification includes checking that each page in the
 * target index has items in logical order as reported by an insertion scankey
 * (the insertion scankey sort-wise NULL semantics are needed for
 * verification).
 *
 *
 * Copyright (c) 2017, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *      contrib/amcheck/verify_nbtree.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>


<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<comment type="block">/*
 * A B-Tree cannot possibly have this many levels, since there must be one
 * block per level, which is bound by the range of BlockNumber:
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>InvalidBtreeLevel</name></cpp:macro>    <cpp:value>((uint32) InvalidBlockNumber)</cpp:value></cpp:define>

<comment type="block">/*
 * State associated with verifying a B-Tree index
 *
 * target is the point of reference for a verification operation.
 *
 * Other B-Tree pages may be allocated, but those are always auxiliary (e.g.,
 * they are current target's child pages). Conceptually, problems are only
 * ever found in the current target page. Each page found by verification's
 * left/right, top/bottom scan becomes the target exactly once.
 */</comment>
<typedef>typedef <type><struct>struct <name>BtreeCheckState</name>
<block>{
    <comment type="block">/*
     * Unchanging state, established at start of verification:
     */</comment>

    <comment type="block">/* B-Tree Index Relation */</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <comment type="block">/* ShareLock held on heap/index, rather than AccessShareLock? */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>readonly</name></decl>;</decl_stmt>
    <comment type="block">/* Per-page context */</comment>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>targetcontext</name></decl>;</decl_stmt>
    <comment type="block">/* Buffer access strategy */</comment>
    <decl_stmt><decl><type><name>BufferAccessStrategy</name></type> <name>checkstrategy</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Mutable state, for verification of particular page:
     */</comment>

    <comment type="block">/* Current target page */</comment>
    <decl_stmt><decl><type><name>Page</name></type>        <name>target</name></decl>;</decl_stmt>
    <comment type="block">/* Target block number */</comment>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>targetblock</name></decl>;</decl_stmt>
    <comment type="block">/* Target page's LSN */</comment>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>targetlsn</name></decl>;</decl_stmt>
}</block></struct></type> <name>BtreeCheckState</name>;</typedef>

<comment type="block">/*
 * Starting point for verifying an entire B-Tree index level
 */</comment>
<typedef>typedef <type><struct>struct <name>BtreeLevel</name>
<block>{
    <comment type="block">/* Level number (0 is leaf page level). */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>level</name></decl>;</decl_stmt>

    <comment type="block">/* Left most block on level.  Scan of level begins here. */</comment>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>leftmost</name></decl>;</decl_stmt>

    <comment type="block">/* Is this level reported as "true" root level by meta page? */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>istruerootlevel</name></decl>;</decl_stmt>
}</block></struct></type> <name>BtreeLevel</name>;</typedef>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>bt_index_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>bt_index_parent_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bt_index_check_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indrelid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>parentcheck</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>btree_index_checkable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bt_check_every_level</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>readonly</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BtreeLevel</name></type> <name>bt_check_level_from_leftmost</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
                             <parameter><decl><type><name>BtreeLevel</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bt_target_page_check</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ScanKey</name></type> <name>bt_right_page_check_scankey</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bt_downlink_check</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>childblock</name></decl></parameter>,
                  <parameter><decl><type><name>ScanKey</name></type> <name>targetkey</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>offset_is_negative_infinity</name><parameter_list>(<parameter><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl></parameter>,
                            <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>invariant_leq_offset</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
                     <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>,
                     <parameter><decl><type><name>OffsetNumber</name></type> <name>upperbound</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>invariant_geq_offset</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
                     <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>,
                     <parameter><decl><type><name>OffsetNumber</name></type> <name>lowerbound</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>invariant_leq_nontarget_offset</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
                               <parameter><decl><type><name>Page</name></type> <name>other</name></decl></parameter>,
                               <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>,
                               <parameter><decl><type><name>OffsetNumber</name></type> <name>upperbound</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Page</name></type> <name>palloc_btree_page</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * bt_index_check(index regclass)
 *
 * Verify integrity of B-Tree index.
 *
 * Acquires AccessShareLock on heap &amp; index relations.  Does not consider
 * invariants that exist between parent/child pages.
 */</comment>
<function><type><name>Datum</name></type>
<name>bt_index_check</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>indrelid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>bt_index_check_internal</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bt_index_parent_check(index regclass)
 *
 * Verify integrity of B-Tree index.
 *
 * Acquires ShareLock on heap &amp; index relations.  Verifies that downlinks in
 * parent pages are valid lower bounds on child pages.
 */</comment>
<function><type><name>Datum</name></type>
<name>bt_index_parent_check</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>indrelid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>bt_index_check_internal</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper for bt_index_[parent_]check, coordinating the bulk of the work.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bt_index_check_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indrelid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>parentcheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>heapid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>indrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>heaprel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKMODE</name></type>    <name>lockmode</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>parentcheck</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>ShareLock</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * We must lock table before index to avoid deadlocks.  However, if the
     * passed indrelid isn't an index then IndexGetRelation() will fail.
     * Rather than emitting a not-very-helpful error message, postpone
     * complaining, expecting that the is-it-an-index test below will fail.
     *
     * In hot standby mode this will raise an error when parentcheck is true.
     */</comment>
    <expr_stmt><expr><name>heapid</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>heapid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>heaprel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>heapid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>heaprel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Open the target index relations separately (like relation_openrv(), but
     * with heap relation locked first to prevent deadlocking).  In hot
     * standby mode this will raise an error when parentcheck is true.
     */</comment>
    <expr_stmt><expr><name>indrel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Since we did the IndexGetRelation call above without any lock, it's
     * barely possible that a race against an index drop/recreation could have
     * netted us the wrong table.  Although the table itself won't actually be
     * examined during verification currently, a recheck still seems like a
     * good idea.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>heaprel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>heapid</name> <operator>!=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open parent table of index %s"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Relation suitable for checking as B-Tree? */</comment>
    <expr_stmt><expr><call><name>btree_index_checkable</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check index */</comment>
    <expr_stmt><expr><call><name>bt_check_every_level</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>, <argument><expr><name>parentcheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Release locks early. That's ok here because nothing in the called
     * routines will trigger shared cache invalidations to be sent, so we can
     * relax the usual pattern of only releasing locks after commit.
     */</comment>
    <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>heaprel</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>heaprel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Basic checks about the suitability of a relation for checking as a B-Tree
 * index.
 *
 * NB: Intentionally not checking permissions, the function is normally not
 * callable by non-superusers. If granted, it's useful to be able to check a
 * whole cluster.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>btree_index_checkable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
        <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only B-Tree indexes are supported as targets for verification"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Relation \"%s\" is not a B-Tree index."</literal></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot access temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Index \"%s\" is associated with temporary relation."</literal></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IndexIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_index</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot check index \"%s\""</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Index is not valid"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Main entry point for B-Tree SQL-callable functions. Walks the B-Tree in
 * logical order, verifying invariants as it goes.
 *
 * It is the caller's responsibility to acquire appropriate heavyweight lock on
 * the index relation, and advise us if extra checks are safe when a ShareLock
 * is held.
 *
 * A ShareLock is generally assumed to prevent any kind of physical
 * modification to the index structure, including modifications that VACUUM may
 * make.  This does not include setting of the LP_DEAD bit by concurrent index
 * scans, although that is just metadata that is not able to directly affect
 * any check performed here.  Any concurrent process that might act on the
 * LP_DEAD bit being set (recycle space) requires a heavyweight lock that
 * cannot be held while we hold a ShareLock.  (Besides, even if that could
 * happen, the ad-hoc recycling when a page might otherwise split is performed
 * per-page, and requires an exclusive buffer lock, which wouldn't cause us
 * trouble.  _bt_delitems_vacuum() may only delete leaf items, and so the extra
 * parent/child check cannot be affected.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bt_check_every_level</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>readonly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>metapage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>previouslevel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BtreeLevel</name></type>    <name>current</name></decl>;</decl_stmt>

    <comment type="block">/*
     * RecentGlobalXmin assertion matches index_getnext_tid().  See note on
     * RecentGlobalXmin/B-Tree page deletion.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>RecentGlobalXmin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize state for entire verification operation
     */</comment>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BtreeCheckState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readonly</name></name> <operator>=</operator> <name>readonly</name></expr>;</expr_stmt>
    <comment type="block">/* Create context for page */</comment>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>targetcontext</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                                 <argument><expr><literal type="string">"amcheck context"</literal></expr></argument>,
                                                 <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
                                                 <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
                                                 <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>checkstrategy</name></name> <operator>=</operator> <call><name>GetAccessStrategy</name><argument_list>(<argument><expr><name>BAS_BULKREAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get true root block from meta-page */</comment>
    <expr_stmt><expr><name>metapage</name> <operator>=</operator> <call><name>palloc_btree_page</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>BTREE_METAPAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>metad</name> <operator>=</operator> <call><name>BTPageGetMeta</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Certain deletion patterns can result in "skinny" B-Tree indexes, where
     * the fast root and true root differ.
     *
     * Start from the true root, not the fast root, unlike conventional index
     * scans.  This approach is more thorough, and removes the risk of
     * following a stale fast root from the meta page.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name> <operator>!=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"harmless fast root mismatch in index %s"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Fast root block %u (level %u) differs from true root block %u (level %u)."</literal></expr></argument>,
                                    <argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name></expr></argument>, <argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name></expr></argument>,
                                    <argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name></expr></argument>, <argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Starting at the root, verify every level.  Move left to right, top to
     * bottom.  Note that there may be no pages other than the meta page (meta
     * page can indicate that root is P_NONE when the index is totally empty).
     */</comment>
    <expr_stmt><expr><name>previouslevel</name> <operator>=</operator> <name>InvalidBtreeLevel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current</name><operator>.</operator><name>leftmost</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current</name><operator>.</operator><name>istruerootlevel</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name><name>current</name><operator>.</operator><name>leftmost</name></name> <operator>!=</operator> <name>P_NONE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Verify this level, and get left most page for next level down, if
         * not at leaf level
         */</comment>
        <expr_stmt><expr><name>current</name> <operator>=</operator> <call><name>bt_check_level_from_leftmost</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>current</name><operator>.</operator><name>leftmost</name></name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" has no valid pages on level below %u or first level"</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>previouslevel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>previouslevel</name> <operator>=</operator> <name><name>current</name><operator>.</operator><name>level</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Be tidy: */</comment>
    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given a left-most block at some level, move right, verifying each page
 * individually (with more verification across pages for "readonly"
 * callers).  Caller should pass the true root page as the leftmost initially,
 * working their way down by passing what is returned for the last call here
 * until level 0 (leaf page level) was reached.
 *
 * Returns state for next call, if any.  This includes left-most block number
 * one level lower that should be passed on next level/call, which is set to
 * P_NONE on last call here (when leaf level is verified).  Level numbers
 * follow the nbtree convention: higher levels have higher numbers, because new
 * levels are added only due to a root page split.  Note that prior to the
 * first root page split, the root is also a leaf page, so there is always a
 * level 0 (leaf level), and it's always the last level processed.
 *
 * Note on memory management:  State's per-page context is reset here, between
 * each call to bt_target_page_check().
 */</comment>
<function><type><specifier>static</specifier> <name>BtreeLevel</name></type>
<name>bt_check_level_from_leftmost</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BtreeLevel</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* State to establish early, concerning entire level */</comment>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BtreeLevel</name></type>    <name>nextleveldown</name></decl>;</decl_stmt>

    <comment type="block">/* Variables for iterating across level using right links */</comment>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>leftcurrent</name> <init>= <expr><name>P_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>current</name> <init>= <expr><name><name>level</name><operator>.</operator><name>leftmost</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Initialize return state */</comment>
    <expr_stmt><expr><name><name>nextleveldown</name><operator>.</operator><name>leftmost</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nextleveldown</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name>InvalidBtreeLevel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nextleveldown</name><operator>.</operator><name>istruerootlevel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* Use page-level context for duration of this call */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"verifying level %u%s"</literal></expr></argument>, <argument><expr><name><name>level</name><operator>.</operator><name>level</name></name></expr></argument>,
         <argument><expr><ternary><condition><expr><name><name>level</name><operator>.</operator><name>istruerootlevel</name></name></expr> ?</condition><then>
         <expr><literal type="string">" (true root level)"</literal></expr> </then><else>: <expr><ternary><condition><expr><name><name>level</name><operator>.</operator><name>level</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">" (leaf level)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <do>do
    <block>{<block_content>
        <comment type="block">/* Don't rely on CHECK_FOR_INTERRUPTS() calls at lower level */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Initialize state for this iteration */</comment>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name> <operator>=</operator> <name>current</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <call><name>palloc_btree_page</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>=</operator> <call><name>PageGetLSN</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"block %u fell off the end of index \"%s\""</literal></expr></argument>,
                                <argument><expr><name>current</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"block %u of index \"%s\" ignored"</literal></expr></argument>,
                                <argument><expr><name>current</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <goto>goto <name>nextpage</name>;</goto>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>nextleveldown</name><operator>.</operator><name>leftmost</name></name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * A concurrent page split could make the caller supplied leftmost
             * block no longer contain the leftmost page, or no longer be the
             * true root, but where that isn't possible due to heavyweight
             * locking, check that the first valid page meets caller's
             * expectations.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>readonly</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_LEFTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"block %u is not leftmost in index \"%s\""</literal></expr></argument>,
                                    <argument><expr><name>current</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>level</name><operator>.</operator><name>istruerootlevel</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>P_ISROOT</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"block %u is not true root in index \"%s\""</literal></expr></argument>,
                                    <argument><expr><name>current</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Before beginning any non-trivial examination of level, prepare
             * state for next bt_check_level_from_leftmost() invocation for
             * the next level for the next level down (if any).
             *
             * There should be at least one non-ignorable page per level,
             * unless this is the leaf level, which is assumed by caller to be
             * final level.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ItemId</name></type>        <name>itemid</name></decl>;</decl_stmt>

                <comment type="block">/* Internal page -- downlink gets leftmost on next level */</comment>
                <expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nextleveldown</name><operator>.</operator><name>leftmost</name></name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nextleveldown</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * Leaf page -- final level caller must process.
                 *
                 * Note that this could also be the root page, if there has
                 * been no root page split yet.
                 */</comment>
                <expr_stmt><expr><name><name>nextleveldown</name><operator>.</operator><name>leftmost</name></name> <operator>=</operator> <name>P_NONE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nextleveldown</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name>InvalidBtreeLevel</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * Finished setting up state for this call/level.  Control will
             * never end up back here in any future loop iteration for this
             * level.
             */</comment>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>readonly</name></name> <operator>&amp;&amp;</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>!=</operator> <name>leftcurrent</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"left link/right link pair in index \"%s\" not in agreement"</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Block=%u left block=%u left link from block=%u."</literal></expr></argument>,
                                        <argument><expr><name>current</name></expr></argument>, <argument><expr><name>leftcurrent</name></expr></argument>, <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Check level, which must be valid for non-ignorable page */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>level</name><operator>.</operator><name>level</name></name> <operator>!=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"leftmost down link for level points to block in index \"%s\" whose level is not one level down"</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Block pointed to=%u expected level=%u level in pointed to block=%u."</literal></expr></argument>,
                                        <argument><expr><name>current</name></expr></argument>, <argument><expr><name><name>level</name><operator>.</operator><name>level</name></name></expr></argument>, <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Verify invariants for page -- all important checks occur here */</comment>
        <expr_stmt><expr><call><name>bt_target_page_check</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>nextpage</name>:</label>

        <comment type="block">/* Try to detect circular links */</comment>
        <if_stmt><if>if <condition>(<expr><name>current</name> <operator>==</operator> <name>leftcurrent</name> <operator>||</operator> <name>current</name> <operator>==</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"circular link chain found in block %u of index \"%s\""</literal></expr></argument>,
                            <argument><expr><name>current</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>leftcurrent</name> <operator>=</operator> <name>current</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>

        <comment type="block">/* Free page and associated memory for this iteration */</comment>
        <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    while <condition>(<expr><name>current</name> <operator>!=</operator> <name>P_NONE</name></expr>)</condition>;</do>

    <comment type="block">/* Don't change context for caller */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>nextleveldown</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Function performs the following checks on target page, or pages ancillary to
 * target page:
 *
 * - That every "real" data item is less than or equal to the high key, which
 *     is an upper bound on the items on the pages (where there is a high key at
 *     all -- pages that are rightmost lack one).
 *
 * - That within the page, every "real" item is less than or equal to the item
 *     immediately to its right, if any (i.e., that the items are in order within
 *     the page, so that the binary searches performed by index scans are sane).
 *
 * - That the last item stored on the page is less than or equal to the first
 *     "real" data item on the page to the right (if such a first item is
 *     available).
 *
 * Furthermore, when state passed shows ShareLock held, and target page is
 * internal page, function also checks:
 *
 * - That all child pages respect downlinks lower bound.
 *
 * Note:  Memory allocated in this routine is expected to be released by caller
 * resetting state-&gt;targetcontext.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bt_target_page_check</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>max</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>topaque</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>topaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"verifying %u items on %s block %u"</literal></expr></argument>, <argument><expr><name>max</name></expr></argument>,
         <argument><expr><ternary><condition><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"leaf"</literal></expr> </then><else>: <expr><literal type="string">"internal"</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Loop over page items, starting from first non-highkey item, not high
     * key (if any).  Also, immediately skip "negative infinity" real item (if
     * any).
     */</comment>
    <for>for <control>(<init><expr><name>offset</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr>;</init>
         <condition><expr><name>offset</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition>
         <incr><expr><name>offset</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ItemId</name></type>        <name>itemid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ScanKey</name></type>        <name>skey</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Don't try to generate scankey using "negative infinity" garbage
         * data
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>offset_is_negative_infinity</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Build insertion scankey for current page offset */</comment>
        <expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>skey</name> <operator>=</operator> <call><name>_bt_mkscankey</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * * High key check *
         *
         * If there is a high key (if this is not the rightmost page on its
         * entire level), check that high key actually is upper bound on all
         * page items.
         *
         * We prefer to check all items against high key rather than checking
         * just the last and trusting that the operator class obeys the
         * transitive law (which implies that all previous items also
         * respected the high key invariant if they pass the item order
         * check).
         *
         * Ideally, we'd compare every item in the index against every other
         * item in the index, and not trust opclass obedience of the
         * transitive law to bridge the gap between children and their
         * grandparents (as well as great-grandparents, and so on).  We don't
         * go to those lengths because that would be prohibitively expensive,
         * and probably not markedly more effective in practice.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>invariant_leq_offset</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>skey</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>itid</name></decl>,
                       <decl><type ref="prev"><modifier>*</modifier></type><name>htid</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>itid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u,%u)"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>htid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u,%u)"</literal></expr></argument>,
                            <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"high key invariant violated for index \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Index tid=%s points to %s tid=%s page lsn=%X/%X."</literal></expr></argument>,
                                        <argument><expr><name>itid</name></expr></argument>,
                                        <argument><expr><ternary><condition><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"heap"</literal></expr> </then><else>: <expr><literal type="string">"index"</literal></expr></else></ternary></expr></argument>,
                                        <argument><expr><name>htid</name></expr></argument>,
                                        <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                                        <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * * Item order check *
         *
         * Check that items are stored on page in logical order, by checking
         * current item is less than or equal to next item (if any).
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>max</name> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>invariant_leq_offset</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>skey</name></expr></argument>,
                                  <argument><expr><call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>itid</name></decl>,
                       <decl><type ref="prev"><modifier>*</modifier></type><name>htid</name></decl>,
                       <decl><type ref="prev"><modifier>*</modifier></type><name>nitid</name></decl>,
                       <decl><type ref="prev"><modifier>*</modifier></type><name>nhtid</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>itid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u,%u)"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>htid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u,%u)"</literal></expr></argument>,
                            <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nitid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u,%u)"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>,
                             <argument><expr><call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Reuse itup to get pointed-to heap location of second item */</comment>
            <expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nhtid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u,%u)"</literal></expr></argument>,
                             <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"item order invariant violated for index \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Lower index tid=%s (points to %s tid=%s) "</literal>
                                        <literal type="string">"higher index tid=%s (points to %s tid=%s) "</literal>
                                        <literal type="string">"page lsn=%X/%X."</literal></expr></argument>,
                                        <argument><expr><name>itid</name></expr></argument>,
                                        <argument><expr><ternary><condition><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"heap"</literal></expr> </then><else>: <expr><literal type="string">"index"</literal></expr></else></ternary></expr></argument>,
                                        <argument><expr><name>htid</name></expr></argument>,
                                        <argument><expr><name>nitid</name></expr></argument>,
                                        <argument><expr><ternary><condition><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"heap"</literal></expr> </then><else>: <expr><literal type="string">"index"</literal></expr></else></ternary></expr></argument>,
                                        <argument><expr><name>nhtid</name></expr></argument>,
                                        <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                                        <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>

        <comment type="block">/*
         * * Last item check *
         *
         * Check last item against next/right page's first data item's when
         * last item on page is reached.  This additional check can detect
         * transposed pages.
         *
         * This check is similar to the item order check that will have
         * already been performed for every other "real" item on target page
         * when last item is checked.  The difference is that the next item
         * (the item that is compared to target's last item) needs to come
         * from the next/sibling page.  There may not be such an item
         * available from sibling for various reasons, though (e.g., target is
         * the rightmost page on level).
         */</comment>
        <if type="elseif">else if <condition>(<expr><name>offset</name> <operator>==</operator> <name>max</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ScanKey</name></type>        <name>rightkey</name></decl>;</decl_stmt>

            <comment type="block">/* Get item in next/right page */</comment>
            <expr_stmt><expr><name>rightkey</name> <operator>=</operator> <call><name>bt_right_page_check_scankey</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>rightkey</name> <operator>&amp;&amp;</operator>
                <operator>!</operator><call><name>invariant_geq_offset</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>rightkey</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * As explained at length in bt_right_page_check_scankey(),
                 * there is a known !readonly race that could account for
                 * apparent violation of invariant, which we must check for
                 * before actually proceeding with raising error.  Our canary
                 * condition is that target page was deleted.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>readonly</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Get fresh copy of target page */</comment>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <call><name>palloc_btree_page</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* Note that we deliberately do not update target LSN */</comment>
                    <expr_stmt><expr><name>topaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * All !readonly checks now performed; just return
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return;</return></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cross page item order invariant violated for index \"%s\""</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Last item on page tid=(%u,%u) page lsn=%X/%X."</literal></expr></argument>,
                                            <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
                                            <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                                            <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * * Downlink check *
         *
         * Additional check of child items iff this is an internal page and
         * caller holds a ShareLock.  This happens for every downlink (item)
         * in target excluding the negative-infinity downlink (again, this is
         * because it has no useful value to compare).
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>readonly</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>BlockNumber</name></type> <name>childblock</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>bt_downlink_check</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>childblock</name></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Return a scankey for an item on page to right of current target (or the
 * first non-ignorable page), sufficient to check ordering invariant on last
 * item in current target page.  Returned scankey relies on local memory
 * allocated for the child page, which caller cannot pfree().  Caller's memory
 * context should be reset between calls here.
 *
 * This is the first data item, and so all adjacent items are checked against
 * their immediate sibling item (which may be on a sibling page, or even a
 * "cousin" page at parent boundaries where target's rightlink points to page
 * with different parent page).  If no such valid item is available, return
 * NULL instead.
 *
 * Note that !readonly callers must reverify that target page has not
 * been concurrently deleted.
 */</comment>
<function><type><specifier>static</specifier> <name>ScanKey</name></type>
<name>bt_right_page_check_scankey</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemId</name></type>        <name>rightitem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>targetnext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>rightpage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>nline</name></decl>;</decl_stmt>

    <comment type="block">/* Determine target's next block number */</comment>
    <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If target is already rightmost, no right sibling; nothing to do here */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * General notes on concurrent page splits and page deletion:
     *
     * Routines like _bt_search() don't require *any* page split interlock
     * when descending the tree, including something very light like a buffer
     * pin. That's why it's okay that we don't either.  This avoidance of any
     * need to "couple" buffer locks is the raison d' etre of the Lehman &amp; Yao
     * algorithm, in fact.
     *
     * That leaves deletion.  A deleted page won't actually be recycled by
     * VACUUM early enough for us to fail to at least follow its right link
     * (or left link, or downlink) and find its sibling, because recycling
     * does not occur until no possible index scan could land on the page.
     * Index scans can follow links with nothing more than their snapshot as
     * an interlock and be sure of at least that much.  (See page
     * recycling/RecentGlobalXmin notes in nbtree README.)
     *
     * Furthermore, it's okay if we follow a rightlink and find a half-dead or
     * dead (ignorable) page one or more times.  There will either be a
     * further right link to follow that leads to a live page before too long
     * (before passing by parent's rightmost child), or we will find the end
     * of the entire level instead (possible when parent page is itself the
     * rightmost on its level).
     */</comment>
    <expr_stmt><expr><name>targetnext</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rightpage</name> <operator>=</operator> <call><name>palloc_btree_page</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetnext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/* We landed on a deleted page, so step right to find a live page */</comment>
        <expr_stmt><expr><name>targetnext</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"level %u leftmost page of index \"%s\" was found deleted or half dead"</literal></expr></argument>,
                        <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Deleted page found when building scankey from right sibling."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Be slightly more pro-active in freeing this memory, just in case */</comment>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * No ShareLock held case -- why it's safe to proceed.
     *
     * Problem:
     *
     * We must avoid false positive reports of corruption when caller treats
     * item returned here as an upper bound on target's last item.  In
     * general, false positives are disallowed.  Avoiding them here when
     * caller is !readonly is subtle.
     *
     * A concurrent page deletion by VACUUM of the target page can result in
     * the insertion of items on to this right sibling page that would
     * previously have been inserted on our target page.  There might have
     * been insertions that followed the target's downlink after it was made
     * to point to right sibling instead of target by page deletion's first
     * phase. The inserters insert items that would belong on target page.
     * This race is very tight, but it's possible.  This is our only problem.
     *
     * Non-problems:
     *
     * We are not hindered by a concurrent page split of the target; we'll
     * never land on the second half of the page anyway.  A concurrent split
     * of the right page will also not matter, because the first data item
     * remains the same within the left half, which we'll reliably land on. If
     * we had to skip over ignorable/deleted pages, it cannot matter because
     * their key space has already been atomically merged with the first
     * non-ignorable page we eventually find (doesn't matter whether the page
     * we eventually find is a true sibling or a cousin of target, which we go
     * into below).
     *
     * Solution:
     *
     * Caller knows that it should reverify that target is not ignorable
     * (half-dead or deleted) when cross-page sibling item comparison appears
     * to indicate corruption (invariant fails).  This detects the single race
     * condition that exists for caller.  This is correct because the
     * continued existence of target block as non-ignorable (not half-dead or
     * deleted) implies that target page was not merged into from the right by
     * deletion; the key space at or after target never moved left.  Target's
     * parent either has the same downlink to target as before, or a &lt;=
     * downlink due to deletion at the left of target.  Target either has the
     * same highkey as before, or a highkey &lt;= before when there is a page
     * split. (The rightmost concurrently-split-from-target-page page will
     * still have the same highkey as target was originally found to have,
     * which for our purposes is equivalent to target's highkey itself never
     * changing, since we reliably skip over
     * concurrently-split-from-target-page pages.)
     *
     * In simpler terms, we allow that the key space of the target may expand
     * left (the key space can move left on the left side of target only), but
     * the target key space cannot expand right and get ahead of us without
     * our detecting it.  The key space of the target cannot shrink, unless it
     * shrinks to zero due to the deletion of the original page, our canary
     * condition.  (To be very precise, we're a bit stricter than that because
     * it might just have been that the target page split and only the
     * original target page was deleted.  We can be more strict, just not more
     * lax.)
     *
     * Top level tree walk caller moves on to next page (makes it the new
     * target) following recovery from this race.  (cf.  The rationale for
     * child/downlink verification needing a ShareLock within
     * bt_downlink_check(), where page deletion is also the main source of
     * trouble.)
     *
     * Note that it doesn't matter if right sibling page here is actually a
     * cousin page, because in order for the key space to be readjusted in a
     * way that causes us issues in next level up (guiding problematic
     * concurrent insertions to the cousin from the grandparent rather than to
     * the sibling from the parent), there'd have to be page deletion of
     * target's parent page (affecting target's parent's downlink in target's
     * grandparent page).  Internal page deletion only occurs when there are
     * no child pages (they were all fully deleted), and caller is checking
     * that the target's parent has at least one non-deleted (so
     * non-ignorable) child: the target page.  (Note that the first phase of
     * deletion atomically marks the page to be deleted half-dead/ignorable at
     * the same time downlink in its parent is removed, so caller will
     * definitely not fail to detect that this happened.)
     *
     * This trick is inspired by the method backward scans use for dealing
     * with concurrent page splits; concurrent page deletion is a problem that
     * similarly receives special consideration sometimes (it's possible that
     * the backwards scan will re-read its "original" block after failing to
     * find a right-link to it, having already moved in the opposite direction
     * (right/"forwards") a few times to try to locate one).  Just like us,
     * that happens only to determine if there was a concurrent page deletion
     * of a reference page, and just like us if there was a page deletion of
     * that reference page it means we can move on from caring about the
     * reference page.  See the nbtree README for a full description of how
     * that works.
     */</comment>
    <expr_stmt><expr><name>nline</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get first data item, if any
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>nline</name> <operator>&gt;=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Return first data item (if any) */</comment>
        <expr_stmt><expr><name>rightitem</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
             <name>nline</name> <operator>&gt;=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Return first item after the internal page's "negative infinity"
         * item
         */</comment>
        <expr_stmt><expr><name>rightitem</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>,
                                  <argument><expr><call><name>OffsetNumberNext</name><argument_list>(<argument><expr><call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * No first item.  Page is probably empty leaf page, but it's also
         * possible that it's an internal page with only a negative infinity
         * item.
         */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s block %u of index \"%s\" has no first data item"</literal></expr></argument>,
                        <argument><expr><ternary><condition><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"leaf"</literal></expr> </then><else>: <expr><literal type="string">"internal"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>targetnext</name></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Return first real item scankey.  Note that this relies on right page
     * memory remaining allocated.
     */</comment>
    <return>return <expr><call><name>_bt_mkscankey</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,
                         <argument><expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><name>rightitem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Checks one of target's downlink against its child page.
 *
 * Conceptually, the target page continues to be what is checked here.  The
 * target block is still blamed in the event of finding an invariant violation.
 * The downlink insertion into the target is probably where any problem raised
 * here arises, and there is no such thing as a parent link, so doing the
 * verification this way around is much more practical.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bt_downlink_check</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>childblock</name></decl></parameter>,
                  <parameter><decl><type><name>ScanKey</name></type> <name>targetkey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoffset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>child</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>copaque</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Caller must have ShareLock on target relation, because of
     * considerations around page deletion by VACUUM.
     *
     * NB: In general, page deletion deletes the right sibling's downlink, not
     * the downlink of the page being deleted; the deleted page's downlink is
     * reused for its sibling.  The key space is thereby consolidated between
     * the deleted page and its right sibling.  (We cannot delete a parent
     * page's rightmost child unless it is the last child page, and we intend
     * to also delete the parent itself.)
     *
     * If this verification happened without a ShareLock, the following race
     * condition could cause false positives:
     *
     * In general, concurrent page deletion might occur, including deletion of
     * the left sibling of the child page that is examined here.  If such a
     * page deletion were to occur, closely followed by an insertion into the
     * newly expanded key space of the child, a window for the false positive
     * opens up: the stale parent/target downlink originally followed to get
     * to the child legitimately ceases to be a lower bound on all items in
     * the page, since the key space was concurrently expanded "left".
     * (Insertion followed the "new" downlink for the child, not our now-stale
     * downlink, which was concurrently physically removed in target/parent as
     * part of deletion's first phase.)
     *
     * Note that while the cross-page-same-level last item check uses a trick
     * that allows it to perform verification for !readonly callers, a similar
     * trick seems difficult here.  The trick that that other check uses is,
     * in essence, to lock down race conditions to those that occur due to
     * concurrent page deletion of the target; that's a race that can be
     * reliably detected before actually reporting corruption.
     *
     * On the other hand, we'd need to lock down race conditions involving
     * deletion of child's left page, for long enough to read the child page
     * into memory (in other words, a scheme with concurrently held buffer
     * locks on both child and left-of-child pages).  That's unacceptable for
     * amcheck functions on general principle, though.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readonly</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Verify child page has the downlink key from target page (its parent) as
     * a lower bound.
     *
     * Check all items, rather than checking just the first and trusting that
     * the operator class obeys the transitive law.
     */</comment>
    <expr_stmt><expr><name>child</name> <operator>=</operator> <call><name>palloc_btree_page</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>childblock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>copaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>maxoffset</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>offset</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>copaque</name></expr></argument>)</argument_list></call></expr>;</init>
         <condition><expr><name>offset</name> <operator>&lt;=</operator> <name>maxoffset</name></expr>;</condition>
         <incr><expr><name>offset</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * Skip comparison of target page key against "negative infinity"
         * item, if any.  Checking it would indicate that it's not an upper
         * bound, but that's only because of the hard-coding within
         * _bt_compare().
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>offset_is_negative_infinity</name><argument_list>(<argument><expr><name>copaque</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>invariant_leq_nontarget_offset</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>child</name></expr></argument>,
                                            <argument><expr><name>targetkey</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"down-link lower bound invariant violated for index \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Parent block=%u child index tid=(%u,%u) parent page lsn=%X/%X."</literal></expr></argument>,
                                        <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name>childblock</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
                                        <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                                        <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Is particular offset within page (whose special state is passed by caller)
 * the page negative-infinity item?
 *
 * As noted in comments above _bt_compare(), there is special handling of the
 * first data item as a "negative infinity" item.  The hard-coding within
 * _bt_compare() makes comparing this item for the purposes of verification
 * pointless at best, since the IndexTuple only contains a valid TID (a
 * reference TID to child page).
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>offset_is_negative_infinity</name><parameter_list>(<parameter><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * For internal pages only, the first item after high key, if any, is
     * negative infinity item.  Internal pages always have a negative infinity
     * item, whereas leaf pages never have one.  This implies that negative
     * infinity item is either first or second line item, or there is none
     * within page.
     *
     * Right-most pages don't have a high key, but could be said to
     * conceptually have a "positive infinity" high key.  Thus, there is a
     * symmetry between down link items in parent pages, and high keys in
     * children.  Together, they represent the part of the key space that
     * belongs to each page in the index.  For example, all children of the
     * root page will have negative infinity as a lower bound from root
     * negative infinity downlink, and positive infinity as an upper bound
     * (implicitly, from "imaginary" positive infinity high key in root).
     */</comment>
    <return>return <expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>offset</name> <operator>==</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Does the invariant hold that the key is less than or equal to a given upper
 * bound offset item?
 *
 * If this function returns false, convention is that caller throws error due
 * to corruption.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>invariant_leq_offset</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>,
                     <parameter><decl><type><name>OffsetNumber</name></type> <name>upperbound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int16</name></type>        <name>natts</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnatts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>cmp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>_bt_compare</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>natts</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>upperbound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>cmp</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Does the invariant hold that the key is greater than or equal to a given
 * lower bound offset item?
 *
 * If this function returns false, convention is that caller throws error due
 * to corruption.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>invariant_geq_offset</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>,
                     <parameter><decl><type><name>OffsetNumber</name></type> <name>lowerbound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int16</name></type>        <name>natts</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnatts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>cmp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>_bt_compare</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>natts</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>lowerbound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>cmp</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Does the invariant hold that the key is less than or equal to a given upper
 * bound offset item, with the offset relating to a caller-supplied page that
 * is not the current target page? Caller's non-target page is typically a
 * child page of the target, checked as part of checking a property of the
 * target page (i.e. the key comes from the target).
 *
 * If this function returns false, convention is that caller throws error due
 * to corruption.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>invariant_leq_nontarget_offset</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
                               <parameter><decl><type><name>Page</name></type> <name>nontarget</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>,
                               <parameter><decl><type><name>OffsetNumber</name></type> <name>upperbound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int16</name></type>        <name>natts</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnatts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>cmp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>_bt_compare</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>natts</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>nontarget</name></expr></argument>, <argument><expr><name>upperbound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>cmp</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a block number of a B-Tree page, return page in palloc()'d memory.
 * While at it, perform some basic checks of the page.
 *
 * There is never an attempt to get a consistent view of multiple pages using
 * multiple concurrent buffer locks; in general, we only acquire a single pin
 * and buffer lock at a time, which is often all that the nbtree code requires.
 *
 * Operating on a copy of the page is useful because it prevents control
 * getting stuck in an uninterruptible state when an underlying operator class
 * misbehaves.
 */</comment>
<function><type><specifier>static</specifier> <name>Page</name></type>
<name>palloc_btree_page</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We copy the page into local storage to avoid holding pin on the buffer
     * longer than we must.
     */</comment>
    <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>,
                                <argument><expr><name><name>state</name><operator>-&gt;</operator><name>checkstrategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Perform the same basic sanity checking that nbtree itself performs for
     * every page:
     */</comment>
    <expr_stmt><expr><call><name>_bt_checkpage</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Only use copy of page in palloc()'d memory */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;</operator> <name>BTP_META</name> <operator>&amp;&amp;</operator> <name>blocknum</name> <operator>!=</operator> <name>BTREE_METAPAGE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid meta page found at block %u in index \"%s\""</literal></expr></argument>,
                        <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check page from block that ought to be meta page */</comment>
    <if_stmt><if>if <condition>(<expr><name>blocknum</name> <operator>==</operator> <name>BTREE_METAPAGE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name> <init>= <expr><call><name>BTPageGetMeta</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;</operator> <name>BTP_META</name><operator>)</operator> <operator>||</operator>
            <name><name>metad</name><operator>-&gt;</operator><name>btm_magic</name></name> <operator>!=</operator> <name>BTREE_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" meta page is corrupt"</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>!=</operator> <name>BTREE_VERSION</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"version mismatch in index \"%s\": file version %d, code version %d"</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name></expr></argument>, <argument><expr><name>BTREE_VERSION</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Deleted pages have no sane "level" field, so can only check non-deleted
     * page level
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid leaf page level %u for block %u in index \"%s\""</literal></expr></argument>,
                        <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>blocknum</name> <operator>!=</operator> <name>BTREE_METAPAGE</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid internal page level 0 for block %u in index \"%s\""</literal></expr></argument>,
                        <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>P_HAS_GARBAGE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"internal page block %u in index \"%s\" has garbage items"</literal></expr></argument>,
                        <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>page</name></expr>;</return>
</block_content>}</block></function>
</unit>
