<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/contrib/cube/cube.c"><comment type="block" format="doxygen">/******************************************************************************
  contrib/cube/cube.c

  This file contains routines that can be bound to a Postgres backend and
  called by the backend in the process of processing queries.  The calling
  format for these routines is dictated by Postgres architecture.
******************************************************************************/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/stratnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cubedata.h"</cpp:file></cpp:include>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<comment type="block">/*
 * Taken from the intarray contrib header
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARRPTR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>( (double *) ARR_DATA_PTR(x) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARRNELEMS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>ArrayGetNItems( ARR_NDIM(x), ARR_DIMS(x))</cpp:value></cpp:define>

<comment type="block">/*
** Input/Output routines
*/</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_a_f8_f8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_a_f8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_f8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_f8_f8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_c_f8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_c_f8_f8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_ll_coord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_ur_coord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_coord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_coord_llur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_subset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
** GiST support methods
*/</comment>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>g_cube_consistent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>g_cube_compress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>g_cube_decompress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>g_cube_penalty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>g_cube_picksplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>g_cube_union</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>g_cube_same</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>g_cube_distance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
** B-tree support functions
*/</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
** R-tree support functions
*/</comment>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_contains</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_contained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_overlap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_union</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_inter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
** miscellaneous
*/</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>distance_taxicab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_distance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>distance_chebyshev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_is_point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>cube_enlarge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
** For internal use only
*/</comment>
<function_decl><type><name>int32</name></type>        <name>cube_cmp_v0</name><parameter_list>(<parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type>        <name>cube_contains_v0</name><parameter_list>(<parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type>        <name>cube_overlap_v0</name><parameter_list>(<parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>cube_union_v0</name><parameter_list>(<parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>        <name>rt_cube_size</name><parameter_list>(<parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>sz</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>g_cube_binary_union</name><parameter_list>(<parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>r1</name></decl></parameter>, <parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>r2</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sizep</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type>        <name>g_cube_leaf_consistent</name><parameter_list>(<parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type>        <name>g_cube_internal_consistent</name><parameter_list>(<parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Auxiliary funxtions
*/</comment>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>distance_1D</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>a1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>a2</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>b1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>b2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>cube_is_point_internal</name><parameter_list>(<parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>cube</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block" format="doxygen">/*****************************************************************************
 * Input/Output functions
 *****************************************************************************/</comment>

<comment type="block">/* NdBox = [(lowerleft),(upperright)] */</comment>
<comment type="block">/* [(xLL(1)...xLL(N)),(xUR(1)...xUR(n))] */</comment>
<function><type><name>Datum</name></type>
<name>cube_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>cube_scanner_init</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>cube_yyparse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>cube_yyerror</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"cube parser failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>cube_scanner_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_NDBOX</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Allows the construction of a cube from 2 float[]'s
*/</comment>
<function><type><name>Datum</name></type>
<name>cube_a_f8_f8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>ur</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>ll</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>dim</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>point</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name>       <modifier>*</modifier></type><name>dur</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>dll</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>array_contains_nulls</name><argument_list>(<argument><expr><name>ur</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>array_contains_nulls</name><argument_list>(<argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_ELEMENT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot work with arrays containing NULLs"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>ARRNELEMS</name><argument_list>(<argument><expr><name>ur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ARRNELEMS</name><argument_list>(<argument><expr><name>ll</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>dim</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_ELEMENT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"UR and LL arrays must be of same length"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>dur</name> <operator>=</operator> <call><name>ARRPTR</name><argument_list>(<argument><expr><name>ur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dll</name> <operator>=</operator> <call><name>ARRPTR</name><argument_list>(<argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if it's a point */</comment>
    <expr_stmt><expr><name>point</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>dur</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>dll</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>point</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <ternary><condition><expr><name>point</name></expr> ?</condition><then> <expr><call><name>POINT_SIZE</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>CUBE_SIZE</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>NDBOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>dur</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>point</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name> <operator>+</operator> <name>dim</name></expr>]</index></name> <operator>=</operator> <name><name>dll</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SET_POINT_BIT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_NDBOX</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allows the construction of a zero-volume cube from a float[]
*/</comment>
<function><type><name>Datum</name></type>
<name>cube_a_f8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>ur</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>dim</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name>       <modifier>*</modifier></type><name>dur</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>array_contains_nulls</name><argument_list>(<argument><expr><name>ur</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_ELEMENT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot work with arrays containing NULLs"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>ARRNELEMS</name><argument_list>(<argument><expr><name>ur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>dur</name> <operator>=</operator> <call><name>ARRPTR</name><argument_list>(<argument><expr><name>ur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>POINT_SIZE</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>NDBOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_POINT_BIT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>dur</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><call><name>PG_RETURN_NDBOX</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>cube_subset</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>idx</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size</name></decl>,
                <decl><type ref="prev"/><name>dim</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>dx</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>array_contains_nulls</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_ELEMENT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot work with arrays containing NULLs"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>dx</name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>ARRNELEMS</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <ternary><condition><expr><call><name>IS_POINT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>POINT_SIZE</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>CUBE_SIZE</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>NDBOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IS_POINT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SET_POINT_BIT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>dx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_ELEMENT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Index out of bounds"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>x</name><index>[<expr><name><name>dx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_POINT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name> <operator>+</operator> <name>dim</name></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>x</name><index>[<expr><name><name>dx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_NDBOX</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>cube_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>cube</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>dim</name> <init>= <expr><call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>float8out_internal</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>cube</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cube_is_point_internal</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>float8out_internal</name><argument_list>(<argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>cube</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>cube</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *                           GiST functions
 *****************************************************************************/</comment>

<comment type="block">/*
** The GiST Consistent method for boxes
** Should return false if for all data items x below entry,
** the predicate x op query == FALSE, where op is the oper
** corresponding to strategy in the pg_amop table.
*/</comment>
<function><type><name>Datum</name></type>
<name>g_cube_consistent</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name> <init>= <expr><operator>(</operator><name>StrategyNumber</name><operator>)</operator> <call><name>PG_GETARG_UINT16</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Oid        subtype = PG_GETARG_OID(3); */</comment>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>recheck</name> <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>res</name></decl>;</decl_stmt>

    <comment type="block">/* All cases served by this function are exact */</comment>
    <expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * if entry is not leaf, use g_cube_internal_consistent, else use
     * g_cube_leaf_consistent
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>GIST_LEAF</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>g_cube_leaf_consistent</name><argument_list>(<argument><expr><call><name>DatumGetNDBOX</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>query</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>g_cube_internal_consistent</name><argument_list>(<argument><expr><call><name>DatumGetNDBOX</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name>query</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** The GiST Union method for boxes
** returns the minimal bounding box that encloses all the entries in entryvec
*/</comment>
<function><type><name>Datum</name></type>
<name>g_cube_union</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name> <init>= <expr><operator>(</operator><name>GistEntryVector</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>sizep</name> <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>NDBOX</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetNDBOX</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * sizep = sizeof(NDBOX); -- NDBOX has variable size
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>sizep</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>g_cube_binary_union</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>,
                                  <argument><expr><call><name>DatumGetNDBOX</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>sizep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** GiST Compress and Decompress methods for boxes
** do not do anything.
*/</comment>

<function><type><name>Datum</name></type>
<name>g_cube_compress</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>g_cube_decompress</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>DatumGetNDBOX</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>key</name> <operator>!=</operator> <call><name>DatumGetNDBOX</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>retval</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTENTRY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><operator>*</operator><name>retval</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
                      <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** The GiST Penalty method for boxes
** As in the R-tree paper, we use change in area as our penalty metric
*/</comment>
<function><type><name>Datum</name></type>
<name>g_cube_penalty</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>origentry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>newentry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>ud</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>tmp1</name></decl>,
                <decl><type ref="prev"/><name>tmp2</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ud</name> <operator>=</operator> <call><name>cube_union_v0</name><argument_list>(<argument><expr><call><name>DatumGetNDBOX</name><argument_list>(<argument><expr><name><name>origentry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><call><name>DatumGetNDBOX</name><argument_list>(<argument><expr><name><name>newentry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rt_cube_size</name><argument_list>(<argument><expr><name>ud</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rt_cube_size</name><argument_list>(<argument><expr><call><name>DatumGetNDBOX</name><argument_list>(<argument><expr><name><name>origentry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator> <operator>(</operator><name>tmp1</name> <operator>-</operator> <name>tmp2</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><operator>*</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/*
** The GiST PickSplit method for boxes
** We use Guttman's poly time split algorithm
*/</comment>
<function><type><name>Datum</name></type>
<name>g_cube_picksplit</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name> <init>= <expr><operator>(</operator><name>GistEntryVector</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GIST_SPLITVEC</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>GIST_SPLITVEC</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>datum_alpha</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>datum_beta</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>datum_l</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>datum_r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>union_d</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>union_dl</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>union_dr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>inter_d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>firsttime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>size_alpha</name></decl>,
                <decl><type ref="prev"/><name>size_beta</name></decl>,
                <decl><type ref="prev"/><name>size_union</name></decl>,
                <decl><type ref="prev"/><name>size_inter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>size_waste</name></decl>,
                <decl><type ref="prev"/><name>waste</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>size_l</name></decl>,
                <decl><type ref="prev"/><name>size_r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nbytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>seed_1</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>seed_2</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>left</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>right</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>(</operator><name>maxoff</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_left</name></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_right</name></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>firsttime</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>waste</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>datum_alpha</name> <operator>=</operator> <call><name>DatumGetNDBOX</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>j</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>datum_beta</name> <operator>=</operator> <call><name>DatumGetNDBOX</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* compute the wasted space by unioning these guys */</comment>
            <comment type="block">/* size_waste = size_union - size_inter; */</comment>
            <expr_stmt><expr><name>union_d</name> <operator>=</operator> <call><name>cube_union_v0</name><argument_list>(<argument><expr><name>datum_alpha</name></expr></argument>, <argument><expr><name>datum_beta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>rt_cube_size</name><argument_list>(<argument><expr><name>union_d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size_union</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>inter_d</name> <operator>=</operator> <call><name>DatumGetNDBOX</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>cube_inter</name></expr></argument>,
                                                        <argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>, <argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>rt_cube_size</name><argument_list>(<argument><expr><name>inter_d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size_inter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>size_waste</name> <operator>=</operator> <name>size_union</name> <operator>-</operator> <name>size_inter</name></expr>;</expr_stmt>

            <comment type="block">/*
             * are these a more promising split than what we've already seen?
             */</comment>

            <if_stmt><if>if <condition>(<expr><name>size_waste</name> <operator>&gt;</operator> <name>waste</name> <operator>||</operator> <name>firsttime</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>waste</name> <operator>=</operator> <name>size_waste</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>seed_1</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>seed_2</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>firsttime</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <expr_stmt><expr><name>left</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>spl_left</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>right</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>spl_right</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nright</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>datum_alpha</name> <operator>=</operator> <call><name>DatumGetNDBOX</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>seed_1</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>datum_l</name> <operator>=</operator> <call><name>cube_union_v0</name><argument_list>(<argument><expr><name>datum_alpha</name></expr></argument>, <argument><expr><name>datum_alpha</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rt_cube_size</name><argument_list>(<argument><expr><name>datum_l</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size_l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>datum_beta</name> <operator>=</operator> <call><name>DatumGetNDBOX</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>seed_2</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>datum_r</name> <operator>=</operator> <call><name>cube_union_v0</name><argument_list>(<argument><expr><name>datum_beta</name></expr></argument>, <argument><expr><name>datum_beta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rt_cube_size</name><argument_list>(<argument><expr><name>datum_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now split up the regions between the two seeds.  An important property
     * of this split algorithm is that the split vector v has the indices of
     * items to be split in order in its left and right vectors.  We exploit
     * this property by doing a merge in the code that actually splits the
     * page.
     *
     * For efficiency, we also place the new index tuple in this loop. This is
     * handled at the very end, when we have placed all the existing tuples
     * and i == maxoff + 1.
     */</comment>

    <expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * If we've already decided where to place this item, just put it on
         * the right list.  Otherwise, we need to figure out which page needs
         * the least enlargement in order to store the item.
         */</comment>

        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>seed_1</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>left</name><operator>++</operator> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>seed_2</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>right</name><operator>++</operator> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nright</name></name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* okay, which page needs least enlargement? */</comment>
        <expr_stmt><expr><name>datum_alpha</name> <operator>=</operator> <call><name>DatumGetNDBOX</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>union_dl</name> <operator>=</operator> <call><name>cube_union_v0</name><argument_list>(<argument><expr><name>datum_l</name></expr></argument>, <argument><expr><name>datum_alpha</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>union_dr</name> <operator>=</operator> <call><name>cube_union_v0</name><argument_list>(<argument><expr><name>datum_r</name></expr></argument>, <argument><expr><name>datum_alpha</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>rt_cube_size</name><argument_list>(<argument><expr><name>union_dl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size_alpha</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>rt_cube_size</name><argument_list>(<argument><expr><name>union_dr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size_beta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* pick which page to add it to */</comment>
        <if_stmt><if>if <condition>(<expr><name>size_alpha</name> <operator>-</operator> <name>size_l</name> <operator>&lt;</operator> <name>size_beta</name> <operator>-</operator> <name>size_r</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>datum_l</name> <operator>=</operator> <name>union_dl</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>size_l</name> <operator>=</operator> <name>size_alpha</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>left</name><operator>++</operator> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>datum_r</name> <operator>=</operator> <name>union_dr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>size_r</name> <operator>=</operator> <name>size_beta</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>right</name><operator>++</operator> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nright</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><operator>*</operator><name>left</name> <operator>=</operator> <operator>*</operator><name>right</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt> <comment type="block">/* sentinel value, see dosplit() */</comment>

    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_ldatum</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>datum_l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_rdatum</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>datum_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Equality method
*/</comment>
<function><type><name>Datum</name></type>
<name>g_cube_same</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>b1</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>b2</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>cube_cmp_v0</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_NDBOX</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** SUPPORT ROUTINES
*/</comment>
<function><type><name>bool</name></type>
<name>g_cube_leaf_consistent</name><parameter_list>(<parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
                       <parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                       <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>retval</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>RTOverlapStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <call><name>cube_overlap_v0</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTSameStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <operator>(</operator><call><name>cube_cmp_v0</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTContainsStrategyNumber</name></expr>:</case>
        <case>case <expr><name>RTOldContainsStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <call><name>cube_contains_v0</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTContainedByStrategyNumber</name></expr>:</case>
        <case>case <expr><name>RTOldContainedByStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <call><name>cube_contains_v0</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    </block_content>}</block></switch>
    <return>return <expr><operator>(</operator><name>retval</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>g_cube_internal_consistent</name><parameter_list>(<parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
                           <parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                           <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>retval</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>RTOverlapStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <call><name>cube_overlap_v0</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTSameStrategyNumber</name></expr>:</case>
        <case>case <expr><name>RTContainsStrategyNumber</name></expr>:</case>
        <case>case <expr><name>RTOldContainsStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <call><name>cube_contains_v0</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTContainedByStrategyNumber</name></expr>:</case>
        <case>case <expr><name>RTOldContainedByStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <call><name>cube_overlap_v0</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    </block_content>}</block></switch>
    <return>return <expr><operator>(</operator><name>retval</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>NDBOX</name> <modifier>*</modifier></type>
<name>g_cube_binary_union</name><parameter_list>(<parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>r1</name></decl></parameter>, <parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>r2</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sizep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>cube_union_v0</name><argument_list>(<argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>sizep</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>retval</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* cube_union_v0 */</comment>
<function><type><name>NDBOX</name> <modifier>*</modifier></type>
<name>cube_union_v0</name><parameter_list>(<parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>dim</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size</name></decl>;</decl_stmt>

    <comment type="block">/* trivial case */</comment>
    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>a</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* swap the arguments if needed, so that 'a' is always larger than 'b' */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>b</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>CUBE_SIZE</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* First compute the union of the dimensions present in both args */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Min</name><argument_list>(
                           <argument><expr><call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name> <operator>+</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Max</name><argument_list>(
                                    <argument><expr><call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* continue on the higher dimensions only present in 'a' */</comment>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name> <operator>+</operator> <name>dim</name></expr>]</index></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
                                 <argument><expr><call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Check if the result was in fact a point, and set the flag in the datum
     * accordingly. (we don't bother to repalloc it smaller)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>cube_is_point_internal</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>POINT_SIZE</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_POINT_BIT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><operator>(</operator><name>result</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>cube_union</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>cube_union_v0</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_NDBOX</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* cube_inter */</comment>
<function><type><name>Datum</name></type>
<name>cube_inter</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>swapped</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>dim</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size</name></decl>;</decl_stmt>

    <comment type="block">/* swap the arguments if needed, so that 'a' is always larger than 'b' */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>b</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>swapped</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>CUBE_SIZE</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>NDBOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* First compute intersection of the dimensions present in both args */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Max</name><argument_list>(
                           <argument><expr><call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name> <operator>+</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Min</name><argument_list>(
                                    <argument><expr><call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* continue on the higher dimensions only present in 'a' */</comment>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name> <operator>+</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
                                    <argument><expr><call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Check if the result was in fact a point, and set the flag in the datum
     * accordingly. (we don't bother to repalloc it smaller)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>cube_is_point_internal</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>POINT_SIZE</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_POINT_BIT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>swapped</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Is it OK to return a non-null intersection for non-overlapping boxes?
     */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_NDBOX</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* cube_size */</comment>
<function><type><name>Datum</name></type>
<name>cube_size</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>rt_cube_size</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rt_cube_size</name><parameter_list>(<parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <operator>(</operator><name>NDBOX</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* special case for GiST */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IS_POINT</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* necessarily has zero size */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>*=</operator> <call><name>Abs</name><argument_list>(<argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* make up a metric in which one box will be 'lower' than the other
   -- this can be useful for sorting and to determine uniqueness */</comment>
<function><type><name>int32</name></type>
<name>cube_cmp_v0</name><parameter_list>(<parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>dim</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* compare the common dimensions */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator>
            <call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator>
            <call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator>
            <call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator>
            <call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* compare extra dimensions to zero */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>dim</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>dim</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * if all common dimensions are equal, the cube with more dimensions
         * wins
         */</comment>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>dim</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>dim</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * if all common dimensions are equal, the cube with more dimensions
         * wins
         */</comment>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* They're really equal */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>cube_cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>cube_cmp_v0</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>cube_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>cube_cmp_v0</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>cube_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>cube_cmp_v0</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>cube_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>cube_cmp_v0</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>cube_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>cube_cmp_v0</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>cube_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>cube_cmp_v0</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>cube_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>cube_cmp_v0</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Contains */</comment>
<comment type="block">/* Box(A) CONTAINS Box(B) IFF pt(A) &lt; pt(B) */</comment>
<function><type><name>bool</name></type>
<name>cube_contains_v0</name><parameter_list>(<parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>a</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>b</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>(</operator><name>FALSE</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * the further comparisons will make sense if the excess dimensions of
         * (b) were zeroes Since both UL and UR coordinates must be zero, we
         * can check them all without worrying about which is which.
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><operator>(</operator><name>FALSE</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><operator>(</operator><name>FALSE</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Can't care less about the excess dimensions of (a), if any */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>Min</name><argument_list>(<argument><expr><call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator>
            <call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>(</operator><name>FALSE</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator>
            <call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>(</operator><name>FALSE</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><operator>(</operator><name>TRUE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>cube_contains</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>cube_contains_v0</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Contained */</comment>
<comment type="block">/* Box(A) Contained by Box(B) IFF Box(B) Contains Box(A) */</comment>
<function><type><name>Datum</name></type>
<name>cube_contained</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>cube_contains_v0</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Overlap */</comment>
<comment type="block">/* Box(A) Overlap Box(B) IFF (pt(a)LL &lt; pt(B)UR) &amp;&amp; (pt(b)LL &lt; pt(a)UR) */</comment>
<function><type><name>bool</name></type>
<name>cube_overlap_v0</name><parameter_list>(<parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>a</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>b</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>(</operator><name>FALSE</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* swap the box pointers if needed */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>b</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* compare within the dimensions of (b) */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>(</operator><name>FALSE</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>(</operator><name>FALSE</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* compare to zero those dimensions in (a) absent in (b) */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>(</operator><name>FALSE</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>(</operator><name>FALSE</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><operator>(</operator><name>TRUE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>cube_overlap</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>cube_overlap_v0</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Distance */</comment>
<comment type="block">/* The distance is computed as a per axis sum of the squared distances
   between 1D projections of the boxes onto Cartesian axes. Assuming zero
   distance between overlapping projections, this metric coincides with the
   "common sense" geometric distance */</comment>
<function><type><name>Datum</name></type>
<name>cube_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>swapped</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>d</name></decl>,
                <decl><type ref="prev"/><name>distance</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* swap the box pointers if needed */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>b</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>swapped</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>distance</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
    <comment type="block">/* compute within the dimensions of (b) */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>distance_1D</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>distance</name> <operator>+=</operator> <name>d</name> <operator>*</operator> <name>d</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* compute distance to zero for those dimensions in (a) absent in (b) */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>distance_1D</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>distance</name> <operator>+=</operator> <name>d</name> <operator>*</operator> <name>d</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>swapped</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>sqrt</name><argument_list>(<argument><expr><name>distance</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>distance_taxicab</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>swapped</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>distance</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* swap the box pointers if needed */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>b</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>swapped</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>distance</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
    <comment type="block">/* compute within the dimensions of (b) */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>distance</name> <operator>+=</operator> <call><name>fabs</name><argument_list>(<argument><expr><call><name>distance_1D</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* compute distance to zero for those dimensions in (a) absent in (b) */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>distance</name> <operator>+=</operator> <call><name>fabs</name><argument_list>(<argument><expr><call><name>distance_1D</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><name>swapped</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>distance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>distance_chebyshev</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>swapped</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>d</name></decl>,
                <decl><type ref="prev"/><name>distance</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* swap the box pointers if needed */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>b</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>swapped</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>distance</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
    <comment type="block">/* compute within the dimensions of (b) */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>fabs</name><argument_list>(<argument><expr><call><name>distance_1D</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&gt;</operator> <name>distance</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>distance</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* compute distance to zero for those dimensions in (a) absent in (b) */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>fabs</name><argument_list>(<argument><expr><call><name>distance_1D</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&gt;</operator> <name>distance</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>distance</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>swapped</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>distance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>g_cube_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name> <init>= <expr><operator>(</operator><name>StrategyNumber</name><operator>)</operator> <call><name>PG_GETARG_UINT16</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>cube</name> <init>= <expr><call><name>DatumGetNDBOX</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>retval</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>CubeKNNDistanceCoord</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>coord</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IS_POINT</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <name><name>cube</name><operator>-&gt;</operator><name>x</name><index>[<expr><operator>(</operator><name>coord</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>cube</name><operator>-&gt;</operator><name>x</name><index>[<expr><operator>(</operator><name>coord</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>,
                         <argument><expr><name><name>cube</name><operator>-&gt;</operator><name>x</name><index>[<expr><operator>(</operator><name>coord</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>CubeKNNDistanceTaxicab</name></expr>:</case>
                <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>distance_taxicab</name></expr></argument>,
                                                            <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>CubeKNNDistanceEuclid</name></expr>:</case>
                <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>cube_distance</name></expr></argument>,
                                                            <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>CubeKNNDistanceChebyshev</name></expr>:</case>
                <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>distance_chebyshev</name></expr></argument>,
                                                            <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized cube strategy number: %d"</literal></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>retval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>distance_1D</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>a1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>a2</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>b1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>b2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* interval (a) is entirely on the left of (b) */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>a1</name> <operator>&lt;=</operator> <name>b1</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>a2</name> <operator>&lt;=</operator> <name>b1</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>a1</name> <operator>&lt;=</operator> <name>b2</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>a2</name> <operator>&lt;=</operator> <name>b2</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>(</operator><call><name>Min</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>Max</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* interval (a) is entirely on the right of (b) */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>a1</name> <operator>&gt;</operator> <name>b1</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>a2</name> <operator>&gt;</operator> <name>b1</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>a1</name> <operator>&gt;</operator> <name>b2</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>a2</name> <operator>&gt;</operator> <name>b2</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>(</operator><call><name>Min</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>Max</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* the rest are all sorts of intersections */</comment>
    <return>return <expr><operator>(</operator><literal type="number">0.0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Test if a box is also a point */</comment>
<function><type><name>Datum</name></type>
<name>cube_is_point</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>cube</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cube_is_point_internal</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>cube</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cube_is_point_internal</name><parameter_list>(<parameter><decl><type><name>NDBOX</name> <modifier>*</modifier></type><name>cube</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IS_POINT</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Even if the point-flag is not set, all the lower-left coordinates might
     * match the upper-right coordinates, so that the value is in fact a
     * point. Such values don't arise with current code - the point flag is
     * always set if appropriate - but they might be present on-disk in
     * clusters upgraded from pre-9.4 versions.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>cube</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>UR_COORD</name><argument_list>(<argument><expr><name>cube</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return dimensions in use in the data structure */</comment>
<function><type><name>Datum</name></type>
<name>cube_dim</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>dim</name> <init>= <expr><call><name>DIM</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return a specific normalized LL coordinate */</comment>
<function><type><name>Datum</name></type>
<name>cube_ll_coord</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>n</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>DIM</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>n</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return a specific normalized UR coordinate */</comment>
<function><type><name>Datum</name></type>
<name>cube_ur_coord</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>n</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>DIM</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>n</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UR_COORD</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Function returns cube coordinate.
 * Numbers from 1 to DIM denotes first corner coordinates.
 * Numbers from DIM+1 to 2*DIM denotes second corner coordinates.
 */</comment>
<function><type><name>Datum</name></type>
<name>cube_coord</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>cube</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>coord</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>coord</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>coord</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>*</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_ELEMENT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cube index %d is out of bounds"</literal></expr></argument>, <argument><expr><name>coord</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IS_POINT</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name><name>cube</name><operator>-&gt;</operator><name>x</name><index>[<expr><operator>(</operator><name>coord</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name><name>cube</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>coord</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * This function works like cube_coord(),
 * but rearranges coordinates of corners to get cube representation
 * in the form of (lower left, upper right).
 * For historical reasons that extension allows us to create cubes in form
 * ((2,1),(1,2)) and instead of normalizing such cube to ((1,1),(2,2)) it
 * stores cube in original way. But to get cubes ordered by one of dimensions
 * directly from the index without extra sort step we need some
 * representation-independent coordinate getter. This function implements it.
 */</comment>
<function><type><name>Datum</name></type>
<name>cube_coord_llur</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>cube</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>coord</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>coord</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>coord</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>*</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_ELEMENT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cube index %d is out of bounds"</literal></expr></argument>, <argument><expr><name>coord</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>coord</name> <operator>&lt;=</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IS_POINT</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name><name>cube</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>coord</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>Min</name><argument_list>(<argument><expr><name><name>cube</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>coord</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                 <argument><expr><name><name>cube</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>coord</name> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IS_POINT</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name><name>cube</name><operator>-&gt;</operator><name>x</name><index>[<expr><operator>(</operator><name>coord</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>Max</name><argument_list>(<argument><expr><name><name>cube</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>coord</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                 <argument><expr><name><name>cube</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>coord</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Increase or decrease box size by a radius in at least n dimensions. */</comment>
<function><type><name>Datum</name></type>
<name>cube_enlarge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>r</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>n</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>dim</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>CUBE_MAX_DIM</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name>CUBE_MAX_DIM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>dim</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>dim</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>CUBE_SIZE</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>NDBOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <name>dim</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>r</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>r</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>LL_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>r</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>UR_COORD</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>r</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <comment type="block">/* dim &gt; a-&gt;dim only if r &gt; 0 */</comment>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><name>r</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Check if the result was in fact a point, and set the flag in the datum
     * accordingly. (we don't bother to repalloc it smaller)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>cube_is_point_internal</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>POINT_SIZE</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_POINT_BIT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_NDBOX</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Create a one dimensional box with identical upper and lower coordinates */</comment>
<function><type><name>Datum</name></type>
<name>cube_f8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>x</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>POINT_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>NDBOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_POINT_BIT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_NDBOX</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Create a one dimensional box */</comment>
<function><type><name>Datum</name></type>
<name>cube_f8_f8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>x0</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>x1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>x0</name> <operator>==</operator> <name>x1</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>POINT_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>NDBOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_POINT_BIT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>x0</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>CUBE_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>NDBOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>x0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>x1</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_NDBOX</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a dimension to an existing cube with the same values for the new
   coordinate */</comment>
<function><type><name>Datum</name></type>
<name>cube_c_f8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>cube</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>x</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IS_POINT</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>POINT_SIZE</name><argument_list>(<argument><expr><operator>(</operator><call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>NDBOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_POINT_BIT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>cube</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><call><name>DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>CUBE_SIZE</name><argument_list>(<argument><expr><operator>(</operator><call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>NDBOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>cube</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><call><name>DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name><name>cube</name><operator>-&gt;</operator><name>x</name><index>[<expr><call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><call><name>DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>cube</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_NDBOX</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a dimension to an existing cube */</comment>
<function><type><name>Datum</name></type>
<name>cube_c_f8_f8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>cube</name> <init>= <expr><call><name>PG_GETARG_NDBOX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>x1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>x2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NDBOX</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IS_POINT</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>x1</name> <operator>==</operator> <name>x2</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>POINT_SIZE</name><argument_list>(<argument><expr><operator>(</operator><call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>NDBOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_POINT_BIT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>cube</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><call><name>DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>x1</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>CUBE_SIZE</name><argument_list>(<argument><expr><operator>(</operator><call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>NDBOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>LL_COORD</name><argument_list>(<argument><expr><name>cube</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><call><name>DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <call><name>UR_COORD</name><argument_list>(<argument><expr><name>cube</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><call><name>DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>x1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <call><name>DIM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>x2</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>cube</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_NDBOX</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
