<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/contrib/pg_stat_cluster_activity/pg_stat_cluster_activity.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/explain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/ip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/squeue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/atomics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/portal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_STAT_GET_ClUSTER_ACTIVITY_COLS</name></cpp:macro> <cpp:value>22</cpp:value></cpp:define>

<comment type="block">/* ----------
 * Total number of backends including auxiliary
 *
 * We reserve a slot for each possible BackendId, plus one for each
 * possible auxiliary process type.  (This scheme assumes there is not
 * more than one of any auxiliary process type at a time.) MaxBackends
 * includes autovacuum workers and background workers as well.
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NumBackendStatSlots</name></cpp:macro> <cpp:value>(MaxBackends + NUM_AUXPROCTYPES)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UINT32_ACCESS_ONCE</name><parameter_list>(<parameter><type><name>var</name></type></parameter>)</parameter_list></cpp:macro>		 <cpp:value>((uint32)(*((volatile uint32 *)&amp;(var))))</cpp:value></cpp:define>

<comment type="block">/*
 * PgClusterStatus is something like PgBackendStatus (see pgstat.c) but it
 * contains information that a query executed in a cluster database system.
 * Each PgClusterStatus stands for a backend process forked by postmaster,
 * the same way PgBackendStatus does, like extended fields of PgBackendStatus.
 * We show it in view pg_stat_cluster_activity, still, one tuple for an entry.
 */</comment>
<typedef>typedef <type><struct>struct <name>PgClusterStatus</name>
<block>{
	<comment type="block">/*
	 * To avoid locking overhead, we use the following protocol: a backend
	 * increments changecount before modifying its entry, and again after
	 * finishing a modification.  A would-be reader should note the value of
	 * changecount, copy the entry into private memory, then check
	 * changecount again.  If the value hasn't changed, and if it's even,
	 * the copy is valid; otherwise start over.  This makes updates cheap
	 * while reads are potentially expensive, but that's the tradeoff we want.
	 *
	 * The above protocol needs the memory barriers to ensure that the
	 * apparent order of execution is as it desires. Otherwise, for example,
	 * the CPU might rearrange the code so that changecount is incremented
	 * twice before the modification on a machine with weak memory ordering.
	 * This surprising result can lead to bugs.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>changecount</name></decl>;</decl_stmt>
	
	<decl_stmt><decl><type><name>bool</name></type> <name>valid</name></decl>;</decl_stmt>                     <comment type="block">/* don't show this entry if false */</comment>
	
	<comment type="block">/* fields that will be shown in pg_stat_cluster_activity */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>sessionid</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* global session id in a cluster, one for a session */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>nodename</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>     <comment type="block">/* nodename, determined after process started */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>role</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>         <comment type="block">/* coord, datanode, producer or consumer */</comment>
	
	<comment type="block">/* portal_name or portal_name_unique */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>sqname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<comment type="block">/* true if sharequeue end, but currently change when query ends in this backend */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>sqdone</name></decl>;</decl_stmt>
	<comment type="block">/* part of plantree this backend is processing, OR last processed if backend is idle */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>planstate</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
	
	<comment type="block">/*
	 * portal name: the name of current portal, given by upper node of processing query 
	 * cursor name: contained in planstate this backend is querying, which would be
	 *              portal name of next layer of nodes bellow this backend
	 *              
	 * Note: with these two fields plus nodename, we can build a backend tree of executing query
	 *       in whole distributed system.
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>portal</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>cursors</name><index>[<expr><name>NAMEDATALEN</name> <operator>*</operator> <literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>PgClusterStatus</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>PgClusterStatus</name> <modifier>*</modifier></type><name>ClusterStatusArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PgClusterStatus</name> <modifier>*</modifier></type><name>MyCSEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>shmem_startup_hook_type</name></type> <name>prev_shmem_startup_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pgstat_report_hook_type</name></type> <name>prev_pgstat_report_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PortalStart_hook_type</name></type> <name>prev_PortalStart</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PortalDrop_hook_type</name></type> <name>prev_PortalDrop</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ExecutorStart_hook_type</name></type> <name>prev_ExecutorStart</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgcs_enable_planstate</name></decl>;</decl_stmt> <comment type="block">/* whether to show planstate in result sets */</comment>

<comment type="block">/*
 * Macros to load and store st_changecount with the memory barriers.
 *
 * increment_changecount_before() and
 * increment_changecount_after() need to be called before and after
 * entries are modified, respectively. This makes sure that st_changecount
 * is incremented around the modification.
 *
 * Also save_changecount_before() and save_changecount_after()
 * need to be called before and after entries are copied into private memory
 * respectively.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>increment_changecount_before</name><parameter_list>(<parameter><type><name>status</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>do {	\
		status-&gt;changecount++;	\
		pg_write_barrier(); \
	} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>increment_changecount_after</name><parameter_list>(<parameter><type><name>status</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do {	\
		pg_write_barrier(); \
		status-&gt;changecount++;	\
		Assert((status-&gt;changecount &amp; 1) == 0); \
	} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>save_changecount_before</name><parameter_list>(<parameter><type><name>status</name></type></parameter>, <parameter><type><name>save_changecount</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>do {	\
		save_changecount = status-&gt;changecount; \
		pg_read_barrier();	\
	} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>save_changecount_after</name><parameter_list>(<parameter><type><name>status</name></type></parameter>, <parameter><type><name>save_changecount</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>do {	\
		pg_read_barrier();	\
		save_changecount = status-&gt;changecount; \
	} while (0)</cpp:value></cpp:define>

<function_decl><type><name>Datum</name></type> <name>pg_stat_get_cluster_activity</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Datum</name></type> <name>pg_signal_session</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Datum</name></type> <name>pg_terminate_session</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Datum</name></type> <name>pg_cancel_session</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>_PG_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pg_stat_get_cluster_activity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pg_signal_session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pg_terminate_session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pg_cancel_session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function><type><specifier>static</specifier> <name>ParamListInfo</name></type>
<name>EvaluateSessionIDParam</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sessionid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>num_params</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name> <init>= <expr><operator>(</operator><name>ParamListInfo</name><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ParamListInfoData</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call> <operator>+</operator>
		        <name>num_params</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExternData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	
	<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>
	
	<comment type="block">/* we have static list of params, so no hooks needed */</comment>
	<expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>paramFetch</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>paramFetchArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>parserSetup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>numParams</name></name> <operator>=</operator> <name>num_params</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>paramMask</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>prm</name> <operator>=</operator> <operator>&amp;</operator><name><name>paramLI</name><operator>-&gt;</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>pflags</name></name> <operator>=</operator> <name>PARAM_FLAG_CONST</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sessionid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>sessionid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	
	<return>return <expr><name>paramLI</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * walk through planstate tree and gets cursors it contains in
 * RemoteSubplan node, formed as a single string delimited each
 * cursor by a space (one cursor stands for a RemoteSubplan node).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cursorCollectWalker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>RemoteSubplanState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RemoteSubplan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>RemoteSubplan</name> <operator>*</operator><operator>)</operator> <name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>cursor</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>unique</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"_"</literal><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>unique</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* add a space as delimiter */</comment>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	
	<return>return <expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>cursorCollectWalker</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the shared status array and several string buffers
 * during postmaster startup.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateSharedClusterStatus</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
	
	<comment type="block">/* Create or attach to the shared array */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgClusterStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NumBackendStatSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ClusterStatusArray</name> <operator>=</operator> <operator>(</operator><name>PgClusterStatus</name> <operator>*</operator><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Cluster Status Array"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We're the first - initialize.
		 */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>ClusterStatusArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Shut down a single backend's statistics reporting at process exit.
 *
 * Flush any remaining statistics counts out to the collector.
 * Without this, operations triggered during backend exit (such as
 * temp table deletions) won't be counted.
 *
 * Lastly, clear out our entry in the PgBackendStatus array.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgcs_shutdown_hook</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>PgClusterStatus</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>MyCSEntry</name></expr></init></decl>;</decl_stmt>
	
	<comment type="block">/*
	 * Clear my status entry, following the protocol of bumping st_changecount
	 * before and after.  We use a volatile pointer here to ensure the
	 * compiler doesn't try to get cute.
	 */</comment>
	<expr_stmt><expr><call><name>increment_changecount_before</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* mark invalid to hide this entry */</comment>
	
	<expr_stmt><expr><call><name>increment_changecount_after</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgcs_entry_initialize() -
 *
 *	Initialize my cluster status entry, and set up our on-proc-exit hook.
 *	as an extension but we don't have hook during process startup, so called
 *	each time the backend try to report something.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgcs_entry_initialize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* already initialized */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyCSEntry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ClusterStatusArray</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shared memory for pg_stat_cluster_activity is not prepared"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			        <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"maybe you need to set shared_preload_libraries in postgresql.conf file"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	
	<comment type="block">/* Initialize MyCSEntry */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyBackendId</name> <operator>!=</operator> <name>InvalidBackendId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyBackendId</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>MyBackendId</name> <operator>&lt;=</operator> <name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>MyCSEntry</name> <operator>=</operator> <operator>&amp;</operator><name><name>ClusterStatusArray</name><index>[<expr><name>MyBackendId</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Must be an auxiliary process */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyAuxProcType</name> <operator>!=</operator> <name>NotAnAuxProcess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<comment type="block">/*
		 * Assign the MyCSEntry for an auxiliary process. Since it doesn't
		 * have a BackendId, the slot is statically allocated based on the
		 * auxiliary process type (MyAuxProcType).  Backends use slots indexed
		 * in the range from 1 to MaxBackends (inclusive), so we use
		 * MaxBackends + AuxBackendType + 1 as the index of the slot for an
		 * auxiliary process.
		 */</comment>
		<expr_stmt><expr><name>MyCSEntry</name> <operator>=</operator> <operator>&amp;</operator><name><name>ClusterStatusArray</name><index>[<expr><name>MaxBackends</name> <operator>+</operator> <name>MyAuxProcType</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	
	<comment type="block">/* also set nodename here, it won't change anyway */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>MyCSEntry</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* Set up a process-exit hook to clean up */</comment>
	<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>pgcs_shutdown_hook</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgcs_report_common
 * 
 *  Report common fileds of cluster backend status activity,
 *  called by pgcs_report_query_activity and pgcs_report_activity.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgcs_report_common</name><parameter_list>(<parameter><decl><type><name>PgClusterStatus</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>sessionid</name></name></expr></argument>, <argument><expr><name>PGXCSessionId</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>sqdone</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgcs_report_role
 * 
 *  Report role, sqname, also if this backend become consumer, remove
 *  previous planstate and cursor.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgcs_report_role</name><parameter_list>(<parameter><decl><type><name>PgClusterStatus</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* fields need queryDesc */</comment>
	<if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>desc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>desc</name><operator>-&gt;</operator><name>squeue</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>sqname</name></name></expr></argument>, <argument><expr><call><name>SqueueName</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>squeue</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsSqueueProducer</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>role</name></name></expr></argument>, <argument><expr><literal type="string">"producer"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsSqueueConsumer</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>role</name></name></expr></argument>, <argument><expr><literal type="string">"consumer"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* consumer does not know of planstate */</comment>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>planstate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>cursors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* do not support */</comment>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>role</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>role</name></name></expr></argument>, <argument><expr><literal type="string">"parallel worker"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>role</name></name></expr></argument>, <argument><expr><literal type="string">"datanode"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>role</name></name></expr></argument>, <argument><expr><literal type="string">"coordinator"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* do not support */</comment>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>role</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgcs_report_query_activity
 *
 *  Do nothing but set common field, just enable this cluster entry
 *  to make it visible in the same time as pg_stat_activity. Hooked
 *  in pgstat_report_activity, args are redundant.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgcs_report_query_activity</name><parameter_list>(<parameter><decl><type><name>BackendState</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd_str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>PgClusterStatus</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>pgcs_entry_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <name>MyCSEntry</name></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>pgcs_report_common</name><argument_list>(<argument><expr><operator>(</operator><name>PgClusterStatus</name> <operator>*</operator><operator>)</operator> <name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>prev_pgstat_report_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_pgstat_report_hook</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>cmd_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgcs_report_executor_activity
 * 
 *  Report fileds of per-query referred, hooked as ExecutorStart_hook
 *  report planstate, cursors and common fields.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgcs_report_executor_activity</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>PgClusterStatus</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>planstate_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>cursors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>prev_ExecutorStart</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_ExecutorStart</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ExecutorStart</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	
	<expr_stmt><expr><call><name>pgcs_entry_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <name>MyCSEntry</name></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>desc</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	
	<comment type="block">/* if query already done, just report sqdone and return */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>already_executed</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>increment_changecount_before</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>sqdone</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>increment_changecount_after</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>planstate</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* make planstate text tree if enabled */</comment>
		<if_stmt><if>if <condition>(<expr><name>pgcs_enable_planstate</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name> <init>= <expr><call><name>NewExplainState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>costs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<comment type="block">/* we don't want plan-&gt;targetlist been changed */</comment>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>skip_remote_query</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			
			<expr_stmt><expr><call><name>ExplainBeginOutput</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPrintPlan</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainEndOutput</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* remove last '\n' */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>data</name><index>[<expr><operator>--</operator><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>planstate_str</name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>planstate_str</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>planstate_str</name></expr></argument>, <argument><expr><literal type="string">"disabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		
		<comment type="block">/* find name of RemoteSubplan to show as cursors */</comment>
		<expr_stmt><expr><name>cursors</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cursorCollectWalker</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><name>cursors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><call><name>increment_changecount_before</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>planstate_str</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>planstate_str</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><name><name>planstate_str</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name><name>planstate_str</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>cursors</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>cursors</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>cursors</name></name></expr></argument>, <argument><expr><name><name>cursors</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name><name>cursors</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name> <operator>*</operator> <literal type="number">64</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<expr_stmt><expr><call><name>pgcs_report_common</name><argument_list>(<argument><expr><operator>(</operator><name>PgClusterStatus</name> <operator>*</operator><operator>)</operator> <name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgcs_report_role</name><argument_list>(<argument><expr><operator>(</operator><name>PgClusterStatus</name> <operator>*</operator><operator>)</operator> <name>entry</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>increment_changecount_after</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgcs_report_activity
 * 
 *  Report fileds of per-portal referred, hooked as PortalStart_hook
 *  report portal name and common fields.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgcs_report_activity</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>PgClusterStatus</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name></name></expr></init></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>pgcs_entry_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <name>MyCSEntry</name></expr>;</expr_stmt>
	
	<comment type="block">/* if query already done, just report sqdone and return */</comment>
	<if_stmt><if>if <condition>(<expr><name>desc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>desc</name><operator>-&gt;</operator><name>already_executed</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>increment_changecount_before</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>sqdone</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>increment_changecount_after</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><call><name>increment_changecount_before</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>portal</name></name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgcs_report_common</name><argument_list>(<argument><expr><operator>(</operator><name>PgClusterStatus</name> <operator>*</operator><operator>)</operator> <name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgcs_report_role</name><argument_list>(<argument><expr><operator>(</operator><name>PgClusterStatus</name> <operator>*</operator><operator>)</operator> <name>entry</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>increment_changecount_after</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_fetch_stat_local_csentry
 * 
 *  Given a backend id, find particular cluster status entry, copy valid
 *  entry into local memory, loop around changecount to ensure concurrency.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>PgClusterStatus</name> <modifier>*</modifier></type>
<name>pgstat_fetch_stat_local_csentry</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>beid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgClusterStatus</name> <modifier>*</modifier></type><name>csentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgClusterStatus</name> <modifier>*</modifier></type><name>local</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgClusterStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>local</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>ClusterStatusArray</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shared memory for pg_stat_cluster_activity is not prepared"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			        <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"maybe you need to set shared_preload_libraries in postgresql.conf"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>beid</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	
	<expr_stmt><expr><name>csentry</name> <operator>=</operator> <operator>&amp;</operator><name><name>ClusterStatusArray</name><index>[<expr><name>beid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>before_changecount</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>after_changecount</name></decl>;</decl_stmt>
		
		<expr_stmt><expr><call><name>save_changecount_before</name><argument_list>(<argument><expr><name>csentry</name></expr></argument>, <argument><expr><name>before_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>csentry</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>local</name></expr></argument>, <argument><expr><name>csentry</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgClusterStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>save_changecount_after</name><argument_list>(<argument><expr><name>csentry</name></expr></argument>, <argument><expr><name>after_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>before_changecount</name> <operator>==</operator> <name>after_changecount</name> <operator>&amp;&amp;</operator>
		    <operator>(</operator><name>before_changecount</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		
		<comment type="block">/* Make sure we can break out of loop if stuck... */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	
	<return>return <expr><name>local</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pg_stat_get_remote_activity
 * 
 *  Execute pg_stat_get_cluster_activity query remotely and save
 *  results in tuplestore.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_stat_get_remote_activity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sessionid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>coordonly</name></decl></parameter>, <parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUERY_LEN</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>char</name></type>    <name><name>query</name><index>[<expr><name>QUERY_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>              <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>		<name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteQuery</name> 		<modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteQueryState</name>    <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name>		<modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	
	<comment type="block">/*
	 * Here we call pg_stat_get_cluster_activity in remote with args:
	 * coordonly = false, localonly = true, to prevent recursive calls in remote nodes.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>QUERY_LEN</name></expr></argument>, <argument><expr><literal type="string">"select * from pg_stat_get_cluster_activity($1, false, true)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_NONE</name></expr>;</expr_stmt>
	<comment type="block">/*
	 * set exec_nodes to NULL makes ExecRemoteQuery send query to all nodes
	 * (local CN nodes won't recieved query again).
	 */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>query</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>force_autocommit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>missing_ok</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>coordonly</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>GetAllCoordNodes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_COORDS</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<comment type="block">/* prepare to execute */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name> <operator>=</operator> <call><name>EvaluateSessionIDParam</name><argument_list>(<argument><expr><name>sessionid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>ExecInitRemoteQuery</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecAssignResultType</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>pstate</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<while>while <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	
	<expr_stmt><expr><call><name>ExecEndRemoteQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pg_stat_get_cluster_activity
 * 
 *  Internal SRF function of this extension, access sharememory to find
 *  every live backend which executed or executing query. copy to local
 *  and show status. also we collect some fields from PGBackendStatus
 *
 *  arguments:  sessionid -- global unique id for a session, generated by CN
 *              coordonly -- only dispatch to other cn if true.
 *              localonly -- collect local entries status if true.
 *              
 *  Note: since we also collect PGBackendStatus, get them first and use
 *  backend id to access particular cluster status entry to narrow down
 *  loop search range from all backend slots to localNumBackends (see pgstat.c)
 * ----------
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_stat_get_cluster_activity</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>              <name>num_backends</name> <init>= <expr><call><name>pgstat_fetch_stat_numbackends</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			     <name>curr_backend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>             <name>with_sessionid</name> <init>= <expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>             <name>coordonly</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>             <name>localonly</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>      <modifier>*</modifier></type><name>sessionid</name> <init>= <expr><ternary><condition><expr><name>with_sessionid</name></expr> ?</condition><then> <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name>   <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	     <name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>    <name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>    <name>oldcontext</name></decl>;</decl_stmt>
	
	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
						<literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<comment type="block">/* Build a tuple descriptor for our result type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<comment type="block">/* switch to query's memory context to save results during execution */</comment>
	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* dispatch query to remote if needed */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>localonly</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_stat_get_remote_activity</name><argument_list>(<argument><expr><name>sessionid</name></expr></argument>, <argument><expr><name>coordonly</name></expr></argument>, <argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<comment type="block">/* 1-based index */</comment>
	<for>for <control>(<init><expr><name>curr_backend</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>curr_backend</name> <operator>&lt;=</operator> <name>num_backends</name></expr>;</condition> <incr><expr><name>curr_backend</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* for each row */</comment>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>PG_STAT_GET_ClUSTER_ACTIVITY_COLS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>PG_STAT_GET_ClUSTER_ACTIVITY_COLS</name></expr>]</index></name></decl>;</decl_stmt>
		
		<comment type="block">/* same as pg_stat_get_activity */</comment>
		<decl_stmt><decl><type><name>LocalPgBackendStatus</name> <modifier>*</modifier></type><name>local_beentry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PgBackendStatus</name> <modifier>*</modifier></type><name>beentry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>wait_event_type</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>wait_event</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		
		<comment type="block">/* cluster information */</comment>
		<decl_stmt><decl><type><name>PgClusterStatus</name> <modifier>*</modifier></type><name>local_csentry</name></decl>;</decl_stmt>
		
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<comment type="block">/* Get the next one in the list */</comment>
		<expr_stmt><expr><name>local_beentry</name> <operator>=</operator> <call><name>pgstat_fetch_stat_local_beentry</name><argument_list>(<argument><expr><name>curr_backend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>local_csentry</name> <operator>=</operator> <call><name>pgstat_fetch_stat_local_csentry</name><argument_list>(<argument><expr><name><name>local_beentry</name><operator>-&gt;</operator><name>backend_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>local_beentry</name> <operator>||</operator> <operator>!</operator><name>local_csentry</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
			
			<comment type="block">/* Ignore missing entries if looking for specific sessionid */</comment>
			<if_stmt><if>if <condition>(<expr><name>with_sessionid</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></for>
			
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"&lt;backend information not available&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>local_csentry</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		
		<expr_stmt><expr><name>beentry</name> <operator>=</operator> <operator>&amp;</operator><name><name>local_beentry</name><operator>-&gt;</operator><name>backendStatus</name></name></expr>;</expr_stmt>
		<comment type="block">/* If looking for specific sessionid, ignore all the others */</comment>
		<if_stmt><if>if <condition>(<expr><name>with_sessionid</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>sessionid</name></expr></argument>, <argument><expr><name><name>local_csentry</name><operator>-&gt;</operator><name>sessionid</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		
		<comment type="block">/* Values available to all callers */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>local_csentry</name><operator>-&gt;</operator><name>sessionid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_procpid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<if_stmt><if>if <condition>(<expr><name><name>beentry</name><operator>-&gt;</operator><name>st_databaseid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dbname</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_databaseid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>dbname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		
		<if_stmt><if>if <condition>(<expr><name><name>beentry</name><operator>-&gt;</operator><name>st_userid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>usename</name> <init>= <expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_userid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>usename</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>usename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		
		<comment type="block">/* Values only available to owner or superuser or pg_read_all_stats */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_userid</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		    <call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_STATS</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SockAddr</name></type>	<name>zero_clientaddr</name></decl>;</decl_stmt>
			
			<comment type="block">/* A zeroed client addr means we don't know */</comment>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zero_clientaddr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zero_clientaddr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>beentry</name><operator>-&gt;</operator><name>st_clientaddr</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>zero_clientaddr</name></expr></argument>,
			           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zero_clientaddr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>beentry</name><operator>-&gt;</operator><name>st_clientaddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_IPV6</name></cpp:ifdef>
				    <operator>||</operator> <name><name>beentry</name><operator>-&gt;</operator><name>st_clientaddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>remote_host</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>remote_port</name><index>[<expr><name>NI_MAXSERV</name></expr>]</index></name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
					
					<expr_stmt><expr><name><name>remote_host</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>remote_port</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pg_getnameinfo_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>beentry</name><operator>-&gt;</operator><name>st_clientaddr</name><operator>.</operator><name>addr</name></name></expr></argument>,
					                         <argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_clientaddr</name><operator>.</operator><name>salen</name></name></expr></argument>,
					                         <argument><expr><name>remote_host</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>remote_host</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					                         <argument><expr><name>remote_port</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>remote_port</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					                         <argument><expr><name>NI_NUMERICHOST</name> <operator>|</operator> <name>NI_NUMERICSERV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>clean_ipv6_addr</name><argument_list>(<argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_clientaddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>, <argument><expr><name>remote_host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>inet_in</name></expr></argument>,
						                                <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>remote_host</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>beentry</name><operator>-&gt;</operator><name>st_clienthostname</name></name> <operator>&amp;&amp;</operator>
						    <name><name>beentry</name><operator>-&gt;</operator><name>st_clienthostname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_clienthostname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name>remote_port</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>beentry</name><operator>-&gt;</operator><name>st_clientaddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_UNIX</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Unix sockets always reports NULL for host and -1 for
					 * port, so it's possible to tell the difference to
					 * connections we have no permissions to view, or with
					 * errors.
					 */</comment>
					<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Unknown address type, should never happen */</comment>
					<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
			
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>local_csentry</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>local_csentry</name><operator>-&gt;</operator><name>role</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>BackendPidGetProc</name><argument_list>(<argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_procpid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>proc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint32</name></type>		<name>raw_wait_event</name></decl>;</decl_stmt>
				
				<expr_stmt><expr><name>raw_wait_event</name> <operator>=</operator> <call><name>UINT32_ACCESS_ONCE</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>wait_event_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>wait_event_type</name> <operator>=</operator> <call><name>pgstat_get_wait_event_type</name><argument_list>(<argument><expr><name>raw_wait_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>wait_event</name> <operator>=</operator> <call><name>pgstat_get_wait_event</name><argument_list>(<argument><expr><name>raw_wait_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>!=</operator> <name>B_BACKEND</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * For an auxiliary process, retrieve process info from
				 * AuxiliaryProcs stored in shared-memory.
				 */</comment>
				<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>AuxiliaryPidGetProc</name><argument_list>(<argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_procpid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				
				<if_stmt><if>if <condition>(<expr><name>proc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>uint32</name></type>		<name>raw_wait_event</name></decl>;</decl_stmt>
					
					<expr_stmt><expr><name>raw_wait_event</name> <operator>=</operator>
						<call><name>UINT32_ACCESS_ONCE</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>wait_event_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>wait_event_type</name> <operator>=</operator>
						<call><name>pgstat_get_wait_event_type</name><argument_list>(<argument><expr><name>raw_wait_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>wait_event</name> <operator>=</operator> <call><name>pgstat_get_wait_event</name><argument_list>(<argument><expr><name>raw_wait_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			
			<if_stmt><if>if <condition>(<expr><name>wait_event_type</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>wait_event_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			
			<if_stmt><if>if <condition>(<expr><name>wait_event</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>wait_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			
			<switch>switch <condition>(<expr><name><name>beentry</name><operator>-&gt;</operator><name>st_state</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>STATE_IDLE</name></expr>:</case>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"idle"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>STATE_RUNNING</name></expr>:</case>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"active"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>STATE_IDLEINTRANSACTION</name></expr>:</case>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"idle in transaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>STATE_FASTPATH</name></expr>:</case>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"fastpath function call"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>STATE_IDLEINTRANSACTION_ABORTED</name></expr>:</case>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"idle in transaction (aborted)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>STATE_DISABLED</name></expr>:</case>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"disabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>STATE_UNDEFINED</name></expr>:</case>
					<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>local_csentry</name><operator>-&gt;</operator><name>sqname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>local_csentry</name><operator>-&gt;</operator><name>sqdone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_activity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">15</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>local_csentry</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>local_csentry</name><operator>-&gt;</operator><name>portal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">17</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>local_csentry</name><operator>-&gt;</operator><name>cursors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<if_stmt><if>if <condition>(<expr><name><name>beentry</name><operator>-&gt;</operator><name>st_proc_start_timestamp</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">18</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_proc_start_timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">18</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			
			<if_stmt><if>if <condition>(<expr><name><name>beentry</name><operator>-&gt;</operator><name>st_xact_start_timestamp</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">19</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_xact_start_timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">19</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			
			<if_stmt><if>if <condition>(<expr><name><name>beentry</name><operator>-&gt;</operator><name>st_activity_start_timestamp</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">20</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_activity_start_timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">20</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			
			<if_stmt><if>if <condition>(<expr><name><name>beentry</name><operator>-&gt;</operator><name>st_state_start_timestamp</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">21</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_state_start_timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">21</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"&lt;insufficient privilege&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">15</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">17</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">18</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">19</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">20</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">21</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		
		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	
	<comment type="block">/* clean up and return the tuplestore */</comment>
	<expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgcs_signal_session_remote</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sessionid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>signal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUERY_LEN</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>char</name></type>    <name><name>query</name><index>[<expr><name>QUERY_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>              <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>		<name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteQuery</name> 		<modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteQueryState</name>    <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> 				<modifier>*</modifier></type><name>dummy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name>		<modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>QUERY_LEN</name></expr></argument>, <argument><expr><literal type="string">"select pg_signal_session($1, %d, true)"</literal></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_NONE</name></expr>;</expr_stmt>
	<comment type="block">/*
	 * set exec_nodes to NULL makes ExecRemoteQuery send query to all nodes
	 * (local CN nodes won't recieved query again).
	 */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>query</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>force_autocommit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	
	<comment type="block">/*
	 * We only need the target entry to determine result data type.
	 * So create dummy even if real expression is a function.
	 */</comment>
	<expr_stmt><expr><name>dummy</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
	                                     <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>dummy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* prepare to execute */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name> <operator>=</operator> <call><name>EvaluateSessionIDParam</name><argument_list>(<argument><expr><name>sessionid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>ExecInitRemoteQuery</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecEndRemoteQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"result of pg_signal_session executed remotely is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgcs_signal_session</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sessionid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>signal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>         <name>num_backends</name> <init>= <expr><call><name>pgstat_fetch_stat_numbackends</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>curr_backend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocalPgBackendStatus</name> <modifier>*</modifier></type><name>local_beentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgClusterStatus</name>      <modifier>*</modifier></type><name>local_csentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgBackendStatus</name>      <modifier>*</modifier></type><name>beentry</name></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>signal</name> <operator>==</operator> <name>SIGTERM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>funcname</name> <operator>=</operator> <literal type="string">"pg_terminate_backend"</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>signal</name> <operator>==</operator> <name>SIGINT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>funcname</name> <operator>=</operator> <literal type="string">"pg_cancel_backend"</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pgcs_signal_session only support SIGTERM and SIGINT, not %d"</literal></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	
	<comment type="block">/* 1-based index */</comment>
	<for>for <control>(<init><expr><name>curr_backend</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>curr_backend</name> <operator>&lt;=</operator> <name>num_backends</name></expr>;</condition> <incr><expr><name>curr_backend</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Get the next one in the list */</comment>
		<expr_stmt><expr><name>local_beentry</name> <operator>=</operator> <call><name>pgstat_fetch_stat_local_beentry</name><argument_list>(<argument><expr><name>curr_backend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>local_csentry</name> <operator>=</operator> <call><name>pgstat_fetch_stat_local_csentry</name><argument_list>(<argument><expr><name><name>local_beentry</name><operator>-&gt;</operator><name>backend_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<if_stmt><if>if <condition>(<expr><name><name>local_csentry</name><operator>-&gt;</operator><name>valid</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>local_csentry</name><operator>-&gt;</operator><name>sessionid</name></name></expr></argument>, <argument><expr><name>sessionid</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>beentry</name> <operator>=</operator> <operator>&amp;</operator><name><name>local_beentry</name><operator>-&gt;</operator><name>backendStatus</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><call><name>fmgr_internal_function</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>,
			                 <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_procpid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_signal_session</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sessionid</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>signal</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>localonly</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pgcs_signal_session</name><argument_list>(<argument><expr><name>sessionid</name></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>localonly</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pgcs_signal_session_remote</name><argument_list>(<argument><expr><name>sessionid</name></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<return>return <expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_terminate_session</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>pg_signal_session</name></expr></argument>,
	                           <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
	                           <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr></argument>,
	                           <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_cancel_session</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>pg_signal_session</name></expr></argument>,
	                           <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
	                           <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>)</argument_list></call></expr></argument>,
	                           <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Hooked as shmem_startup_hook
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgcs_shmem_startup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>prev_shmem_startup_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_shmem_startup_hook</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<expr_stmt><expr><call><name>CreateSharedClusterStatus</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate shared memory space needed.
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>pgcs_memsize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgClusterStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NumBackendStatSlots</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Module load callback
 */</comment>
<function><type><name>void</name></type>
<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>process_shared_preload_libraries_in_progress</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	
	<comment type="block">/*
	 * Define (or redefine) custom GUC variables.
	 */</comment>
	<expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(<argument><expr><literal type="string">"pg_stat_cluster_activity.enable_planstate"</literal></expr></argument>,
	                         <argument><expr><literal type="string">"whether to show planstate in result sets."</literal></expr></argument>,
	                         <argument><expr><name>NULL</name></expr></argument>,
	                         <argument><expr><operator>&amp;</operator><name>pgcs_enable_planstate</name></expr></argument>,
	                         <argument><expr><name>true</name></expr></argument>,
	                         <argument><expr><name>PGC_SUSET</name></expr></argument>,
	                         <argument><expr><literal type="number">0</literal></expr></argument>,
	                         <argument><expr><name>NULL</name></expr></argument>,
	                         <argument><expr><name>NULL</name></expr></argument>,
	                         <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/*
	 * Request additional shared resources.  (These are no-ops if we're not in
	 * the postmaster process.)  We'll allocate or attach to the shared
	 * resources in pgcs_shmem_startup().
	 */</comment>
	<expr_stmt><expr><call><name>RequestAddinShmemSpace</name><argument_list>(<argument><expr><call><name>pgcs_memsize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/*
	 * Install hooks.
	 */</comment>
	<expr_stmt><expr><name>prev_shmem_startup_hook</name> <operator>=</operator> <name>shmem_startup_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmem_startup_hook</name> <operator>=</operator> <name>pgcs_shmem_startup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_pgstat_report_hook</name> <operator>=</operator> <name>pgstat_report_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pgstat_report_hook</name> <operator>=</operator> <name>pgcs_report_query_activity</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_PortalStart</name> <operator>=</operator> <name>PortalStart_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>PortalStart_hook</name> <operator>=</operator> <name>pgcs_report_activity</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_PortalDrop</name> <operator>=</operator> <name>PortalDrop_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>PortalDrop_hook</name> <operator>=</operator> <name>pgcs_report_activity</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_ExecutorStart</name> <operator>=</operator> <name>ExecutorStart_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorStart_hook</name> <operator>=</operator> <name>pgcs_report_executor_activity</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Module unload callback
 */</comment>
<function><type><name>void</name></type>
<name>_PG_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Uninstall hooks. */</comment>
	<expr_stmt><expr><name>shmem_startup_hook</name> <operator>=</operator> <name>prev_shmem_startup_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pgstat_report_hook</name> <operator>=</operator> <name>prev_pgstat_report_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>PortalStart_hook</name> <operator>=</operator> <name>prev_PortalStart</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>PortalDrop_hook</name> <operator>=</operator> <name>prev_PortalDrop</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorStart_hook</name> <operator>=</operator> <name>prev_ExecutorStart</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
