<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/contrib/pg_unlock/pg_unlock.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"c.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/palloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tuptable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxcnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/poolmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_GID</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DBNAME</name></cpp:macro>	<cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_RELNAME</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_MODE</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DEADLOCK</name></cpp:macro> <cpp:value>10000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DEADLOCK_CHECKLOOP</name></cpp:macro> <cpp:value>(10)</cpp:value></cpp:define>

<comment type="block">/*macros about space allocation and release*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>\
<cpp:value>do{\
	x = NULL;\
	x##_count = 0;\
	x##_size = 0;\
}while(0);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RPALLOC</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>\
<cpp:value>do{\
    if (x##_size &lt; x##_count+1)\
    {\
        int temp_size = (x##_size &gt; 0) ? x##_size : 1;\
        if (NULL == x)\
        {\
			x = palloc0(2*temp_size*sizeof(*x));\
		}\
        else\
        {\
        	x = repalloc(x, 2*temp_size*sizeof(*x));\
        }\
    	x##_size = 2*temp_size;\
    }\
}while(0);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PALLOC</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro>\
<cpp:value>do{\
    RPALLOC(x);\
    x[x##_count] = y;\
    x##_count++;\
}while(0);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RFREE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>\
<cpp:value>do{\
    if (x##_size &gt; 0)\
    {\
        pfree(x);\
    }\
    x = NULL;\
    x##_count = 0;\
    x##_size = 0;\
}while(0);</cpp:value></cpp:define>

<comment type="block">/*data structures*/</comment>
	<comment type="block">/*about lock*/</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>Lockmode_ASL</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,	<comment type="block">/*AccessShareLock*/</comment>
	<decl><name>Lockmode_RSL</name></decl>,		<comment type="block">/*RowShareLock*/</comment>
	<decl><name>Lockmode_REL</name></decl>,		<comment type="block">/*RowExclusiveLock*/</comment>
	<decl><name>Lockmode_SUEL</name></decl>,		<comment type="block">/*ShareUpdateExclusiveLock*/</comment>
	<decl><name>Lockmode_SL</name></decl>,			<comment type="block">/*ShareLock*/</comment>
	<decl><name>Lockmode_SREL</name></decl>,		<comment type="block">/*ShareRowExclusiveLock*/</comment>
	<decl><name>Lockmode_EL</name></decl>,			<comment type="block">/*ExclusiveLock*/</comment>
	<decl><name>Lockmode_AEL</name></decl> 		<comment type="block">/*AccessExclusiveLock*/</comment>
}</block></enum></type> <name>MODE</name>;</typedef>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>Locktype_Relation</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>Locktype_Page</name></decl>,
	<decl><name>Locktype_Tuple</name></decl>,
	<decl><name>Locktype_Transactionid</name></decl>,
	<decl><name>Locktype_Object</name></decl>,
	<decl><name>Locktype_Userlock</name></decl>, 
	<decl><name>Locktype_Advisory</name></decl>
}</block></enum></type> <name>LOCKTYPE</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>LOCKTYPE</name></type>	<name>m_locktype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>m_dbname</name><index>[<expr><name>MAX_DBNAME</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>m_relname</name><index>[<expr><name>MAX_RELNAME</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> 		<name>m_page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type> 		<name>m_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MODE</name></type>		<name>m_mode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>m_granted</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>m_transactionid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>m_node</name></decl>;</decl_stmt>		
	<decl_stmt><decl><type><name>uint32</name></type>		<name>m_pid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type>      <name>m_query</name></decl>;</decl_stmt>
}</block></struct></type> <name>lockinfo</name>;</typedef>

	<comment type="block">/*about deadlock*/</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type>	<name>txns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>txns_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>txns_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>killed</name></decl>;</decl_stmt>
}</block></struct></type> <name>deadlock</name>;</typedef>

	<comment type="block">/*about transactions*/</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>pre</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		 	<name>post</name></decl>;</decl_stmt>
}</block></struct></type><name>Edge</name>;</typedef>

<typedef>typedef <type><struct>struct 
<block>{
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>	<comment type="block">/*slot[i][j] stores value of row i, colum j*/</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>slot_count</name></decl>;</decl_stmt>	<comment type="block">/*number of rows*/</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>slot_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>attnum</name></decl>;</decl_stmt>
}</block></struct></type><name>TupleTableSlots</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name><name>gid</name><index>[<expr><name>MAX_GID</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/*globla transactionid*/</comment>
	<decl_stmt><decl><type><name>uint32</name>		<modifier>*</modifier></type><name>pid</name></decl>;</decl_stmt>			<comment type="block">/*Local pid on each node*/</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>pid_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pid_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		 	<modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>			<comment type="block">/*a global transaction corresponding to multiple nodes*/</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>node_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>node_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>  		<name>initiator</name></decl>;</decl_stmt>		<comment type="block">/*node initiating the transaction*/</comment>
	<decl_stmt><decl><type><name>lockinfo</name>	<modifier>*</modifier></type><name>hold</name></decl>;</decl_stmt>			<comment type="block">/*hold lock list of the transaction*/</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>hold_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hold_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lockinfo</name>	<modifier>*</modifier></type><name>wait</name></decl>;</decl_stmt>			<comment type="block">/*wait lock list of the transaction*/</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>wait_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wait_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	 	<name>searched</name></decl>;</decl_stmt>		<comment type="block">/*transaction travesal status during deadlock detection*/</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>alive</name></decl>;</decl_stmt>			<comment type="block">/*whether the transaction is killed*/</comment>
	<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type>		<name>deadlock</name></decl>;</decl_stmt>		<comment type="block">/*belonging deadlocks*/</comment>
	<decl_stmt><decl><type><name>int</name></type> 		<name>deadlock_count</name></decl>;</decl_stmt>	<comment type="block">/*deadlock count of the transaction*/</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>deadlock_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Edge</name><modifier>*</modifier></type>		<name>out</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>out_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>out_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wait_txn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type>       <name>query</name></decl>;</decl_stmt>
}</block></struct></type><name>transaction</name>;</typedef>

<typedef>typedef <type><struct>struct 
<block>{
	<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type>	<name>stack</name></decl>;</decl_stmt>			<comment type="block">/*stack during depth-first search*/</comment>
	<decl_stmt><decl><type><name>int</name></type>		<name>stack_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>stack_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type>	<name>stackpre</name></decl>;</decl_stmt>		<comment type="block">/*stores parents of transactions in stack*/</comment>
	<decl_stmt><decl><type><name>int</name></type>		<name>stackpre_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>stackpre_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type>	<name>path</name></decl>;</decl_stmt>			<comment type="block">/*extended path in depth-first search*/</comment>
	<decl_stmt><decl><type><name>int</name></type>		<name>path_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>path_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type>	<name>txn_exist</name></decl>;</decl_stmt>		<comment type="block">/*stores index of trasaction[i] in path, 
							txn_exist[txnid] = i; (path[i] = txnid or txn_exist[txnid] = -1;)*/</comment>
}</block></struct></type> <name>deeplist</name>;</typedef>

	<comment type="block">/*about output results*/</comment>
<typedef>typedef <type><struct>struct 
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>edge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>edge_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>edge_size</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nodes_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nodes_size</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>querys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>querys_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>querys_size</name></decl>;</decl_stmt>
}</block></struct></type> <name>PrintEdge</name>;</typedef>

<typedef>typedef <type><struct>struct 
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>deadlock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>deadlock_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>per_size</name></decl>;</decl_stmt>
}</block></struct></type> <name>PrintDeadlock</name>;</typedef>

<typedef>typedef <type><struct>struct 
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>txn_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>txn_size</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>cancel_query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cancel_query_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cancel_query_size</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nodename_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nodename_size</name></decl>;</decl_stmt>
}</block></struct></type> <name>PrintRollbackTxn</name>;</typedef>

<typedef>typedef <type><struct>struct 
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PrintRollbackTxn</name> <modifier>*</modifier></type><name>Ptxns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	<name>Ptxns_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>Ptxns_size</name></decl>;</decl_stmt>
}</block></struct></type> <name>PrintAllRollbackTxns</name>;</typedef>

	
<comment type="block">/*function list*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ResetGlobalVariables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

	<comment type="block">/*plugin entry function*/</comment>
<function_decl><type><name>Datum</name></type>	<name>pg_unlock_execute</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pg_unlock_execute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>Datum</name></type>	<name>pg_unlock_check_deadlock</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pg_unlock_check_deadlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>Datum</name></type>	<name>pg_unlock_check_dependency</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pg_unlock_check_dependency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>Datum</name></type>	<name>pg_unlock_killbypid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pg_unlock_killbypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>Datum</name></type> <name>pg_findgxid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pg_findgxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*get all the transaction info*/</comment>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>TTSgetvalue</name><parameter_list>(<parameter><decl><type><name>TupleTableSlots</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tup_num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_num</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>DropTupleTableSlots</name><parameter_list>(<parameter><decl><type><name>TupleTableSlots</name> <modifier>*</modifier></type>
<name>Slots</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type>	<name>execute_on_single_node</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlots</name> <modifier>*</modifier></type> <name>tuples</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>GetAllTransInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>LoadTransaction</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>InitTransaction</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>txn_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>add_pid_node</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>txn_index</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LOCKTYPE</name></type>	
		<name>find_locktype</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>locktype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>MODE</name></type>	<name>find_mode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>;</function_decl>

	<comment type="block">/*build transaction dependency gragh*/</comment>
<function_decl><type><name>void</name></type>	<name>InitAllEdge</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>InitEdge</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pre</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>post</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type>	<name>is_conflict_withtxn</name><parameter_list>(<parameter><decl><type><name>lockinfo</name> <modifier>*</modifier></type><name>wait</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>post_txn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type>	<name>is_conflict_withlock</name><parameter_list>(<parameter><decl><type><name>lockinfo</name> <modifier>*</modifier></type><name>wait</name></decl></parameter>, <parameter><decl><type><name>lockinfo</name> <modifier>*</modifier></type><name>hold</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type>	<name>check_include</name><parameter_list>(<parameter><decl><type><name>lockinfo</name> <modifier>*</modifier></type><name>wait</name></decl></parameter>, <parameter><decl><type><name>lockinfo</name> <modifier>*</modifier></type><name>hold</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>DropTransaction</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>DropAlltransactions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>DropEdge</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>;</function_decl>

	<comment type="block">/*find all deadlocks*/</comment>
<function_decl><type><name>void</name></type>	<name>InitDeadlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>DropDeadlock</name><parameter_list>(<parameter><decl><type><name>deadlock</name> <modifier>*</modifier></type><name>loop</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>DropAlldeadlocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>DetectDeadlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>		<name>traverse</name><parameter_list>(<parameter><decl><type><name>deeplist</name><modifier>*</modifier></type> <name>list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>path_deadlock</name><parameter_list>(<parameter><decl><type><name>deeplist</name> <modifier>*</modifier></type> <name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>InitDeeplist</name><parameter_list>(<parameter><decl><type><name>deeplist</name><modifier>*</modifier></type> <name>list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>DropDeeplist</name><parameter_list>(<parameter><decl><type><name>deeplist</name><modifier>*</modifier></type> <name>list</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>void</name></type>	<name>ClearDeeplist</name><parameter_list>(<parameter><decl><type><name>deeplist</name><modifier>*</modifier></type> <name>list</name></decl></parameter>)</parameter_list>;</function_decl> 

	<comment type="block">/*recover all deadlocks*/</comment>
<function_decl><type><name>void</name></type>	<name>RecoverDeadlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>CountDeadlocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>CountWaitTxn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>SortByDeadlock</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sort_txnid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>quiksort</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sort_txnid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>low</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>high</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>KillDeadlockByTxn</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>txnid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type>	<name>DeadlockExists</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>;</function_decl>

	<comment type="block">/*output results*/</comment>
<function_decl><type><name>void</name></type>	<name>InitPrintEdge</name><parameter_list>(<parameter><decl><type><name>PrintEdge</name> <modifier>*</modifier></type><name>Pedge</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>DropPrintEdge</name><parameter_list>(<parameter><decl><type><name>PrintEdge</name> <modifier>*</modifier></type><name>Pedge</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>InitPrintDeadlock</name><parameter_list>(<parameter><decl><type><name>PrintDeadlock</name> <modifier>*</modifier></type><name>Pdeadlock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>DropPrintDeadlock</name><parameter_list>(<parameter><decl><type><name>PrintDeadlock</name> <modifier>*</modifier></type><name>Pdeadlock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>InitPrinttxn</name><parameter_list>(<parameter><decl><type><name>PrintRollbackTxn</name> <modifier>*</modifier></type><name>Ptxn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>DropPrinttxn</name><parameter_list>(<parameter><decl><type><name>PrintRollbackTxn</name> <modifier>*</modifier></type><name>Ptxn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>char</name>	<modifier>*</modifier></type><name>GetGxid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>pid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>		<name>check_node_pid</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodename</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>pid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type>	<name>check_exist_gid</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>KillTxn</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>txnid</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*global variables*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name>		<modifier>*</modifier></type><name>cn_node_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name>		<modifier>*</modifier></type><name>dn_node_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name>		<modifier>*</modifier></type><name>sdn_node_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name>		<modifier>*</modifier></type><name>cn_health_map</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name>		<modifier>*</modifier></type><name>dn_health_map</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>		<name>cn_nodes_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>		<name>dn_nodes_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>		<name>sdn_nodes_num</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>transaction</name>	<modifier>*</modifier></type>
				<name>pgxc_transaction</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/*stores all transactions*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>		<name>pgxc_transaction_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/*transaction count*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>		<name>pgxc_transaction_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/*records capacity of pgxc_transaction*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name>		<modifier>*</modifier><modifier>*</modifier></type><name>pgxc_edge</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>deadlock</name> <modifier>*</modifier></type>
				<name>pgxc_deadlock</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>		<name>pgxc_deadlock_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>		<name>pgxc_deadlock_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>m_matrix</name><index>[<expr><literal type="number">8</literal></expr>]</index><index>[<expr><literal type="number">8</literal></expr>]</index></name> <init>= <comment type="block">/*conflict info among lock modes*/</comment>
<expr><block>{
	<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ResetGlobalVariables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>cn_node_list</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dn_node_list</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sdn_node_list</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cn_health_map</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dn_health_map</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cn_nodes_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>dn_nodes_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>sdn_nodes_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>pgxc_transaction</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/*stores all transactions*/</comment>
    <expr_stmt><expr><name>pgxc_transaction_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/*transaction count*/</comment>
    <expr_stmt><expr><name>pgxc_transaction_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/*records capacity of pgxc_transaction*/</comment>
    <expr_stmt><expr><name>pgxc_edge</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>pgxc_deadlock</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pgxc_deadlock_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pgxc_deadlock_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></function>


<comment type="block">/* 
 * pg_unlock_execute -- detect and recover deadlocks
 * input: 	no
 * output:	info of rollback transactions
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_unlock_execute</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESS_CONTROL_ATTR_NUM</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ACCESS_CONTROL_ATTR_NUM</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACCESS_CONTROL_ATTR_NUM</name></cpp:macro>  <cpp:value>5</cpp:value></cpp:define>
		<decl_stmt><decl><type><name>FuncCallContext</name> 		<modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PrintAllRollbackTxns</name>	<modifier>*</modifier></type><name>Partxns</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>					<modifier>*</modifier><modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>                    <modifier>*</modifier><modifier>*</modifier></type><name>nodename</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>                    <modifier>*</modifier><modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>				<name>tuple</name></decl>;</decl_stmt>		
	
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>ACCESS_CONTROL_ATTR_NUM</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>ACCESS_CONTROL_ATTR_NUM</name></expr>]</index></name></decl>;</decl_stmt>
		
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can only called on coordinator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>ACCESS_CONTROL_ATTR_NUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"executetime"</literal></expr></argument>,
						   <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"txnindex"</literal></expr></argument>,
						   <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"rollbacktxn(ip:port)"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"nodename"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"cancel_query"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PrintAllRollbackTxns</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>Partxns</name> <operator>=</operator> <operator>(</operator><name>PrintAllRollbackTxns</name> <operator>*</operator><operator>)</operator><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INIT</name><argument_list>(<argument><expr><name><name>Partxns</name><operator>-&gt;</operator><name>Ptxns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Partxns</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

		<expr_stmt><expr><call><name>ResetGlobalVariables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*get node list*/</comment>
		<expr_stmt><expr><call><name>PgxcNodeGetOidsExtend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cn_node_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_node_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sdn_node_list</name></expr></argument>, 
							  <argument><expr><operator>&amp;</operator><name>cn_nodes_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_nodes_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sdn_nodes_num</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cn_health_map</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>cn_nodes_num</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dn_health_map</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>dn_nodes_num</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<do>do
		<block>{<block_content>
			<comment type="block">/*get all transaction info and associat it to global xid*/</comment>
			<expr_stmt><expr><call><name>GetAllTransInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pgxc_transaction_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pg_unlock: there is no transaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			
			<comment type="block">/*build transaction dependency graph*/</comment>
			<expr_stmt><expr><call><name>InitAllEdge</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			
			<comment type="block">/*detect deadlocks*/</comment>
			<expr_stmt><expr><call><name>DetectDeadlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pgxc_deadlock_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*program ends until there is no deadlock*/</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pg_unlock: there is no deadlock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/*recover deadlocks through killing one transaction*/</comment>
			<expr_stmt><expr><call><name>RecoverDeadlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*record output info*/</comment>
			<expr_stmt><expr><call><name>RPALLOC</name><argument_list>(<argument><expr><name><name>Partxns</name><operator>-&gt;</operator><name>Ptxns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>InitPrinttxn</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>Partxns</name><operator>-&gt;</operator><name>Ptxns</name><index>[<expr><name><name>Partxns</name><operator>-&gt;</operator><name>Ptxns_count</name></name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>Partxns</name><operator>-&gt;</operator><name>Ptxns</name><index>[<expr><name><name>Partxns</name><operator>-&gt;</operator><name>Ptxns_count</name></name></expr>]</index></name><operator>.</operator><name>txn_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>Partxns</name><operator>-&gt;</operator><name>Ptxns_count</name></name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>Partxns</name><operator>-&gt;</operator><name>Ptxns_count</name></name> <operator>&gt;=</operator> <name>MAX_DEADLOCK_CHECKLOOP</name></expr>)</condition>
                <block>{<block_content>
				    <comment type="block">/* avoid deadlock all the time */</comment>
				    <break>break;</break>
                </block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>DropAlldeadlocks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>DropAlltransactions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>while<condition>(<expr><name>true</name></expr>)</condition>;</do>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>	
	<expr_stmt><expr><name>Partxns</name> <operator>=</operator> <operator>(</operator><name>PrintAllRollbackTxns</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name><name>Partxns</name><operator>-&gt;</operator><name>index</name></name> <operator>&lt;</operator> <name><name>Partxns</name><operator>-&gt;</operator><name>Ptxns_count</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PrintRollbackTxn</name> <modifier>*</modifier></type><name>temp</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>Partxns</name><operator>-&gt;</operator><name>Ptxns</name><index>[<expr><name><name>Partxns</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>rec</name> <operator>=</operator> <name><name>Partxns</name><operator>-&gt;</operator><name>Ptxns</name><index>[<expr><name><name>Partxns</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>txn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nodename</name> <operator>=</operator> <name><name>Partxns</name><operator>-&gt;</operator><name>Ptxns</name><index>[<expr><name><name>Partxns</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>nodename</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>query</name> <operator>=</operator> <name><name>Partxns</name><operator>-&gt;</operator><name>Ptxns</name><index>[<expr><name><name>Partxns</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>cancel_query</name></expr>;</expr_stmt>
        
		<while>while <condition>(<expr><name><name>temp</name><operator>-&gt;</operator><name>index</name></name> <operator>&lt;</operator> <name><name>temp</name><operator>-&gt;</operator><name>txn_count</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>temp</name><operator>-&gt;</operator><name>index</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>Partxns</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>temp</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>rec</name><index>[<expr><name><name>temp</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>nodename</name><index>[<expr><name><name>temp</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>query</name><index>[<expr><name><name>temp</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>index</name></name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>temp</name><operator>-&gt;</operator><name>index</name></name> <operator>&lt;</operator> <name><name>temp</name><operator>-&gt;</operator><name>txn_count</name></name></expr>)</condition>
            <block>{<block_content>
			    <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name><name>Partxns</name><operator>-&gt;</operator><name>index</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>Partxns</name><operator>-&gt;</operator><name>Ptxns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Partxns</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>               
		<expr_stmt><expr><call><name>DropAlldeadlocks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DropAlltransactions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cn_health_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dn_health_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cn_node_list</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cn_node_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cn_nodes_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>dn_node_list</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dn_node_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dn_nodes_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>sdn_node_list</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sdn_node_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sdn_nodes_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>  
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* 
 * pg_unlock_check_deadlock -- detect deadlocks without recover
 * input: 	no
 * output:	info of deadlocks
 */</comment>
<function><type><name>Datum</name></type>	<name>pg_unlock_check_deadlock</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESS_CONTROL_ATTR_NUM</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ACCESS_CONTROL_ATTR_NUM</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACCESS_CONTROL_ATTR_NUM</name></cpp:macro>  <cpp:value>4</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>FuncCallContext</name> 		<modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PrintDeadlock</name>			<modifier>*</modifier></type><name>Pdeadlock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>					<modifier>*</modifier><modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>                    <modifier>*</modifier><modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>                    <modifier>*</modifier><modifier>*</modifier></type><name>querys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>				<name>tuple</name></decl>;</decl_stmt>		

	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>ACCESS_CONTROL_ATTR_NUM</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>ACCESS_CONTROL_ATTR_NUM</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>ACCESS_CONTROL_ATTR_NUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"deadlockid"</literal></expr></argument>,
						   <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"deadlocks"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"nodename"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"query"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PrintDeadlock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>Pdeadlock</name> <operator>=</operator> <operator>(</operator><name>PrintDeadlock</name><operator>*</operator><operator>)</operator><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
		
		<expr_stmt><expr><call><name>ResetGlobalVariables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*get node list*/</comment>
		<expr_stmt><expr><call><name>PgxcNodeGetOidsExtend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cn_node_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_node_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sdn_node_list</name></expr></argument>, 
							  <argument><expr><operator>&amp;</operator><name>cn_nodes_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_nodes_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sdn_nodes_num</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cn_health_map</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>cn_nodes_num</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dn_health_map</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>dn_nodes_num</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<comment type="block">/*get all transaction info and associat it to global xid*/</comment>
		<expr_stmt><expr><call><name>GetAllTransInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*build transaction dependency graph*/</comment>
		<expr_stmt><expr><call><name>InitAllEdge</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*detect deadlocks*/</comment>
		<expr_stmt><expr><call><name>DetectDeadlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*record output info*/</comment>
		<expr_stmt><expr><call><name>InitPrintDeadlock</name><argument_list>(<argument><expr><name>Pdeadlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>	
	<expr_stmt><expr><name>Pdeadlock</name> <operator>=</operator> <operator>(</operator><name>PrintDeadlock</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rec</name> <operator>=</operator> <name><name>Pdeadlock</name><operator>-&gt;</operator><name>deadlock</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nodes</name> <operator>=</operator> <name><name>Pdeadlock</name><operator>-&gt;</operator><name>nodename</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>querys</name> <operator>=</operator> <name><name>Pdeadlock</name><operator>-&gt;</operator><name>query</name></name></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>index</name></name> <operator>&lt;</operator> <name><name>Pdeadlock</name><operator>-&gt;</operator><name>deadlock_count</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>rec</name><index>[<expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>querys</name><index>[<expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>index</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>DropPrintDeadlock</name><argument_list>(<argument><expr><name>Pdeadlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DropAlldeadlocks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DropAlltransactions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cn_health_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dn_health_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cn_node_list</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cn_node_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cn_nodes_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>dn_node_list</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dn_node_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dn_nodes_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>sdn_node_list</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sdn_node_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sdn_nodes_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* 
 * pg_unlock_check_dependency -- only detect transaction dependency
 * input: 	no
 * output:	info of transaction dependency
 */</comment>
<function><type><name>Datum</name></type>	<name>pg_unlock_check_dependency</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESS_CONTROL_ATTR_NUM</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ACCESS_CONTROL_ATTR_NUM</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACCESS_CONTROL_ATTR_NUM</name></cpp:macro>  <cpp:value>4</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>FuncCallContext</name> 		<modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PrintEdge</name>				<modifier>*</modifier></type><name>Pedge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>					<modifier>*</modifier><modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>                    <modifier>*</modifier><modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>                    <modifier>*</modifier><modifier>*</modifier></type><name>querys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>				<name>tuple</name></decl>;</decl_stmt>		

	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>ACCESS_CONTROL_ATTR_NUM</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>ACCESS_CONTROL_ATTR_NUM</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>ACCESS_CONTROL_ATTR_NUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"dependencyid"</literal></expr></argument>,
						   <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"dependency"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"nodename"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"query"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PrintEdge</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>Pedge</name> <operator>=</operator> <operator>(</operator><name>PrintEdge</name><operator>*</operator><operator>)</operator><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
		
		<expr_stmt><expr><call><name>ResetGlobalVariables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*get node list*/</comment>
		<expr_stmt><expr><call><name>PgxcNodeGetOidsExtend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cn_node_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_node_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sdn_node_list</name></expr></argument>, 
							  <argument><expr><operator>&amp;</operator><name>cn_nodes_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_nodes_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sdn_nodes_num</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cn_health_map</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>cn_nodes_num</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dn_health_map</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>dn_nodes_num</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*get all transaction info and associat it to global xid*/</comment>
		<expr_stmt><expr><call><name>GetAllTransInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*build transaction dependency graph*/</comment>
		<expr_stmt><expr><call><name>InitAllEdge</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*record output info*/</comment>
		<expr_stmt><expr><call><name>InitPrintEdge</name><argument_list>(<argument><expr><name>Pedge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>	
	<expr_stmt><expr><name>Pedge</name> <operator>=</operator> <operator>(</operator><name>PrintEdge</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rec</name> <operator>=</operator> <name><name>Pedge</name><operator>-&gt;</operator><name>edge</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nodes</name> <operator>=</operator> <name><name>Pedge</name><operator>-&gt;</operator><name>nodes</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>querys</name> <operator>=</operator> <name><name>Pedge</name><operator>-&gt;</operator><name>querys</name></name></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name><name>Pedge</name><operator>-&gt;</operator><name>index</name></name> <operator>&lt;</operator> <name><name>Pedge</name><operator>-&gt;</operator><name>edge_count</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>rec</name><index>[<expr><name><name>Pedge</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name><name>Pedge</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>querys</name><index>[<expr><name><name>Pedge</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Pedge</name><operator>-&gt;</operator><name>index</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>DropPrintEdge</name><argument_list>(<argument><expr><name>Pedge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DropAlltransactions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cn_health_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dn_health_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cn_node_list</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cn_node_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cn_nodes_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>dn_node_list</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dn_node_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dn_nodes_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>sdn_node_list</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sdn_node_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sdn_nodes_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<comment type="block">/* 
 * pg_unlock_killbypid -- kill certain transaction by user
 * input: 	nodename, pid
 * output:	execute result success of error info
 */</comment>
<function><type><name>Datum</name></type>	<name>pg_unlock_killbypid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>Kstatus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>nodename</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>	<name>kpid</name> <init>= <expr><call><name>PG_GETARG_UINT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">100</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>gid</name><index>[<expr><name>MAX_GID</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	<modifier>*</modifier></type><name>t_status</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>txnindex</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>Kstatus</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can only called on coordinator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>ResetGlobalVariables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*get node list*/</comment>
		<expr_stmt><expr><call><name>PgxcNodeGetOidsExtend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cn_node_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_node_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sdn_node_list</name></expr></argument>, 
							  <argument><expr><operator>&amp;</operator><name>cn_nodes_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_nodes_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sdn_nodes_num</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cn_health_map</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>cn_nodes_num</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dn_health_map</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>dn_nodes_num</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*get all transaction info and associat it to global xid*/</comment>
		<expr_stmt><expr><call><name>GetAllTransInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*find global transaction according to nodename and pid*/</comment>
		<expr_stmt><expr><name>txnindex</name> <operator>=</operator> <call><name>check_node_pid</name><argument_list>(<argument><expr><name>nodename</name></expr></argument>, <argument><expr><name>kpid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>txnindex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>Kstatus</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="string">"Fail:error not exists node:%s or pid:%u on node %s"</literal></expr></argument>, <argument><expr><name>nodename</name></expr></argument>, <argument><expr><name>kpid</name></expr></argument>, <argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>get_pgxc_nodetype</name><argument_list>(<argument><expr><call><name>get_pgxc_nodeoid</name><argument_list>(<argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">'C'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>Kstatus</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="string">"Fail:error node:%s is not coordinator"</literal></expr></argument>, <argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>txnindex</name></expr>]</index></name><operator>.</operator><name>gid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*kill the transaction*/</comment>
		<expr_stmt><expr><call><name>KillTxn</name><argument_list>(<argument><expr><name>txnindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DropAlltransactions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		
		<comment type="block">/*check whether this transaction is existed*/</comment>
		<expr_stmt><expr><call><name>LoadTransaction</name><argument_list>(<argument><expr><call><name>get_pgxc_nodeoid</name><argument_list>(<argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>check_exist_gid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>Kstatus</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="string">"Success: pid:%u on node %s is killed"</literal></expr></argument>, <argument><expr><name>kpid</name></expr></argument>, <argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>Kstatus</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="string">"Fail:error pid:%u on node %s is not killed"</literal></expr></argument>, <argument><expr><name>kpid</name></expr></argument>, <argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>while<condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>
	<expr_stmt><expr><call><name>DropAlltransactions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cn_health_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dn_health_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cn_node_list</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cn_node_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cn_nodes_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>dn_node_list</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dn_node_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dn_nodes_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>sdn_node_list</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sdn_node_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sdn_nodes_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>t_status</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name>Kstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>Kstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>t_status</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* 
 * execute_on_single_node -- execute query on certain node and get results
 * input: 	node oid, execute query, number of attribute in results, results
 * return:	(Datum) 0
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>execute_on_single_node</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlots</name> <modifier>*</modifier></type><name>tuples</name></decl></parameter>)</parameter_list>  <comment type="line">//delete numnodes, delete nodelist, insert node</comment>
<block>{<block_content>

	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ii</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attnum</name></decl>;</decl_stmt>
	<comment type="block">/*check health of node*/</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>ishealthy</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
	<decl_stmt><decl><type><name>EState</name>				<modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>		<name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteQuery</name> 		<modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteQueryState</name>	<modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name>		<modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> 				<modifier>*</modifier></type><name>dummy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>				<name>ntype</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


	<comment type="block">/*get heathy status of query node*/</comment>
	<expr_stmt><expr><call><name>PoolPingNodeRecheck</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PgxcNodeGetHealthMap</name><argument_list>(<argument><expr><name>cn_node_list</name></expr></argument>, <argument><expr><name>dn_node_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cn_nodes_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_nodes_num</name></expr></argument>, <argument><expr><name>cn_health_map</name></expr></argument>, <argument><expr><name>dn_health_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>get_pgxc_nodetype</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'C'</literal></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cn_nodes_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cn_node_list</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>node</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ishealthy</name> <operator>=</operator> <name><name>cn_health_map</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dn_nodes_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>dn_node_list</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>node</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ishealthy</name> <operator>=</operator> <name><name>dn_health_map</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
	<comment type="block">/*
	 * Make up RemoteQuery plan node
	 */</comment>
	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_NONE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntype</name> <operator>=</operator> <name>PGXC_NODE_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>,
		<argument><expr><call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ntype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ntype</name> <operator>==</operator> <name>PGXC_NODE_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unknown node Oid: %u"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>ntype</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name></expr>)</condition> 
	<block>{<block_content>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_COORDS</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>query</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>force_autocommit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/*
	 * We only need the target entry to determine result data type.
	 * So create dummy even if real expression is a function.
	 */</comment>
	<for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;=</operator> <name>attnum</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>dummy</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="line">//TEXTOID??</comment>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
										  <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>dummy</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* prepare to execute */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>ExecInitRemoteQuery</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*execute query on node when node is healthy*/</comment>
	<expr_stmt><expr><call><name>INIT</name><argument_list>(<argument><expr><name><name>tuples</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuples</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ishealthy</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuples</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_tuple</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
			<expr_stmt><expr><call><name>RPALLOC</name><argument_list>(<argument><expr><name><name>tuples</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tuples</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>i_tuple</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>attnum</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
			<for>for <control>(<init><expr><name>i_attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i_attnum</name> <operator>&lt;</operator> <name>attnum</name></expr>;</condition> <incr><expr><name>i_attnum</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i_attnum</name></expr>]</index></name> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator><literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>tuples</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>i_tuple</name></expr>]</index><index>[<expr><name>i_attnum</name></expr>]</index></name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i_attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>tuples</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>i_tuple</name></expr>]</index><index>[<expr><name>i_attnum</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name><name>tuples</name><operator>-&gt;</operator><name>slot_count</name></name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i_tuple</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ExecEndRemoteQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/*
	 * Connect to SPI manager
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>SPI_connect</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* internal error */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI connect failure - returned %d"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get pg_***_size function results from all Datanodes */</comment>
	<expr_stmt><expr><name>nodename</name> <operator>=</operator> <call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>SPI_execute_direct</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>spi_tupdesc</name> <operator>=</operator> <name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>SPI_OK_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to execute query '%s' on node '%s'"</literal></expr></argument>,
				        <argument><expr><name>query</name></expr></argument>, <argument><expr><name>nodename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The query must always return one row having one column:
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>SPI_processed</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>spi_tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>spi_tupdesc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* For single node, don't assume the type of datum. It can be bool also. */</comment>
	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
		<if_stmt><if>if <condition>(<expr><name>isnull</name> 
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
            <operator>&amp;&amp;</operator> <operator>(</operator><name>NULL</name> <operator>!=</operator> <name>result</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>            
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Expected datum but got null instead "</literal>
						<literal type="string">"while executing query '%s'"</literal></expr></argument>,
						<argument><expr><name>query</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
 * GetAllTransInfo -- get all transactions from all nodes and stores them in pgxc_transaction
 * input: 	no
 * return:	no
 */</comment>
<function><type><name>void</name></type> <name>GetAllTransInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>	
	<decl_stmt><decl><type><name>int</name></type>	<name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cn_nodes_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LoadTransaction</name><argument_list>(<argument><expr><name><name>cn_node_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dn_nodes_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LoadTransaction</name><argument_list>(<argument><expr><name><name>dn_node_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * BinarySearchGid -- Binary search gid in pgxc_transaction
 * input: 	gid
 * return:	gid pos or insert pos, was gid found
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>BinarySearchGid</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>low</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>high</name> <init>= <expr><name>pgxc_transaction_count</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>mid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cmp_result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>low</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>low</name> <operator>+</operator> <name>high</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>cmp_result</name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>mid</name></expr>]</index></name><operator>.</operator><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cmp_result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* gid == pgxc_transaction[mid].gid */</comment>
            <expr_stmt><expr><operator>*</operator><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <return>return <expr><name>mid</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>cmp_result</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* gid &gt; pgxc_transaction[mid].gid */</comment>
            <expr_stmt><expr><name>low</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* gid &lt; pgxc_transaction[mid].gid */</comment>
            <expr_stmt><expr><name>high</name> <operator>=</operator> <name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* return insert pos */</comment>
    <return>return <expr><name>high</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * LoadTransaction -- get transactions from certain node and stores them in pgxc_transaction
 * input: 	node oid
 * return:	no
 */</comment>
<function><type><name>void</name></type> <name>LoadTransaction</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>	
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_stmt</name> <init>= <expr><literal type="string">"select a1.pid::text, a1.locktype::text, a2.datname::text, a2.relname::text, "</literal>
						 <literal type="string">"a1.page::text, a1.tuple::text, a1.mode::text, a1.granted::text, a1.transactionid::text, a3.query::text, pg_findgxid(a1.pid::int)::text "</literal>
						 <literal type="string">"from (select locktype::text, database, relation, page::text, "</literal>
									  <literal type="string">"tuple::text, mode::text, granted::text, pid::text, transactionid::text "</literal>
									  <literal type="string">"from pg_locks where (locktype = 'relation' or locktype = 'page' or locktype = 'tuple' or locktype = 'transactionid')"</literal>
									  <literal type="string">" and (pid is not null))a1 "</literal>
 							  <literal type="string">"left join "</literal>
 							  <literal type="string">"(select distinct pg_database.datname::text, pg_class.relname::text, "</literal>
				  								<literal type="string">"pg_locks.database, pg_locks.relation "</literal>
				  								<literal type="string">"from pg_database, pg_class, pg_locks, pg_namespace "</literal>
				  								<literal type="string">"where pg_database.oid = pg_locks.database and pg_class.oid = pg_locks.relation "</literal>
				  									  <literal type="string">"and pg_namespace.oid = pg_class.relnamespace and pg_namespace.nspname "</literal>
				 									  <literal type="string">"not in ('pg_catalog','information_schema'))a2 "</literal>
								  <literal type="string">"on a1.database = a2.database and a1.relation = a2.relation "</literal>
								  <literal type="string">"left join "</literal>
								  <literal type="string">"(select pid::text, query::text from pg_stat_activity)a3 on a1.pid = a3.pid and a3.pid != '%d' "</literal>
								  <literal type="string">"where (a1.locktype = 'transactionid' and a1.transactionid is not null)"</literal>
								  	<literal type="string">" or (a1.locktype != 'transactionid' and a2.datname is not null and a2.relname is not null) order by a1.pid;"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name></type> <name><name>query_txnid</name><index>[<expr><literal type="number">2048</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*stores tuples in result_txnid*/</comment>
	<decl_stmt><decl><type><name>TupleTableSlots</name></type>	<name>result_txnid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i_txn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ntuples</name></decl>;</decl_stmt> 
	<decl_stmt><decl><type><name>uint32</name></type> <name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>temp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rel_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>gid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nodeid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lockinfo</name></type> <name>templock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>query_txnid</name></expr></argument>, <argument><expr><name>query_stmt</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>execute_on_single_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>query_txnid</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>result_txnid</name><operator>.</operator><name>slot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> 
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pg_unlock: there is no transaction on node %s"</literal></expr></argument>, <argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><name>ntuples</name> <operator>=</operator> <name><name>result_txnid</name><operator>.</operator><name>slot_count</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><call><name>TTSgetvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*get global xid of pid on node*/</comment>
        <expr_stmt><expr><name>gid</name> <operator>=</operator> <call><name>TTSgetvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*select for update apply for transactionid without global xid*/</comment>
		<if_stmt><if>if <condition>(<expr><name>gid</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		
		<comment type="block">/*check whether the gid is already existed*/</comment>
        <expr_stmt><expr><name>i_txn</name> <operator>=</operator> <call><name>BinarySearchGid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*insert this new transaction when gid is not find in pgxc_transaction*/</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RPALLOC</name><argument_list>(<argument><expr><name>pgxc_transaction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxc_transaction</name><index>[<expr><name>i_txn</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pgxc_transaction</name><index>[<expr><name>i_txn</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>pgxc_transaction_count</name> <operator>-</operator> <name>i_txn</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>transaction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>InitTransaction</name><argument_list>(<argument><expr><name>i_txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>i_txn</name></expr>]</index></name><operator>.</operator><name>gid</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MAX_GID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pgxc_transaction_count</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>add_pid_node</name><argument_list>(<argument><expr><name>i_txn</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nodeid</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgxc_transaction</name><index>[<expr><name>i_txn</name></expr>]</index></name><operator>.</operator><name>initiator</name> <operator>=</operator> <call><name>get_nodeoid_from_nodeid</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>PGXC_NODE_COORDINATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">//pgxc_transaction[i_txn].initiator = get_pgxc_nodeoid(ptr);</comment>

		<comment type="block">/*read lockinfo from result_txnid*/</comment>
		<expr_stmt><expr><name><name>templock</name><operator>.</operator><name>m_pid</name></name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>templock</name><operator>.</operator><name>m_node</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>templock</name><operator>.</operator><name>m_locktype</name></name> <operator>=</operator> <call><name>find_locktype</name><argument_list>(<argument><expr><call><name>TTSgetvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<comment type="block">/*we only consider the first four locktypes*/</comment>
		<if_stmt><if>if <condition>(<expr><name><name>templock</name><operator>.</operator><name>m_locktype</name></name> <operator>&gt;</operator> <name>Locktype_Transactionid</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		
		<expr_stmt><expr><name>db_name</name> <operator>=</operator> <call><name>TTSgetvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>db_name</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>templock</name><operator>.</operator><name>m_dbname</name></name></expr></argument>, <argument><expr><name>db_name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>db_name</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>templock</name><operator>.</operator><name>m_dbname</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>templock</name><operator>.</operator><name>m_dbname</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>rel_name</name> <operator>=</operator> <call><name>TTSgetvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rel_name</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>templock</name><operator>.</operator><name>m_relname</name></name></expr></argument>, <argument><expr><name>rel_name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>rel_name</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>templock</name><operator>.</operator><name>m_relname</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>templock</name><operator>.</operator><name>m_relname</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TTSgetvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>templock</name><operator>.</operator><name>m_page</name></name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><call><name>TTSgetvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>templock</name><operator>.</operator><name>m_page</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TTSgetvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>templock</name><operator>.</operator><name>m_tuple</name></name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><call><name>TTSgetvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>templock</name><operator>.</operator><name>m_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>templock</name><operator>.</operator><name>m_mode</name></name> <operator>=</operator> <call><name>find_mode</name><argument_list>(<argument><expr><call><name>TTSgetvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TTSgetvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>templock</name><operator>.</operator><name>m_transactionid</name></name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><call><name>TTSgetvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>templock</name><operator>.</operator><name>m_transactionid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>TTSgetvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>TTSgetvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>)</condition> 
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>TTSgetvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1024</literal></expr>)</condition> 
            <block>{<block_content>
                <expr_stmt><expr><name><name>templock</name><operator>.</operator><name>m_query</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>TTSgetvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> 
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>templock</name><operator>.</operator><name>m_query</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><literal type="number">1025</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>templock</name><operator>.</operator><name>m_query</name></name></expr></argument>, <argument><expr><call><name>TTSgetvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> 
        <else>else 
        <block>{<block_content>
            <expr_stmt><expr><name><name>templock</name><operator>.</operator><name>m_query</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
		<comment type="block">/*put templock into transaction hold list or wait list due to granted*/</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>templock</name><operator>.</operator><name>m_granted</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PALLOC</name><argument_list>(<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>i_txn</name></expr>]</index></name><operator>.</operator><name>hold</name></expr></argument>, <argument><expr><name>templock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>templock</name><operator>.</operator><name>m_granted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PALLOC</name><argument_list>(<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>i_txn</name></expr>]</index></name><operator>.</operator><name>wait</name></expr></argument>, <argument><expr><name>templock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		</block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pgxc_transaction</name><index>[<expr><name>i_txn</name></expr>]</index></name><operator>.</operator><name>initiator</name> <operator>==</operator> <name>node</name></expr>)</condition> 
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>templock</name><operator>.</operator><name>m_query</name></name></expr>)</condition> 
            <block>{<block_content>
                <expr_stmt><expr><name><name>pgxc_transaction</name><index>[<expr><name>i_txn</name></expr>]</index></name><operator>.</operator><name>query</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>templock</name><operator>.</operator><name>m_query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> 
            <else>else 
            <block>{<block_content>
                <expr_stmt><expr><name><name>pgxc_transaction</name><index>[<expr><name>i_txn</name></expr>]</index></name><operator>.</operator><name>query</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"unknown"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

	</block_content>}</block></for>
	<expr_stmt><expr><call><name>DropTupleTableSlots</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
 * TTSgetvalue -- get attribute from TupleTableSlots
 * input: 	result, index of tuple, index of field
 * return:	attribute result
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>TTSgetvalue</name><parameter_list>(<parameter><decl><type><name>TupleTableSlots</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tup_num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>result</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>tup_num</name></expr>]</index><index>[<expr><name>field_num</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>DropTupleTableSlots</name><parameter_list>(<parameter><decl><type><name>TupleTableSlots</name> <modifier>*</modifier></type>
<name>Slots</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>Slots</name><operator>-&gt;</operator><name>slot_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>Slots</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>Slots</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>Slots</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>Slots</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>Slots</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>Slots</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Slots</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>InitTransaction</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>txn_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>transaction</name> <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>temp</name> <operator>=</operator> <name>pgxc_transaction</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pg_unlock: error pgxc_transaction is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>INIT</name><argument_list>(<argument><expr><name><name>temp</name><index>[<expr><name>txn_index</name></expr>]</index></name><operator>.</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INIT</name><argument_list>(<argument><expr><name><name>temp</name><index>[<expr><name>txn_index</name></expr>]</index></name><operator>.</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INIT</name><argument_list>(<argument><expr><name><name>temp</name><index>[<expr><name>txn_index</name></expr>]</index></name><operator>.</operator><name>hold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INIT</name><argument_list>(<argument><expr><name><name>temp</name><index>[<expr><name>txn_index</name></expr>]</index></name><operator>.</operator><name>wait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INIT</name><argument_list>(<argument><expr><name><name>temp</name><index>[<expr><name>txn_index</name></expr>]</index></name><operator>.</operator><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>temp</name><index>[<expr><name>txn_index</name></expr>]</index></name><operator>.</operator><name>searched</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>temp</name><index>[<expr><name>txn_index</name></expr>]</index></name><operator>.</operator><name>alive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INIT</name><argument_list>(<argument><expr><name><name>temp</name><index>[<expr><name>txn_index</name></expr>]</index></name><operator>.</operator><name>deadlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>temp</name><index>[<expr><name>txn_index</name></expr>]</index></name><operator>.</operator><name>wait_txn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>temp</name><index>[<expr><name>txn_index</name></expr>]</index></name><operator>.</operator><name>query</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
 * add_pid_node -- add pid and node to certain transaction
 * input: 	index of transaction, pid, node oid
 * return:	void
 */</comment>
<function><type><name>void</name></type> <name>add_pid_node</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>txn_index</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>transaction</name> <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>temp</name> <operator>=</operator> <name>pgxc_transaction</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PALLOC</name><argument_list>(<argument><expr><name><name>temp</name><index>[<expr><name>txn_index</name></expr>]</index></name><operator>.</operator><name>pid</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PALLOC</name><argument_list>(<argument><expr><name><name>temp</name><index>[<expr><name>txn_index</name></expr>]</index></name><operator>.</operator><name>node</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>LOCKTYPE</name></type> <name>find_locktype</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>locktype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTYPE</name></type> <name>j</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>locktype</name></expr></argument>, <argument><expr><literal type="string">"relation"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <name>Locktype_Relation</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>locktype</name></expr></argument>, <argument><expr><literal type="string">"page"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <name>Locktype_Page</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>locktype</name></expr></argument>, <argument><expr><literal type="string">"tuple"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <name>Locktype_Tuple</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>locktype</name></expr></argument>, <argument><expr><literal type="string">"transactionid"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <name>Locktype_Transactionid</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>locktype</name></expr></argument>, <argument><expr><literal type="string">"object"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <name>Locktype_Object</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>locktype</name></expr></argument>, <argument><expr><literal type="string">"userlock"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <name>Locktype_Userlock</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>locktype</name></expr></argument>, <argument><expr><literal type="string">"advisory"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <name>Locktype_Advisory</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pg_unlock: unknown locktype: %s"</literal></expr></argument>, <argument><expr><name>locktype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>j</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>MODE</name></type> <name>find_mode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MODE</name></type> <name>i</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"AccessShareLock"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>Lockmode_ASL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"RowShareLock"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>Lockmode_RSL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"RowExclusiveLock"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>Lockmode_REL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"ShareUpdateExclusiveLock"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>Lockmode_SUEL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"ShareLock"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>Lockmode_SL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"ShareRowExclusiveLock"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>Lockmode_SREL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"ExclusiveLock"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>Lockmode_EL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"AccessExclusiveLock"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>Lockmode_AEL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pg_unlock: unkown lock mode %s"</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>i</name></expr>;</return> 
</block_content>}</block></function>

<comment type="block">/* 
 * InitAllEdge -- build all transaction dependency graph and stores in pgxc_transaction, pgxc_edge
 * input: 	no
 * return:	no
 */</comment>
<function><type><name>void</name></type> <name>InitAllEdge</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pgxc_edge</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>pgxc_transaction_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pgxc_transaction_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pgxc_edge</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>pgxc_transaction_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>pgxc_transaction_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pgxc_edge</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	
	<comment type="block">/*search for all edges*/</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pgxc_transaction_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>pgxc_transaction_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>j</name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>InitEdge</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* 
 * InitEdge -- build dependency between two transactions and stores it in pgxc_transaction, pgxc_edge
 * input: 	pre transaction index, post transaction index
 * return:	no
 */</comment>
<function><type><name>void</name></type> <name>InitEdge</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pre</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>post</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>out_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Edge</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	<name>pre_end</name> <init>= <expr><name><name>pgxc_transaction</name><index>[<expr><name>pre</name></expr>]</index></name><operator>.</operator><name>wait_count</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lockinfo</name> <modifier>*</modifier></type><name>pre_wait</name> <init>= <expr><name><name>pgxc_transaction</name><index>[<expr><name>pre</name></expr>]</index></name><operator>.</operator><name>wait</name></expr></init></decl>;</decl_stmt>
	
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pre_end</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*if lock pre_wait[i] conflict with pgxc_transaction[post]*/</comment>
		<if_stmt><if>if <condition>(<expr><call><name>is_conflict_withtxn</name><argument_list>(<argument><expr><name>pre_wait</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>post</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RPALLOC</name><argument_list>(<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>pre</name></expr>]</index></name><operator>.</operator><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>out</name> <operator>=</operator> <name><name>pgxc_transaction</name><index>[<expr><name>pre</name></expr>]</index></name><operator>.</operator><name>out</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>out_count</name> <operator>=</operator> <name><name>pgxc_transaction</name><index>[<expr><name>pre</name></expr>]</index></name><operator>.</operator><name>out_count</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>out</name><index>[<expr><name>out_count</name></expr>]</index></name><operator>.</operator><name>pre</name> <operator>=</operator> <name>pre</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>out</name><index>[<expr><name>out_count</name></expr>]</index></name><operator>.</operator><name>post</name> <operator>=</operator> <name>post</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pgxc_transaction</name><index>[<expr><name>pre</name></expr>]</index></name><operator>.</operator><name>out_count</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pgxc_edge</name><index>[<expr><name>pre</name></expr>]</index><index>[<expr><name>post</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* 
 * is_conflict_withtxn -- build dependency between two transactions and stores it in pgxc_transaction, pgxc_edge
 * input: 	pre transaction index, post transaction index
 * return:	conflict or not
 */</comment>
<function><type><name>bool</name></type> <name>is_conflict_withtxn</name><parameter_list>(<parameter><decl><type><name>lockinfo</name> <modifier>*</modifier></type><name>wait</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>post_txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>conflict</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lockinfo</name> <modifier>*</modifier></type><name>hold</name> <init>= <expr><name><name>pgxc_transaction</name><index>[<expr><name>post_txn</name></expr>]</index></name><operator>.</operator><name>hold</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>hold_count</name> <init>= <expr><name><name>pgxc_transaction</name><index>[<expr><name>post_txn</name></expr>]</index></name><operator>.</operator><name>hold_count</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>hold_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>is_conflict_withlock</name><argument_list>(<argument><expr><name>wait</name></expr></argument>, <argument><expr><name>hold</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>conflict</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>conflict</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * is_conflict_withlock -- build dependency between two locks
 * input: 	pre lockinfo, post lockinfo
 * return:	conflict or not
 */</comment>
<function><type><name>bool</name></type> <name>is_conflict_withlock</name><parameter_list>(<parameter><decl><type><name>lockinfo</name> <modifier>*</modifier></type><name>wait</name></decl></parameter>, <parameter><decl><type><name>lockinfo</name> <modifier>*</modifier></type><name>hold</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>conflict</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>sameobject</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	
	<comment type="block">/*locks of same granted will not conflict*/</comment>
	<if_stmt><if>if <condition>(<expr><name><name>wait</name><operator>-&gt;</operator><name>m_node</name></name> <operator>!=</operator> <name><name>hold</name><operator>-&gt;</operator><name>m_node</name></name> <operator>||</operator> <name><name>wait</name><operator>-&gt;</operator><name>m_granted</name></name> <operator>==</operator> <name><name>hold</name><operator>-&gt;</operator><name>m_granted</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>conflict</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	
	<comment type="block">/*locks of different locktype will not conflict*/</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>wait</name><operator>-&gt;</operator><name>m_locktype</name></name> <operator>&lt;</operator> <name>Locktype_Transactionid</name><operator>)</operator> <operator>^</operator> <operator>(</operator><name><name>hold</name><operator>-&gt;</operator><name>m_locktype</name></name> <operator>&lt;</operator> <name>Locktype_Transactionid</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sameobject</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	
	<comment type="block">/*check locktype among relation, page and tuple*/</comment>
	<if type="elseif">else if<condition>(<expr><name><name>wait</name><operator>-&gt;</operator><name>m_locktype</name></name> <operator>&lt;</operator> <name>Locktype_Transactionid</name> <operator>&amp;&amp;</operator> <name><name>hold</name><operator>-&gt;</operator><name>m_locktype</name></name> <operator>&lt;</operator> <name>Locktype_Transactionid</name></expr>)</condition> 
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>wait</name><operator>-&gt;</operator><name>m_dbname</name></name></expr></argument>, <argument><expr><name><name>hold</name><operator>-&gt;</operator><name>m_dbname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>check_include</name><argument_list>(<argument><expr><name>wait</name></expr></argument>, <argument><expr><name>hold</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sameobject</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	
	<comment type="block">/*check between transactionid*/</comment>
	<if type="elseif">else if<condition>(<expr><name><name>wait</name><operator>-&gt;</operator><name>m_locktype</name></name> <operator>==</operator> <name>Locktype_Transactionid</name> <operator>&amp;&amp;</operator> <name><name>hold</name><operator>-&gt;</operator><name>m_locktype</name></name> <operator>==</operator> <name>Locktype_Transactionid</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>wait</name><operator>-&gt;</operator><name>m_node</name></name> <operator>!=</operator> <name><name>hold</name><operator>-&gt;</operator><name>m_node</name></name> <operator>||</operator> <name><name>wait</name><operator>-&gt;</operator><name>m_transactionid</name></name> <operator>!=</operator> <name><name>hold</name><operator>-&gt;</operator><name>m_transactionid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sameobject</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>	
	</block_content>}</block></if></if_stmt>
	
	<comment type="block">/*check locktype among relation, page and tuple*/</comment>
	<if_stmt><if>if <condition>(<expr><name>sameobject</name> <operator>==</operator> <name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>conflict</name> <operator>=</operator> <operator>(</operator><name><name>m_matrix</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>wait</name><operator>-&gt;</operator><name>m_mode</name></name></expr>]</index><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>hold</name><operator>-&gt;</operator><name>m_mode</name></name></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>conflict</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>check_include</name><parameter_list>(<parameter><decl><type><name>lockinfo</name> <modifier>*</modifier></type><name>wait</name></decl></parameter>, <parameter><decl><type><name>lockinfo</name> <modifier>*</modifier></type><name>hold</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>include</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTYPE</name></type> <name>i</name> <init>= <expr><name><name>wait</name><operator>-&gt;</operator><name>m_locktype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTYPE</name></type> <name>j</name> <init>= <expr><name><name>hold</name><operator>-&gt;</operator><name>m_locktype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>min</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>max</name></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>&gt;=</operator> <name>Locktype_Transactionid</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>j</name> <operator>&gt;=</operator> <name>Locktype_Transactionid</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>include</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>min</name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>&lt;=</operator> <name>j</name></expr> ?</condition><then> <expr><name>i</name></expr> </then><else>: <expr><name>j</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>max</name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>&lt;=</operator> <name>j</name></expr> ?</condition><then> <expr><name>j</name></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>min</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>Locktype_Relation</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>wait</name><operator>-&gt;</operator><name>m_relname</name></name></expr></argument>, <argument><expr><name><name>hold</name><operator>-&gt;</operator><name>m_relname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>include</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>Locktype_Page</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>wait</name><operator>-&gt;</operator><name>m_relname</name></name></expr></argument>, <argument><expr><name><name>hold</name><operator>-&gt;</operator><name>m_relname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*locks in same relation and page or 
				relation lock and page lock of the same relation*/</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>!=</operator> <name>j</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>wait</name><operator>-&gt;</operator><name>m_page</name></name> <operator>==</operator> <name><name>hold</name><operator>-&gt;</operator><name>m_page</name></name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>include</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>Locktype_Tuple</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>wait</name><operator>-&gt;</operator><name>m_relname</name></name></expr></argument>, <argument><expr><name><name>hold</name><operator>-&gt;</operator><name>m_relname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>max</name> <operator>==</operator> <name>Locktype_Relation</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>include</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>wait</name><operator>-&gt;</operator><name>m_page</name></name> <operator>==</operator> <name><name>hold</name><operator>-&gt;</operator><name>m_page</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>max</name> <operator>==</operator> <name>Locktype_Page</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>include</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>wait</name><operator>-&gt;</operator><name>m_tuple</name></name> <operator>==</operator> <name><name>hold</name><operator>-&gt;</operator><name>m_tuple</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>max</name> <operator>==</operator> <name>Locktype_Tuple</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>include</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pg_unlock: could not match locktype %d to relation, page or tuple"</literal></expr></argument>, <argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>include</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>InitDeadlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>RPALLOC</name><argument_list>(<argument><expr><name>pgxc_deadlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INIT</name><argument_list>(<argument><expr><name><name>pgxc_deadlock</name><index>[<expr><name>pgxc_deadlock_count</name></expr>]</index></name><operator>.</operator><name>txns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RPALLOC</name><argument_list>(<argument><expr><name><name>pgxc_deadlock</name><index>[<expr><name>pgxc_deadlock_count</name></expr>]</index></name><operator>.</operator><name>txns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pgxc_deadlock</name><index>[<expr><name>pgxc_deadlock_count</name></expr>]</index></name><operator>.</operator><name>killed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>DropDeadlock</name><parameter_list>(<parameter><decl><type><name>deadlock</name> <modifier>*</modifier></type><name>loop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>loop</name><operator>-&gt;</operator><name>txns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>loop</name><operator>-&gt;</operator><name>killed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>DropAlldeadlocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>pgxc_deadlock_count</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DropDeadlock</name><argument_list>(<argument><expr><name>pgxc_deadlock</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name>pgxc_deadlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
 * DetectDeadlock -- detect deadlock according to transaction dependency and store them in pgxc_deadlock
 * input: 	no
 * return:	no
 */</comment>
<function><type><name>void</name></type> <name>DetectDeadlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deeplist</name></type> <name>dfs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>loop_start</name></decl>;</decl_stmt>
    
	<expr_stmt><expr><call><name>InitDeeplist</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pgxc_transaction_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>pgxc_deadlock_count</name> <operator>&gt;</operator> <name>MAX_DEADLOCK</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		
		<comment type="block">/*we can find all the deadlocks that conclude the transaction through tranvers it*/</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pgxc_transaction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>searched</name> <operator>==</operator> <name>true</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*push i into stack*/</comment>
			<expr_stmt><expr><call><name>PALLOC</name><argument_list>(<argument><expr><name><name>dfs</name><operator>.</operator><name>stack</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PALLOC</name><argument_list>(<argument><expr><name><name>dfs</name><operator>.</operator><name>stackpre</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<while>while <condition>(<expr><name><name>dfs</name><operator>.</operator><name>stack_count</name></name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
		<block>{<block_content>
    		<if_stmt><if>if <condition>(<expr><name>pgxc_deadlock_count</name> <operator>&gt;</operator> <name>MAX_DEADLOCK</name></expr>)</condition>
    		<block>{<block_content>
    			<break>break;</break>
    		</block_content>}</block></if></if_stmt>
			<comment type="block">/*loop_start indicate whether deadlock exists*/</comment>
			<expr_stmt><expr><name>loop_start</name> <operator>=</operator> <call><name>traverse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>loop_start</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>path_deadlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dfs</name></expr></argument>, <argument><expr><name>loop_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>ClearDeeplist</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>DropDeeplist</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
 * traverse -- traverse according to transaction dependency and store them in list-&gt;path
 * input: 	deeplist
 * return:	index of deadlock start transaction in path
 */</comment>
<function><type><name>int</name></type> <name>traverse</name><parameter_list>(<parameter><decl><type><name>deeplist</name><modifier>*</modifier></type> <name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	
	<comment type="block">/*pop the last element in stack*/</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>post</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>list</name><operator>-&gt;</operator><name>stack_count</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt> 
	<decl_stmt><decl><type><name>int</name></type> <name>startpre</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>stackpre</name><index>[<expr><name><name>list</name><operator>-&gt;</operator><name>stackpre_count</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>stack_count</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>stackpre_count</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pgxc_transaction</name><index>[<expr><name>start</name></expr>]</index></name><operator>.</operator><name>searched</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*delete element in path, if the pop element in stack is not its post*/</comment>
	<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>path_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<while>while<condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>path</name><index>[<expr><name><name>list</name><operator>-&gt;</operator><name>path_count</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>startpre</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>path_count</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>txn_exist</name><index>[<expr><name><name>list</name><operator>-&gt;</operator><name>path</name><index>[<expr><name><name>list</name><operator>-&gt;</operator><name>path_count</name></name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>
	
	<comment type="block">/*push the pop element into path*/</comment>
	<expr_stmt><expr><call><name>PALLOC</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>txn_exist</name><index>[<expr><name>start</name></expr>]</index></name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>path_count</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	
	<comment type="block">/*find all the outedge of the above pop element*/</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pgxc_transaction</name><index>[<expr><name>start</name></expr>]</index></name><operator>.</operator><name>out_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>post</name> <operator>=</operator> <name><name>pgxc_transaction</name><index>[<expr><name>start</name></expr>]</index></name><operator>.</operator><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>post</name></expr>;</expr_stmt>
		
		<comment type="block">/*if the transaction post does not exit in path*/</comment>
		<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>txn_exist</name><index>[<expr><name>post</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PALLOC</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>, <argument><expr><name>post</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PALLOC</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>stackpre</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/*or return the index of path according to the transaction*/</comment>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>txn_exist</name><index>[<expr><name>post</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * path_deadlock -- add element in path to pgxc_deadlock
 * input: 	deeplist, index of deadlock start element in path
 * return:	no
 */</comment>
<function><type><name>void</name></type> <name>path_deadlock</name><parameter_list>(<parameter><decl><type><name>deeplist</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>deadlock</name> <modifier>*</modifier></type><name>loop</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ij</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>total_count</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>path_count</name></name> <operator>-</operator> <name>start</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isexist</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ii_txns_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ij_txns_count</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>InitDeadlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>loop</name> <operator>=</operator> <name>pgxc_deadlock</name><operator>+</operator><name>pgxc_deadlock_count</name></expr>;</expr_stmt>
	
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>list</name><operator>-&gt;</operator><name>path_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PALLOC</name><argument_list>(<argument><expr><name><name>loop</name><operator>-&gt;</operator><name>txns</name></name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/*first check whether the deadlock is exits*/</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pgxc_deadlock_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pgxc_deadlock</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>txns_count</name> <operator>==</operator> <name>total_count</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>isexist</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ii_txns_count</name> <operator>=</operator> <name><name>pgxc_deadlock</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>txns_count</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ij_txns_count</name> <operator>=</operator> <name><name>loop</name><operator>-&gt;</operator><name>txns_count</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ij</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>ii_txns_count</name> <operator>&amp;&amp;</operator> <name>ij</name> <operator>&lt;</operator> <name>ij_txns_count</name></expr>;</condition><incr/>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>pgxc_deadlock</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>txns</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>!=</operator> <name><name>loop</name><operator>-&gt;</operator><name>txns</name><index>[<expr><name>ij</name> <operator>%</operator> <name><name>loop</name><operator>-&gt;</operator><name>txns_count</name></name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>ii</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ij</name> <operator>&lt;</operator> <name><name>loop</name><operator>-&gt;</operator><name>txns_count</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>ij</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*deadlock not exist*/</comment>
						<expr_stmt><expr><name>isexist</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	
						<break>break;</break>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>ii</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>ij</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>isexist</name> <operator>==</operator> <name>true</name></expr>)</condition>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/*deadlock in list[start~path_count-1] is already exist*/</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	
	<if_stmt><if>if <condition>(<expr><name>isexist</name> <operator>==</operator> <name>false</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pgxc_deadlock_count</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>loop</name><operator>-&gt;</operator><name>txns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/*if not existed then insert into pgxc_deadlock*/</comment>
	<return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>InitDeeplist</name><parameter_list>(<parameter><decl><type><name>deeplist</name><modifier>*</modifier></type> <name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt> 
	<expr_stmt><expr><call><name>INIT</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INIT</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>stackpre</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INIT</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>txn_exist</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>pgxc_transaction_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pgxc_transaction_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>txn_exist</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ClearDeeplist</name><parameter_list>(<parameter><decl><type><name>deeplist</name> <modifier>*</modifier></type> <name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>stack_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>stackpre_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>path_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pgxc_transaction_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>txn_exist</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>DropDeeplist</name><parameter_list>(<parameter><decl><type><name>deeplist</name> <modifier>*</modifier></type> <name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>stackpre</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>txn_exist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>txn_exist</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * RecoverDeadlock -- kill at most one transaction in each deadlock
 * input: 	no
 * return:	no
 */</comment>
<function><type><name>void</name></type> <name>RecoverDeadlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type> <name>sort_txnid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>pgxc_deadlock_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>sort_txnid</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>pgxc_transaction_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*Count deadlocks belong to each transactions*/</comment>
	<expr_stmt><expr><call><name>CountDeadlocks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CountWaitTxn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*sort transaction index by deadlock count*/</comment>
	<expr_stmt><expr><call><name>SortByDeadlock</name><argument_list>(<argument><expr><name>sort_txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*first kill transaction with the most deadlocks*/</comment>
	<expr_stmt><expr><call><name>KillDeadlockByTxn</name><argument_list>(<argument><expr><name><name>sort_txnid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sort_txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>CountDeadlocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
	
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pgxc_deadlock_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>pgxc_deadlock</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>txns_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PALLOC</name><argument_list>(<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name><name>pgxc_deadlock</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>txns</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>deadlock</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	<return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SortByDeadlock</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sort_txnid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pgxc_transaction_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>sort_txnid</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>quiksort</name><argument_list>(<argument><expr><name>sort_txnid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pgxc_transaction_count</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>quiksort</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sort_txnid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>low</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>high</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>low</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>high</name></expr></init></decl>;</decl_stmt>  
	<decl_stmt><decl><type><name>int</name></type> <name>temp</name> <init>= <expr><name><name>sort_txnid</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt> 
  
	<if_stmt><if>if<condition>( <expr><name>low</name> <operator>&gt;</operator> <name>high</name></expr>)</condition>
	<block>{<block_content>		   
	   <return>return ;</return>
	</block_content>}</block></if></if_stmt>
	<while>while<condition>(<expr><name>i</name> <operator>&lt;</operator> <name>j</name></expr>)</condition> 
	<block>{<block_content>
		<while>while<condition>(<expr><operator>(</operator><operator>(</operator><name><name>pgxc_transaction</name><index>[<expr><name><name>sort_txnid</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>deadlock_count</name>
			<operator>&lt;</operator> <name><name>pgxc_transaction</name><index>[<expr><name>temp</name></expr>]</index></name><operator>.</operator><name>deadlock_count</name><operator>)</operator> 
				<operator>||</operator> <operator>(</operator><operator>(</operator><name><name>pgxc_transaction</name><index>[<expr><name><name>sort_txnid</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>deadlock_count</name>
					<operator>==</operator> <name><name>pgxc_transaction</name><index>[<expr><name>temp</name></expr>]</index></name><operator>.</operator><name>deadlock_count</name><operator>)</operator>
					<operator>&amp;&amp;</operator> <operator>(</operator><name><name>pgxc_transaction</name><index>[<expr><name><name>sort_txnid</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>wait_txn</name>
						<operator>&lt;=</operator> <name><name>pgxc_transaction</name><index>[<expr><name>temp</name></expr>]</index></name><operator>.</operator><name>wait_txn</name><operator>)</operator><operator>)</operator><operator>)</operator> 
			<operator>&amp;&amp;</operator> <operator>(</operator><name>i</name> <operator>&lt;</operator> <name>j</name><operator>)</operator></expr>)</condition>
		<block>{<block_content> 
			<expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt> 
		</block_content>}</block></while>
		<expr_stmt><expr><name><name>sort_txnid</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sort_txnid</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		<while>while<condition>(<expr><operator>(</operator><operator>(</operator><name><name>pgxc_transaction</name><index>[<expr><name><name>sort_txnid</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>deadlock_count</name>
			<operator>&gt;</operator> <name><name>pgxc_transaction</name><index>[<expr><name>temp</name></expr>]</index></name><operator>.</operator><name>deadlock_count</name><operator>)</operator>
				<operator>||</operator> <operator>(</operator><operator>(</operator><name><name>pgxc_transaction</name><index>[<expr><name><name>sort_txnid</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>deadlock_count</name>
					<operator>==</operator> <name><name>pgxc_transaction</name><index>[<expr><name>temp</name></expr>]</index></name><operator>.</operator><name>deadlock_count</name><operator>)</operator> 
					<operator>&amp;&amp;</operator> <operator>(</operator><name><name>pgxc_transaction</name><index>[<expr><name><name>sort_txnid</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>wait_txn</name>
						<operator>&gt;=</operator> <name><name>pgxc_transaction</name><index>[<expr><name>temp</name></expr>]</index></name><operator>.</operator><name>wait_txn</name><operator>)</operator><operator>)</operator><operator>)</operator>
			<operator>&amp;&amp;</operator> <operator>(</operator><name>i</name> <operator>&lt;</operator> <name>j</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt> 
		</block_content>}</block></while>  
		<expr_stmt><expr><name><name>sort_txnid</name><index>[<expr><name>j</name></expr>]</index></name><operator>=</operator> <name><name>sort_txnid</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	 <expr_stmt><expr><name><name>sort_txnid</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
	 <expr_stmt><expr><call><name>quiksort</name><argument_list>(<argument><expr><name>sort_txnid</name></expr></argument>,<argument><expr><name>low</name></expr></argument>,<argument><expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	 <expr_stmt><expr><call><name>quiksort</name><argument_list>(<argument><expr><name>sort_txnid</name></expr></argument>,<argument><expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>high</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* 
 * KillDeadlockByTxn -- kill certain transaction
 * input: 	transaction index
 * return:	no
 */</comment>
<function><type><name>void</name></type> <name>KillDeadlockByTxn</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>txnid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>transaction</name> <modifier>*</modifier></type><name>txn</name> <init>= <expr><name>pgxc_transaction</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><name><name>pgxc_transaction</name><index>[<expr><name>txnid</name></expr>]</index></name><operator>.</operator><name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name><modifier>*</modifier></type> <name>pid</name> <init>= <expr><name><name>pgxc_transaction</name><index>[<expr><name>txnid</name></expr>]</index></name><operator>.</operator><name>pid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>query</name><index>[<expr><literal type="number">500</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlots</name></type> <name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DeadlockExists</name><argument_list>(<argument><expr><name>txnid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><name><name>txn</name><index>[<expr><name>txnid</name></expr>]</index></name><operator>.</operator><name>alive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>txn</name><index>[<expr><name>txnid</name></expr>]</index></name><operator>.</operator><name>deadlock_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pgxc_deadlock</name><index>[<expr><name><name>txn</name><index>[<expr><name>txnid</name></expr>]</index></name><operator>.</operator><name><name>deadlock</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>killed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pgxc_transaction</name><index>[<expr><name>txnid</name></expr>]</index></name><operator>.</operator><name>node_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>,<argument><expr><literal type="string">"select pg_cancel_backend(%u);"</literal></expr></argument>, <argument><expr><name><name>pid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>execute_on_single_node</name><argument_list>(<argument><expr><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DropTupleTableSlots</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>DeadlockExists</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>transaction</name> <modifier>*</modifier></type><name>txn</name> <init>= <expr><name>pgxc_transaction</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>txn</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>deadlock_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pgxc_deadlock</name><index>[<expr><name><name>txn</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name><name>deadlock</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>killed</name> <operator>==</operator> <name>false</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>DropTransaction</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>transaction</name> <modifier>*</modifier></type><name>txn</name> <init>= <expr><name>pgxc_transaction</name></expr></init></decl>;</decl_stmt>
    
	<expr_stmt><expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>searched</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>wait_txn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hold_size</name> <operator>&amp;&amp;</operator> <name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>hold</name><operator>-&gt;</operator><name>m_query</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>hold</name><operator>-&gt;</operator><name>m_query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>hold</name><operator>-&gt;</operator><name>m_query</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>wait_size</name> <operator>&amp;&amp;</operator> <name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>wait</name><operator>-&gt;</operator><name>m_query</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>wait</name><operator>-&gt;</operator><name>m_query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>wait</name><operator>-&gt;</operator><name>m_query</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>wait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>deadlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>query</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>txn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>query</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>DropAlltransactions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pgxc_transaction_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DropTransaction</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>pgxc_edge</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pgxc_transaction_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pgxc_edge</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>pgxc_transaction_count</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pgxc_edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pgxc_edge</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name>pgxc_transaction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>InitPrintEdge</name><parameter_list>(<parameter><decl><type><name>PrintEdge</name> <modifier>*</modifier></type><name>Pedge</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>index1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>index2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	
    <expr_stmt><expr><name><name>Pedge</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INIT</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>edge</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INIT</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INIT</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>querys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RPALLOC</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>edge</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RPALLOC</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RPALLOC</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>querys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pgxc_transaction_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>pgxc_transaction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>out_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RPALLOC</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>edge</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>Pedge</name><operator>-&gt;</operator><name>edge</name><index>[<expr><name><name>Pedge</name><operator>-&gt;</operator><name>edge_count</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">2</literal><operator>*</operator><name>MAX_GID</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<expr_stmt><expr><name>index1</name> <operator>=</operator> <name><name>pgxc_transaction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>out</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pre</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>index2</name> <operator>=</operator> <name><name>pgxc_transaction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>out</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>post</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>edge</name><index>[<expr><name><name>Pedge</name><operator>-&gt;</operator><name>edge_count</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>MAX_GID</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><literal type="string">"%s --&gt; %s"</literal></expr></argument>, 
					<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>index1</name></expr>]</index></name><operator>.</operator><name>gid</name></expr></argument>, <argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>index2</name></expr>]</index></name><operator>.</operator><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>RPALLOC</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>Pedge</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name><name>Pedge</name><operator>-&gt;</operator><name>nodes_count</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">2</literal><operator>*</operator><name>NAMEDATALEN</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name><name>Pedge</name><operator>-&gt;</operator><name>nodes_count</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>NAMEDATALEN</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><literal type="string">"%s --&gt; %s"</literal></expr></argument>, 
					<argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>index1</name></expr>]</index></name><operator>.</operator><name>initiator</name></expr></argument>)</argument_list></call></expr></argument>, 
					<argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>index2</name></expr>]</index></name><operator>.</operator><name>initiator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>RPALLOC</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>querys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>pgxc_transaction</name><index>[<expr><name>index1</name></expr>]</index></name><operator>.</operator><name>query</name></expr>)</condition> 
            <block>{<block_content>
                <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>index1</name></expr>]</index></name><operator>.</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>pgxc_transaction</name><index>[<expr><name>index2</name></expr>]</index></name><operator>.</operator><name>query</name></expr>)</condition> 
            <block>{<block_content>
                <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>index2</name></expr>]</index></name><operator>.</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>Pedge</name><operator>-&gt;</operator><name>querys</name><index>[<expr><name><name>Pedge</name><operator>-&gt;</operator><name>querys_count</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name><operator>+</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>querys</name><index>[<expr><name><name>Pedge</name><operator>-&gt;</operator><name>querys_count</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name><operator>+</operator><literal type="number">10</literal></expr></argument>, <argument><expr><literal type="string">"%s --&gt; %s"</literal></expr></argument>, 
					<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>index1</name></expr>]</index></name><operator>.</operator><name>query</name></expr></argument>, <argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>index2</name></expr>]</index></name><operator>.</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>Pedge</name><operator>-&gt;</operator><name>edge_count</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>Pedge</name><operator>-&gt;</operator><name>nodes_count</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>Pedge</name><operator>-&gt;</operator><name>querys_count</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>DropPrintEdge</name><parameter_list>(<parameter><decl><type><name>PrintEdge</name> <modifier>*</modifier></type><name>Pedge</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>Pedge</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>Pedge</name><operator>-&gt;</operator><name>edge_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>edge</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>edge</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>Pedge</name><operator>-&gt;</operator><name>nodes_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>Pedge</name><operator>-&gt;</operator><name>querys_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>querys</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>Pedge</name><operator>-&gt;</operator><name>querys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Pedge</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>Pedge</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>InitPrintDeadlock</name><parameter_list>(<parameter><decl><type><name>PrintDeadlock</name> <modifier>*</modifier></type><name>Pdeadlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>		
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type>  <name>nodename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type>  <name>deadlock_query</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>deadlock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>deadlock_count</name></name> <operator>=</operator> <name>pgxc_deadlock_count</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>per_size</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>pgxc_deadlock_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>deadlock</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>pgxc_deadlock_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>nodename</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>pgxc_deadlock_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>pgxc_deadlock_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pgxc_deadlock_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>per_size</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pgxc_deadlock</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>txns_count</name><operator>*</operator><operator>(</operator><name>MAX_GID</name><operator>+</operator><literal type="number">10</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>deadlock</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>per_size</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>nodename</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>pgxc_deadlock</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>txns_count</name> <operator>*</operator> <name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>deadlock_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>pgxc_deadlock</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>txns_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">"%-15s(%-15s:%-12d)"</literal></expr></argument>, <argument><expr><name><name>pgxc_transaction</name><index>[<expr><name><name>pgxc_deadlock</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>txns</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>gid</name></expr></argument>, 
					<argument><expr><call><name>get_pgxc_nodehost</name><argument_list>(<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name><name>pgxc_deadlock</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>txns</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>initiator</name></expr></argument>)</argument_list></call></expr></argument>, 
					<argument><expr><call><name>get_pgxc_nodeport</name><argument_list>(<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name><name>pgxc_deadlock</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>txns</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>initiator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nodename</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name><name>pgxc_deadlock</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>txns</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>initiator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>deadlock_query</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pgxc_transaction</name><index>[<expr><name><name>pgxc_deadlock</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>txns</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name><name>pgxc_deadlock</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>txns_count</name><operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nodename</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>deadlock_query</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>deadlock</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>per_size</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>query</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>nodename</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pgxc_deadlock</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>txns_count</name> <operator>*</operator> <name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>nodename</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>query</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>deadlock_query</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>query</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>deadlock_query</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>deadlock_query</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>DropPrintDeadlock</name><parameter_list>(<parameter><decl><type><name>PrintDeadlock</name> <modifier>*</modifier></type><name>Pdeadlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>Pdeadlock</name><operator>-&gt;</operator><name>deadlock_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>deadlock</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>nodename</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>query</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>deadlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>per_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>deadlock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>nodename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>per_size</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Pdeadlock</name><operator>-&gt;</operator><name>deadlock_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>InitPrinttxn</name><parameter_list>(<parameter><decl><type><name>PrintRollbackTxn</name> <modifier>*</modifier></type><name>Ptxn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INIT</name><argument_list>(<argument><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>txn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INIT</name><argument_list>(<argument><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INIT</name><argument_list>(<argument><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>cancel_query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pgxc_transaction_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pgxc_transaction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alive</name> <operator>==</operator> <name>false</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RPALLOC</name><argument_list>(<argument><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>txn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>txn</name><index>[<expr><name><name>Ptxn</name><operator>-&gt;</operator><name>txn_count</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>MAX_GID</name><operator>+</operator><literal type="number">10</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>txn</name><index>[<expr><name><name>Ptxn</name><operator>-&gt;</operator><name>txn_count</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%-15s(%-15s:%-15d)"</literal></expr></argument>, <argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gid</name></expr></argument>,
											<argument><expr><call><name>get_pgxc_nodehost</name><argument_list>(<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initiator</name></expr></argument>)</argument_list></call></expr></argument>, 
											<argument><expr><call><name>get_pgxc_nodeport</name><argument_list>(<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initiator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RPALLOC</name><argument_list>(<argument><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>nodename</name><index>[<expr><name><name>Ptxn</name><operator>-&gt;</operator><name>nodename_count</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>nodename</name><index>[<expr><name><name>Ptxn</name><operator>-&gt;</operator><name>nodename_count</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initiator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
			<expr_stmt><expr><call><name>RPALLOC</name><argument_list>(<argument><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>cancel_query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>pgxc_transaction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>query</name></expr>)</condition> 
            <block>{<block_content>
                <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>cancel_query</name><index>[<expr><name><name>Ptxn</name><operator>-&gt;</operator><name>cancel_query_count</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>cancel_query</name><index>[<expr><name><name>Ptxn</name><operator>-&gt;</operator><name>cancel_query_count</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> 
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>cancel_query</name><index>[<expr><name><name>Ptxn</name><operator>-&gt;</operator><name>cancel_query_count</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>cancel_query</name><index>[<expr><name><name>Ptxn</name><operator>-&gt;</operator><name>cancel_query_count</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"unknown"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            
			<expr_stmt><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>txn_count</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>nodename_count</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>cancel_query_count</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>DropPrinttxn</name><parameter_list>(<parameter><decl><type><name>PrintRollbackTxn</name> <modifier>*</modifier></type><name>Ptxn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>Ptxn</name><operator>-&gt;</operator><name>txn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>txn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>Ptxn</name><operator>-&gt;</operator><name>cancel_query_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>cancel_query</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>Ptxn</name><operator>-&gt;</operator><name>nodename_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>nodename</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>txn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>cancel_query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RFREE</name><argument_list>(<argument><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Ptxn</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>Ptxn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
 * GetGxid -- get global xid of certain pid on certain node
 * input: 	node oid, pid
 * return:	global xid
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>GetGxid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>temp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlots</name></type> <name>result</name></decl>;</decl_stmt>	
	<decl_stmt><decl><type><name>char</name></type> <name><name>query</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><literal type="string">"select pg_findgxid(%u)"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	<expr_stmt><expr><call><name>execute_on_single_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>slot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> 
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pg_unlock: could not obtain global transactionid from pid %u on node %s"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>res</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>TTSgetvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><literal type="number">20</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><literal type="number">20</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>DropTupleTableSlots</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * pg_findgxid -- get global xid of certain pid
 * input: 	pid
 * return:	global xid
 */</comment>
<function><type><name>Datum</name></type> <name>pg_findgxid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>	<name>pid</name> <init>= <expr><call><name>PG_GETARG_UINT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>globalXid</name> <init>= <expr><call><name>GetGlobalTransactionId</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>t_gxid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>globalXid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>t_gxid</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name>globalXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return	<expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>t_gxid</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
 * check_node_pid -- check whether certain pid on certain node exists
 * input: 	nodename, pid
 * return:	exist or not
 */</comment>
<function><type><name>int</name></type> <name>check_node_pid</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodename</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pgxc_transaction_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initiator</name></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><name>nodename</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>pgxc_transaction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pid_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name><name>pgxc_transaction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pid</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>res</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * KillTxn -- kill certain transaction
 * input: 	transaction index
 * return:	no
 */</comment>
<function><type><name>void</name></type> <name>KillTxn</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>txnid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlots</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>query</name><index>[<expr><literal type="number">500</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><name><name>pgxc_transaction</name><index>[<expr><name>txnid</name></expr>]</index></name><operator>.</operator><name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name><modifier>*</modifier></type> <name>pid</name> <init>= <expr><name><name>pgxc_transaction</name><index>[<expr><name>txnid</name></expr>]</index></name><operator>.</operator><name>pid</name></expr></init></decl>;</decl_stmt>
	
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pgxc_transaction</name><index>[<expr><name>txnid</name></expr>]</index></name><operator>.</operator><name>node_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>,<argument><expr><literal type="string">"select pg_cancel_backend(%u);"</literal></expr></argument>, <argument><expr><name><name>pid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>execute_on_single_node</name><argument_list>(<argument><expr><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DropTupleTableSlots</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * check_exist_gid -- check whether certain transaction exists
 * input: 	transaction global xid
 * return:	exist or not
 */</comment>
<function><type><name>bool</name></type> <name>check_exist_gid</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pgxc_transaction_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pgxc_transaction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gid</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>CountWaitTxn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pgxc_transaction_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>pgxc_transaction_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>pgxc_edge</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>pgxc_transaction</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>wait_txn</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
</block_content>}</block></function>
</unit>
