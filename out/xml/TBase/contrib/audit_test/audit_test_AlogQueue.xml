<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/contrib/audit_test/audit_test_AlogQueue.c"><comment type="block">/*
 * contrib/audit_test/audit_test.c
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_getopt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/atomics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TestAlogProducerCount</name></cpp:macro>  <cpp:value>1000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TestAlogQueueSize</name></cpp:macro> <cpp:value>1200</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TestAlogBuffSize</name></cpp:macro> <cpp:value>40960</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TestAlogFileSize</name></cpp:macro> <cpp:value>102400000</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Assert</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Assert</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Assert</name></cpp:macro> <cpp:value>assert</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>TestAuditLogQueue</name>
<block>{
	<decl_stmt><decl><type><name>pid_t</name></type>					<name>q_pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>						<name>q_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>					<name>q_lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type>			<name>q_head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type>			<name>q_tail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>					<name><name>q_area</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>AlogQueue</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>shared_queue_idx</name><index>[<expr><name>TestAlogProducerCount</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>AlogQueue</name> <modifier>*</modifier></type> <name><name>shared_queue</name> <index>[<expr><name>TestAlogProducerCount</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>AlogQueue</name> <modifier>*</modifier></type> <name>local_cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>alog_file_name</name> <init>= <expr><literal type="string">"test_alog.txt"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type> <name>alog_file_fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> 	<name>alog_queue_offset_to</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> 	<name>alog_queue_is_full</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> 	<name>alog_queue_is_empty</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> 	<name>alog_queue_is_enough</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> 		<name>alog_queue_remain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> 		<name>alog_queue_used</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> 	<name>alog_queue_push</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buff</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> 	<name>alog_queue_push2</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buff1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len1</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buff2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> 	<name>alog_queue_pushn</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name><name>buff</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name><name>len</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> 		<name>alog_queue_get_str_len</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> 	<name>alog_queue_clear_str_len</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> 	<name>alog_queue_pop_to_queue</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>to</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> 	<name>alog_queue_pop_to_file</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>logfile</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>		<name>alog_write_log_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>logfile</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> 		<name>alog_random_string</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><name>TestAlogBuffSize</name></expr>]</index></name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>test_alog</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>test_alog0</name><parameter_list>()</parameter_list>;</function_decl>


<comment type="block">/* --------------------------------
 *		AlogQueue routines
 * --------------------------------
 */</comment>

<comment type="block">/*
 * Get a write pointer in queue
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>alog_queue_offset_to</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>start</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>queue</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&lt;</operator> <name><name>queue</name><operator>-&gt;</operator><name>q_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>start</name> <operator>+=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>AlogQueue</name></expr></argument>, <argument><expr><name>q_area</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>start</name> <operator>+=</operator> <name>offset</name></expr>;</expr_stmt>

	<return>return <expr><name>start</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>alog_queue_is_full</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_head</name> <operator>&lt;</operator> <name>q_size</name> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>q_tail</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>q_size</name> <operator>==</operator> <name>q_head</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>alog_queue_is_empty</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_head</name> <operator>&lt;</operator> <name>q_size</name> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>q_tail</name> <operator>==</operator> <name>q_head</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * how many bytes already in used
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>alog_queue_used</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>used</name> <init>= <expr><operator>(</operator><name>q_tail</name> <operator>-</operator> <name>q_head</name> <operator>+</operator> <name>q_size</name><operator>)</operator> <operator>%</operator> <name>q_size</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_head</name> <operator>&lt;</operator> <name>q_size</name> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>used</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * how many bytes remain in Queue
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>alog_queue_remain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>remain</name> <init>= <expr><operator>(</operator><name>q_head</name> <operator>-</operator> <name>q_tail</name> <operator>+</operator> <name>q_size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>q_size</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_head</name> <operator>&lt;</operator> <name>q_size</name> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>remain</name> <operator>==</operator> <operator>(</operator><name>q_size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><operator>(</operator><name>q_tail</name> <operator>-</operator> <name>q_head</name> <operator>+</operator> <name>q_size</name><operator>)</operator> <operator>%</operator> <name>q_size</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>remain</name> <operator>==</operator> <operator>(</operator><name>q_size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>q_size</name></expr></argument>, <argument><expr><name>q_head</name></expr></argument>, <argument><expr><name>q_tail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>remain</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * whether queue has enough space for N bytes ?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>alog_queue_is_enough</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>remain</name> <init>= <expr><call><name>alog_queue_remain</name><argument_list>(<argument><expr><name>q_size</name></expr></argument>, <argument><expr><name>q_head</name></expr></argument>, <argument><expr><name>q_tail</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>N</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_head</name> <operator>&lt;</operator> <name>q_size</name> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>remain</name> <operator>&gt;</operator> <name>N</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * write buff to queue
 *
 * len = size(int) + strlen(str)
 *
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>alog_queue_push</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buff</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name><name>buff_array</name> <index>[]</index></name> <init>= <expr><block>{ <expr><name>buff</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name><name>len_array</name> <index>[]</index></name> <init>= <expr><block>{ <expr><name>len</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>alog_queue_pushn</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>buff_array</name></expr></argument>, <argument><expr><name>len_array</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len_array</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>len_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * write buff1 and buff2 to queue
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>alog_queue_push2</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buff1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len1</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buff2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name><name>buff_array</name><index>[]</index></name> <init>= <expr><block>{<expr><name>buff1</name></expr>, <expr><name>buff2</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name><name>len_array</name><index>[]</index></name> <init>= <expr><block>{<expr><name>len1</name></expr>, <expr><name>len2</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>alog_queue_pushn</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>buff_array</name></expr></argument>, <argument><expr><name>len_array</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len_array</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>len_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>alog_queue_pushn</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name><name>buff</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name><name>len</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_head</name> <init>= <expr><name><name>queue</name><operator>-&gt;</operator><name>q_head</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_tail</name> <init>= <expr><name><name>queue</name><operator>-&gt;</operator><name>q_tail</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_size</name> <init>= <expr><name><name>queue</name><operator>-&gt;</operator><name>q_size</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>q_head_before</name> <init>= <expr><name>q_head</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>q_tail_before</name> <init>= <expr><name>q_tail</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>q_size_before</name> <init>= <expr><name>q_size</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>q_used_before</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>q_used_after</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>total_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>total_len</name> <operator>+=</operator> <name><name>len</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_head</name> <operator>&lt;</operator> <name>q_size</name> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buff</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>total_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>q_used_before</name> <operator>=</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>q_size_before</name></expr></argument>, <argument><expr><name>q_head_before</name></expr></argument>, <argument><expr><name>q_tail_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>alog_queue_is_full</name><argument_list>(<argument><expr><name>q_size</name></expr></argument>, <argument><expr><name>q_head</name></expr></argument>, <argument><expr><name>q_tail</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>alog_queue_is_enough</name><argument_list>(<argument><expr><name>q_size</name></expr></argument>, <argument><expr><name>q_head</name></expr></argument>, <argument><expr><name>q_tail</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>curr_buff</name> <init>= <expr><name><name>buff</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>curr_len</name> <init>= <expr><name><name>len</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* has enough space, write directly */</comment>
		<if_stmt><if>if <condition>(<expr><name>q_size</name> <operator>-</operator> <name>q_tail</name> <operator>&gt;=</operator> <name>curr_len</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_start</name> <init>= <expr><call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>q_tail</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>curr_buff</name></expr></argument>, <argument><expr><name>curr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* must write as two parts */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>first_len</name> <init>= <expr><name>q_size</name> <operator>-</operator> <name>q_tail</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>second_len</name> <init>= <expr><name>curr_len</name> <operator>-</operator> <name>first_len</name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>first_buf</name> <init>= <expr><name>curr_buff</name> <operator>+</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>second_buf</name> <init>= <expr><name>curr_buff</name> <operator>+</operator> <name>first_len</name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>first_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>first_len</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>second_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>second_len</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* 01. write the first parts into the tail of queue-&gt;q_area */</comment>
			<expr_stmt><expr><name>p_start</name> <operator>=</operator> <call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>q_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>first_buf</name></expr></argument>, <argument><expr><name>first_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>q_tail</name> <operator>+</operator> <name>first_len</name><operator>)</operator> <operator>%</operator> <name>q_size</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* 02. write the remain parts into the head of queue-&gt;q_area */</comment>
			<expr_stmt><expr><name>p_start</name> <operator>=</operator> <call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>second_buf</name></expr></argument>, <argument><expr><name>second_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>q_tail</name> <operator>=</operator> <operator>(</operator><name>q_tail</name> <operator>+</operator> <name>curr_len</name><operator>)</operator> <operator>%</operator> <name>q_size</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>q_tail</name></name> <operator>=</operator> <name>q_tail</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>q_used_after</name> <operator>=</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>q_size</name></expr></argument>, <argument><expr><name>q_head</name></expr></argument>, <argument><expr><name>q_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_used_before</name> <operator>+</operator> <name>total_len</name> <operator>==</operator> <name>q_used_after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * |&lt;- strlen value -&gt;|&lt;- string message content -&gt;|
 * |											   |
 * |											   |
 * |&lt;------------------ buff ---------------------&gt;|
 *
 * len = size(int) + strlen(str)
 *
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>alog_queue_get_str_len</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_size</name> <init>= <expr><name><name>queue</name><operator>-&gt;</operator><name>q_size</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="char">'\0'</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* read len directly */</comment>
	<if_stmt><if>if <condition>(<expr><name>q_size</name> <operator>-</operator> <name>offset</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>q_start</name> <init>= <expr><call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>q_start</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* must read as two parts */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>first_len</name> <init>= <expr><name>q_size</name> <operator>-</operator> <name>offset</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>second_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>first_len</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>first_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>first_len</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>second_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>second_len</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* 01. copy the first parts */</comment>
		<expr_stmt><expr><name>p_start</name> <operator>=</operator> <call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>first_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* 02. copy the remain parts */</comment>
		<expr_stmt><expr><name>p_start</name> <operator>=</operator> <call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <name>first_len</name></expr></argument>, <argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>second_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>len</name><operator>)</operator></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>len</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>alog_queue_clear_str_len</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_size</name> <init>= <expr><name><name>queue</name><operator>-&gt;</operator><name>q_size</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="char">'\0'</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* read len directly */</comment>
	<if_stmt><if>if <condition>(<expr><name>q_size</name> <operator>-</operator> <name>offset</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>q_start</name> <init>= <expr><call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>q_start</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* must read as two parts */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>first_len</name> <init>= <expr><name>q_size</name> <operator>-</operator> <name>offset</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>second_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>first_len</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>first_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>first_len</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>second_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>second_len</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* 01. copy the first parts */</comment>
		<expr_stmt><expr><name>p_start</name> <operator>=</operator> <call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>first_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* 02. copy the remain parts */</comment>
		<expr_stmt><expr><name>p_start</name> <operator>=</operator> <call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>second_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * copy message from queue to another as much as possible
 *
 * |&lt;- strlen value -&gt;|&lt;- string message content -&gt;|
 * |											   |
 * |											   |
 * |&lt;------------------ buff ---------------------&gt;|
 *
 * len = size(int) + strlen(str)
 *
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>alog_queue_pop_to_queue</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_from_head</name> <init>= <expr><name><name>from</name><operator>-&gt;</operator><name>q_head</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_from_tail</name> <init>= <expr><name><name>from</name><operator>-&gt;</operator><name>q_tail</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_from_size</name> <init>= <expr><name><name>from</name><operator>-&gt;</operator><name>q_size</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_to_head</name> <init>= <expr><name><name>to</name><operator>-&gt;</operator><name>q_head</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_to_tail</name> <init>= <expr><name><name>to</name><operator>-&gt;</operator><name>q_tail</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_to_size</name> <init>= <expr><name><name>to</name><operator>-&gt;</operator><name>q_size</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>from_head</name> <init>= <expr><name>q_from_head</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>from_tail</name> <init>= <expr><name>q_from_tail</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>from_size</name> <init>= <expr><name>q_from_size</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>to_head</name> <init>= <expr><name>q_to_head</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>to_tail</name> <init>= <expr><name>q_to_tail</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>to_size</name> <init>= <expr><name>q_to_size</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>from_total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>from_used</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>from_copyed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>to_used</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>to_copyed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>from_total</name> <operator>=</operator> <name>from_used</name> <operator>=</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>to_used</name> <operator>=</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>to_size</name></expr></argument>, <argument><expr><name>to_head</name></expr></argument>, <argument><expr><name>to_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>from_head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>from_tail</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_head</name> <operator>&lt;</operator> <name>from_size</name> <operator>&amp;&amp;</operator> <name>from_tail</name> <operator>&lt;</operator> <name>from_size</name> <operator>&amp;&amp;</operator> <name>from_used</name> <operator>&lt;=</operator> <name>from_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>to_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>to_head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>to_tail</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>to_head</name> <operator>&lt;</operator> <name>to_size</name> <operator>&amp;&amp;</operator> <name>to_tail</name> <operator>&lt;</operator> <name>to_size</name> <operator>&amp;&amp;</operator> <name>to_used</name> <operator>&lt;=</operator> <name>to_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* from is empty, ignore */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>alog_queue_is_empty</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* to is full, can not write */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>alog_queue_is_full</name><argument_list>(<argument><expr><name>to_size</name></expr></argument>, <argument><expr><name>to_head</name></expr></argument>, <argument><expr><name>to_tail</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* copy message into queue until to is full or from is empty */</comment>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>string_len</name> <init>= <expr><call><name>alog_queue_get_str_len</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>copy_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>string_len</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>string_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>string_len</name> <operator>&lt;</operator> <name>from_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>copy_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>copy_len</name> <operator>&lt;</operator> <name>from_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>alog_queue_is_enough</name><argument_list>(<argument><expr><name>to_size</name></expr></argument>, <argument><expr><name>to_head</name></expr></argument>, <argument><expr><name>to_tail</name></expr></argument>, <argument><expr><name>copy_len</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* just copy dierctly */</comment>
		<if_stmt><if>if <condition>(<expr><name>from_size</name> <operator>-</operator> <name>from_head</name> <operator>&gt;=</operator> <name>copy_len</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_start</name> <init>= <expr><call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>alog_queue_push</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>copy_len</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* must copy as two parts */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>first_len</name> <init>= <expr><name>from_size</name> <operator>-</operator> <name>from_head</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>second_len</name> <init>= <expr><name>copy_len</name> <operator>-</operator> <name>first_len</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_first_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_second_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>first_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>first_len</name> <operator>&lt;</operator> <name>from_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>second_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>second_len</name> <operator>&lt;</operator> <name>from_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>p_first_start</name> <operator>=</operator> <call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p_second_start</name> <operator>=</operator> <call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* 01. copy the content parts into the tail of to-&gt;q_area */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>alog_queue_push2</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>p_first_start</name></expr></argument>, <argument><expr><name>first_len</name></expr></argument>, <argument><expr><name>p_second_start</name></expr></argument>, <argument><expr><name>second_len</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>from_head</name> <operator>=</operator> <operator>(</operator><name>from_head</name> <operator>+</operator> <name>copy_len</name><operator>)</operator> <operator>%</operator> <name>from_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>to_tail</name> <operator>=</operator> <operator>(</operator><name>to_tail</name> <operator>+</operator> <name>copy_len</name><operator>)</operator> <operator>%</operator> <name>to_size</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>from_copyed</name> <operator>+=</operator> <name>copy_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>to_copyed</name> <operator>+=</operator> <name>copy_len</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_copyed</name> <operator>&lt;=</operator> <name>from_total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_used</name> <operator>-</operator> <name>copy_len</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>to_used</name> <operator>+</operator> <name>copy_len</name> <operator>&lt;=</operator> <name>to_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_used</name> <operator>-</operator> <name>copy_len</name> <operator>==</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>to_used</name> <operator>+</operator> <name>copy_len</name> <operator>==</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>to_size</name></expr></argument>, <argument><expr><name>to_head</name></expr></argument>, <argument><expr><name>to_tail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>from_used</name> <operator>=</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>to_used</name> <operator>=</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>to_size</name></expr></argument>, <argument><expr><name>to_head</name></expr></argument>, <argument><expr><name>to_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>alog_queue_is_empty</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

	<expr_stmt><expr><name><name>from</name><operator>-&gt;</operator><name>q_head</name></name> <operator>=</operator> <name>from_head</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * copy message from queue to file as much as possible
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>alog_queue_pop_to_file</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>logfile</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_from_head</name> <init>= <expr><name><name>from</name><operator>-&gt;</operator><name>q_head</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_from_tail</name> <init>= <expr><name><name>from</name><operator>-&gt;</operator><name>q_tail</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_from_size</name> <init>= <expr><name><name>from</name><operator>-&gt;</operator><name>q_size</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>from_head</name> <init>= <expr><name>q_from_head</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>from_tail</name> <init>= <expr><name>q_from_tail</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>from_size</name> <init>= <expr><name>q_from_size</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>from_total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>from_used</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>from_copyed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>from_total</name> <operator>=</operator> <name>from_used</name> <operator>=</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>from_head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>from_tail</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_head</name> <operator>&lt;</operator> <name>from_size</name> <operator>&amp;&amp;</operator> <name>from_tail</name> <operator>&lt;</operator> <name>from_size</name> <operator>&amp;&amp;</operator> <name>from_used</name> <operator>&lt;=</operator> <name>from_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* from is empty, ignore */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>alog_queue_is_empty</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* copy message into file until from is empty */</comment>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>string_len</name> <init>= <expr><call><name>alog_queue_get_str_len</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>copy_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>string_len</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* just copy dierctly */</comment>
		<if_stmt><if>if <condition>(<expr><name>from_size</name> <operator>-</operator> <name>from_head</name> <operator>&gt;=</operator> <name>copy_len</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_start</name> <init>= <expr><call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>from_head</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* only copy message content, not write message len */</comment>
			<expr_stmt><expr><call><name>alog_write_log_file</name><argument_list>(<argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>string_len</name></expr></argument>, <argument><expr><name>logfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>from_size</name> <operator>-</operator> <name>from_head</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* must copy as two parts */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>first_len</name> <init>= <expr><name>from_size</name> <operator>-</operator> <name>from_head</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>second_len</name> <init>= <expr><name>string_len</name> <operator>-</operator> <name>first_len</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>first_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>first_len</name> <operator>&lt;</operator> <name>from_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>second_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>second_len</name> <operator>&lt;</operator> <name>from_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>p_start</name> <operator>=</operator> <call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>from_head</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>alog_write_log_file</name><argument_list>(<argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>first_len</name></expr></argument>, <argument><expr><name>logfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>p_start</name> <operator>=</operator> <call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>alog_write_log_file</name><argument_list>(<argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>second_len</name></expr></argument>, <argument><expr><name>logfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* just copy content only */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>cpy_offset</name> <init>= <expr><operator>(</operator><name>from_head</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>%</operator> <name>from_size</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_start</name> <init>= <expr><call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>cpy_offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_size</name> <operator>-</operator> <name>from_head</name> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>alog_write_log_file</name><argument_list>(<argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>string_len</name></expr></argument>, <argument><expr><name>logfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>from_head</name> <operator>=</operator> <operator>(</operator><name>from_head</name> <operator>+</operator> <name>copy_len</name><operator>)</operator> <operator>%</operator> <name>from_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>from_copyed</name> <operator>+=</operator> <name>copy_len</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_copyed</name> <operator>&lt;=</operator> <name>from_total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_used</name> <operator>-</operator> <name>copy_len</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_used</name> <operator>-</operator> <name>copy_len</name> <operator>==</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>from_used</name> <operator>=</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>alog_queue_is_empty</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

	<expr_stmt><expr><name><name>from</name><operator>-&gt;</operator><name>q_head</name></name> <operator>=</operator> <name>from_head</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>alog_write_log_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>logfile</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>	<name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>logfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* can't use ereport here because of possible recursion */</comment>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>count</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"could not write to audit log file: %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlogQueue</name> <modifier>*</modifier></type>
<name>alog_make_queue</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size_kb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>alogSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>alogSize</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>AlogQueue</name></expr></argument>, <argument><expr><name>q_area</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>alogSize</name> <operator>=</operator> <name>alogSize</name> <operator>+</operator> <name>q_size_kb</name> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>queue</name> <operator>=</operator> <operator>(</operator><name>AlogQueue</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>alogSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>queue</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>alogSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>q_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>q_size</name></name> <operator>=</operator> <name>q_size_kb</name> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>q_lock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>q_head</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>q_tail</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>queue</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type>
<name>alog_open_log_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fh</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mode_t</name></type>		<name>oumask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>oumask</name> <operator>=</operator> <call><name>umask</name><argument_list>(<argument><expr><operator>(</operator><name>mode_t</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>~</operator><operator>(</operator><name>S_IWUSR</name> <operator>|</operator> <name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>S_IRWXU</name> <operator>|</operator> <name>S_IRWXG</name> <operator>|</operator> <name>S_IRWXO</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>oumask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fh</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PG_IOLBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>fh</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>alog_random_string</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><name>TestAlogBuffSize</name></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name><name>letter</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="char">'a'</literal></expr>, <expr><literal type="char">'b'</literal></expr>, <expr><literal type="char">'c'</literal></expr>, <expr><literal type="char">'d'</literal></expr>, <expr><literal type="char">'e'</literal></expr>, <expr><literal type="char">'f'</literal></expr>, <expr><literal type="char">'g'</literal></expr>, <expr><literal type="char">'h'</literal></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'j'</literal></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'l'</literal></expr>, <expr><literal type="char">'m'</literal></expr>, <expr><literal type="char">'n'</literal></expr>,
					  <expr><literal type="char">'o'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><literal type="char">'q'</literal></expr>, <expr><literal type="char">'r'</literal></expr>, <expr><literal type="char">'s'</literal></expr>, <expr><literal type="char">'t'</literal></expr>, <expr><literal type="char">'u'</literal></expr>, <expr><literal type="char">'v'</literal></expr>, <expr><literal type="char">'w'</literal></expr>, <expr><literal type="char">'x'</literal></expr>, <expr><literal type="char">'y'</literal></expr>, <expr><literal type="char">'z'</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <name>TestAlogBuffSize</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>buff</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><name>TestAlogBuffSize</name><operator>/</operator><literal type="number">10</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>*=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>TestAlogBuffSize</name> <operator>-</operator> <literal type="number">10</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>len</name>  <operator>=</operator> <name>TestAlogBuffSize</name> <operator>-</operator> <literal type="number">10</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// len = 100;</comment>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>len</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>i</name> <operator>%</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>letter</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>buff</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name><name>letter</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>buff</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>

	<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type> <name>alog_producer</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>para</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type> <name>idx</name> <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>para</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><name>TestAlogBuffSize</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="char">'0'</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>srand</name><argument_list>(<argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>alog_random_string</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name> <init>= <expr><name><name>shared_queue</name> <index>[<expr><operator>*</operator><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><operator>!</operator><call><name>alog_queue_push</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><literal type="number">10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></while>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type> <name>alog_consumer</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>para</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TestAlogProducerCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>alog_queue_pop_to_queue</name><argument_list>(<argument><expr><name><name>shared_queue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>local_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>ftell</name><argument_list>(<argument><expr><name>alog_file_fp</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>TestAlogFileSize</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fh</name> <init>= <expr><call><name>alog_open_log_file</name><argument_list>(<argument><expr><name>alog_file_name</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>alog_file_fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>alog_file_fp</name> <operator>=</operator> <name>fh</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>alog_queue_pop_to_file</name><argument_list>(<argument><expr><name><name>shared_queue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>alog_file_fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></while>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type> <name>alog_writer</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>para</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>file</name> <init>= <expr><name>alog_file_fp</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>ftell</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>TestAlogFileSize</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fh</name> <init>= <expr><call><name>alog_open_log_file</name><argument_list>(<argument><expr><name>alog_file_name</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>file</name> <operator>=</operator> <name>fh</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>alog_queue_pop_to_file</name><argument_list>(<argument><expr><name>local_cache</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<enum>enum <name>MT_thr_detach</name>
<block>{
	<decl><name>MT_THR_JOINABLE</name></decl>,
	<decl><name>MT_THR_DETACHED</name></decl>
}</block>;</enum>

<function><type><specifier>static</specifier> <name>int32</name></type> <name>CreateThread</name><parameter_list>(<parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>f</name>) <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <decl_stmt><decl><type><name>pthread_attr_t</name></type> <name>attr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pthread_t</name></type>      <name>threadid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pthread_attr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>mode</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>MT_THR_JOINABLE</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pthread_attr_setdetachstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>PTHREAD_CREATE_JOINABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>MT_THR_DETACHED</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pthread_attr_setdetachstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>PTHREAD_CREATE_DETACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <default>default:</default>
			<break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>threadid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>test_alog</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>queue_size_kb</name> <init>= <expr><name>TestAlogQueueSize</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TestAlogProducerCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>shared_queue</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>alog_make_queue</name><argument_list>(<argument><expr><name>queue_size_kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared_queue_idx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>local_cache</name> <operator>=</operator> <call><name>alog_make_queue</name><argument_list>(<argument><expr><name>queue_size_kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>alog_file_fp</name> <operator>=</operator> <call><name>alog_open_log_file</name><argument_list>(<argument><expr><name>alog_file_name</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CreateThread</name><argument_list>(<argument><expr><name>alog_writer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> ,<argument><expr><name>MT_THR_DETACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TestAlogProducerCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CreateThread</name><argument_list>(<argument><expr><name>alog_producer</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><operator>(</operator><name><name>shared_queue_idx</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>)</operator></expr></argument>, <argument><expr><name>MT_THR_DETACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>alog_consumer</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>test_alog0</name><parameter_list>()</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>int</name></type> <name>queue_size_kb</name> <init>= <expr><name>TestAlogQueueSize</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>q0</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>q1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><name>TestAlogBuffSize</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="char">'0'</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>srand</name><argument_list>(<argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>q0</name> <operator>=</operator> <call><name>alog_make_queue</name><argument_list>(<argument><expr><name>queue_size_kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q1</name> <operator>=</operator> <call><name>alog_make_queue</name><argument_list>(<argument><expr><name>queue_size_kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>alog_random_string</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><call><name>alog_queue_push</name><argument_list>(<argument><expr><name>q0</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

	<expr_stmt><expr><call><name>alog_queue_pop_to_queue</name><argument_list>(<argument><expr><name>q0</name></expr></argument>, <argument><expr><name>q1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>file</name> <init>= <expr><call><name>alog_open_log_file</name><argument_list>(<argument><expr><name>alog_file_name</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>alog_queue_pop_to_file</name><argument_list>(<argument><expr><name>q1</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while<condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

</unit>
