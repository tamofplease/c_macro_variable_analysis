<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/contrib/pgcrypto/imath.c"><comment type="block">/* imath version 1.3 */</comment>
<comment type="block">/*
  Name:        imath.c
  Purpose:    Arbitrary precision integer arithmetic routines.
  Author:    M. J. Fromberger &lt;http://spinning-yarns.org/michael/sw/&gt;
  Info:        Id: imath.c 21 2006-04-02 18:58:36Z sting

  Copyright (C) 2002 Michael J. Fromberger, All Rights Reserved.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 */</comment>
<comment type="block">/* contrib/pgcrypto/imath.c */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"imath.h"</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>assert</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>assert</name><parameter_list>(<parameter><type><name>TEST</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Assert(TEST)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRACEABLE_CLAMP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRACEABLE_FREE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<comment type="block">/* {{{ Constants */</comment>

<decl_stmt><decl><type><specifier>const</specifier> <name>mp_result</name></type> <name>MP_OK</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* no error, all is well  */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>mp_result</name></type> <name>MP_FALSE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* boolean false          */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>mp_result</name></type> <name>MP_TRUE</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* boolean true              */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>mp_result</name></type> <name>MP_MEMORY</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* out of memory          */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>mp_result</name></type> <name>MP_RANGE</name> <init>= <expr><operator>-</operator><literal type="number">3</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* argument out of range  */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>mp_result</name></type> <name>MP_UNDEF</name> <init>= <expr><operator>-</operator><literal type="number">4</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* result undefined          */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>mp_result</name></type> <name>MP_TRUNC</name> <init>= <expr><operator>-</operator><literal type="number">5</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* output truncated          */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>mp_result</name></type> <name>MP_BADARG</name> <init>= <expr><operator>-</operator><literal type="number">6</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* invalid null argument  */</comment>

<decl_stmt><decl><type><specifier>const</specifier> <name>mp_sign</name></type> <name>MP_NEG</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* value is strictly negative */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>mp_sign</name></type> <name>MP_ZPOS</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* value is non-negative      */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s_unknown_err</name> <init>= <expr><literal type="string">"unknown result code"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>s_error_msg</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="string">"error code 0"</literal></expr>,
    <expr><literal type="string">"boolean true"</literal></expr>,
    <expr><literal type="string">"out of memory"</literal></expr>,
    <expr><literal type="string">"argument out of range"</literal></expr>,
    <expr><literal type="string">"result undefined"</literal></expr>,
    <expr><literal type="string">"output truncated"</literal></expr>,
    <expr><literal type="string">"invalid null argument"</literal></expr>,
    <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* }}} */</comment>

<comment type="block">/* Optional library flags */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MP_CAP_DIGITS</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>        <comment type="block">/* flag bit to capitalize letter digits */</comment>

<comment type="block">/* Argument checking macros
   Use CHECK() where a return value is required; NRCHECK() elsewhere */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK</name><parameter_list>(<parameter><type><name>TEST</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>assert(TEST)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NRCHECK</name><parameter_list>(<parameter><type><name>TEST</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>assert(TEST)</cpp:value></cpp:define>

<comment type="block">/* {{{ Logarithm table for computing output sizes */</comment>

<comment type="block">/* The ith entry of this table gives the value of log_i(2).

   An integer value n requires ceil(log_i(n)) digits to be represented
   in base i.  Since it is easy to compute lg(n), by counting bits, we
   can compute log_i(n) = lg(n) * log_i(2).
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>double</name></type> <name><name>s_log2</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="number">0.000000000</literal></expr>, <expr><literal type="number">0.000000000</literal></expr>, <expr><literal type="number">1.000000000</literal></expr>, <expr><literal type="number">0.630929754</literal></expr>, <comment type="block">/* 0  1  2    3 */</comment>
    <expr><literal type="number">0.500000000</literal></expr>, <expr><literal type="number">0.430676558</literal></expr>, <expr><literal type="number">0.386852807</literal></expr>, <expr><literal type="number">0.356207187</literal></expr>, <comment type="block">/* 4  5  6    7 */</comment>
    <expr><literal type="number">0.333333333</literal></expr>, <expr><literal type="number">0.315464877</literal></expr>, <expr><literal type="number">0.301029996</literal></expr>, <expr><literal type="number">0.289064826</literal></expr>, <comment type="block">/* 8  9 10 11 */</comment>
    <expr><literal type="number">0.278942946</literal></expr>, <expr><literal type="number">0.270238154</literal></expr>, <expr><literal type="number">0.262649535</literal></expr>, <expr><literal type="number">0.255958025</literal></expr>, <comment type="block">/* 12 13 14 15 */</comment>
    <expr><literal type="number">0.250000000</literal></expr>, <expr><literal type="number">0.244650542</literal></expr>, <expr><literal type="number">0.239812467</literal></expr>, <expr><literal type="number">0.235408913</literal></expr>, <comment type="block">/* 16 17 18 19 */</comment>
    <expr><literal type="number">0.231378213</literal></expr>, <expr><literal type="number">0.227670249</literal></expr>, <expr><literal type="number">0.224243824</literal></expr>, <expr><literal type="number">0.221064729</literal></expr>, <comment type="block">/* 20 21 22 23 */</comment>
    <expr><literal type="number">0.218104292</literal></expr>, <expr><literal type="number">0.215338279</literal></expr>, <expr><literal type="number">0.212746054</literal></expr>, <expr><literal type="number">0.210309918</literal></expr>, <comment type="block">/* 24 25 26 27 */</comment>
    <expr><literal type="number">0.208014598</literal></expr>, <expr><literal type="number">0.205846832</literal></expr>, <expr><literal type="number">0.203795047</literal></expr>, <expr><literal type="number">0.201849087</literal></expr>, <comment type="block">/* 28 29 30 31 */</comment>
    <expr><literal type="number">0.200000000</literal></expr>, <expr><literal type="number">0.198239863</literal></expr>, <expr><literal type="number">0.196561632</literal></expr>, <expr><literal type="number">0.194959022</literal></expr>, <comment type="block">/* 32 33 34 35 */</comment>
    <expr><literal type="number">0.193426404</literal></expr>, <expr><literal type="number">0.191958720</literal></expr>, <expr><literal type="number">0.190551412</literal></expr>, <expr><literal type="number">0.189200360</literal></expr>, <comment type="block">/* 36 37 38 39 */</comment>
    <expr><literal type="number">0.187901825</literal></expr>, <expr><literal type="number">0.186652411</literal></expr>, <expr><literal type="number">0.185449023</literal></expr>, <expr><literal type="number">0.184288833</literal></expr>, <comment type="block">/* 40 41 42 43 */</comment>
    <expr><literal type="number">0.183169251</literal></expr>, <expr><literal type="number">0.182087900</literal></expr>, <expr><literal type="number">0.181042597</literal></expr>, <expr><literal type="number">0.180031327</literal></expr>, <comment type="block">/* 44 45 46 47 */</comment>
    <expr><literal type="number">0.179052232</literal></expr>, <expr><literal type="number">0.178103594</literal></expr>, <expr><literal type="number">0.177183820</literal></expr>, <expr><literal type="number">0.176291434</literal></expr>, <comment type="block">/* 48 49 50 51 */</comment>
    <expr><literal type="number">0.175425064</literal></expr>, <expr><literal type="number">0.174583430</literal></expr>, <expr><literal type="number">0.173765343</literal></expr>, <expr><literal type="number">0.172969690</literal></expr>, <comment type="block">/* 52 53 54 55 */</comment>
    <expr><literal type="number">0.172195434</literal></expr>, <expr><literal type="number">0.171441601</literal></expr>, <expr><literal type="number">0.170707280</literal></expr>, <expr><literal type="number">0.169991616</literal></expr>, <comment type="block">/* 56 57 58 59 */</comment>
    <expr><literal type="number">0.169293808</literal></expr>, <expr><literal type="number">0.168613099</literal></expr>, <expr><literal type="number">0.167948779</literal></expr>, <expr><literal type="number">0.167300179</literal></expr>, <comment type="block">/* 60 61 62 63 */</comment>
    <expr><literal type="number">0.166666667</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* }}} */</comment>
<comment type="block">/* {{{ Various macros */</comment>

<comment type="block">/* Return the number of digits needed to represent a static value */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MP_VALUE_DIGITS</name><parameter_list>(<parameter><type><name>V</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>((sizeof(V)+(sizeof(mp_digit)-1))/sizeof(mp_digit))</cpp:value></cpp:define>

<comment type="block">/* Round precision P to nearest word boundary */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROUND_PREC</name><parameter_list>(<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((mp_size)(2*(((P)+1)/2)))</cpp:value></cpp:define>

<comment type="block">/* Set array P of S digits to zero */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZERO</name><parameter_list>(<parameter><type><name>P</name></type></parameter>, <parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do{mp_size i__=(S)*sizeof(mp_digit);mp_digit *p__=(P);memset(p__,0,i__);}while(0)</cpp:value></cpp:define>

<comment type="block">/* Copy S digits from array P to array Q */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPY</name><parameter_list>(<parameter><type><name>P</name></type></parameter>, <parameter><type><name>Q</name></type></parameter>, <parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do{mp_size i__=(S)*sizeof(mp_digit);mp_digit *p__=(P),*q__=(Q);\
memcpy(q__,p__,i__);}while(0)</cpp:value></cpp:define>

<comment type="block">/* Reverse N elements of type T in array A */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REV</name><parameter_list>(<parameter><type><name>T</name></type></parameter>, <parameter><type><name>A</name></type></parameter>, <parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do{T *u_=(A),*v_=u_+(N)-1;while(u_&lt;v_){T xch=*u_;*u_++=*v_;*v_--=xch;}}while(0)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TRACEABLE_CLAMP</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLAMP</name><parameter_list>(<parameter><type><name>Z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>s_clamp(Z)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLAMP</name><parameter_list>(<parameter><type><name>Z</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do{mp_int z_=(Z);mp_size uz_=MP_USED(z_);mp_digit *dz_=MP_DIGITS(z_)+uz_-1;\
while(uz_ &gt; 1 &amp;&amp; (*dz_-- == 0)) --uz_;MP_USED(z_)=uz_;}while(0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MIN</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MAX</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<parameter><type><name>A</name></type></parameter>, <parameter><type><name>B</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((B)&lt;(A)?(B):(A))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX</name><parameter_list>(<parameter><type><name>A</name></type></parameter>, <parameter><type><name>B</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((B)&gt;(A)?(B):(A))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWAP</name><parameter_list>(<parameter><type><name>T</name></type></parameter>, <parameter><type><name>A</name></type></parameter>, <parameter><type><name>B</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do{T t_=(A);A=(B);B=t_;}while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEMP</name><parameter_list>(<parameter><type><name>K</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(temp + (K))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETUP</name><parameter_list>(<parameter><type><name>E</name></type></parameter>, <parameter><type><name>C</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do{if((res = (E)) != MP_OK) goto CLEANUP; ++(C);}while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMPZ</name><parameter_list>(<parameter><type><name>Z</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>(((Z)-&gt;used==1&amp;&amp;(Z)-&gt;digits[0]==0)?0:((Z)-&gt;sign==MP_NEG)?-1:1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UMUL</name><parameter_list>(<parameter><type><name>X</name></type></parameter>, <parameter><type><name>Y</name></type></parameter>, <parameter><type><name>Z</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do{mp_size ua_=MP_USED(X),ub_=MP_USED(Y);mp_size o_=ua_+ub_;\
ZERO(MP_DIGITS(Z),o_);\
(void) s_kmul(MP_DIGITS(X),MP_DIGITS(Y),MP_DIGITS(Z),ua_,ub_);\
MP_USED(Z)=o_;CLAMP(Z);}while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USQR</name><parameter_list>(<parameter><type><name>X</name></type></parameter>, <parameter><type><name>Z</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do{mp_size ua_=MP_USED(X),o_=ua_+ua_;ZERO(MP_DIGITS(Z),o_);\
(void) s_ksqr(MP_DIGITS(X),MP_DIGITS(Z),ua_);MP_USED(Z)=o_;CLAMP(Z);}while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPPER_HALF</name><parameter_list>(<parameter><type><name>W</name></type></parameter>)</parameter_list></cpp:macro>            <cpp:value>((mp_word)((W) &gt;&gt; MP_DIGIT_BIT))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOWER_HALF</name><parameter_list>(<parameter><type><name>W</name></type></parameter>)</parameter_list></cpp:macro>            <cpp:value>((mp_digit)(W))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HIGH_BIT_SET</name><parameter_list>(<parameter><type><name>W</name></type></parameter>)</parameter_list></cpp:macro>            <cpp:value>((W) &gt;&gt; (MP_WORD_BIT - 1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_WILL_OVERFLOW</name><parameter_list>(<parameter><type><name>W</name></type></parameter>, <parameter><type><name>V</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((MP_WORD_MAX - (V)) &lt; (W))</cpp:value></cpp:define>

<comment type="block">/* }}} */</comment>

<comment type="block">/* Default number of digits allocated to a new mp_int */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>mp_size</name></type> <name>default_precision</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Minimum number of digits to invoke recursive multiply */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>mp_size</name></type> <name>multiply_threshold</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Default library configuration flags */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>mp_word</name></type> <name>mp_flags</name> <init>= <expr><name>MP_CAP_DIGITS</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Allocate a buffer of (at least) num digits, or return
   NULL if that couldn't be done.  */</comment>
<function_decl><type><specifier>static</specifier> <name>mp_digit</name> <modifier>*</modifier></type><name>s_alloc</name><parameter_list>(<parameter><decl><type><name>mp_size</name></type> <name>num</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TRACEABLE_FREE</name></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>s_free</name><parameter_list>(<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>px_free(P)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Insure that z has at least min digits allocated, resizing if
   necessary.  Returns true if successful, false if out of memory. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>s_pad</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>min</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Normalize by removing leading zeroes (except when z = 0) */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TRACEABLE_CLAMP</name></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_clamp</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Fill in a "fake" mp_int on the stack with a given value */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_fake</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name><name>vbuf</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Compare two runs of digits of given length, returns &lt;0, 0, &gt;0 */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>s_cdig</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Pack the unsigned digits of v into array t */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>s_vpack</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name><name>t</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Compare magnitudes of a and b, returns &lt;0, 0, &gt;0 */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>s_ucmp</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Compare magnitudes of a and v, returns &lt;0, 0, &gt;0 */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>s_vcmp</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Unsigned magnitude addition; assumes dc is big enough.
   Carry out is returned (no memory allocated). */</comment>
<function_decl><type><specifier>static</specifier> <name>mp_digit</name></type> <name>s_uadd</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>,
       <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Unsigned magnitude subtraction.  Assumes dc is big enough. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_usub</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>,
       <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Unsigned recursive multiplication.  Assumes dc is big enough. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>s_kmul</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>,
       <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Unsigned magnitude multiplication.  Assumes dc is big enough. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_umul</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>,
       <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Unsigned recursive squaring.  Assumes dc is big enough. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>s_ksqr</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Unsigned magnitude squaring.  Assumes dc is big enough. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_usqr</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Single digit addition.  Assumes a is big enough. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_dadd</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Single digit multiplication.  Assumes a is big enough. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_dmul</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Single digit multiplication on buffers; assumes dc is big enough. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_dbmul</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>,
        <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Single digit division.  Replaces a with the quotient,
   returns the remainder.  */</comment>
<function_decl><type><specifier>static</specifier> <name>mp_digit</name></type> <name>s_ddiv</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Quick division by a power of 2, replaces z (no allocation) */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_qdiv</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>p2</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Quick remainder by a power of 2, replaces z (no allocation) */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_qmod</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>p2</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Quick multiplication by a power of 2, replaces z.
   Allocates if necessary; returns false in case this fails. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>s_qmul</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>p2</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Quick subtraction from a power of 2, replaces z.
   Allocates if necessary; returns false in case this fails. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>s_qsub</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>p2</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Return maximum k such that 2^k divides z. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>s_dp2k</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Return k &gt;= 0 such that z = 2^k, or -1 if there is no such k. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>s_isp2</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Set z to 2^k.  May allocate; returns false in case this fails. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>s_2expt</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Normalize a and b for division, returns normalization constant */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>s_norm</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Compute constant mu for Barrett reduction, given modulus m, result
   replaces z, m is untouched. */</comment>
<function_decl><type><specifier>static</specifier> <name>mp_result</name></type> <name>s_brmu</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Reduce a modulo m, using Barrett's algorithm. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>s_reduce</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>mu</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>q1</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>q2</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Modular exponentiation, using Barrett reduction */</comment>
<function_decl><type><specifier>static</specifier> <name>mp_result</name></type> <name>s_embar</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>mu</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Unsigned magnitude division.  Assumes |a| &gt; |b|.  Allocates
   temporaries; overwrites a with quotient, b with remainder. */</comment>
<function_decl><type><specifier>static</specifier> <name>mp_result</name></type> <name>s_udiv</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Compute the number of digits in radix r required to represent the
   given value.  Does not account for sign flags, terminators, etc. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>s_outlen</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>r</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Guess how many digits of precision will be needed to represent a
   radix r value of the specified number of digits.  Returns a value
   guaranteed to be no smaller than the actual number required. */</comment>
<function_decl><type><specifier>static</specifier> <name>mp_size</name></type> <name>s_inlen</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>r</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Convert a character to a digit value in radix r, or
   -1 if out of range */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>s_ch2val</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Convert a digit value to a character */</comment>
<function_decl><type><specifier>static</specifier> <name>char</name></type> <name>s_val2ch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>caps</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Take 2's complement of a buffer in place */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_2comp</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Convert a value to binary, ignoring sign.  On input, *limpos is the
   bound on how many bytes should be written to buf; on output, *limpos
   is set to the number of bytes actually written. */</comment>
<function_decl><type><specifier>static</specifier> <name>mp_result</name></type> <name>s_tobin</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>limpos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pad</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/* Dump a representation of the mp_int to standard output */</comment>
void        s_print(char *tag, mp_int z);
void        s_print_buf(char *tag, mp_digit *buf, mp_size num);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* {{{ get_default_precision() */</comment>

<function><type><name>mp_size</name></type>
<name>mp_get_default_precision</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>default_precision</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_set_default_precision(s) */</comment>

<function><type><name>void</name></type>
<name>mp_set_default_precision</name><parameter_list>(<parameter><decl><type><name>mp_size</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>NRCHECK</name><argument_list>(<argument><expr><name>s</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>default_precision</name> <operator>=</operator> <operator>(</operator><name>mp_size</name><operator>)</operator> <call><name>ROUND_PREC</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_get_multiply_threshold() */</comment>

<function><type><name>mp_size</name></type>
<name>mp_get_multiply_threshold</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>multiply_threshold</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_set_multiply_threshold(s) */</comment>

<function><type><name>void</name></type>
<name>mp_set_multiply_threshold</name><parameter_list>(<parameter><decl><type><name>mp_size</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>multiply_threshold</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_init(z) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_init</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>mp_int_init_size</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>default_precision</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_alloc() */</comment>

<function><type><name>mp_int</name></type>
<name>mp_int_alloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_int</name></type>        <name>out</name> <init>= <expr><call><name>px_alloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mpz_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>out</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_init_size(z, prec) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_init_size</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>prec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>prec</name> <operator>=</operator> <operator>(</operator><name>mp_size</name><operator>)</operator> <call><name>ROUND_PREC</name><argument_list>(<argument><expr><name>prec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>prec</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>prec</name></expr></argument>, <argument><expr><name>default_precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>s_alloc</name><argument_list>(<argument><expr><name>prec</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MP_ALLOC</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>prec</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>

    <return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_init_copy(z, old) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_init_copy</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>old</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>uold</name></decl>,
                <decl><type ref="prev"/><name>target</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>old</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>uold</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>uold</name></expr></argument>, <argument><expr><name>default_precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_init_size</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>uold</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>COPY</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>uold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_init_value(z, value) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_init_value</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_init</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>mp_int_set_value</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_set_value(z, value) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_set_value</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>ndig</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* How many digits to copy */</comment>
    <expr_stmt><expr><name>ndig</name> <operator>=</operator> <operator>(</operator><name>mp_size</name><operator>)</operator> <call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>ndig</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>mp_size</name><operator>)</operator> <call><name>s_vpack</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>MP_NEG</name></expr> </then><else>: <expr><name>MP_ZPOS</name></expr></else></ternary></expr>;</expr_stmt>

    <return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_clear(z) */</comment>

<function><type><name>void</name></type>
<name>mp_int_clear</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>z</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>s_free</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_free(z) */</comment>

<function><type><name>void</name></type>
<name>mp_int_free</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>NRCHECK</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>z</name><operator>-&gt;</operator><name>digits</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>px_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_copy(a, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_copy</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>!=</operator> <name>c</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>mp_size</name></type>        <name>ua</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>da</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>dc</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ua</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>da</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dc</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>COPY</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>, <argument><expr><name>ua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>ua</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_swap(a, c) */</comment>

<function><type><name>void</name></type>
<name>mp_int_swap</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>!=</operator> <name>c</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>mpz_t</name></type>        <name>tmp</name> <init>= <expr><operator>*</operator><name>a</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><operator>*</operator><name>a</name> <operator>=</operator> <operator>*</operator><name>c</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>c</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_zero(z) */</comment>

<function><type><name>void</name></type>
<name>mp_int_zero</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>NRCHECK</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_abs(a, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_abs</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
    <return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_neg(a, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_neg</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">1</literal> <operator>-</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_add(a, b, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_add</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>ua</name></decl>,
                <decl><type ref="prev"/><name>ub</name></decl>,
                <decl><type ref="prev"/><name>uc</name></decl>,
                <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ua</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ub</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>uc</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>ua</name></expr></argument>, <argument><expr><name>ub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Same sign -- add magnitudes, preserve sign of addends */</comment>
        <decl_stmt><decl><type><name>mp_digit</name></type>    <name>carry</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>carry</name> <operator>=</operator> <call><name>s_uadd</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ua</name></expr></argument>, <argument><expr><name>ub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>uc</name> <operator>=</operator> <name>max</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>carry</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>max</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>max</name></expr>]</index></name> <operator>=</operator> <name>carry</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>++</operator><name>uc</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>uc</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Different signs -- subtract magnitudes, preserve sign of greater */</comment>
        <decl_stmt><decl><type><name>mp_int</name></type>        <name>x</name></decl>,
                    <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>cmp</name> <init>= <expr><call><name>s_ucmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* magnitude comparison, sign ignored */</comment>

        <comment type="block">/* Set x to max(a, b), y to min(a, b) to simplify later code */</comment>
        <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>y</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>y</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* Subtract smaller from larger */</comment>
        <expr_stmt><expr><call><name>s_usub</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Give result the sign of the larger */</comment>
        <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_add_value(a, value, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_add_value</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mpz_t</name></type>        <name>vtmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name></type>    <name><name>vbuf</name><index>[<expr><call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>s_fake</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>mp_int_add</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_sub(a, b, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_sub</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>ua</name></decl>,
                <decl><type ref="prev"/><name>ub</name></decl>,
                <decl><type ref="prev"/><name>uc</name></decl>,
                <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ua</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ub</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>uc</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>ua</name></expr></argument>, <argument><expr><name>ub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Different signs -- add magnitudes and keep sign of a */</comment>
        <decl_stmt><decl><type><name>mp_digit</name></type>    <name>carry</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>carry</name> <operator>=</operator> <call><name>s_uadd</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ua</name></expr></argument>, <argument><expr><name>ub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>uc</name> <operator>=</operator> <name>max</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>carry</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>max</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>max</name></expr>]</index></name> <operator>=</operator> <name>carry</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>++</operator><name>uc</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>uc</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Same signs -- subtract magnitudes */</comment>
        <decl_stmt><decl><type><name>mp_int</name></type>        <name>x</name></decl>,
                    <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>mp_sign</name></type>        <name>osign</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>cmp</name> <init>= <expr><call><name>s_ucmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>y</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>osign</name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>y</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>osign</name> <operator>=</operator> <name>MP_NEG</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_NEG</name> <operator>&amp;&amp;</operator> <name>cmp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>osign</name> <operator>=</operator> <literal type="number">1</literal> <operator>-</operator> <name>osign</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>s_usub</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>osign</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_sub_value(a, value, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_sub_value</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mpz_t</name></type>        <name>vtmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name></type>    <name><name>vbuf</name><index>[<expr><call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>s_fake</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>mp_int_sub</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_mul(a, b, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_mul</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>osize</name></decl>,
                <decl><type ref="prev"/><name>ua</name></decl>,
                <decl><type ref="prev"/><name>ub</name></decl>,
                <decl><type ref="prev"/><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_sign</name></type>        <name>osign</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If either input is zero, we can shortcut multiplication */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>mp_int_compare_zero</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>mp_int_compare_zero</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>MP_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Output is positive if inputs have same sign, otherwise negative */</comment>
    <expr_stmt><expr><name>osign</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>MP_ZPOS</name></expr> </then><else>: <expr><name>MP_NEG</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/*
     * If the output is not equal to any of the inputs, we'll write the
     * results there directly; otherwise, allocate a temporary space.
     */</comment>
    <expr_stmt><expr><name>ua</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ub</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>osize</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>ua</name></expr></argument>, <argument><expr><name>ub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>osize</name> <operator>=</operator> <literal type="number">4</literal> <operator>*</operator> <operator>(</operator><operator>(</operator><name>osize</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>a</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>b</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ROUND_PREC</name><argument_list>(<argument><expr><name>osize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>default_precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>out</name> <operator>=</operator> <call><name>s_alloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>osize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>osize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_kmul</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>ua</name></expr></argument>, <argument><expr><name>ub</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If we allocated a new buffer, get rid of whatever memory c was already
     * using, and fix up its fields to reflect that.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>out</name> <operator>!=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>s_free</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>out</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MP_ALLOC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>osize</name></expr>;</expr_stmt>            <comment type="block">/* might not be true, but we'll fix it ... */</comment>
    <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    <comment type="block">/* ... right here */</comment>
    <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>osign</name></expr>;</expr_stmt>

    <return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_mul_value(a, value, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_mul_value</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mpz_t</name></type>        <name>vtmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name></type>    <name><name>vbuf</name><index>[<expr><call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>s_fake</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>mp_int_mul</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_mul_pow2(a, p2, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_mul_pow2</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p2</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>p2</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>s_qmul</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>p2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_OK</name></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_sqr(a, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_sqr</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>osize</name></decl>,
                <decl><type ref="prev"/><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get a temporary buffer big enough to hold the result */</comment>
    <expr_stmt><expr><name>osize</name> <operator>=</operator> <operator>(</operator><name>mp_size</name><operator>)</operator> <literal type="number">4</literal> <operator>*</operator> <operator>(</operator><operator>(</operator><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>c</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ROUND_PREC</name><argument_list>(<argument><expr><name>osize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>default_precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>out</name> <operator>=</operator> <call><name>s_alloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>osize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>osize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>s_ksqr</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get rid of whatever memory c was already using, and fix up its fields
     * to reflect the new digit array it's using
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>out</name> <operator>!=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>s_free</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>out</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MP_ALLOC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>osize</name></expr>;</expr_stmt>            <comment type="block">/* might not be true, but we'll fix it ... */</comment>
    <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    <comment type="block">/* ... right here */</comment>
    <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>

    <return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_div(a, b, q, r) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_div</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>cmp</name></decl>,
                <decl><type ref="prev"/><name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>lg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name> <init>= <expr><name>MP_OK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mpz_t</name></type>        <name><name>temp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_int</name></type>        <name>qout</name></decl>,
                <decl><type ref="prev"/><name>rout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_sign</name></type>        <name>sa</name> <init>= <expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>,
                <decl><type ref="prev"/><name>sb</name> <init>= <expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>q</name> <operator>!=</operator> <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_UNDEF</name></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name>cmp</name> <operator>=</operator> <call><name>s_ucmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If |a| &lt; |b|, no division is required: q = 0, r = a
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <return>return <expr><name>MP_OK</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If |a| = |b|, no division is required: q = 1 or -1, r = 0
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>sa</name> <operator>!=</operator> <name>sb</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_NEG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><name>MP_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * When |a| &gt; |b|, real division is required.  We need someplace to store
     * quotient and remainder, but q and r are allowed to be NULL or to
     * overlap with the inputs.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>lg</name> <operator>=</operator> <call><name>s_isp2</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>q</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>q</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>MP_OK</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>qout</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>qout</name> <operator>=</operator> <call><name>TEMP</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SETUP</name><argument_list>(<argument><expr><call><name>mp_int_init_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&amp;&amp;</operator> <name>a</name> <operator>!=</operator> <name>r</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>MP_OK</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>rout</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>rout</name> <operator>=</operator> <call><name>TEMP</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SETUP</name><argument_list>(<argument><expr><call><name>mp_int_init_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>s_udiv</name><argument_list>(<argument><expr><name>qout</name></expr></argument>, <argument><expr><name>rout</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>q</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>lg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>qout</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>s_qmod</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>lg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>rout</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Recompute signs for output */</comment>
    <if_stmt><if>if <condition>(<expr><name>rout</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>rout</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>sa</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>rout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>rout</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>qout</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>qout</name></expr></argument>)</argument_list></call> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>sa</name> <operator>==</operator> <name>sb</name><operator>)</operator></expr> ?</condition><then> <expr><name>MP_ZPOS</name></expr> </then><else>: <expr><name>MP_NEG</name></expr></else></ternary></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>qout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>qout</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>q</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>qout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>rout</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>

<label><name>CLEANUP</name>:</label>
    <while>while <condition>(<expr><operator>--</operator><name>last</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_mod(a, m, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_mod</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mpz_t</name></type>        <name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_int</name></type>        <name>out</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>m</name> <operator>==</operator> <name>c</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>out</name> <operator>=</operator> <operator>&amp;</operator><name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_div</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>mp_int_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<label><name>CLEANUP</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>out</name> <operator>!=</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>


<comment type="block">/* {{{ mp_int_div_value(a, value, q, r) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_div_value</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mpz_t</name></type>        <name>vtmp</name></decl>,
                <decl><type ref="prev"/><name>rtmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name></type>    <name><name>vbuf</name><index>[<expr><call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rtmp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>s_fake</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_div</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rtmp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_to_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rtmp</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* can't fail */</comment>

<label><name>CLEANUP</name>:</label>
    <expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rtmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_div_pow2(a, p2, q, r) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_div_pow2</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p2</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name> <init>= <expr><name>MP_OK</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>p2</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q</name> <operator>!=</operator> <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>q</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>MP_OK</name> <operator>&amp;&amp;</operator> <name>r</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>s_qmod</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_expt(a, b, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_expt</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mpz_t</name></type>        <name>t</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>v</name> <init>= <expr><call><name>abs</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>b</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_init_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_set_value</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>v</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>v</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_mul</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></while>

<label><name>CLEANUP</name>:</label>
    <expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_expt_value(a, b, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_expt_value</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mpz_t</name></type>        <name>t</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>v</name> <init>= <expr><call><name>abs</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>b</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_init_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_set_value</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>v</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>v</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_mul</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></while>

<label><name>CLEANUP</name>:</label>
    <expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_compare(a, b) */</comment>

<function><type><name>int</name></type>
<name>mp_int_compare</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_sign</name></type>        <name>sa</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>sa</name> <operator>=</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>sa</name> <operator>==</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>cmp</name> <init>= <expr><call><name>s_ucmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If they're both zero or positive, the normal comparison applies; if
         * both negative, the sense is reversed.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>sa</name> <operator>==</operator> <name>MP_ZPOS</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>cmp</name></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><name>cmp</name></expr>;</return></block_content></block></else></if_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>sa</name> <operator>==</operator> <name>MP_ZPOS</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_compare_unsigned(a, b) */</comment>

<function><type><name>int</name></type>
<name>mp_int_compare_unsigned</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>NRCHECK</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>s_ucmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_compare_zero(z) */</comment>

<function><type><name>int</name></type>
<name>mp_int_compare_zero</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>NRCHECK</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>z</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_ZPOS</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_compare_value(z, value) */</comment>

<function><type><name>int</name></type>
<name>mp_int_compare_value</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_sign</name></type>        <name>vsign</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>MP_NEG</name></expr> </then><else>: <expr><name>MP_ZPOS</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>cmp</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>vsign</name> <operator>==</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>s_vcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>vsign</name> <operator>==</operator> <name>MP_ZPOS</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>cmp</name></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><name>cmp</name></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_exptmod(a, b, m, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_exptmod</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>um</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mpz_t</name></type>        <name><name>temp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_int</name></type>        <name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>m</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Zero moduli and negative exponents are not considered. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_UNDEF</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_RANGE</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>um</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SETUP</name><argument_list>(<argument><expr><call><name>mp_int_init_size</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>um</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SETUP</name><argument_list>(<argument><expr><call><name>mp_int_init_size</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>um</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>b</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>m</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SETUP</name><argument_list>(<argument><expr><call><name>mp_int_init_size</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>um</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_mod</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>s_brmu</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>s_embar</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>CLEANUP</name>:</label>
    <while>while <condition>(<expr><operator>--</operator><name>last</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_exptmod_evalue(a, value, m, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_exptmod_evalue</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mpz_t</name></type>        <name>vtmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name></type>    <name><name>vbuf</name><index>[<expr><call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>s_fake</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>mp_int_exptmod</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_exptmod_bvalue(v, b, m, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_exptmod_bvalue</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>,
                      <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mpz_t</name></type>        <name>vtmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name></type>    <name><name>vbuf</name><index>[<expr><call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>s_fake</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>mp_int_exptmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_exptmod_known(a, b, m, mu, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_exptmod_known</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>mu</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>um</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mpz_t</name></type>        <name><name>temp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_int</name></type>        <name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>a</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>&amp;&amp;</operator> <name>m</name> <operator>&amp;&amp;</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Zero moduli and negative exponents are not considered. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_UNDEF</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_RANGE</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>um</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SETUP</name><argument_list>(<argument><expr><call><name>mp_int_init_size</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>um</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>b</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>m</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SETUP</name><argument_list>(<argument><expr><call><name>mp_int_init_size</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>um</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_mod</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>s_embar</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>mu</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>CLEANUP</name>:</label>
    <while>while <condition>(<expr><operator>--</operator><name>last</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_redux_const(m, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_redux_const</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>m</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>m</name> <operator>!=</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>s_brmu</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_invmod(a, m, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_invmod</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_sign</name></type>        <name>sa</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mpz_t</name></type>        <name><name>temp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>m</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>CMPZ</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_RANGE</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>sa</name> <operator>=</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* need this for the result later */</comment>

    <for>for <control>(<init><expr><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>last</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>last</name></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_init</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_egcd</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>mp_int_compare_value</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>MP_UNDEF</name></expr>;</expr_stmt>
        <goto>goto <name>CLEANUP</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* It is first necessary to constrain the value to the proper range */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_mod</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Now, if 'a' was originally negative, the value we have is actually the
     * magnitude of the negative representative; to get the positive value we
     * have to subtract from the modulus.  Otherwise, the value is okay as it
     * stands.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>sa</name> <operator>==</operator> <name>MP_NEG</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>mp_int_sub</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<label><name>CLEANUP</name>:</label>
    <while>while <condition>(<expr><operator>--</operator><name>last</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_gcd(a, b, c) */</comment>

<comment type="block">/* Binary GCD algorithm due to Josef Stein, 1961 */</comment>
<function><type><name>mp_result</name></type>
<name>mp_int_gcd</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>ca</name></decl>,
                <decl><type ref="prev"/><name>cb</name></decl>,
                <decl><type ref="prev"/><name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mpz_t</name></type>        <name>u</name></decl>,
                <decl><type ref="prev"/><name>v</name></decl>,
                <decl><type ref="prev"/><name>t</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ca</name> <operator>=</operator> <call><name>CMPZ</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cb</name> <operator>=</operator> <call><name>CMPZ</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ca</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cb</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_UNDEF</name></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>ca</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>mp_int_abs</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>cb</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>mp_int_abs</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_init_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>u</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>U</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_init_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>V</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><operator>&amp;</operator><name>u</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>

    <block>{<block_content>                            <comment type="block">/* Divide out common factors of 2 from u and v */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>div2_u</name> <init>= <expr><call><name>s_dp2k</name><argument_list>(<argument><expr><operator>&amp;</operator><name>u</name></expr></argument>)</argument_list></call></expr></init></decl>,
                    <decl><type ref="prev"/><name>div2_v</name> <init>= <expr><call><name>s_dp2k</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>div2_u</name></expr></argument>, <argument><expr><name>div2_v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>u</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><call><name>mp_int_is_odd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>u</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_neg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>u</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><call><name>s_dp2k</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_neg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_sub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>u</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_abs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>u</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_qmul</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>k</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>MP_MEMORY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>CLEANUP</name>:</label>
    <expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>V</name>:</label>    <expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>U</name>:</label>    <expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_egcd(a, b, c, x, y) */</comment>

<comment type="block">/* This is the binary GCD algorithm again, but this time we keep track
   of the elementary matrix operations as we go, so we can get values
   x and y satisfying c = ax + by.
 */</comment>
<function><type><name>mp_result</name></type>
<name>mp_int_egcd</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>,
            <parameter><decl><type><name>mp_int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>k</name></decl>,
                <decl><type ref="prev"/><name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>ca</name></decl>,
                <decl><type ref="prev"/><name>cb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mpz_t</name></type>        <name><name>temp</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
          <operator>(</operator><name>x</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>y</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ca</name> <operator>=</operator> <call><name>CMPZ</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cb</name> <operator>=</operator> <call><name>CMPZ</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ca</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cb</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_UNDEF</name></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>ca</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_abs</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_set_value</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>MP_OK</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>cb</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_abs</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_set_value</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>MP_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Initialize temporaries: A:0, B:1, C:2, D:3, u:4, v:5, ou:6, ov:7
     */</comment>
    <for>for <control>(<init><expr><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>last</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><operator>++</operator><name>last</name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_init</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SETUP</name><argument_list>(<argument><expr><call><name>mp_int_init_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SETUP</name><argument_list>(<argument><expr><call><name>mp_int_init_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We will work with absolute values here */</comment>
    <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>

    <block>{<block_content>                            <comment type="block">/* Divide out common factors of 2 from u and v */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>div2_u</name> <init>= <expr><call><name>s_dp2k</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>,
                    <decl><type ref="prev"/><name>div2_v</name> <init>= <expr><call><name>s_dp2k</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>div2_u</name></expr></argument>, <argument><expr><name>div2_v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>SETUP</name><argument_list>(<argument><expr><call><name>mp_int_init_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SETUP</name><argument_list>(<argument><expr><call><name>mp_int_init_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <while>while <condition>(<expr><call><name>mp_int_is_even</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>mp_int_is_odd</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>mp_int_is_odd</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_add</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
                    <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
                    <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <while>while <condition>(<expr><call><name>mp_int_is_even</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>mp_int_is_odd</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>mp_int_is_odd</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_add</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
                    <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
                    <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><call><name>mp_int_compare</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>y</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>c</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_qmul</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>MP_MEMORY</name></expr>;</expr_stmt>
                    <goto>goto <name>CLEANUP</name>;</goto>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

<label><name>CLEANUP</name>:</label>
    <while>while <condition>(<expr><operator>--</operator><name>last</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_divisible_value(a, v) */</comment>

<function><type><name>int</name></type>
<name>mp_int_divisible_value</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>rem</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>mp_int_div_value</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rem</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>rem</name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_is_pow2(z) */</comment>

<function><type><name>int</name></type>
<name>mp_int_is_pow2</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>s_isp2</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_sqrt(a, c) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_sqrt</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name> <init>= <expr><name>MP_OK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mpz_t</name></type>        <name><name>temp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The square root of a negative value does not exist in the integers. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_NEG</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_UNDEF</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>SETUP</name><argument_list>(<argument><expr><call><name>mp_int_init_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SETUP</name><argument_list>(<argument><expr><call><name>mp_int_init</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_sqr</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>mp_int_compare_unsigned</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_div</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_add</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_div_pow2</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>mp_int_compare_unsigned</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_sub_value</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>mp_int_compare_unsigned</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>CLEANUP</name>:</label>
    <while>while <condition>(<expr><operator>--</operator><name>last</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_to_int(z, out) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_to_int</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>uv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>uz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_sign</name></type>        <name>sz</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make sure the value is representable as an int */</comment>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>sz</name> <operator>==</operator> <name>MP_ZPOS</name> <operator>&amp;&amp;</operator> <call><name>mp_int_compare_value</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
        <call><name>mp_int_compare_value</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>INT_MIN</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_RANGE</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>uz</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dz</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>uz</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>uz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>uv</name> <operator>&lt;&lt;=</operator> <name>MP_DIGIT_BIT</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>uv</name> <operator>=</operator> <operator>(</operator><name>uv</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>MP_DIGIT_BIT</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator> <operator>|</operator> <operator>*</operator><name>dz</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>--</operator><name>uz</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>sz</name> <operator>==</operator> <name>MP_NEG</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator> <name>uv</name></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator> <name>uv</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_to_string(z, radix, str, limit) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_to_string</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>radix</name></decl></parameter>,
                 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>cmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>str</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>limit</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>radix</name> <argument_list type="generic">&lt; <argument><expr><name>MP_MIN_RADIX</name> <operator>||</operator> <name>radix</name></expr></argument> &gt;</argument_list></name> <name>MP_MAX_RADIX</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_RANGE</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <call><name>s_val2ch</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mp_flags</name> <operator>&amp;</operator> <name>MP_CAP_DIGITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>mpz_t</name></type>        <name>tmp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>h</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_init_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_NEG</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>--</operator><name>limit</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>h</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

        <comment type="block">/* Generate digits in reverse order until finished or limit reached */</comment>
        <for>for <control>( <comment type="block">/* */</comment> <init>;</init> <condition><expr><name>limit</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>limit</name></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>mp_digit</name></type>    <name>d</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cmp</name> <operator>=</operator> <call><name>CMPZ</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>s_ddiv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_digit</name><operator>)</operator> <name>radix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <call><name>s_val2ch</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>mp_flags</name> <operator>&amp;</operator> <name>MP_CAP_DIGITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>t</name> <operator>=</operator> <name>str</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <comment type="block">/* Put digits back in correct output order */</comment>
        <while>while <condition>(<expr><name>h</name> <operator>&lt;</operator> <name>t</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type>        <name>tc</name> <init>= <expr><operator>*</operator><name>h</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><operator>*</operator><name>h</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>t</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>t</name><operator>--</operator> <operator>=</operator> <name>tc</name></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_OK</name></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>MP_TRUNC</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_string_len(z, radix) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_string_len</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>radix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>radix</name> <argument_list type="generic">&lt; <argument><expr><name>MP_MIN_RADIX</name> <operator>||</operator> <name>radix</name></expr></argument> &gt;</argument_list></name> <name>MP_MAX_RADIX</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_RANGE</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>s_outlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* for terminator */</comment>

    <comment type="block">/* Allow for sign marker on negatives */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_NEG</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_read_string(z, radix, *str) */</comment>

<comment type="block">/* Read zero-terminated string into z */</comment>
<function><type><name>mp_result</name></type>
<name>mp_int_read_string</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>radix</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>mp_int_read_cstring</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_read_cstring(z, radix, *str, **end) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_read_cstring</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>radix</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>ch</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>str</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>radix</name> <argument_list type="generic">&lt; <argument><expr><name>MP_MIN_RADIX</name> <operator>||</operator> <name>radix</name></expr></argument> &gt;</argument_list></name> <name>MP_MAX_RADIX</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_RANGE</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Skip leading whitespace */</comment>
    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>++</operator><name>str</name></expr>;</expr_stmt></block_content></block></while>

    <comment type="block">/* Handle leading sign tag (+/-, positive default) */</comment>
    <switch>switch <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="char">'-'</literal></expr>:</case>
            <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_NEG</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>++</operator><name>str</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'+'</literal></expr>:</case>
            <expr_stmt><expr><operator>++</operator><name>str</name></expr>;</expr_stmt>                <comment type="block">/* fallthrough */</comment>
        <default>default:</default>
            <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* Skip leading zeroes */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <call><name>s_ch2val</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>++</operator><name>str</name></expr>;</expr_stmt></block_content></block></while>

    <comment type="block">/* Make sure there is enough space for the value */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><call><name>s_inlen</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>radix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>ch</name> <operator>=</operator> <call><name>s_ch2val</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>s_dmul</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_digit</name><operator>)</operator> <name>radix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>s_dadd</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_digit</name><operator>)</operator> <name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name>str</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Override sign for zero, even if negative specified. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>end</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>str</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Return a truncation error if the string has unprocessed characters
     * remaining, so the caller can tell if the whole string was done
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_TRUNC</name></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>MP_OK</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_count_bits(z) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_count_bits</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>nbits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>uz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name></type>    <name>d</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>uz</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>uz</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>z</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>--</operator><name>uz</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nbits</name> <operator>=</operator> <name>uz</name> <operator>*</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>z</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>uz</name></expr>]</index></name></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>d</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>d</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name>nbits</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>nbits</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_to_binary(z, buf, limit) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_to_binary</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>PAD_FOR_2C</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>limpos</name> <init>= <expr><name>limit</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>buf</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>s_tobin</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>limpos</name></expr></argument>, <argument><expr><name>PAD_FOR_2C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_NEG</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>s_2comp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>limpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_read_binary(z, buf, len) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_read_binary</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>need</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dz</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>buf</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Figure out how many digits are needed to represent this value */</comment>
    <expr_stmt><expr><name>need</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>len</name> <operator>*</operator> <name>CHAR_BIT</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>MP_DIGIT_BIT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>need</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the high-order bit is set, take the 2's complement before reading
     * the value (it will be restored afterward)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <operator>(</operator><name>CHAR_BIT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_NEG</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>s_2comp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>dz</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>tmp</name> <operator>=</operator> <name>buf</name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <name>len</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr><operator>,</operator> <expr><operator>++</operator><name>tmp</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>s_qmul</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>CHAR_BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>dz</name> <operator>|=</operator> <operator>*</operator><name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Restore 2's complement if we took it before */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_NEG</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>s_2comp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_binary_len(z) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_binary_len</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name> <init>= <expr><call><name>mp_int_count_bits</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>bytes</name> <init>= <expr><call><name>mp_int_unsigned_len</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>bytes</name> <operator>=</operator> <operator>(</operator><name>res</name> <operator>+</operator> <operator>(</operator><name>CHAR_BIT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>CHAR_BIT</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If the highest-order bit falls exactly on a byte boundary, we need to
     * pad with an extra byte so that the sign will be read correctly when
     * reading it back in.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>*</operator> <name>CHAR_BIT</name> <operator>==</operator> <name>res</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>++</operator><name>bytes</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>bytes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_to_unsigned(z, buf, limit) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_to_unsigned</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>NO_PADDING</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>buf</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>s_tobin</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>limit</name></expr></argument>, <argument><expr><name>NO_PADDING</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_read_unsigned(z, buf, len) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_read_unsigned</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>need</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dz</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>buf</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Figure out how many digits are needed to represent this value */</comment>
    <expr_stmt><expr><name>need</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>len</name> <operator>*</operator> <name>CHAR_BIT</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>MP_DIGIT_BIT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>need</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>dz</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>tmp</name> <operator>=</operator> <name>buf</name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <name>len</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr><operator>,</operator> <expr><operator>++</operator><name>tmp</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_qmul</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>CHAR_BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>dz</name> <operator>|=</operator> <operator>*</operator><name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_int_unsigned_len(z) */</comment>

<function><type><name>mp_result</name></type>
<name>mp_int_unsigned_len</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name> <init>= <expr><call><name>mp_int_count_bits</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>bytes</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>bytes</name> <operator>=</operator> <operator>(</operator><name>res</name> <operator>+</operator> <operator>(</operator><name>CHAR_BIT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>CHAR_BIT</name></expr>;</expr_stmt>

    <return>return <expr><name>bytes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ mp_error_string(res) */</comment>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>mp_error_string</name><parameter_list>(<parameter><decl><type><name>mp_result</name></type> <name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>ix</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>res</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>s_unknown_err</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>-</operator><name>res</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>ix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ix</name> <operator>&lt;</operator> <name>res</name> <operator>&amp;&amp;</operator> <name><name>s_error_msg</name><index>[<expr><name>ix</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><operator>++</operator><name>ix</name></expr></incr>)</control><block type="pseudo"><block_content>
        <empty_stmt>;</empty_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><name><name>s_error_msg</name><index>[<expr><name>ix</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>s_error_msg</name><index>[<expr><name>ix</name></expr>]</index></name></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>s_unknown_err</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/*------------------------------------------------------------------------*/</comment>
<comment type="block">/* Private functions for internal use.  These make assumptions.           */</comment>

<comment type="block">/* {{{ s_alloc(num) */</comment>

<function><type><specifier>static</specifier> <name>mp_digit</name> <modifier>*</modifier></type>
<name>s_alloc</name><parameter_list>(<parameter><decl><type><name>mp_size</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>px_alloc</name><argument_list>(<argument><expr><name>num</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>mp_digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>out</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* for debugging */</comment>

    <return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_realloc(old, num) */</comment>

<function><type><specifier>static</specifier> <name>mp_digit</name> <modifier>*</modifier></type>
<name>s_realloc</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>old</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>new</name> <init>= <expr><call><name>px_realloc</name><argument_list>(<argument><expr><name>old</name></expr></argument>, <argument><expr><name>num</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>mp_digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>new</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* for debugging */</comment>

    <return>return <expr><name>new</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_free(ptr) */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TRACEABLE_FREE</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>px_free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_pad(z, min) */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_pad</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>min</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>MP_ALLOC</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>min</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>mp_size</name></type>        <name>nsize</name> <init>= <expr><call><name>ROUND_PREC</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>s_realloc</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MP_ALLOC</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>nsize</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_clamp(z) */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TRACEABLE_CLAMP</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_clamp</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>uz</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>zd</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>uz</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>uz</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>zd</name><operator>--</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>--</operator><name>uz</name></expr>;</expr_stmt></block_content></block></while>

    <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>uz</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_fake(z, value, vbuf) */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_fake</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name><name>vbuf</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>uv</name> <init>= <expr><operator>(</operator><name>mp_size</name><operator>)</operator> <call><name>s_vpack</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>uv</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>MP_NEG</name></expr> </then><else>: <expr><name>MP_ZPOS</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <name>vbuf</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_cdig(da, db, len) */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_cdig</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dat</name> <init>= <expr><name>da</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>dbt</name> <init>= <expr><name>db</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>( <comment type="block">/* */</comment> <init>;</init> <condition><expr><name>len</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>len</name></expr><operator>,</operator> <expr><operator>--</operator><name>dat</name></expr><operator>,</operator> <expr><operator>--</operator><name>dbt</name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>dat</name> <operator>&gt;</operator> <operator>*</operator><name>dbt</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>*</operator><name>dat</name> <operator>&lt;</operator> <operator>*</operator><name>dbt</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_vpack(v, t[]) */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_vpack</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name><name>t</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>uv</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><name>v</name></expr> </then><else>: <expr><name>v</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ndig</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>uv</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>t</name><index>[<expr><name>ndig</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <while>while <condition>(<expr><name>uv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>t</name><index>[<expr><name>ndig</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>mp_digit</name><operator>)</operator> <name>uv</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>uv</name> <operator>&gt;&gt;=</operator> <name>MP_DIGIT_BIT</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>uv</name> <operator>&gt;&gt;=</operator> <name>MP_DIGIT_BIT</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>ndig</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_ucmp(a, b) */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_ucmp</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>ua</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>,
                <decl><type ref="prev"/><name>ub</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>ua</name> <operator>&gt;</operator> <name>ub</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>ub</name> <operator>&gt;</operator> <name>ua</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>s_cdig</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ua</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_vcmp(a, v) */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_vcmp</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_digit</name></type>    <name><name>vdig</name><index>[<expr><call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ndig</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>ua</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>ndig</name> <operator>=</operator> <call><name>s_vpack</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>vdig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>ua</name> <operator>&gt;</operator> <name>ndig</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>ua</name> <operator>&lt;</operator> <name>ndig</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>s_cdig</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>vdig</name></expr></argument>, <argument><expr><name>ndig</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_uadd(da, db, dc, size_a, size_b) */</comment>

<function><type><specifier>static</specifier> <name>mp_digit</name></type>
<name>s_uadd</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>,
       <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_word</name></type>        <name>w</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Insure that da is the longer of the two to simplify later code */</comment>
    <if_stmt><if>if <condition>(<expr><name>size_b</name> <operator>&gt;</operator> <name>size_a</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>mp_digit</name> <operator>*</operator></expr></argument>, <argument><expr><name>da</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>mp_size</name></expr></argument>, <argument><expr><name>size_a</name></expr></argument>, <argument><expr><name>size_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Add corresponding digits until the shorter number runs out */</comment>
    <for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>size_b</name></expr>;</condition> <incr><expr><operator>++</operator><name>pos</name></expr><operator>,</operator> <expr><operator>++</operator><name>da</name></expr><operator>,</operator> <expr><operator>++</operator><name>db</name></expr><operator>,</operator> <expr><operator>++</operator><name>dc</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <name>w</name> <operator>+</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>da</name> <operator>+</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>db</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>dc</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Propagate carries as far as necessary */</comment>
    <for>for <control>( <comment type="block">/* */</comment> <init>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>size_a</name></expr>;</condition> <incr><expr><operator>++</operator><name>pos</name></expr><operator>,</operator> <expr><operator>++</operator><name>da</name></expr><operator>,</operator> <expr><operator>++</operator><name>dc</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <name>w</name> <operator>+</operator> <operator>*</operator><name>da</name></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>dc</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Return carry out */</comment>
    <return>return <expr><operator>(</operator><name>mp_digit</name><operator>)</operator> <name>w</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_usub(da, db, dc, size_a, size_b) */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_usub</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>,
       <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_word</name></type>        <name>w</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* We assume that |a| &gt;= |b| so this should definitely hold */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size_a</name> <operator>&gt;=</operator> <name>size_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Subtract corresponding digits and propagate borrow */</comment>
    <for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>size_b</name></expr>;</condition> <incr><expr><operator>++</operator><name>pos</name></expr><operator>,</operator> <expr><operator>++</operator><name>da</name></expr><operator>,</operator> <expr><operator>++</operator><name>db</name></expr><operator>,</operator> <expr><operator>++</operator><name>dc</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>mp_word</name><operator>)</operator> <name>MP_DIGIT_MAX</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator>    <comment type="block">/* MP_RADIX */</comment>
             <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>da</name><operator>)</operator> <operator>-</operator> <name>w</name> <operator>-</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>db</name></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>dc</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Finish the subtraction for remaining upper digits of da */</comment>
    <for>for <control>( <comment type="block">/* */</comment> <init>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>size_a</name></expr>;</condition> <incr><expr><operator>++</operator><name>pos</name></expr><operator>,</operator> <expr><operator>++</operator><name>da</name></expr><operator>,</operator> <expr><operator>++</operator><name>dc</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>mp_word</name><operator>)</operator> <name>MP_DIGIT_MAX</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator>    <comment type="block">/* MP_RADIX */</comment>
             <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>da</name><operator>)</operator> <operator>-</operator> <name>w</name></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>dc</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* If there is a borrow out at the end, it violates the precondition */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>w</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_kmul(da, db, dc, size_a, size_b) */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_kmul</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>,
       <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>bot_size</name></decl>;</decl_stmt>

    <comment type="block">/* Make sure b is the smaller of the two input values */</comment>
    <if_stmt><if>if <condition>(<expr><name>size_b</name> <operator>&gt;</operator> <name>size_a</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>mp_digit</name> <operator>*</operator></expr></argument>, <argument><expr><name>da</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>mp_size</name></expr></argument>, <argument><expr><name>size_a</name></expr></argument>, <argument><expr><name>size_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Insure that the bottom is the larger half in an odd-length split; the
     * code below relies on this being true.
     */</comment>
    <expr_stmt><expr><name>bot_size</name> <operator>=</operator> <operator>(</operator><name>size_a</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * If the values are big enough to bother with recursion, use the
     * Karatsuba algorithm to compute the product; otherwise use the normal
     * multiplication algorithm
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>multiply_threshold</name> <operator>&amp;&amp;</operator>
        <name>size_a</name> <operator>&gt;=</operator> <name>multiply_threshold</name> <operator>&amp;&amp;</operator>
        <name>size_b</name> <operator>&gt;</operator> <name>bot_size</name></expr>)</condition>
    <block>{<block_content>

        <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>t1</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>t2</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>t3</name></decl>,
                    <decl><type ref="prev"/><name>carry</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>a_top</name> <init>= <expr><name>da</name> <operator>+</operator> <name>bot_size</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>b_top</name> <init>= <expr><name>db</name> <operator>+</operator> <name>bot_size</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>mp_size</name></type>        <name>at_size</name> <init>= <expr><name>size_a</name> <operator>-</operator> <name>bot_size</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>mp_size</name></type>        <name>bt_size</name> <init>= <expr><name>size_b</name> <operator>-</operator> <name>bot_size</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>mp_size</name></type>        <name>buf_size</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <name>bot_size</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Do a single allocation for all three temporary buffers needed; each
         * buffer must be big enough to hold the product of two bottom halves,
         * and one buffer needs space for the completed product; twice the
         * space is plenty.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>t1</name> <operator>=</operator> <call><name>s_alloc</name><argument_list>(<argument><expr><literal type="number">4</literal> <operator>*</operator> <name>buf_size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>t2</name> <operator>=</operator> <name>t1</name> <operator>+</operator> <name>buf_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>t3</name> <operator>=</operator> <name>t2</name> <operator>+</operator> <name>buf_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><literal type="number">4</literal> <operator>*</operator> <name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * t1 and t2 are initially used as temporaries to compute the inner
         * product (a1 + a0)(b1 + b0) = a1b1 + a1b0 + a0b1 + a0b0
         */</comment>
        <expr_stmt><expr><name>carry</name> <operator>=</operator> <call><name>s_uadd</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>a_top</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>bot_size</name></expr></argument>, <argument><expr><name>at_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* t1 = a1 + a0 */</comment>
        <expr_stmt><expr><name><name>t1</name><index>[<expr><name>bot_size</name></expr>]</index></name> <operator>=</operator> <name>carry</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>carry</name> <operator>=</operator> <call><name>s_uadd</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>b_top</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>bot_size</name></expr></argument>, <argument><expr><name>bt_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* t2 = b1 + b0 */</comment>
        <expr_stmt><expr><name><name>t2</name><index>[<expr><name>bot_size</name></expr>]</index></name> <operator>=</operator> <name>carry</name></expr>;</expr_stmt>

        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_kmul</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>bot_size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>bot_size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* t3 = t1 * t2 */</comment>

        <comment type="block">/*
         * Now we'll get t1 = a0b0 and t2 = a1b1, and subtract them out so
         * that we're left with only the pieces we want:  t3 = a1b0 + a0b1
         */</comment>
        <expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_kmul</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>bot_size</name></expr></argument>, <argument><expr><name>bot_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* t1 = a0 * b0 */</comment>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_kmul</name><argument_list>(<argument><expr><name>a_top</name></expr></argument>, <argument><expr><name>b_top</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>at_size</name></expr></argument>, <argument><expr><name>bt_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* t2 = a1 * b1 */</comment>

        <comment type="block">/* Subtract out t1 and t2 to get the inner product */</comment>
        <expr_stmt><expr><call><name>s_usub</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>buf_size</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>s_usub</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>buf_size</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Assemble the output value */</comment>
        <expr_stmt><expr><call><name>COPY</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>carry</name> <operator>=</operator> <call><name>s_uadd</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>dc</name> <operator>+</operator> <name>bot_size</name></expr></argument>, <argument><expr><name>dc</name> <operator>+</operator> <name>bot_size</name></expr></argument>,
                       <argument><expr><name>buf_size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>carry</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>carry</name> <operator>=</operator> <call><name>s_uadd</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>dc</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>bot_size</name></expr></argument>, <argument><expr><name>dc</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>bot_size</name></expr></argument>,
                       <argument><expr><name>buf_size</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>carry</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>s_free</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                <comment type="block">/* note t2 and t3 are just internal pointers
                                 * to t1 */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>s_umul</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>, <argument><expr><name>size_a</name></expr></argument>, <argument><expr><name>size_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_umul(da, db, dc, size_a, size_b) */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_umul</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>,
       <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>a</name></decl>,
                <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_word</name></type>        <name>w</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>a</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>a</name> <operator>&lt;</operator> <name>size_a</name></expr>;</condition> <incr><expr><operator>++</operator><name>a</name></expr><operator>,</operator> <expr><operator>++</operator><name>dc</name></expr><operator>,</operator> <expr><operator>++</operator><name>da</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dct</name> <init>= <expr><name>dc</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dbt</name> <init>= <expr><name>db</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>da</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>w</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>b</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>b</name> <operator>&lt;</operator> <name>size_b</name></expr>;</condition> <incr><expr><operator>++</operator><name>b</name></expr><operator>,</operator> <expr><operator>++</operator><name>dbt</name></expr><operator>,</operator> <expr><operator>++</operator><name>dct</name></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>da</name> <operator>*</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>dbt</name> <operator>+</operator> <name>w</name> <operator>+</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>dct</name></expr>;</expr_stmt>

            <expr_stmt><expr><operator>*</operator><name>dct</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><operator>*</operator><name>dct</name> <operator>=</operator> <operator>(</operator><name>mp_digit</name><operator>)</operator> <name>w</name></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_ksqr(da, dc, size_a) */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_ksqr</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>multiply_threshold</name> <operator>&amp;&amp;</operator> <name>size_a</name> <operator>&gt;</operator> <name>multiply_threshold</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>mp_size</name></type>        <name>bot_size</name> <init>= <expr><operator>(</operator><name>size_a</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>a_top</name> <init>= <expr><name>da</name> <operator>+</operator> <name>bot_size</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>t1</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>t2</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>t3</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>mp_size</name></type>        <name>at_size</name> <init>= <expr><name>size_a</name> <operator>-</operator> <name>bot_size</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>mp_size</name></type>        <name>buf_size</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <name>bot_size</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>t1</name> <operator>=</operator> <call><name>s_alloc</name><argument_list>(<argument><expr><literal type="number">4</literal> <operator>*</operator> <name>buf_size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>t2</name> <operator>=</operator> <name>t1</name> <operator>+</operator> <name>buf_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>t3</name> <operator>=</operator> <name>t2</name> <operator>+</operator> <name>buf_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><literal type="number">4</literal> <operator>*</operator> <name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_ksqr</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>bot_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* t1 = a0 ^ 2 */</comment>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_ksqr</name><argument_list>(<argument><expr><name>a_top</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>at_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* t2 = a1 ^ 2 */</comment>

        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_kmul</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>a_top</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>bot_size</name></expr></argument>, <argument><expr><name>at_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* t3 = a0 * a1 */</comment>

        <comment type="block">/* Quick multiply t3 by 2, shifting left (can't overflow) */</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                        <decl><type ref="prev"/><name>top</name> <init>= <expr><name>bot_size</name> <operator>+</operator> <name>at_size</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>mp_word</name></type>        <name>w</name></decl>,
                        <decl><type ref="prev"/><name>save</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>top</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t3</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>w</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <name>save</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>t3</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>save</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><name><name>t3</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/* Assemble the output value */</comment>
        <expr_stmt><expr><call><name>COPY</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>bot_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_uadd</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>dc</name> <operator>+</operator> <name>bot_size</name></expr></argument>, <argument><expr><name>dc</name> <operator>+</operator> <name>bot_size</name></expr></argument>,
                      <argument><expr><name>buf_size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>buf_size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_uadd</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>dc</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>bot_size</name></expr></argument>, <argument><expr><name>dc</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>bot_size</name></expr></argument>,
                      <argument><expr><name>buf_size</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>px_free</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* note that t2 and t2 are internal pointers
                                 * only */</comment>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>s_usqr</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>, <argument><expr><name>size_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_usqr(da, dc, size_a) */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_usqr</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_word</name></type>        <name>w</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size_a</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><name>dc</name> <operator>+=</operator> <literal type="number">2</literal></expr><operator>,</operator> <expr><operator>++</operator><name>da</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dct</name> <init>= <expr><name>dc</name></expr></init></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>dat</name> <init>= <expr><name>da</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>da</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Take care of the first digit, no rollover */</comment>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>dat</name> <operator>*</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>dat</name> <operator>+</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>dct</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>dct</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name>dat</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name>dct</name></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>size_a</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr><operator>,</operator> <expr><operator>++</operator><name>dat</name></expr><operator>,</operator> <expr><operator>++</operator><name>dct</name></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>mp_word</name></type>        <name>t</name> <init>= <expr><operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>da</name> <operator>*</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>dat</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>mp_word</name></type>        <name>u</name> <init>= <expr><name>w</name> <operator>+</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>dct</name></expr></init></decl>,
                        <decl><type ref="prev"/><name>ov</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Check if doubling t will overflow a word */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>HIGH_BIT_SET</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ov</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>w</name> <operator>=</operator> <name>t</name> <operator>+</operator> <name>t</name></expr>;</expr_stmt>

            <comment type="block">/* Check if adding u to w will overflow a word */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>ADD_WILL_OVERFLOW</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ov</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>w</name> <operator>+=</operator> <name>u</name></expr>;</expr_stmt>

            <expr_stmt><expr><operator>*</operator><name>dct</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ov</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>w</name> <operator>+=</operator> <name>MP_DIGIT_MAX</name></expr>;</expr_stmt>    <comment type="block">/* MP_RADIX */</comment>
                <expr_stmt><expr><operator>++</operator><name>w</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>w</name> <operator>=</operator> <name>w</name> <operator>+</operator> <operator>*</operator><name>dct</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>dct</name> <operator>=</operator> <operator>(</operator><name>mp_digit</name><operator>)</operator> <name>w</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>++</operator><name>dct</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>w</name> <operator>=</operator> <name>w</name> <operator>+</operator> <operator>*</operator><name>dct</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>dct</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>w</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_dadd(a, b) */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_dadd</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_word</name></type>        <name>w</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>da</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>ua</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>da</name> <operator>+</operator> <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>da</name><operator>++</operator> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>ua</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>ua</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>ua</name></expr><operator>,</operator> <expr><operator>++</operator><name>da</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>da</name> <operator>+</operator> <name>w</name></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>da</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>w</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>da</name> <operator>=</operator> <operator>(</operator><name>mp_digit</name><operator>)</operator> <name>w</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_dmul(a, b) */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_dmul</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_word</name></type>        <name>w</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>da</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>ua</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>ua</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>da</name> <operator>*</operator> <name>b</name> <operator>+</operator> <name>w</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>da</name><operator>++</operator> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>--</operator><name>ua</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>w</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>da</name> <operator>=</operator> <operator>(</operator><name>mp_digit</name><operator>)</operator> <name>w</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_dbmul(da, b, dc, size_a) */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_dbmul</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_word</name></type>        <name>w</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>size_a</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>da</name><operator>++</operator> <operator>*</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <name>b</name> <operator>+</operator> <name>w</name></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>dc</name><operator>++</operator> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>--</operator><name>size_a</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>w</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>dc</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_ddiv(da, d, dc, size_a) */</comment>

<function><type><specifier>static</specifier> <name>mp_digit</name></type>
<name>s_ddiv</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_word</name></type>        <name>w</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>qdigit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>ua</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>da</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>ua</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>( <comment type="block">/* */</comment> <init>;</init> <condition><expr><name>ua</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>ua</name></expr><operator>,</operator> <expr><operator>--</operator><name>da</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>w</name> <operator>&lt;&lt;</operator> <name>MP_DIGIT_BIT</name><operator>)</operator> <operator>|</operator> <operator>*</operator><name>da</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>w</name> <operator>&gt;=</operator> <name>b</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>qdigit</name> <operator>=</operator> <name>w</name> <operator>/</operator> <name>b</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>w</name> <operator>=</operator> <name>w</name> <operator>%</operator> <name>b</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>qdigit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><operator>*</operator><name>da</name> <operator>=</operator> <operator>(</operator><name>mp_digit</name><operator>)</operator> <name>qdigit</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>mp_digit</name><operator>)</operator> <name>w</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_qdiv(z, p2) */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_qdiv</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>ndig</name> <init>= <expr><name>p2</name> <operator>/</operator> <name>MP_DIGIT_BIT</name></expr></init></decl>,
                <decl><type ref="prev"/><name>nbits</name> <init>= <expr><name>p2</name> <operator>%</operator> <name>MP_DIGIT_BIT</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>uz</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>ndig</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>mp_size</name></type>        <name>mark</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>to</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>ndig</name> <operator>&gt;=</operator> <name>uz</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>from</name> <operator>=</operator> <name>to</name> <operator>+</operator> <name>ndig</name></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>mark</name> <operator>=</operator> <name>ndig</name></expr>;</init> <condition><expr><name>mark</name> <operator>&lt;</operator> <name>uz</name></expr>;</condition> <incr><expr><operator>++</operator><name>mark</name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

        <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>uz</name> <operator>-</operator> <name>ndig</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>nbits</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>mp_digit</name></type>    <name>d</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>dz</name></decl>,
                    <decl><type ref="prev"/><name>save</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>mp_size</name></type>        <name>up</name> <init>= <expr><name>MP_DIGIT_BIT</name> <operator>-</operator> <name>nbits</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>uz</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dz</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>uz</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <for>for <control>( <comment type="block">/* */</comment> <init>;</init> <condition><expr><name>uz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>uz</name></expr><operator>,</operator> <expr><operator>--</operator><name>dz</name></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>save</name> <operator>=</operator> <operator>*</operator><name>dz</name></expr>;</expr_stmt>

            <expr_stmt><expr><operator>*</operator><name>dz</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>dz</name> <operator>&gt;&gt;</operator> <name>nbits</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>d</name> <operator>&lt;&lt;</operator> <name>up</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>d</name> <operator>=</operator> <name>save</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>z</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_qmod(z, p2) */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_qmod</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>start</name> <init>= <expr><name>p2</name> <operator>/</operator> <name>MP_DIGIT_BIT</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>rest</name> <init>= <expr><name>p2</name> <operator>%</operator> <name>MP_DIGIT_BIT</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>uz</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name></type>    <name>mask</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>rest</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;=</operator> <name>uz</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>start</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_qmul(z, p2) */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_qmul</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>uz</name></decl>,
                <decl><type ref="prev"/><name>need</name></decl>,
                <decl><type ref="prev"/><name>rest</name></decl>,
                <decl><type ref="prev"/><name>extra</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>from</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>to</name></decl>,
                <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>p2</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>uz</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>need</name> <operator>=</operator> <name>p2</name> <operator>/</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rest</name> <operator>=</operator> <name>p2</name> <operator>%</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Figure out if we need an extra digit at the top end; this occurs if the
     * topmost `rest' bits of the high-order digit of z are not zero, meaning
     * they will be shifted off the end if not preserved
     */</comment>
    <expr_stmt><expr><name>extra</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rest</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dz</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>uz</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>dz</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>MP_DIGIT_BIT</name> <operator>-</operator> <name>rest</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>extra</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>uz</name> <operator>+</operator> <name>need</name> <operator>+</operator> <name>extra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If we need to shift by whole digits, do that in one pass, then to back
     * and shift by partial digits.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>need</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>uz</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>to</name> <operator>=</operator> <name>from</name> <operator>+</operator> <name>need</name></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>uz</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>to</name><operator>--</operator> <operator>=</operator> <operator>*</operator><name>from</name><operator>--</operator></expr>;</expr_stmt></block_content></block></for>

        <expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>need</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>uz</name> <operator>+=</operator> <name>need</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>rest</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>need</name></expr><operator>,</operator> <expr><name>from</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>need</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>uz</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><operator>++</operator><name>from</name></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>mp_digit</name></type>    <name>save</name> <init>= <expr><operator>*</operator><name>from</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><operator>*</operator><name>from</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>from</name> <operator>&lt;&lt;</operator> <name>rest</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>d</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>MP_DIGIT_BIT</name> <operator>-</operator> <name>rest</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>d</name> <operator>=</operator> <name>save</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>d</name> <operator>&gt;&gt;=</operator> <operator>(</operator><name>MP_DIGIT_BIT</name> <operator>-</operator> <name>rest</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>d</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>from</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>uz</name> <operator>+=</operator> <name>extra</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>uz</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_qsub(z, p2) */</comment>

<comment type="block">/* Subtract |z| from 2^p2, assuming 2^p2 &gt; |z|, and set z to be positive */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_qsub</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_digit</name></type>    <name>hi</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>p2</name> <operator>%</operator> <name>MP_DIGIT_BIT</name><operator>)</operator><operator>)</operator></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>zp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>tdig</name> <init>= <expr><operator>(</operator><name>p2</name> <operator>/</operator> <name>MP_DIGIT_BIT</name><operator>)</operator></expr></init></decl>,
                <decl><type ref="prev"/><name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_word</name></type>        <name>w</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>tdig</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>zp</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>tdig</name></expr>;</condition> <incr><expr><operator>++</operator><name>pos</name></expr><operator>,</operator> <expr><operator>++</operator><name>zp</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>mp_word</name><operator>)</operator> <name>MP_DIGIT_MAX</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>w</name> <operator>-</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>zp</name></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>zp</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <ternary><condition><expr><call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>mp_word</name><operator>)</operator> <name>MP_DIGIT_MAX</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>hi</name><operator>)</operator> <operator>-</operator> <name>w</name> <operator>-</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>zp</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>zp</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* no borrow out should be possible */</comment>

    <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_dp2k(z) */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_dp2k</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dp</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>,
                <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>dp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><operator>*</operator><name>dp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>k</name> <operator>+=</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name>dp</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name>d</name> <operator>=</operator> <operator>*</operator><name>dp</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>d</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>d</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name>k</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>k</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_isp2(z) */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_isp2</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>uz</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>,
                <decl><type ref="prev"/><name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dz</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>,
                <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>uz</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>dz</name><operator>++</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>k</name> <operator>+=</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>--</operator><name>uz</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name>d</name> <operator>=</operator> <operator>*</operator><name>dz</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>d</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>++</operator><name>k</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>d</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>k</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_2expt(z, k) */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_2expt</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>ndig</name></decl>,
                <decl><type ref="prev"/><name>rest</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dz</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ndig</name> <operator>=</operator> <operator>(</operator><name>k</name> <operator>+</operator> <name>MP_DIGIT_BIT</name><operator>)</operator> <operator>/</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rest</name> <operator>=</operator> <name>k</name> <operator>%</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>ndig</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>dz</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><name>dz</name></expr></argument>, <argument><expr><name>ndig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>dz</name> <operator>+</operator> <name>ndig</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>rest</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>ndig</name></expr>;</expr_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_norm(a, b) */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_norm</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_digit</name></type>    <name>d</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>digits</name><index>[<expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>d</name> <operator>&lt;</operator> <operator>(</operator><name>mp_digit</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>mp_digit</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>MP_DIGIT_BIT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>                            <comment type="block">/* d &lt; (MP_RADIX / 2) */</comment>
        <expr_stmt><expr><name>d</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name>k</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* These multiplications can't fail */</comment>
    <if_stmt><if>if <condition>(<expr><name>k</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_qmul</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_qmul</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>k</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_brmu(z, m) */</comment>

<function><type><specifier>static</specifier> <name>mp_result</name></type>
<name>s_brmu</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>um</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>um</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>s_2expt</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>MP_DIGIT_BIT</name> <operator>*</operator> <name>um</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>mp_int_div</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_reduce(x, m, mu, q1, q2) */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_reduce</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>mu</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>q1</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>q2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>um</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>,
                <decl><type ref="prev"/><name>umb_p1</name></decl>,
                <decl><type ref="prev"/><name>umb_m1</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>umb_p1</name> <operator>=</operator> <operator>(</operator><name>um</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>umb_m1</name> <operator>=</operator> <operator>(</operator><name>um</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>q1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Compute q2 = floor((floor(x / b^(k-1)) * mu) / b^(k+1)) */</comment>
    <expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><name>q1</name></expr></argument>, <argument><expr><name>umb_m1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UMUL</name><argument_list>(<argument><expr><name>q1</name></expr></argument>, <argument><expr><name>mu</name></expr></argument>, <argument><expr><name>q2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><name>q2</name></expr></argument>, <argument><expr><name>umb_p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set x = x mod b^(k+1) */</comment>
    <expr_stmt><expr><call><name>s_qmod</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>umb_p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now, q is a guess for the quotient a / m. Compute x - q * m mod
     * b^(k+1), replacing x.  This may be off by a factor of 2m, but no more
     * than that.
     */</comment>
    <expr_stmt><expr><call><name>UMUL</name><argument_list>(<argument><expr><name>q2</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>q1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>s_qmod</name><argument_list>(<argument><expr><name>q1</name></expr></argument>, <argument><expr><name>umb_p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_sub</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>q1</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* can't fail */</comment>

    <comment type="block">/*
     * The result may be &lt; 0; if it is, add b^(k+1) to pin it in the proper
     * range.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>CMPZ</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>s_qsub</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>umb_p1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If x &gt; m, we need to back it off until it is in range. This will be
     * required at most twice.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>mp_int_compare</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_sub</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>mp_int_compare</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_sub</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* At this point, x has been properly reduced. */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_embar(a, b, m, mu, c) */</comment>

<comment type="block">/* Perform modular exponentiation using Barrett's method, where mu is
   the reduction constant for m.  Assumes a &lt; m, b &gt; 0. */</comment>
<function><type><specifier>static</specifier> <name>mp_result</name></type>
<name>s_embar</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>mu</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>db</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>dbt</name></decl>,
                <decl><type ref="prev"/><name>umu</name></decl>,
                <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mpz_t</name></type>        <name><name>temp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>umu</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>mu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dbt</name> <operator>=</operator> <name>db</name> <operator>+</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>last</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SETUP</name><argument_list>(<argument><expr><call><name>mp_int_init_size</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">4</literal> <operator>*</operator> <name>umu</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><name>last</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_ALLOC</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><name>last</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_set_value</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Take care of low-order digits */</comment>
    <while>while <condition>(<expr><name>db</name> <operator>&lt;</operator> <name>dbt</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>d</name> <operator>=</operator> <operator>*</operator><name>db</name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <name>MP_DIGIT_BIT</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr><operator>,</operator> <expr><name>d</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* The use of a second temporary avoids allocation */</comment>
                <expr_stmt><expr><call><name>UMUL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_reduce</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>mu</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>MP_MEMORY</name></expr>;</expr_stmt>
                    <goto>goto <name>CLEANUP</name>;</goto>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>


            <expr_stmt><expr><call><name>USQR</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_ZPOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_reduce</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>mu</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <name>MP_MEMORY</name></expr>;</expr_stmt>
                <goto>goto <name>CLEANUP</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_ZPOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


        </block_content>}</block></for>

        <expr_stmt><expr><operator>++</operator><name>db</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Take care of highest-order digit */</comment>
    <expr_stmt><expr><name>d</name> <operator>=</operator> <operator>*</operator><name>dbt</name></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>UMUL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_reduce</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>mu</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <name>MP_MEMORY</name></expr>;</expr_stmt>
                <goto>goto <name>CLEANUP</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>d</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>d</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>USQR</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_reduce</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>mu</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <name>MP_MEMORY</name></expr>;</expr_stmt>
            <goto>goto <name>CLEANUP</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

<label><name>CLEANUP</name>:</label>
    <while>while <condition>(<expr><operator>--</operator><name>last</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_udiv(a, b) */</comment>

<comment type="block">/* Precondition:  a &gt;= b and b &gt; 0
   Postcondition: a' = a / b, b' = a % b
 */</comment>
<function><type><specifier>static</specifier> <name>mp_result</name></type>
<name>s_udiv</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mpz_t</name></type>        <name>q</name></decl>,
                <decl><type ref="prev"/><name>r</name></decl>,
                <decl><type ref="prev"/><name>t</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>ua</name></decl>,
                <decl><type ref="prev"/><name>ub</name></decl>,
                <decl><type ref="prev"/><name>qpos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>da</name></decl>,
                <decl><type ref="prev"/><name>btop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>res</name> <init>= <expr><name>MP_OK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>k</name></decl>,
                <decl><type ref="prev"/><name>skip</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Force signs to positive */</comment>
    <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>

    <comment type="block">/* Normalize, per Knuth */</comment>
    <expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>s_norm</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ua</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ub</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>btop</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>ub</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_init_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name>q</name></expr></argument>, <argument><expr><name>ua</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_init_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name>ua</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>CLEANUP</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>da</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>digits</name></name> <operator>=</operator> <name>da</name> <operator>+</operator> <name>ua</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>        <comment type="block">/* The contents of r are shared with a */</comment>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>used</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>sign</name></name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>alloc</name></name> <operator>=</operator> <call><name>MP_ALLOC</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>digits</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>.</operator><name>alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Solve for quotient digits, store in q.digits in reverse order */</comment>
    <while>while <condition>(<expr><name><name>r</name><operator>.</operator><name>digits</name></name> <operator>&gt;=</operator> <name>da</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>qpos</name> <operator>&lt;=</operator> <name><name>q</name><operator>.</operator><name>alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>s_ucmp</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>r</name><operator>.</operator><name>digits</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>r</name><operator>.</operator><name>used</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>++</operator><name>skip</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>q</name><operator>.</operator><name>digits</name><index>[<expr><name>qpos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>mp_word</name></type>        <name>pfx</name> <init>= <expr><name><name>r</name><operator>.</operator><name>digits</name><index>[<expr><name><name>r</name><operator>.</operator><name>used</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>mp_word</name></type>        <name>qdigit</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>r</name><operator>.</operator><name>used</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>pfx</name> <operator>&lt;</operator> <name>btop</name> <operator>||</operator> <name><name>r</name><operator>.</operator><name>digits</name><index>[<expr><name><name>r</name><operator>.</operator><name>used</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>pfx</name> <operator>&lt;&lt;=</operator> <name>MP_DIGIT_BIT</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>pfx</name> <operator>&lt;&lt;=</operator> <name>MP_DIGIT_BIT</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>pfx</name> <operator>|=</operator> <name><name>r</name><operator>.</operator><name>digits</name><index>[<expr><name><name>r</name><operator>.</operator><name>used</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>qdigit</name> <operator>=</operator> <name>pfx</name> <operator>/</operator> <name>btop</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>qdigit</name> <operator>&gt;</operator> <name>MP_DIGIT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>qdigit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>s_dbmul</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>mp_digit</name><operator>)</operator> <name>qdigit</name></expr></argument>, <argument><expr><name><name>t</name><operator>.</operator><name>digits</name></name></expr></argument>, <argument><expr><name>ub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>t</name><operator>.</operator><name>used</name></name> <operator>=</operator> <name>ub</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><call><name>s_ucmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>--</operator><name>qdigit</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_sub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* cannot fail */</comment>
            </block_content>}</block></while>

            <expr_stmt><expr><call><name>s_usub</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>digits</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>.</operator><name>digits</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>digits</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>used</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>.</operator><name>used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>q</name><operator>.</operator><name>digits</name><index>[<expr><name>qpos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>mp_digit</name><operator>)</operator> <name>qdigit</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>digits</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>.</operator><name>used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>skip</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Put quotient digits in the correct order, and discard extra zeroes */</comment>
    <expr_stmt><expr><name><name>q</name><operator>.</operator><name>used</name></name> <operator>=</operator> <name>qpos</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REV</name><argument_list>(<argument><expr><name>mp_digit</name></expr></argument>, <argument><expr><name><name>q</name><operator>.</operator><name>digits</name></name></expr></argument>, <argument><expr><name>qpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><operator>&amp;</operator><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Denormalize the remainder */</comment>
    <expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>k</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* ok:    0 &lt;= r &lt; b */</comment>
    <expr_stmt><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>q</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* ok:    q &lt;= a       */</comment>

    <expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>CLEANUP</name>:</label>
    <expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_outlen(z, r) */</comment>

<comment type="block">/* Precondition:  2 &lt;= r &lt; 64 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_outlen</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_result</name></type>    <name>bits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>raw</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bits</name> <operator>=</operator> <call><name>mp_int_count_bits</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>raw</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>bits</name> <operator>*</operator> <name><name>s_log2</name><index>[<expr><name>r</name></expr>]</index></name></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>raw</name> <operator>+</operator> <literal type="number">0.999999</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_inlen(len, r) */</comment>

<function><type><specifier>static</specifier> <name>mp_size</name></type>
<name>s_inlen</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>raw</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator> <name>len</name> <operator>/</operator> <name><name>s_log2</name><index>[<expr><name>r</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>bits</name> <init>= <expr><operator>(</operator><name>mp_size</name><operator>)</operator> <operator>(</operator><name>raw</name> <operator>+</operator> <literal type="number">0.5</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

    <return>return <expr><operator>(</operator><name>mp_size</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>bits</name> <operator>+</operator> <operator>(</operator><name>MP_DIGIT_BIT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>MP_DIGIT_BIT</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_ch2val(c, r) */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_ch2val</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>out</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>r</name> <operator>&gt;</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator> <call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="char">'A'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>

    <return>return <expr><ternary><condition><expr><operator>(</operator><name>out</name> <operator>&gt;=</operator> <name>r</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>out</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_val2ch(v, caps) */</comment>

<function><type><specifier>static</specifier> <name>char</name></type>
<name>s_val2ch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>caps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>v</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>v</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</return></block_content></block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name>out</name> <init>= <expr><operator>(</operator><name>v</name> <operator>-</operator> <literal type="number">10</literal><operator>)</operator> <operator>+</operator> <literal type="char">'a'</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>caps</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>out</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><name>out</name></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_2comp(buf, len) */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_2comp</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>s</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><operator>~</operator><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>s</name> <operator>=</operator> <name>c</name> <operator>+</operator> <name>s</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name>s</name> <operator>&amp;</operator> <name>UCHAR_MAX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> <operator>&gt;&gt;=</operator> <name>CHAR_BIT</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* last carry out is ignored */</comment>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_tobin(z, buf, *limpos) */</comment>

<function><type><specifier>static</specifier> <name>mp_result</name></type>
<name>s_tobin</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>limpos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pad</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mp_size</name></type>        <name>uz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>limit</name> <init>= <expr><operator>*</operator><name>limpos</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>uz</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dz</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>uz</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pos</name> <operator>&lt;</operator> <name>limit</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>mp_digit</name></type>    <name>d</name> <init>= <expr><operator>*</operator><name>dz</name><operator>++</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>mp_digit</name></expr></argument>)</argument_list></sizeof></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pos</name> <operator>&lt;</operator> <name>limit</name></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>d</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>d</name> <operator>&gt;&gt;=</operator> <name>CHAR_BIT</name></expr>;</expr_stmt>

            <comment type="block">/* Don't write leading zeroes */</comment>
            <if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>uz</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>            <comment type="block">/* exit loop without signaling truncation */</comment>
        </block_content>}</block></for>

        <comment type="block">/* Detect truncation (loop exited with pos &gt;= limit) */</comment>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><operator>--</operator><name>uz</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>pad</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>buf</name><index>[<expr><name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <operator>(</operator><name>CHAR_BIT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>limit</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>uz</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Digits are in reverse order, fix that */</comment>
    <macro><name>REV</name><argument_list>(<argument>unsigned char</argument>, <argument>buf</argument>, <argument>pos</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <comment type="block">/* Return the number of bytes actually written */</comment>
    <expr_stmt><expr><operator>*</operator><name>limpos</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>

    <return>return <expr><ternary><condition><expr><operator>(</operator><name>uz</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>MP_OK</name></expr> </then><else>: <expr><name>MP_TRUNC</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }}} */</comment>

<comment type="block">/* {{{ s_print(tag, z) */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
void
s_print(char *tag, mp_int z)
{
    int            i;

    fprintf(stderr, "%s: %c ", tag,
            (MP_SIGN(z) == MP_NEG) ? '-' : '+');

    for (i = MP_USED(z) - 1; i &gt;= 0; --i)
        fprintf(stderr, "%0*X", (int) (MP_DIGIT_BIT / 4), z-&gt;digits[i]);

    fputc('\n', stderr);

}

void
s_print_buf(char *tag, mp_digit *buf, mp_size num)
{
    int            i;

    fprintf(stderr, "%s: ", tag);

    for (i = num - 1; i &gt;= 0; --i)
        fprintf(stderr, "%0*X", (int) (MP_DIGIT_BIT / 4), buf[i]);

    fputc('\n', stderr);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* }}} */</comment>

<comment type="block">/* HERE THERE BE DRAGONS */</comment>
</unit>
