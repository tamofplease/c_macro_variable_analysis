<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/fts3/fts3_expr.c"><comment type="block">/*
** 2008 Nov 28
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This module contains code that implements a parser for fts3 query strings
** (the right-hand argument to the MATCH operator). Because the supported 
** syntax is relatively simple, the whole tokenizer/parser system is
** hand-coded. 
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fts3Int.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_CORE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_FTS3</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/*
** By default, this module parses the legacy syntax that has been 
** traditionally used by fts3. Or, if SQLITE_ENABLE_FTS3_PARENTHESIS
** is defined, then it uses the new syntax. The differences between
** the new and the old syntaxes are:
**
**  a) The new syntax supports parenthesis. The old does not.
**
**  b) The new syntax supports the AND and NOT operators. The old does not.
**
**  c) The old syntax supports the "-" token qualifier. This is not 
**     supported by the new syntax (it is replaced by the NOT operator).
**
**  d) When using the old syntax, the OR operator has a greater precedence
**     than an implicit AND. When using the new, both implicity and explicit
**     AND operators have a higher precedence than OR.
**
** If compiled with SQLITE_TEST defined, then this module exports the
** symbol "int sqlite3_fts3_enable_parentheses". Setting this variable
** to zero causes the module to use the old syntax. If it is set to 
** non-zero the new syntax is activated. This is so both syntaxes can
** be tested using a single build of testfixture.
**
** The following describes the syntax supported by the fts3 MATCH
** operator in a similar format to that used by the lemon parser
** generator. This module does not use actually lemon, it uses a
** custom parser.
**
**   query ::= andexpr (OR andexpr)*.
**
**   andexpr ::= notexpr (AND? notexpr)*.
**
**   notexpr ::= nearexpr (NOT nearexpr|-TOKEN)*.
**   notexpr ::= LP query RP.
**
**   nearexpr ::= phrase (NEAR distance_opt nearexpr)*.
**
**   distance_opt ::= .
**   distance_opt ::= / INTEGER.
**
**   phrase ::= TOKEN.
**   phrase ::= COLUMN:TOKEN.
**   phrase ::= "TOKEN TOKEN TOKEN...".
*/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_fts3_enable_parentheses</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS3_PARENTHESIS</name></cpp:ifdef> 
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3_fts3_enable_parentheses</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3_fts3_enable_parentheses</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Default span for NEAR operators.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_FTS3_DEFAULT_NEAR_PARAM</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** isNot:
**   This variable is used by function getNextNode(). When getNextNode() is
**   called, it sets ParseContext.isNot to true if the 'next node' is a 
**   FTSQUERY_PHRASE with a unary "-" attached to it. i.e. "mysql" in the
**   FTS3 query "sqlite -mysql". Otherwise, ParseContext.isNot is set to
**   zero.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ParseContext</name></name></type> <name>ParseContext</name>;</typedef>
<struct>struct <name>ParseContext</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl>;</decl_stmt>      <comment type="block">/* Tokenizer module */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLangid</name></decl>;</decl_stmt>                        <comment type="block">/* Language id used with tokenizer */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name></decl>;</decl_stmt>                 <comment type="block">/* Array of column names for fts3 table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bFts4</name></decl>;</decl_stmt>                          <comment type="block">/* True to allow FTS4-only syntax */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                           <comment type="block">/* Number of entries in azCol[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDefaultCol</name></decl>;</decl_stmt>                    <comment type="block">/* Default column to query */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isNot</name></decl>;</decl_stmt>                          <comment type="block">/* True if getNextNode() sees a unary - */</comment>
  <decl_stmt><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>              <comment type="block">/* Write error message here */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nNest</name></decl>;</decl_stmt>                          <comment type="block">/* Number of nested brackets */</comment>
}</block>;</struct>

<comment type="block">/*
** This function is equivalent to the standard isspace() function. 
**
** The standard isspace() can be awkward to use safely, because although it
** is defined to accept an argument of type int, its behavior when passed
** an integer that falls outside of the range of the unsigned char type
** is undefined (and sometimes, "undefined" means segfault). This wrapper
** is defined to accept an argument of type char, and always returns 0 for
** any values that fall outside of the range of the unsigned char type (i.e.
** negative values).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3isspace</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>c</name><operator>==</operator><literal type="char">' '</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\t'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\n'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\r'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\v'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\f'</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate nByte bytes of memory using sqlite3_malloc(). If successful,
** zero the memory before returning a pointer to it. If unsuccessful, 
** return NULL.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3Fts3MallocZero</name><parameter_list>(<parameter><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlite3Fts3OpenTokenizer</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCsr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_module</name> <specifier>const</specifier> <modifier>*</modifier></type><name>pModule</name> <init>= <expr><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pTokenizer</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>pCsr</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pTokenizer</name></name> <operator>=</operator> <name>pTokenizer</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pModule</name><operator>-&gt;</operator><name>iVersion</name></name><operator>&gt;=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xLanguageid</name></name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name><name>pModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCsr</name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Function getNextNode(), which is called by fts3ExprParse(), may itself
** call fts3ExprParse(). So this forward declaration is required.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>fts3ExprParse</name><parameter_list>(<parameter><decl><type><name>ParseContext</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Extract the next token from buffer z (length n) using the tokenizer
** and other information (column names etc.) in pParse. Create an Fts3Expr
** structure of type FTSQUERY_PHRASE containing a phrase consisting of this
** single token and set *ppExpr to point to it. If the end of the buffer is
** reached before a token is found, set *ppExpr to zero. It is the
** responsibility of the caller to eventually deallocate the allocated 
** Fts3Expr structure (if any) by passing it to sqlite3_free().
**
** Return SQLITE_OK if successful, or SQLITE_NOMEM if a memory allocation
** fails.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getNextToken</name><parameter_list>(
  <parameter><decl><type><name>ParseContext</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                   <comment type="block">/* fts3 query parse context */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>,                               <comment type="block">/* Value for Fts3Phrase.iColumn */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,                   <comment type="block">/* Input string */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppExpr</name></decl></parameter>,                      <comment type="block">/* OUT: expression */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnConsumed</name></decl></parameter>                         <comment type="block">/* OUT: Number of bytes consumed */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_module</name> <specifier>const</specifier> <modifier>*</modifier></type><name>pModule</name> <init>= <expr><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Set variable i to the maximum number of bytes of input to tokenize. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>sqlite3_fts3_enable_parentheses</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'('</literal> <operator>||</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">')'</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><operator>*</operator><name>pnConsumed</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3OpenTokenizer</name><argument_list>(<argument><expr><name>pTokenizer</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>iLangid</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zToken</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nToken</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>iStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>iEnd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>iPosition</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl>;</decl_stmt>                    <comment type="block">/* total space to allocate */</comment>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xNext</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iStart</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Fts3Expr</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Fts3Phrase</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nToken</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pRet</name> <operator>=</operator> <operator>(</operator><name>Fts3Expr</name> <operator>*</operator><operator>)</operator><call><name>sqlite3Fts3MallocZero</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pRet</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <name>FTSQUERY_PHRASE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>pPhrase</name></name> <operator>=</operator> <operator>(</operator><name>Fts3Phrase</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pRet</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>n</name> <operator>=</operator> <name>nToken</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>z</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pRet</name><operator>-&gt;</operator><name>pPhrase</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pRet</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name>zToken</name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><name>iEnd</name><operator>&lt;</operator><name>n</name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>iEnd</name></expr>]</index></name><operator>==</operator><literal type="char">'*'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isPrefix</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>iEnd</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><name>sqlite3_fts3_enable_parentheses</name> 
           <operator>&amp;&amp;</operator> <name>iStart</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>iStart</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> 
          )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>isNot</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>iStart</name><operator>--</operator></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>bFts4</name></name> <operator>&amp;&amp;</operator> <name>iStart</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>iStart</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'^'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>bFirst</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>iStart</name><operator>--</operator></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <break>break;</break>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>

      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>pnConsumed</name> <operator>=</operator> <name>iEnd</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>i</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name><name>pModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <expr_stmt><expr><operator>*</operator><name>ppExpr</name> <operator>=</operator> <name>pRet</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Enlarge a memory allocation.  If an out-of-memory allocation occurs,
** then free the old allocation.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>fts3ReallocOrFree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOrig</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>nNew</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name>pOrig</name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pRet</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pOrig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Buffer zInput, length nInput, contains the contents of a quoted string
** that appeared as part of an fts3 query expression. Neither quote character
** is included in the buffer. This function attempts to tokenize the entire
** input buffer and create an Fts3Expr structure of type FTSQUERY_PHRASE 
** containing the results.
**
** If successful, SQLITE_OK is returned and *ppExpr set to point at the
** allocated Fts3Expr structure. Otherwise, either SQLITE_NOMEM (out of memory
** error) or SQLITE_ERROR (tokenization error) is returned and *ppExpr set
** to 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getNextString</name><parameter_list>(
  <parameter><decl><type><name>ParseContext</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                   <comment type="block">/* fts3 query parse context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInput</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nInput</name></decl></parameter>,         <comment type="block">/* Input string */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppExpr</name></decl></parameter>                       <comment type="block">/* OUT: expression */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_module</name> <specifier>const</specifier> <modifier>*</modifier></type><name>pModule</name> <init>= <expr><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCursor</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTemp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTemp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nSpace</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3Expr</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Fts3Phrase</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nToken</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* The final Fts3Expr data structure, including the Fts3Phrase,
  ** Fts3PhraseToken structures token buffers are all stored as a single 
  ** allocation so that the expression can be freed with a single call to
  ** sqlite3_free(). Setting this up requires a two pass approach.
  **
  ** The first pass, in the block below, uses a tokenizer cursor to iterate
  ** through the tokens in the expression. This pass uses fts3ReallocOrFree()
  ** to assemble data in two dynamic buffers:
  **
  **   Buffer p: Points to the Fts3Expr structure, followed by the Fts3Phrase
  **             structure, followed by the array of Fts3PhraseToken 
  **             structures. This pass only populates the Fts3PhraseToken array.
  **
  **   Buffer zTemp: Contains copies of all tokens.
  **
  ** The second pass, in the block that begins "if( rc==SQLITE_DONE )" below,
  ** appends buffer zTemp to buffer p, and fills in the Fts3Expr and Fts3Phrase
  ** structures.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3OpenTokenizer</name><argument_list>(
      <argument><expr><name>pTokenizer</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>iLangid</name></name></expr></argument>, <argument><expr><name>zInput</name></expr></argument>, <argument><expr><name>nInput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zByte</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>iBegin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>iEnd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>iPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xNext</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zByte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBegin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Fts3PhraseToken</name> <modifier>*</modifier></type><name>pToken</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>fts3ReallocOrFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nSpace</name> <operator>+</operator> <name>ii</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3PhraseToken</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>zTemp</name> <operator>=</operator> <call><name>fts3ReallocOrFree</name><argument_list>(<argument><expr><name>zTemp</name></expr></argument>, <argument><expr><name>nTemp</name> <operator>+</operator> <name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zTemp</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nToken</name><operator>==</operator><name>ii</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pToken</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>Fts3Phrase</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name><name>aToken</name><index>[<expr><name>ii</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pToken</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3PhraseToken</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zTemp</name><index>[<expr><name>nTemp</name></expr>]</index></name></expr></argument>, <argument><expr><name>zByte</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nTemp</name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>isPrefix</name></name> <operator>=</operator> <operator>(</operator><name>iEnd</name><operator>&lt;</operator><name>nInput</name> <operator>&amp;&amp;</operator> <name><name>zInput</name><index>[<expr><name>iEnd</name></expr>]</index></name><operator>==</operator><literal type="char">'*'</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>bFirst</name></name> <operator>=</operator> <operator>(</operator><name>iBegin</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zInput</name><index>[<expr><name>iBegin</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'^'</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>nToken</name> <operator>=</operator> <name>ii</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name><name>pModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCursor</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>jj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>fts3ReallocOrFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nSpace</name> <operator>+</operator> <name>nToken</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3PhraseToken</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>Fts3Phrase</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name><name>aToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>-</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <name>FTSQUERY_PHRASE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPhrase</name></name> <operator>=</operator> <operator>(</operator><name>Fts3Phrase</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>iDefaultCol</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name> <operator>=</operator> <name>nToken</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>nToken</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zTemp</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>, <argument><expr><name>nTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nTemp</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>jj</name></expr>]</index></name><operator>.</operator><name>z</name> <operator>=</operator> <name>zBuf</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zBuf</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>jj</name></expr>]</index></name><operator>.</operator><name>n</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppExpr</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
<label><name>no_mem</name>:</label>

  <if_stmt><if>if<condition>( <expr><name>pCursor</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>pModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppExpr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The output variable *ppExpr is populated with an allocated Fts3Expr 
** structure, or set to 0 if the end of the input buffer is reached.
**
** Returns an SQLite error code. SQLITE_OK if everything works, SQLITE_NOMEM
** if a malloc failure occurs, or SQLITE_ERROR if a parse error is encountered.
** If SQLITE_ERROR is returned, pContext is populated with an error message.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getNextNode</name><parameter_list>(
  <parameter><decl><type><name>ParseContext</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                   <comment type="block">/* fts3 query parse context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,                   <comment type="block">/* Input string */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppExpr</name></decl></parameter>,                      <comment type="block">/* OUT: expression */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnConsumed</name></decl></parameter>                         <comment type="block">/* OUT: Number of bytes consumed */</comment>
)</parameter_list><block>{<block_content>
  <struct><specifier>static</specifier> <specifier>const</specifier> struct <name>Fts3Keyword</name> <block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>                              <comment type="block">/* Keyword text */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>n</name></decl>;</decl_stmt>                      <comment type="block">/* Length of the keyword */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>parenOnly</name></decl>;</decl_stmt>              <comment type="block">/* Only valid in paren mode */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>eType</name></decl>;</decl_stmt>                  <comment type="block">/* Keyword code */</comment>
  }</block> <decl><name><name>aKeyword</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"OR"</literal></expr> ,  <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FTSQUERY_OR</name></expr>   }</block></expr>,
    <expr><block>{ <expr><literal type="string">"AND"</literal></expr>,  <expr><literal type="number">3</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>FTSQUERY_AND</name></expr>  }</block></expr>,
    <expr><block>{ <expr><literal type="string">"NOT"</literal></expr>,  <expr><literal type="number">3</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>FTSQUERY_NOT</name></expr>  }</block></expr>,
    <expr><block>{ <expr><literal type="string">"NEAR"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FTSQUERY_NEAR</name></expr> }</block></expr>
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iColLen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInput</name> <init>= <expr><name>z</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nInput</name> <init>= <expr><name>n</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>isNot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Skip over any whitespace before checking for a keyword, an open or
  ** close bracket, or a quoted string. 
  */</comment>
  <while>while<condition>( <expr><name>nInput</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>fts3isspace</name><argument_list>(<argument><expr><operator>*</operator><name>zInput</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nInput</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>zInput</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>nInput</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* See if we are dealing with a keyword. */</comment>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aKeyword</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>Fts3Keyword</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>Fts3Keyword</name></name> <modifier>*</modifier></type><name>pKey</name> <init>= <expr><operator>&amp;</operator><name><name>aKeyword</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pKey</name><operator>-&gt;</operator><name>parenOnly</name></name> <operator>&amp;</operator> <operator>~</operator><name>sqlite3_fts3_enable_parentheses</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>nInput</name><operator>&gt;=</operator><name><name>pKey</name><operator>-&gt;</operator><name>n</name></name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>zInput</name></expr></argument>, <argument><expr><name><name>pKey</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pKey</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nNear</name> <init>= <expr><name>SQLITE_FTS3_DEFAULT_NEAR_PARAM</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> <init>= <expr><name><name>pKey</name><operator>-&gt;</operator><name>n</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name>cNext</name></decl>;</decl_stmt>

      <comment type="block">/* If this is a "NEAR" keyword, check for an explicit nearness. */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pKey</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_NEAR</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nKey</name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>zInput</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>zInput</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>zInput</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>nKey</name> <operator>+=</operator> <literal type="number">1</literal><operator>+</operator><call><name>sqlite3Fts3ReadInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zInput</name><index>[<expr><name>nKey</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nNear</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* At this point this is probably a keyword. But for that to be true,
      ** the next byte must contain either whitespace, an open or close
      ** parenthesis, a quote character, or EOF. 
      */</comment>
      <expr_stmt><expr><name>cNext</name> <operator>=</operator> <name><name>zInput</name><index>[<expr><name>nKey</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>fts3isspace</name><argument_list>(<argument><expr><name>cNext</name></expr></argument>)</argument_list></call> 
       <operator>||</operator> <name>cNext</name><operator>==</operator><literal type="char">'"'</literal> <operator>||</operator> <name>cNext</name><operator>==</operator><literal type="char">'('</literal> <operator>||</operator> <name>cNext</name><operator>==</operator><literal type="char">')'</literal> <operator>||</operator> <name>cNext</name><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>pRet</name> <operator>=</operator> <operator>(</operator><name>Fts3Expr</name> <operator>*</operator><operator>)</operator><call><name>sqlite3Fts3MallocZero</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3Expr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pRet</name></expr> )</condition><block>{<block_content>
          <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <name><name>pKey</name><operator>-&gt;</operator><name>eType</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>nNear</name></name> <operator>=</operator> <name>nNear</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>ppExpr</name> <operator>=</operator> <name>pRet</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pnConsumed</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>zInput</name> <operator>-</operator> <name>z</name><operator>)</operator> <operator>+</operator> <name>nKey</name><operator>)</operator></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Turns out that wasn't a keyword after all. This happens if the
      ** user has supplied a token such as "ORacle". Continue.
      */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* See if we are dealing with a quoted phrase. If this is the case, then
  ** search for the closing quote and pass the whole string to getNextString()
  ** for processing. This is easy to do, as fts3 has no syntax for escaping
  ** a quote character embedded in a string.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>zInput</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nInput</name> <operator>&amp;&amp;</operator> <name><name>zInput</name><index>[<expr><name>ii</name></expr>]</index></name><operator>!=</operator><literal type="char">'"'</literal></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <expr_stmt><expr><operator>*</operator><name>pnConsumed</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>zInput</name> <operator>-</operator> <name>z</name><operator>)</operator> <operator>+</operator> <name>ii</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>ii</name><operator>==</operator><name>nInput</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>getNextString</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ii</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ppExpr</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>sqlite3_fts3_enable_parentheses</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>zInput</name><operator>==</operator><literal type="char">'('</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nConsumed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nNest</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_MAX_EXPR_DEPTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nNest</name></name><operator>&gt;</operator><literal type="number">1000</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_MAX_EXPR_DEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:elif>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nNest</name></name><operator>&gt;</operator><name>SQLITE_MAX_EXPR_DEPTH</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zInput</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>nInput</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ppExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nConsumed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pnConsumed</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zInput</name> <operator>-</operator> <name>z</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>nConsumed</name></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>*</operator><name>zInput</name><operator>==</operator><literal type="char">')'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nNest</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pnConsumed</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>zInput</name> <operator>-</operator> <name>z</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>ppExpr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If control flows to this point, this must be a regular token, or 
  ** the end of the input. Read a regular token using the sqlite3_tokenizer
  ** interface. Before doing so, figure out if there is an explicit
  ** column specifier for the token. 
  **
  ** TODO: Strangely, it is not possible to associate a column specifier
  ** with a quoted phrase, only with a single token. Not sure if this was
  ** an implementation artifact or an intentional decision when fts3 was
  ** first implemented. Whichever it was, this module duplicates the 
  ** limitation.
  */</comment>
  <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>iDefaultCol</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iColLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStr</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>azCol</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nStr</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>nInput</name><operator>&gt;</operator><name>nStr</name> <operator>&amp;&amp;</operator> <name><name>zInput</name><index>[<expr><name>nStr</name></expr>]</index></name><operator>==</operator><literal type="char">':'</literal> 
     <operator>&amp;&amp;</operator> <call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zStr</name></expr></argument>, <argument><expr><name>zInput</name></expr></argument>, <argument><expr><name>nStr</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> 
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name>ii</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iColLen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>zInput</name> <operator>-</operator> <name>z</name><operator>)</operator> <operator>+</operator> <name>nStr</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>getNextToken</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>iColLen</name></expr>]</index></name></expr></argument>, <argument><expr><name>n</name><operator>-</operator><name>iColLen</name></expr></argument>, <argument><expr><name>ppExpr</name></expr></argument>, <argument><expr><name>pnConsumed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnConsumed</name> <operator>+=</operator> <name>iColLen</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The argument is an Fts3Expr structure for a binary operator (any type
** except an FTSQUERY_PHRASE). Return an integer value representing the
** precedence of the operator. Lower values have a higher precedence (i.e.
** group more tightly). For example, in the C language, the == operator
** groups more tightly than ||, and would therefore have a higher precedence.
**
** When using the new fts3 query syntax (when SQLITE_ENABLE_FTS3_PARENTHESIS
** is defined), the order of the operators in precedence from highest to
** lowest is:
**
**   NEAR
**   NOT
**   AND (including implicit ANDs)
**   OR
**
** Note that when using the old query syntax, the OR operator has a higher
** precedence than the AND operator.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>opPrecedence</name><parameter_list>(<parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>!=</operator><name>FTSQUERY_PHRASE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>sqlite3_fts3_enable_parentheses</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_NEAR</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_OR</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_AND</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">3</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Argument ppHead contains a pointer to the current head of a query 
** expression tree being parsed. pPrev is the expression node most recently
** inserted into the tree. This function adds pNew, which is always a binary
** operator node, into the expression tree based on the relative precedence
** of pNew and the existing nodes of the tree. This may result in the head
** of the tree changing, in which case *ppHead is set to the new root node.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>insertBinaryOperator</name><parameter_list>(
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppHead</name></decl></parameter>,       <comment type="block">/* Pointer to the root node of a tree */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pPrev</name></decl></parameter>,         <comment type="block">/* Node most recently inserted into the tree */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pNew</name></decl></parameter>           <comment type="block">/* New binary node to insert into expression tree */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pSplit</name> <init>= <expr><name>pPrev</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name><name>pSplit</name><operator>-&gt;</operator><name>pParent</name></name> <operator>&amp;&amp;</operator> <call><name>opPrecedence</name><argument_list>(<argument><expr><name><name>pSplit</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call><operator>&lt;=</operator><call><name>opPrecedence</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pSplit</name> <operator>=</operator> <name><name>pSplit</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name><name>pSplit</name><operator>-&gt;</operator><name>pParent</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSplit</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><name>pSplit</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSplit</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name><name>pSplit</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppHead</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pSplit</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSplit</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Parse the fts3 query expression found in buffer z, length n. This function
** returns either when the end of the buffer is reached or an unmatched 
** closing bracket - ')' - is encountered.
**
** If successful, SQLITE_OK is returned, *ppExpr is set to point to the
** parsed form of the expression and *pnConsumed is set to the number of
** bytes read from buffer z. Otherwise, *ppExpr is set to 0 and SQLITE_NOMEM
** (out of memory error) or SQLITE_ERROR (parse error) is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ExprParse</name><parameter_list>(
  <parameter><decl><type><name>ParseContext</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                   <comment type="block">/* fts3 query parse context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,                   <comment type="block">/* Text of MATCH query */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppExpr</name></decl></parameter>,                      <comment type="block">/* OUT: Parsed query structure */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnConsumed</name></decl></parameter>                         <comment type="block">/* OUT: Number of bytes consumed */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pPrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pNotBranch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Only used in legacy parse mode */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nIn</name> <init>= <expr><name>n</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><name>z</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isRequirePhrase</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>getNextNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>p</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>isPhrase</name></decl>;</decl_stmt>

        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>sqlite3_fts3_enable_parentheses</name> 
            <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_PHRASE</name> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>isNot</name></name></expr> 
        )</condition><block>{<block_content>
          <comment type="block">/* Create an implicit NOT operator. */</comment>
          <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pNot</name> <init>= <expr><call><name>sqlite3Fts3MallocZero</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3Expr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pNot</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3Fts3ExprFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
            <goto>goto <name>exprparse_out</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>pNot</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <name>FTSQUERY_NOT</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNot</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pNot</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>pNotBranch</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pNot</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pNotBranch</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pNotBranch</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pNot</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>pNotBranch</name> <operator>=</operator> <name>pNot</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pPrev</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>isPhrase</name> <operator>=</operator> <operator>(</operator><name>eType</name><operator>==</operator><name>FTSQUERY_PHRASE</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name><operator>)</operator></expr>;</expr_stmt>

          <comment type="block">/* The isRequirePhrase variable is set to true if a phrase or
          ** an expression contained in parenthesis is required. If a
          ** binary operator (AND, OR, NOT or NEAR) is encounted when
          ** isRequirePhrase is set, this is a syntax error.
          */</comment>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isPhrase</name> <operator>&amp;&amp;</operator> <name>isRequirePhrase</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3Fts3ExprFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
            <goto>goto <name>exprparse_out</name>;</goto>
          </block_content>}</block></if></if_stmt>

          <if_stmt><if>if<condition>( <expr><name>isPhrase</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isRequirePhrase</name></expr> )</condition><block>{<block_content>
            <comment type="block">/* Insert an implicit AND operator. */</comment>
            <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pAnd</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRet</name> <operator>&amp;&amp;</operator> <name>pPrev</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pAnd</name> <operator>=</operator> <call><name>sqlite3Fts3MallocZero</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3Expr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pAnd</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3Fts3ExprFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
              <goto>goto <name>exprparse_out</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>pAnd</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <name>FTSQUERY_AND</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>insertBinaryOperator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pRet</name></expr></argument>, <argument><expr><name>pPrev</name></expr></argument>, <argument><expr><name>pAnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pPrev</name> <operator>=</operator> <name>pAnd</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

          <comment type="block">/* This test catches attempts to make either operand of a NEAR
           ** operator something other than a phrase. For example, either of
           ** the following:
           **
           **    (bracketed expression) NEAR phrase
           **    phrase NEAR (bracketed expression)
           **
           ** Return an error in either case.
           */</comment>
          <if_stmt><if>if<condition>( <expr><name>pPrev</name> <operator>&amp;&amp;</operator> <operator>(</operator>
            <operator>(</operator><name>eType</name><operator>==</operator><name>FTSQUERY_NEAR</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isPhrase</name> <operator>&amp;&amp;</operator> <name><name>pPrev</name><operator>-&gt;</operator><name>eType</name></name><operator>!=</operator><name>FTSQUERY_PHRASE</name><operator>)</operator>
         <operator>||</operator> <operator>(</operator><name>eType</name><operator>!=</operator><name>FTSQUERY_PHRASE</name> <operator>&amp;&amp;</operator> <name>isPhrase</name> <operator>&amp;&amp;</operator> <name><name>pPrev</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_NEAR</name><operator>)</operator>
          <operator>)</operator></expr>)</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3Fts3ExprFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
            <goto>goto <name>exprparse_out</name>;</goto>
          </block_content>}</block></if></if_stmt>

          <if_stmt><if>if<condition>( <expr><name>isPhrase</name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPrev</name> <operator>&amp;&amp;</operator> <name><name>pPrev</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>&amp;&amp;</operator> <name><name>pPrev</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pPrev</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pPrev</name></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name>pRet</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>insertBinaryOperator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pRet</name></expr></argument>, <argument><expr><name>pPrev</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name>isRequirePhrase</name> <operator>=</operator> <operator>!</operator><name>isPhrase</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>pPrev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>(</operator><name>nByte</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nByte</name><operator>&lt;=</operator><name>nIn</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nIn</name> <operator>-=</operator> <name>nByte</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zIn</name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name> <operator>&amp;&amp;</operator> <name>pRet</name> <operator>&amp;&amp;</operator> <name>isRequirePhrase</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>sqlite3_fts3_enable_parentheses</name> <operator>&amp;&amp;</operator> <name>pNotBranch</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pRet</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pIter</name> <init>= <expr><name>pNotBranch</name></expr></init></decl>;</decl_stmt>
        <while>while<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>pLeft</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pIter</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name><name>pIter</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pRet</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pIter</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pRet</name> <operator>=</operator> <name>pNotBranch</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnConsumed</name> <operator>=</operator> <name>n</name> <operator>-</operator> <name>nIn</name></expr>;</expr_stmt>

<label><name>exprparse_out</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Fts3ExprFree</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Fts3ExprFree</name><argument_list>(<argument><expr><name>pNotBranch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppExpr</name> <operator>=</operator> <name>pRet</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return SQLITE_ERROR if the maximum depth of the expression tree passed 
** as the only argument is more than nMaxDepth.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ExprCheckDepth</name><parameter_list>(<parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMaxDepth</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nMaxDepth</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> 
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_TOOBIG</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprCheckDepth</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>nMaxDepth</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprCheckDepth</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>nMaxDepth</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function attempts to transform the expression tree at (*pp) to
** an equivalent but more balanced form. The tree is modified in place.
** If successful, SQLITE_OK is returned and (*pp) set to point to the 
** new root expression node. 
**
** nMaxDepth is the maximum allowable depth of the balanced sub-tree.
**
** Otherwise, if an error occurs, an SQLite error code is returned and 
** expression (*pp) freed.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ExprBalance</name><parameter_list>(<parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMaxDepth</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pRoot</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>          <comment type="block">/* Initial root node */</comment>
  <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* List of free nodes. Linked by pParent. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><name><name>pRoot</name><operator>-&gt;</operator><name>eType</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Type of node in this tree */</comment>

  <if_stmt><if>if<condition>( <expr><name>nMaxDepth</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>eType</name><operator>==</operator><name>FTSQUERY_AND</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>FTSQUERY_OR</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>apLeaf</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>apLeaf</name> <operator>=</operator> <operator>(</operator><name>Fts3Expr</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3Expr</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nMaxDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>apLeaf</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>apLeaf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3Expr</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nMaxDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

        <comment type="block">/* Set $p to point to the left-most leaf in the tree of eType nodes. */</comment>
        <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pRoot</name></expr>;</init> <condition><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>eType</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pParent</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pLeft</name></name><operator>==</operator><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* This loop runs once for each leaf in the tree of eType nodes. */</comment>
        <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>iLvl</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pParent</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pParent</name></name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Current parent of p */</comment>

          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParent</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParent</name><operator>-&gt;</operator><name>pLeft</name></name><operator>==</operator><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>pParent</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pParent</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprBalance</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>nMaxDepth</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

          <for>for<control>(<init><expr><name>iLvl</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>p</name> <operator>&amp;&amp;</operator> <name>iLvl</name><operator>&lt;</operator><name>nMaxDepth</name></expr>;</condition> <incr><expr><name>iLvl</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>apLeaf</name><index>[<expr><name>iLvl</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name><name>apLeaf</name><index>[<expr><name>iLvl</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFree</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pFree</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>apLeaf</name><index>[<expr><name>iLvl</name></expr>]</index></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pFree</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pFree</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pFree</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pFree</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pFree</name></expr>;</expr_stmt>

              <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pFree</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>pFree</name> <operator>=</operator> <name><name>pFree</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>apLeaf</name><index>[<expr><name>iLvl</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></for>
          <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3Fts3ExprFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_TOOBIG</name></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>

          <comment type="block">/* If that was the last leaf node, break out of the loop */</comment>
          <if_stmt><if>if<condition>( <expr><name>pParent</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

          <comment type="block">/* Set $p to point to the next leaf in the tree of eType nodes */</comment>
          <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pParent</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</init> <condition><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>eType</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>

          <comment type="block">/* Remove pParent from the original tree. */</comment>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>pParent</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParent</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pLeft</name></name><operator>==</operator><name>pParent</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pParent</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pParent</name><operator>-&gt;</operator><name>pParent</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pParent</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParent</name><operator>==</operator><name>pRoot</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>

          <comment type="block">/* Link pParent into the free node list. It will be used as an
          ** internal node of the new tree.  */</comment>
          <expr_stmt><expr><name><name>pParent</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pFree</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pFree</name> <operator>=</operator> <name>pParent</name></expr>;</expr_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nMaxDepth</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>apLeaf</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>apLeaf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
              </block_content>}</block></if><else>else<block>{<block_content>
                <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFree</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pFree</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pFree</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>apLeaf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pFree</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pFree</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pFree</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pFree</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pFree</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pFree</name> <operator>=</operator> <name><name>pFree</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* An error occurred. Delete the contents of the apLeaf[] array 
          ** and pFree list. Everything else is cleaned up by the call to
          ** sqlite3Fts3ExprFree(pRoot) below.  */</comment>
          <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pDel</name></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nMaxDepth</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3Fts3ExprFree</name><argument_list>(<argument><expr><name><name>apLeaf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
          <while>while<condition>( <expr><operator>(</operator><name>pDel</name><operator>=</operator><name>pFree</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>pFree</name> <operator>=</operator> <name><name>pDel</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></while>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFree</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>( <argument><expr><name>apLeaf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eType</name><operator>==</operator><name>FTSQUERY_NOT</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><name><name>pRoot</name><operator>-&gt;</operator><name>pLeft</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><name><name>pRoot</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLeft</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprBalance</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pLeft</name></expr></argument>, <argument><expr><name>nMaxDepth</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprBalance</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pRight</name></expr></argument>, <argument><expr><name>nMaxDepth</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3Fts3ExprFree</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3Fts3ExprFree</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLeft</name> <operator>&amp;&amp;</operator> <name>pRight</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pLeft</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pLeft</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pRoot</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name>pRight</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pRoot</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Fts3ExprFree</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>pRoot</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is similar to sqlite3Fts3ExprParse(), with the following
** differences:
**
**   1. It does not do expression rebalancing.
**   2. It does not check that the expression does not exceed the 
**      maximum allowable depth.
**   3. Even if it fails, *ppExpr may still be set to point to an 
**      expression tree. It should be deleted using sqlite3Fts3ExprFree()
**      in this case.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ExprParseUnbalanced</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl></parameter>,      <comment type="block">/* Tokenizer module */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>,                        <comment type="block">/* Language id for tokenizer */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name></decl></parameter>,                       <comment type="block">/* Array of column names for fts3 table */</comment>
  <parameter><decl><type><name>int</name></type> <name>bFts4</name></decl></parameter>,                          <comment type="block">/* True to allow FTS4-only syntax */</comment>
  <parameter><decl><type><name>int</name></type> <name>nCol</name></decl></parameter>,                           <comment type="block">/* Number of entries in azCol[] */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDefaultCol</name></decl></parameter>,                    <comment type="block">/* Default column to query */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,               <comment type="block">/* Text of MATCH query */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppExpr</name></decl></parameter>                   <comment type="block">/* OUT: Parsed query structure */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nParsed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ParseContext</name></type> <name>sParse</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParseContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sParse</name><operator>.</operator><name>pTokenizer</name></name> <operator>=</operator> <name>pTokenizer</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sParse</name><operator>.</operator><name>iLangid</name></name> <operator>=</operator> <name>iLangid</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sParse</name><operator>.</operator><name>azCol</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>azCol</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sParse</name><operator>.</operator><name>nCol</name></name> <operator>=</operator> <name>nCol</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sParse</name><operator>.</operator><name>iDefaultCol</name></name> <operator>=</operator> <name>iDefaultCol</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sParse</name><operator>.</operator><name>bFts4</name></name> <operator>=</operator> <name>bFts4</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppExpr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprParse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sParse</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>ppExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nParsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>*</operator><name>ppExpr</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check for mismatched parenthesis */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>sParse</name><operator>.</operator><name>nNest</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Parameters z and n contain a pointer to and length of a buffer containing
** an fts3 query expression, respectively. This function attempts to parse the
** query expression and create a tree of Fts3Expr structures representing the
** parsed expression. If successful, *ppExpr is set to point to the head
** of the parsed expression tree and SQLITE_OK is returned. If an error
** occurs, either SQLITE_NOMEM (out-of-memory error) or SQLITE_ERROR (parse
** error) is returned and *ppExpr is set to 0.
**
** If parameter n is a negative number, then z is assumed to point to a
** nul-terminated string and the length is determined using strlen().
**
** The first parameter, pTokenizer, is passed the fts3 tokenizer module to
** use to normalize query tokens while parsing the expression. The azCol[]
** array, which is assumed to contain nCol entries, should contain the names
** of each column in the target fts3 table, in order from left to right. 
** Column names must be nul-terminated strings.
**
** The iDefaultCol parameter should be passed the index of the table column
** that appears on the left-hand-side of the MATCH operator (the default
** column to match against for tokens for which a column name is not explicitly
** specified as part of the query string), or -1 if tokens may by default
** match any table column.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3ExprParse</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl></parameter>,      <comment type="block">/* Tokenizer module */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>,                        <comment type="block">/* Language id for tokenizer */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name></decl></parameter>,                       <comment type="block">/* Array of column names for fts3 table */</comment>
  <parameter><decl><type><name>int</name></type> <name>bFts4</name></decl></parameter>,                          <comment type="block">/* True to allow FTS4-only syntax */</comment>
  <parameter><decl><type><name>int</name></type> <name>nCol</name></decl></parameter>,                           <comment type="block">/* Number of entries in azCol[] */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDefaultCol</name></decl></parameter>,                    <comment type="block">/* Default column to query */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,               <comment type="block">/* Text of MATCH query */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppExpr</name></decl></parameter>,                  <comment type="block">/* OUT: Parsed query structure */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                        <comment type="block">/* OUT: Error message (sqlite3_malloc) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>fts3ExprParseUnbalanced</name><argument_list>(
      <argument><expr><name>pTokenizer</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>azCol</name></expr></argument>, <argument><expr><name>bFts4</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>iDefaultCol</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>ppExpr</name></expr></argument>
  )</argument_list></call></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Rebalance the expression. And check that its depth does not exceed
  ** SQLITE_FTS3_MAX_EXPR_DEPTH.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ppExpr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprBalance</name><argument_list>(<argument><expr><name>ppExpr</name></expr></argument>, <argument><expr><name>SQLITE_FTS3_MAX_EXPR_DEPTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprCheckDepth</name><argument_list>(<argument><expr><operator>*</operator><name>ppExpr</name></expr></argument>, <argument><expr><name>SQLITE_FTS3_MAX_EXPR_DEPTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Fts3ExprFree</name><argument_list>(<argument><expr><operator>*</operator><name>ppExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppExpr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_TOOBIG</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3Fts3ErrMsg</name><argument_list>(<argument><expr><name>pzErr</name></expr></argument>,
          <argument><expr><literal type="string">"FTS expression tree is too large (maximum depth %d)"</literal></expr></argument>, 
          <argument><expr><name>SQLITE_FTS3_MAX_EXPR_DEPTH</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ERROR</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3Fts3ErrMsg</name><argument_list>(<argument><expr><name>pzErr</name></expr></argument>, <argument><expr><literal type="string">"malformed MATCH expression: [%s]"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free a single node of an expression tree.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3FreeExprNode</name><parameter_list>(<parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_PHRASE</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pPhrase</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Fts3EvalPhraseCleanup</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPhrase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aMI</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free a parsed fts3 query expression allocated by sqlite3Fts3ExprParse().
**
** This function would be simpler if it recursively called itself. But
** that would mean passing a sufficiently large expression to ExprParse()
** could cause a stack overflow.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Fts3ExprFree</name><parameter_list>(<parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pDel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDel</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pDel</name><operator>-&gt;</operator><name>pParent</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pDel</name></expr>;</init> <condition><expr><name>p</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name><operator>||</operator><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name><operator>)</operator></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></else></ternary><operator>)</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pParent</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>p</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pRight</name></name> <operator>||</operator> <name>p</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pParent</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pParent</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fts3FreeExprNode</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pParent</name> <operator>&amp;&amp;</operator> <name>p</name><operator>==</operator><name><name>pParent</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>&amp;&amp;</operator> <name><name>pParent</name><operator>-&gt;</operator><name>pRight</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pRight</name></name> <operator>||</operator> <name>p</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pParent</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block" format="doxygen">/****************************************************************************
*****************************************************************************
** Everything after this point is just test code.
*/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** Return a pointer to a buffer containing a text representation of the
** expression passed as the first argument. The buffer is obtained from
** sqlite3_malloc(). It is the responsibility of the caller to use 
** sqlite3_free() to release the memory. If an OOM condition is encountered,
** NULL is returned.
**
** If the second argument is not NULL, then its contents are prepended to 
** the returned expression text and then freed using sqlite3_free().
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>exprToString</name><parameter_list>(<parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <switch>switch<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>eType</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>FTSQUERY_PHRASE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>pPhrase</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"%zPHRASE %d 0"</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>zBuf</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z %.*s%s"</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, 
            <argument><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>, <argument><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>,
            <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isPrefix</name></expr>?</condition><then><expr><literal type="string">"+"</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <return>return <expr><name>zBuf</name></expr>;</return>
    </block_content>}</block>

    <case>case <expr><name>FTSQUERY_NEAR</name></expr>:</case>
      <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%zNEAR/%d "</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>nNear</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>FTSQUERY_NOT</name></expr>:</case>
      <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%zNOT "</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>FTSQUERY_AND</name></expr>:</case>
      <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%zAND "</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>FTSQUERY_OR</name></expr>:</case>
      <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%zOR "</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <if_stmt><if>if<condition>( <expr><name>zBuf</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z{"</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zBuf</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <call><name>exprToString</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zBuf</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z} {"</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>zBuf</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <call><name>exprToString</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zBuf</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z}"</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>zBuf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is the implementation of a scalar SQL function used to test the 
** expression parser. It should be called as follows:
**
**   fts3_exprtest(&lt;tokenizer&gt;, &lt;expr&gt;, &lt;column 1&gt;, ...);
**
** The first argument, &lt;tokenizer&gt;, is the name of the fts3 tokenizer used
** to parse the query expression (see README.tokenizers). The second argument
** is the query expression to parse. Each subsequent argument is the name
** of a column of the fts3 table that the query expression may refer to.
** For example:
**
**   SELECT fts3_exprtest('simple', 'Bill col2:Bloggs', 'col1', 'col2');
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3ExprTestCommon</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>bRebalance</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zExpr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nExpr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Hash</name> <modifier>*</modifier></type><name>pHash</name> <init>= <expr><operator>(</operator><name>Fts3Hash</name><operator>*</operator><operator>)</operator><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTokenizer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&lt;</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, 
        <argument><expr><literal type="string">"Usage: fts3_exprtest(tokenizer, expr, col1, ..."</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>zTokenizer</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3InitTokenizer</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><name>zTokenizer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTokenizer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>zExpr</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nExpr</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nCol</name> <operator>=</operator> <name>argc</name><operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>azCol</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nCol</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>azCol</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exprtest_out</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>azCol</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>ii</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>bRebalance</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDummy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3ExprParse</name><argument_list>(
        <argument><expr><name>pTokenizer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>azCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>zExpr</name></expr></argument>, <argument><expr><name>nExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDummy</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprParseUnbalanced</name><argument_list>(
        <argument><expr><name>pTokenizer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>azCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>zExpr</name></expr></argument>, <argument><expr><name>nExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pExpr</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Fts3ExprFree</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"Error parsing expression"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name>zBuf</name> <operator>=</operator> <call><name>exprToString</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>sqlite3Fts3ExprFree</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>exprtest_out</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>pTokenizer</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xDestroy</name></name><argument_list>(<argument><expr><name>pTokenizer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>azCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3ExprTest</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>fts3ExprTestCommon</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3ExprTestRebalance</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>fts3ExprTestCommon</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Register the query expression parser test function fts3_exprtest() 
** with database connection db. 
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3ExprInitTestInterface</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Fts3Hash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_create_function</name><argument_list>(
      <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"fts3_exprtest"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pHash</name></expr></argument>, <argument><expr><name>fts3ExprTest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
  )</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"fts3_exprtest_rebalance"</literal></expr></argument>, 
        <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pHash</name></expr></argument>, <argument><expr><name>fts3ExprTestRebalance</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3) */</comment>
</unit>
