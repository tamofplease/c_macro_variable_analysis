<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/fts3/fts3_test.c"><comment type="block">/*
** 2011 Jun 13
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This file is not part of the production FTS code. It is only used for
** testing. It contains a Tcl command that can be used to test if a document
** matches an FTS NEAR expression.
**
** As of March 2012, it also contains a version 1 tokenizer used for testing
** that the sqlite3_tokenizer_module.xLanguage() method is invoked correctly.
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_SQLITE_TCL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"sqlite_tcl.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"tcl.h"</cpp:file></cpp:include>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>SQLITE_TCLAPI</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_TCLAPI</name></cpp:macro></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_FTS3</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_FTS4</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/* Required so that the "ifdef SQLITE_ENABLE_FTS3" below works */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fts3Int.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NM_MAX_TOKEN</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>

<typedef>typedef <type><name><name>struct</name> <name>NearPhrase</name></name></type> <name>NearPhrase</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>NearDocument</name></name></type> <name>NearDocument</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>NearToken</name></name></type> <name>NearToken</name>;</typedef>

<struct>struct <name>NearDocument</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nToken</name></decl>;</decl_stmt>                     <comment type="block">/* Length of token in bytes */</comment>
  <decl_stmt><decl><type><name>NearToken</name> <modifier>*</modifier></type><name>aToken</name></decl>;</decl_stmt>              <comment type="block">/* Token array */</comment>
}</block>;</struct>

<struct>struct <name>NearToken</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                          <comment type="block">/* Length of token in bytes */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>                  <comment type="block">/* Pointer to token string */</comment>
}</block>;</struct>

<struct>struct <name>NearPhrase</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nNear</name></decl>;</decl_stmt>                      <comment type="block">/* Preceding NEAR value */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nToken</name></decl>;</decl_stmt>                     <comment type="block">/* Number of tokens in this phrase */</comment>
  <decl_stmt><decl><type><name>NearToken</name></type> <name><name>aToken</name><index>[<expr><name>NM_MAX_TOKEN</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Array of tokens in this phrase */</comment>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>nm_phrase_match</name><parameter_list>(
  <parameter><decl><type><name>NearPhrase</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>NearToken</name> <modifier>*</modifier></type><name>aToken</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>NearToken</name> <modifier>*</modifier></type><name>pToken</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pToken</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pToken</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pToken</name><operator>-&gt;</operator><name>n</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'*'</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aToken</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>n</name><operator>&lt;</operator><operator>(</operator><name><name>pToken</name><operator>-&gt;</operator><name>n</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>aToken</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>n</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aToken</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>n</name><operator>!=</operator><name><name>pToken</name><operator>-&gt;</operator><name>n</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>aToken</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>nm_near_chain</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>iDir</name></decl></parameter>,                       <comment type="block">/* Direction to iterate through aPhrase[] */</comment>
  <parameter><decl><type><name>NearDocument</name> <modifier>*</modifier></type><name>pDoc</name></decl></parameter>,             <comment type="block">/* Document to match against */</comment>
  <parameter><decl><type><name>int</name></type> <name>iPos</name></decl></parameter>,                       <comment type="block">/* Position at which iPhrase was found */</comment>
  <parameter><decl><type><name>int</name></type> <name>nPhrase</name></decl></parameter>,                    <comment type="block">/* Size of phrase array */</comment>
  <parameter><decl><type><name>NearPhrase</name> <modifier>*</modifier></type><name>aPhrase</name></decl></parameter>,            <comment type="block">/* Phrase array */</comment>
  <parameter><decl><type><name>int</name></type> <name>iPhrase</name></decl></parameter>                     <comment type="block">/* Index of phrase found */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iStop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nNear</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iPhrase2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>NearPhrase</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>NearPhrase</name> <modifier>*</modifier></type><name>pPrev</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDir</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>iDir</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>iDir</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPhrase</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><name>nPhrase</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nNear</name> <operator>=</operator> <name><name>aPhrase</name><index>[<expr><name>iPhrase</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nNear</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iPhrase</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nNear</name> <operator>=</operator> <name><name>aPhrase</name><index>[<expr><name>iPhrase</name></expr>]</index></name><operator>.</operator><name>nNear</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>pPrev</name> <operator>=</operator> <operator>&amp;</operator><name><name>aPhrase</name><index>[<expr><name>iPhrase</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iPhrase2</name> <operator>=</operator> <name>iPhrase</name><operator>+</operator><name>iDir</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>aPhrase</name><index>[<expr><name>iPhrase2</name></expr>]</index></name></expr>;</expr_stmt>

  <expr_stmt><expr><name>iStart</name> <operator>=</operator> <name>iPos</name> <operator>-</operator> <name>nNear</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iStop</name> <operator>=</operator> <name>iPos</name> <operator>+</operator> <name>nNear</name> <operator>+</operator> <name><name>pPrev</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>iStart</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iStart</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iStop</name> <operator>&gt;</operator> <name><name>pDoc</name><operator>-&gt;</operator><name>nToken</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nToken</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iStop</name> <operator>=</operator> <name><name>pDoc</name><operator>-&gt;</operator><name>nToken</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><name>iStart</name></expr>;</init> <condition><expr><name>ii</name><operator>&lt;=</operator><name>iStop</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>nm_phrase_match</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDoc</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>nm_near_chain</name><argument_list>(<argument><expr><name>iDir</name></expr></argument>, <argument><expr><name>pDoc</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><name>nPhrase</name></expr></argument>, <argument><expr><name>aPhrase</name></expr></argument>, <argument><expr><name>iPhrase2</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>nm_match_count</name><parameter_list>(
  <parameter><decl><type><name>NearDocument</name> <modifier>*</modifier></type><name>pDoc</name></decl></parameter>,             <comment type="block">/* Document to match against */</comment>
  <parameter><decl><type><name>int</name></type> <name>nPhrase</name></decl></parameter>,                    <comment type="block">/* Size of phrase array */</comment>
  <parameter><decl><type><name>NearPhrase</name> <modifier>*</modifier></type><name>aPhrase</name></decl></parameter>,            <comment type="block">/* Phrase array */</comment>
  <parameter><decl><type><name>int</name></type> <name>iPhrase</name></decl></parameter>                     <comment type="block">/* Index of phrase to count matches for */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nOcc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>NearPhrase</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>aPhrase</name><index>[<expr><name>iPhrase</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><operator>(</operator><name><name>pDoc</name><operator>-&gt;</operator><name>nToken</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nToken</name></name><operator>)</operator></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>nm_phrase_match</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDoc</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* Test forward NEAR chain (i&gt;iPhrase) */</comment>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>nm_near_chain</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pDoc</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><name>nPhrase</name></expr></argument>, <argument><expr><name>aPhrase</name></expr></argument>, <argument><expr><name>iPhrase</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

      <comment type="block">/* Test reverse NEAR chain (i&lt;iPhrase) */</comment>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>nm_near_chain</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pDoc</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><name>nPhrase</name></expr></argument>, <argument><expr><name>aPhrase</name></expr></argument>, <argument><expr><name>iPhrase</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

      <comment type="block">/* This is a real match. Increment the counter. */</comment>
      <expr_stmt><expr><name>nOcc</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for> 

  <return>return <expr><name>nOcc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Tclcmd: fts3_near_match DOCUMENT EXPR ?OPTIONS?
*/</comment>
<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_TCLAPI</name></type> <name>fts3_near_match_cmd</name><parameter_list>(
  <parameter><decl><type><name>ClientData</name></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nPhrase</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>NearPhrase</name> <modifier>*</modifier></type><name>aPhrase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>NearDocument</name></type> <name>doc</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><modifier>*</modifier></type><name>apDocToken</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_Obj</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_Obj</name> <modifier>*</modifier></type><name>pPhrasecount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><modifier>*</modifier></type><name>apExprToken</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nExprToken</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>clientData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Must have 3 or more arguments. */</comment>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>&lt;</operator><literal type="number">3</literal> <operator>||</operator> <operator>(</operator><name>objc</name><operator>%</operator><literal type="number">2</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"DOCUMENT EXPR ?OPTION VALUE?..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>TCL_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>near_match_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">3</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>objc</name></expr>;</condition> <incr><expr><name>ii</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
    <enum>enum <name>NM_enum</name> <block>{ <decl><name>NM_PHRASECOUNTS</name></decl> }</block>;</enum>
    <struct>struct <name>TestnmSubcmd</name> <block>{
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>enum</name> <name>NM_enum</name></name></type> <name>eOpt</name></decl>;</decl_stmt>
    }</block> <decl><name><name>aOpt</name><index>[]</index></name> <init>= <expr><block>{
      <expr><block>{ <expr><literal type="string">"-phrasecountvar"</literal></expr>, <expr><name>NM_PHRASECOUNTS</name></expr> }</block></expr>,
      <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
    }</block></expr></init></decl>;</struct>
    <decl_stmt><decl><type><name>int</name></type> <name>iOpt</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>Tcl_GetIndexFromObjStruct</name><argument_list>(
        <argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, <argument><expr><name>aOpt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>aOpt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"option"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iOpt</name></expr></argument>)</argument_list></call></expr> 
    )</condition><block>{<block_content>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <switch>switch<condition>( <expr><name><name>aOpt</name><index>[<expr><name>iOpt</name></expr>]</index></name><operator>.</operator><name>eOpt</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>NM_PHRASECOUNTS</name></expr>:</case>
        <expr_stmt><expr><name>pPhrasecount</name> <operator>=</operator> <name><name>objv</name><index>[<expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></for>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>Tcl_ListObjGetElements</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>doc</name><operator>.</operator><name>nToken</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>apDocToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>TCL_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>near_match_out</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>doc</name><operator>.</operator><name>aToken</name></name> <operator>=</operator> <operator>(</operator><name>NearToken</name> <operator>*</operator><operator>)</operator><call><name>ckalloc</name><argument_list>(<argument><expr><name><name>doc</name><operator>.</operator><name>nToken</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>NearToken</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>doc</name><operator>.</operator><name>nToken</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>doc</name><operator>.</operator><name>aToken</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>z</name> <operator>=</operator> <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>apDocToken</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>doc</name><operator>.</operator><name>aToken</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>Tcl_ListObjGetElements</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nExprToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>apExprToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>TCL_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>near_match_out</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>nPhrase</name> <operator>=</operator> <operator>(</operator><name>nExprToken</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>aPhrase</name> <operator>=</operator> <operator>(</operator><name>NearPhrase</name> <operator>*</operator><operator>)</operator><call><name>ckalloc</name><argument_list>(<argument><expr><name>nPhrase</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NearPhrase</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aPhrase</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nPhrase</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NearPhrase</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nPhrase</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Tcl_Obj</name> <modifier>*</modifier></type><name>pPhrase</name> <init>= <expr><name><name>apExprToken</name><index>[<expr><name>ii</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><modifier>*</modifier></type><name>apToken</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nToken</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>jj</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>Tcl_ListObjGetElements</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pPhrase</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>apToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>TCL_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>near_match_out</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nToken</name><operator>&gt;</operator><name>NM_MAX_TOKEN</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"Too many tokens in phrase"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>TCL_ERROR</name></expr>;</expr_stmt>
      <goto>goto <name>near_match_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name>nToken</name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>NearToken</name> <modifier>*</modifier></type><name>pT</name> <init>= <expr><operator>&amp;</operator><name><name>aPhrase</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name><name>aToken</name><index>[<expr><name>jj</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pT</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>apToken</name><index>[<expr><name>jj</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pT</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>aPhrase</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>nToken</name> <operator>=</operator> <name>nToken</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nPhrase</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Tcl_Obj</name> <modifier>*</modifier></type><name>pNear</name> <init>= <expr><name><name>apExprToken</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>ii</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nNear</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>Tcl_GetIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pNear</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nNear</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>TCL_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>near_match_out</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>aPhrase</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>nNear</name> <operator>=</operator> <name>nNear</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nPhrase</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nOcc</name> <init>= <expr><call><name>nm_match_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doc</name></expr></argument>, <argument><expr><name>nPhrase</name></expr></argument>, <argument><expr><name>aPhrase</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pRet</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name>nOcc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nTotal</name> <operator>+=</operator> <name>nOcc</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>pPhrasecount</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_ObjSetVar2</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pPhrasecount</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pRet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewBooleanObj</name><argument_list>(<argument><expr><name>nTotal</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

 <label><name>near_match_out</name>:</label> 
  <expr_stmt><expr><call><name>ckfree</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>aPhrase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ckfree</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>doc</name><operator>.</operator><name>aToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
**   Tclcmd: fts3_configure_incr_load ?CHUNKSIZE THRESHOLD?
**
** Normally, FTS uses hard-coded values to determine the minimum doclist
** size eligible for incremental loading, and the size of the chunks loaded
** when a doclist is incrementally loaded. This command allows the built-in
** values to be overridden for testing purposes.
**
** If present, the first argument is the chunksize in bytes to load doclists
** in. The second argument is the minimum doclist size in bytes to use
** incremental loading with.
**
** Whether or not the arguments are present, this command returns a list of
** two integers - the initial chunksize and threshold when the command is
** invoked. This can be used to restore the default behavior after running
** tests. For example:
**
**    # Override incr-load settings for testing:
**    set cfg [fts3_configure_incr_load $new_chunksize $new_threshold]
**
**    .... run tests ....
**
**    # Restore initial incr-load settings:
**    eval fts3_configure_incr_load $cfg
*/</comment>
<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_TCLAPI</name></type> <name>fts3_configure_incr_load_cmd</name><parameter_list>(
  <parameter><decl><type><name>ClientData</name></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS3</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>test_fts3_node_chunksize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>test_fts3_node_chunk_threshold</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_Obj</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>objc</name><operator>!=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"?CHUNKSIZE THRESHOLD?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(
      <argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pRet</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name>test_fts3_node_chunksize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(
      <argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pRet</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name>test_fts3_node_chunk_threshold</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iArg1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iArg2</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>Tcl_GetIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iArg1</name></expr></argument>)</argument_list></call>
     <operator>||</operator> <call><name>Tcl_GetIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iArg2</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>test_fts3_node_chunksize</name> <operator>=</operator> <name>iArg1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>test_fts3_node_chunk_threshold</name> <operator>=</operator> <name>iArg2</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>clientData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS3</name></cpp:ifdef>
<comment type="block" format="doxygen">/**************************************************************************
** Beginning of test tokenizer code.
**
** For language 0, this tokenizer is similar to the default 'simple' 
** tokenizer. For other languages L, the following:
**
**   * Odd numbered languages are case-sensitive. Even numbered 
**     languages are not.
**
**   * Language ids 100 or greater are considered an error.
**
** The implementation assumes that the input contains only ASCII characters
** (i.e. those that may be encoded in UTF-8 using a single byte).
*/</comment>
<typedef>typedef <type><struct>struct <name>test_tokenizer</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_tokenizer</name></type> <name>base</name></decl>;</decl_stmt>
}</block></struct></type> <name>test_tokenizer</name>;</typedef>

<typedef>typedef <type><struct>struct <name>test_tokenizer_cursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name></type> <name>base</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aInput</name></decl>;</decl_stmt>          <comment type="block">/* Input being tokenized */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nInput</name></decl>;</decl_stmt>                  <comment type="block">/* Size of the input in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iInput</name></decl>;</decl_stmt>                  <comment type="block">/* Current offset in aInput */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iToken</name></decl>;</decl_stmt>                  <comment type="block">/* Index of next token to be returned */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aBuffer</name></decl>;</decl_stmt>               <comment type="block">/* Buffer containing current token */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuffer</name></decl>;</decl_stmt>                 <comment type="block">/* Number of bytes allocated at pToken */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLangid</name></decl>;</decl_stmt>                 <comment type="block">/* Configured language id */</comment>
}</block></struct></type> <name>test_tokenizer_cursor</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testTokenizerCreate</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppTokenizer</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>test_tokenizer</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>test_tokenizer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pNew</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>test_tokenizer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppTokenizer</name> <operator>=</operator> <operator>(</operator><name>sqlite3_tokenizer</name> <operator>*</operator><operator>)</operator><name>pNew</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testTokenizerDestroy</name><parameter_list>(<parameter><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>test_tokenizer</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>test_tokenizer</name> <operator>*</operator><operator>)</operator><name>pTokenizer</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testTokenizerOpen</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl></parameter>,         <comment type="block">/* The tokenizer */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBytes</name></decl></parameter>,        <comment type="block">/* String to be tokenized */</comment>
  <parameter><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>    <comment type="block">/* OUT: Tokenization cursor */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>                    <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>test_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>           <comment type="block">/* New cursor object */</comment>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pTokenizer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <operator>(</operator><name>test_tokenizer_cursor</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>test_tokenizer_cursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>test_tokenizer_cursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aInput</name></name> <operator>=</operator> <name>pInput</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nBytes</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nInput</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nInput</name></name> <operator>=</operator> <name>nBytes</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>(</operator><name>sqlite3_tokenizer_cursor</name> <operator>*</operator><operator>)</operator><name>pCsr</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testTokenizerClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>test_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>test_tokenizer_cursor</name> <operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testIsTokenChar</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'z'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'Z'</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>testTolower</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>ret</name> <init>= <expr><name>c</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>ret</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>ret</name><operator>&lt;=</operator><literal type="char">'Z'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ret</name> <operator>-</operator> <operator>(</operator><literal type="char">'A'</literal><operator>-</operator><literal type="char">'a'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testTokenizerNext</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,  <comment type="block">/* Cursor returned by testTokenizerOpen */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppToken</name></decl></parameter>,               <comment type="block">/* OUT: *ppToken is the token text */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnBytes</name></decl></parameter>,                       <comment type="block">/* OUT: Number of bytes in token */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piStartOffset</name></decl></parameter>,                 <comment type="block">/* OUT: Starting offset of token */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piEndOffset</name></decl></parameter>,                   <comment type="block">/* OUT: Ending offset of token */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piPosition</name></decl></parameter>                     <comment type="block">/* OUT: Position integer of token */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>test_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>test_tokenizer_cursor</name> <operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pEnd</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aInput</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>iInput</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aInput</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>nInput</name></name></expr>]</index></name></expr>;</expr_stmt>

  <comment type="block">/* Skip past any white-space */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>&lt;=</operator><name>pEnd</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>p</name><operator>&lt;</operator><name>pEnd</name> <operator>&amp;&amp;</operator> <call><name>testIsTokenChar</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_DONE</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Advance to the end of the token */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pToken</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nToken</name></decl>;</decl_stmt>
    <while>while<condition>( <expr><name>p</name><operator>&lt;</operator><name>pEnd</name> <operator>&amp;&amp;</operator> <call><name>testIsTokenChar</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><name>nToken</name> <operator>=</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><operator>(</operator><name>p</name><operator>-</operator><name>pToken</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Copy the token into the buffer */</comment>
    <if_stmt><if>if<condition>( <expr><name>nToken</name><operator>&gt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nBuffer</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aBuffer</name></name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aBuffer</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iLangid</name></name> <operator>&amp;</operator> <literal type="number">0x00000001</literal></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nToken</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pToken</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
      </block_content>}</block></if><else>else<block>{<block_content>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nToken</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>testTolower</name><argument_list>(<argument><expr><name><name>pToken</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iToken</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iInput</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aInput</name></name><operator>)</operator></expr>;</expr_stmt>

      <expr_stmt><expr><operator>*</operator><name>ppToken</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aBuffer</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pnBytes</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>nToken</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>piStartOffset</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pToken</name> <operator>-</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aInput</name></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>piEndOffset</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aInput</name></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>piPosition</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>iToken</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testTokenizerLanguage</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>test_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>test_tokenizer_cursor</name> <operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iLangid</name></name> <operator>=</operator> <name>iLangid</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iLangid</name></name><operator>&gt;=</operator><literal type="number">100</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_TCLAPI</name></type> <name>fts3_test_tokenizer_cmd</name><parameter_list>(
  <parameter><decl><type><name>ClientData</name></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS3</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_tokenizer_module</name></type> <name>testTokenizerModule</name> <init>= <expr><block>{
    <expr><literal type="number">1</literal></expr>,
    <expr><name>testTokenizerCreate</name></expr>,
    <expr><name>testTokenizerDestroy</name></expr>,
    <expr><name>testTokenizerOpen</name></expr>,
    <expr><name>testTokenizerClose</name></expr>,
    <expr><name>testTokenizerNext</name></expr>,
    <expr><name>testTokenizerLanguage</name></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>pPtr</name> <init>= <expr><operator>&amp;</operator><name>testTokenizerModule</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewByteArrayObj</name><argument_list>(
    <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pPtr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_tokenizer_module</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>
  )</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>clientData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_TCLAPI</name></type> <name>fts3_test_varint_cmd</name><parameter_list>(
  <parameter><decl><type><name>ClientData</name></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS3</name></cpp:ifdef>
  <decl_stmt><decl><type><name>char</name></type> <name><name>aBuf</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_WideInt</name></type> <name>w</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>w2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>, <decl><type ref="prev"/><name>nByte2</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"INTEGER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>Tcl_GetWideIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>TCL_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nByte2</name> <operator>=</operator> <call><name>sqlite3Fts3GetVarint</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>w</name><operator>!=</operator><name>w2</name> <operator>||</operator> <name>nByte</name><operator>!=</operator><name>nByte2</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"error testing %lld"</literal></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>Tcl_ResetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>w</name><operator>&lt;=</operator><literal type="number">2147483647</literal> <operator>&amp;&amp;</operator> <name>w</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nByte2</name> <operator>=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>int</name><operator>)</operator><name>w</name><operator>!=</operator><name>i</name> <operator>||</operator> <name>nByte</name><operator>!=</operator><name>nByte2</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"error testing %lld (32-bit)"</literal></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>Tcl_ResetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>clientData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** End of tokenizer code.
**************************************************************************/</comment> 

<comment type="block">/*
**      sqlite3_fts3_may_be_corrupt BOOLEAN
**
** Set or clear the global "may-be-corrupt" flag. Return the old value.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_TCLAPI</name></type> <name>fts3_may_be_corrupt</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>bOld</name> <init>= <expr><name>sqlite3_fts3_may_be_corrupt</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>objc</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"?BOOLEAN?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bNew</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>Tcl_GetBooleanFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bNew</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>sqlite3_fts3_may_be_corrupt</name> <operator>=</operator> <name>bNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name>bOld</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>Sqlitetestfts3_Init</name><parameter_list>(<parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"fts3_near_match"</literal></expr></argument>, <argument><expr><name>fts3_near_match_cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, 
      <argument><expr><literal type="string">"fts3_configure_incr_load"</literal></expr></argument>, <argument><expr><name>fts3_configure_incr_load_cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(
      <argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"fts3_test_tokenizer"</literal></expr></argument>, <argument><expr><name>fts3_test_tokenizer_cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(
      <argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"fts3_test_varint"</literal></expr></argument>, <argument><expr><name>fts3_test_varint_cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(
      <argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"sqlite3_fts3_may_be_corrupt"</literal></expr></argument>, <argument><expr><name>fts3_may_be_corrupt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                  <comment type="block">/* SQLITE_ENABLE_FTS3 || SQLITE_ENABLE_FTS4 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                  <comment type="block">/* ifdef SQLITE_TEST */</comment>
</unit>
