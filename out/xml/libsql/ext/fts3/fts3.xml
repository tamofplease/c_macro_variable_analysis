<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libsql/ext/fts3/fts3.c"><comment type="block">/*
** 2006 Oct 10
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This is an SQLite module implementing full-text search.
*/</comment>

<comment type="block">/*
** The code in this file is only compiled if:
**
**     * The FTS3 module is being built as an extension
**       (in which case SQLITE_CORE is not defined), or
**
**     * The FTS3 module is being built into the core of
**       SQLite (in which case SQLITE_ENABLE_FTS3 is defined).
*/</comment>

<comment type="block">/* The full-text index is stored in a series of b+tree (-like)
** structures called segments which map terms to doclists.  The
** structures are like b+trees in layout, but are constructed from the
** bottom up in optimal fashion and are not updatable.  Since trees
** are built from the bottom up, things will be described from the
** bottom up.
**
**
**** Varints ****
** The basic unit of encoding is a variable-length integer called a
** varint.  We encode variable-length integers in little-endian order
** using seven bits * per byte as follows:
**
** KEY:
**         A = 0xxxxxxx    7 bits of data and one flag bit
**         B = 1xxxxxxx    7 bits of data and one flag bit
**
**  7 bits - A
** 14 bits - BA
** 21 bits - BBA
** and so on.
**
** This is similar in concept to how sqlite encodes "varints" but
** the encoding is not the same.  SQLite varints are big-endian
** are are limited to 9 bytes in length whereas FTS3 varints are
** little-endian and can be up to 10 bytes in length (in theory).
**
** Example encodings:
**
**     1:    0x01
**   127:    0x7f
**   128:    0x81 0x00
**
**
**** Document lists ****
** A doclist (document list) holds a docid-sorted list of hits for a
** given term.  Doclists hold docids and associated token positions.
** A docid is the unique integer identifier for a single document.
** A position is the index of a word within the document.  The first 
** word of the document has a position of 0.
**
** FTS3 used to optionally store character offsets using a compile-time
** option.  But that functionality is no longer supported.
**
** A doclist is stored like this:
**
** array {
**   varint docid;          (delta from previous doclist)
**   array {                (position list for column 0)
**     varint position;     (2 more than the delta from previous position)
**   }
**   array {
**     varint POS_COLUMN;   (marks start of position list for new column)
**     varint column;       (index of new column)
**     array {
**       varint position;   (2 more than the delta from previous position)
**     }
**   }
**   varint POS_END;        (marks end of positions for this document.
** }
**
** Here, array { X } means zero or more occurrences of X, adjacent in
** memory.  A "position" is an index of a token in the token stream
** generated by the tokenizer. Note that POS_END and POS_COLUMN occur 
** in the same logical place as the position element, and act as sentinals
** ending a position list array.  POS_END is 0.  POS_COLUMN is 1.
** The positions numbers are not stored literally but rather as two more
** than the difference from the prior position, or the just the position plus
** 2 for the first position.  Example:
**
**   label:       A B C D E  F  G H   I  J K
**   value:     123 5 9 1 1 14 35 0 234 72 0
**
** The 123 value is the first docid.  For column zero in this document
** there are two matches at positions 3 and 10 (5-2 and 9-2+3).  The 1
** at D signals the start of a new column; the 1 at E indicates that the
** new column is column number 1.  There are two positions at 12 and 45
** (14-2 and 35-2+12).  The 0 at H indicate the end-of-document.  The
** 234 at I is the delta to next docid (357).  It has one position 70
** (72-2) and then terminates with the 0 at K.
**
** A "position-list" is the list of positions for multiple columns for
** a single docid.  A "column-list" is the set of positions for a single
** column.  Hence, a position-list consists of one or more column-lists,
** a document record consists of a docid followed by a position-list and
** a doclist consists of one or more document records.
**
** A bare doclist omits the position information, becoming an 
** array of varint-encoded docids.
**
**** Segment leaf nodes ****
** Segment leaf nodes store terms and doclists, ordered by term.  Leaf
** nodes are written using LeafWriter, and read using LeafReader (to
** iterate through a single leaf node's data) and LeavesReader (to
** iterate through a segment's entire leaf layer).  Leaf nodes have
** the format:
**
** varint iHeight;             (height from leaf level, always 0)
** varint nTerm;               (length of first term)
** char pTerm[nTerm];          (content of first term)
** varint nDoclist;            (length of term's associated doclist)
** char pDoclist[nDoclist];    (content of doclist)
** array {
**                             (further terms are delta-encoded)
**   varint nPrefix;           (length of prefix shared with previous term)
**   varint nSuffix;           (length of unshared suffix)
**   char pTermSuffix[nSuffix];(unshared suffix of next term)
**   varint nDoclist;          (length of term's associated doclist)
**   char pDoclist[nDoclist];  (content of doclist)
** }
**
** Here, array { X } means zero or more occurrences of X, adjacent in
** memory.
**
** Leaf nodes are broken into blocks which are stored contiguously in
** the %_segments table in sorted order.  This means that when the end
** of a node is reached, the next term is in the node with the next
** greater node id.
**
** New data is spilled to a new leaf node when the current node
** exceeds LEAF_MAX bytes (default 2048).  New data which itself is
** larger than STANDALONE_MIN (default 1024) is placed in a standalone
** node (a leaf node with a single term and doclist).  The goal of
** these settings is to pack together groups of small doclists while
** making it efficient to directly access large doclists.  The
** assumption is that large doclists represent terms which are more
** likely to be query targets.
**
** TODO(shess) It may be useful for blocking decisions to be more
** dynamic.  For instance, it may make more sense to have a 2.5k leaf
** node rather than splitting into 2k and .5k nodes.  My intuition is
** that this might extend through 2x or 4x the pagesize.
**
**
**** Segment interior nodes ****
** Segment interior nodes store blockids for subtree nodes and terms
** to describe what data is stored by the each subtree.  Interior
** nodes are written using InteriorWriter, and read using
** InteriorReader.  InteriorWriters are created as needed when
** SegmentWriter creates new leaf nodes, or when an interior node
** itself grows too big and must be split.  The format of interior
** nodes:
**
** varint iHeight;           (height from leaf level, always &gt;0)
** varint iBlockid;          (block id of node's leftmost subtree)
** optional {
**   varint nTerm;           (length of first term)
**   char pTerm[nTerm];      (content of first term)
**   array {
**                                (further terms are delta-encoded)
**     varint nPrefix;            (length of shared prefix with previous term)
**     varint nSuffix;            (length of unshared suffix)
**     char pTermSuffix[nSuffix]; (unshared suffix of next term)
**   }
** }
**
** Here, optional { X } means an optional element, while array { X }
** means zero or more occurrences of X, adjacent in memory.
**
** An interior node encodes n terms separating n+1 subtrees.  The
** subtree blocks are contiguous, so only the first subtree's blockid
** is encoded.  The subtree at iBlockid will contain all terms less
** than the first term encoded (or all terms if no term is encoded).
** Otherwise, for terms greater than or equal to pTerm[i] but less
** than pTerm[i+1], the subtree for that term will be rooted at
** iBlockid+i.  Interior nodes only store enough term data to
** distinguish adjacent children (if the rightmost term of the left
** child is "something", and the leftmost term of the right child is
** "wicked", only "w" is stored).
**
** New data is spilled to a new interior node at the same height when
** the current node exceeds INTERIOR_MAX bytes (default 2048).
** INTERIOR_MIN_TERMS (default 7) keeps large terms from monopolizing
** interior nodes and making the tree too skinny.  The interior nodes
** at a given height are naturally tracked by interior nodes at
** height+1, and so on.
**
**
**** Segment directory ****
** The segment directory in table %_segdir stores meta-information for
** merging and deleting segments, and also the root node of the
** segment's tree.
**
** The root node is the top node of the segment's tree after encoding
** the entire segment, restricted to ROOT_MAX bytes (default 1024).
** This could be either a leaf node or an interior node.  If the top
** node requires more than ROOT_MAX bytes, it is flushed to %_segments
** and a new root interior node is generated (which should always fit
** within ROOT_MAX because it only needs space for 2 varints, the
** height and the blockid of the previous root).
**
** The meta-information in the segment directory is:
**   level               - segment level (see below)
**   idx                 - index within level
**                       - (level,idx uniquely identify a segment)
**   start_block         - first leaf node
**   leaves_end_block    - last leaf node
**   end_block           - last block (including interior nodes)
**   root                - contents of root node
**
** If the root node is a leaf node, then start_block,
** leaves_end_block, and end_block are all 0.
**
**
**** Segment merging ****
** To amortize update costs, segments are grouped into levels and
** merged in batches.  Each increase in level represents exponentially
** more documents.
**
** New documents (actually, document updates) are tokenized and
** written individually (using LeafWriter) to a level 0 segment, with
** incrementing idx.  When idx reaches MERGE_COUNT (default 16), all
** level 0 segments are merged into a single level 1 segment.  Level 1
** is populated like level 0, and eventually MERGE_COUNT level 1
** segments are merged to a single level 2 segment (representing
** MERGE_COUNT^2 updates), and so on.
**
** A segment merge traverses all segments at a given level in
** parallel, performing a straightforward sorted merge.  Since segment
** leaf nodes are written in to the %_segments table in order, this
** merge traverses the underlying sqlite disk structures efficiently.
** After the merge, all segment blocks from the merged level are
** deleted.
**
** MERGE_COUNT controls how often we merge segments.  16 seems to be
** somewhat of a sweet spot for insertion performance.  32 and 64 show
** very similar performance numbers to 16 on insertion, though they're
** a tiny bit slower (perhaps due to more overhead in merge-time
** sorting).  8 is about 20% slower than 16, 4 about 50% slower than
** 16, 2 about 66% slower than 16.
**
** At query time, high MERGE_COUNT increases the number of segments
** which need to be scanned and merged.  For instance, with 100k docs
** inserted:
**
**    MERGE_COUNT   segments
**       16           25
**        8           12
**        4           10
**        2            6
**
** This appears to have only a moderate impact on queries for very
** frequent terms (which are somewhat dominated by segment merge
** costs), and infrequent and non-existent terms still seem to be fast
** even with many segments.
**
** TODO(shess) That said, it would be nice to have a better query-side
** argument for MERGE_COUNT of 16.  Also, it is possible/likely that
** optimizations to things like doclist merging will swing the sweet
** spot around.
**
**
**
**** Handling of deletions and updates ****
** Since we're using a segmented structure, with no docid-oriented
** index into the term index, we clearly cannot simply update the term
** index when a document is deleted or updated.  For deletions, we
** write an empty doclist (varint(docid) varint(POS_END)), for updates
** we simply write the new doclist.  Segment merges overwrite older
** data for a particular docid with newer data, so deletes or updates
** will eventually overtake the earlier data and knock it out.  The
** query logic likewise merges doclists so that newer data knocks out
** older data.
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fts3Int.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_CORE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_FTS3</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_FTS3</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_CORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_CORE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fts3.h"</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_CORE</name></cpp:ifndef> 
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
  <macro><name>SQLITE_EXTENSION_INIT1</name></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name><name>struct</name> <name>Fts3HashWrapper</name></name></type> <name>Fts3HashWrapper</name>;</typedef>
<struct>struct <name>Fts3HashWrapper</name> <block>{
  <decl_stmt><decl><type><name>Fts3Hash</name></type> <name>hash</name></decl>;</decl_stmt>                  <comment type="block">/* Hash table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRef</name></decl>;</decl_stmt>                       <comment type="block">/* Number of pointers to this object */</comment>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>fts3EvalNext</name><parameter_list>(<parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>fts3EvalStart</name><parameter_list>(<parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>fts3TermSegReaderCursor</name><parameter_list>(
    <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** This variable is set to false when running tests for which the on disk
** structures should not be corrupt. Otherwise, true. If it is false, extra
** assert() conditions in the fts3 code are activated - conditions that are
** only true if it is guaranteed that the fts3 database is not corrupt.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_fts3_may_be_corrupt</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* 
** Write a 64-bit variable-length integer to memory starting at p[0].
** The length of data written will be between 1 and FTS3_VARINT_MAX bytes.
** The number of bytes written is returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3PutVarint</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_uint64</name></type> <name>vu</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>vu</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>vu</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>vu</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>
  <expr_stmt><expr><name><name>q</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>  <comment type="block">/* turn off high bit in final byte */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>q</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>&lt;=</operator> <name>FTS3_VARINT_MAX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>q</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETVARINT_STEP</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>shift</name></type></parameter>, <parameter><type><name>mask1</name></type></parameter>, <parameter><type><name>mask2</name></type></parameter>, <parameter><type><name>var</name></type></parameter>, <parameter><type><name>ret</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>v = (v &amp; mask1) | ( (*(const unsigned char*)(ptr++)) &lt;&lt; shift );  \
  if( (v &amp; mask2)==0 ){ var = v; return ret; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETVARINT_INIT</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>shift</name></type></parameter>, <parameter><type><name>mask1</name></type></parameter>, <parameter><type><name>mask2</name></type></parameter>, <parameter><type><name>var</name></type></parameter>, <parameter><type><name>ret</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>v = (*ptr++);                                               \
  if( (v &amp; mask2)==0 ){ var = v; return ret; }</cpp:value></cpp:define>

<function><type><name>int</name></type> <name>sqlite3Fts3GetVarintU</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, <parameter><decl><type><name>sqlite_uint64</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>pBuf</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pStart</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>a</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>b</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>shift</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>GETVARINT_INIT</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,  <argument><expr><literal type="number">0x00</literal></expr></argument>,     <argument><expr><literal type="number">0x80</literal></expr></argument>, <argument><expr><operator>*</operator><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>GETVARINT_STEP</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>,  <argument><expr><literal type="number">0x7F</literal></expr></argument>,     <argument><expr><literal type="number">0x4000</literal></expr></argument>, <argument><expr><operator>*</operator><name>v</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>GETVARINT_STEP</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>, <argument><expr><literal type="number">0x3FFF</literal></expr></argument>,   <argument><expr><literal type="number">0x200000</literal></expr></argument>, <argument><expr><operator>*</operator><name>v</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>GETVARINT_STEP</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">21</literal></expr></argument>, <argument><expr><literal type="number">0x1FFFFF</literal></expr></argument>, <argument><expr><literal type="number">0x10000000</literal></expr></argument>, <argument><expr><operator>*</operator><name>v</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <operator>(</operator><name>a</name> <operator>&amp;</operator> <literal type="number">0x0FFFFFFF</literal> <operator>)</operator></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>shift</name><operator>=</operator><literal type="number">28</literal></expr>;</init> <condition><expr><name>shift</name><operator>&lt;=</operator><literal type="number">63</literal></expr>;</condition> <incr><expr><name>shift</name><operator>+=</operator><literal type="number">7</literal></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u64</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>p</name><operator>++</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>b</name> <operator>+=</operator> <operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0x7F</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>pStart</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Read a 64-bit variable-length integer from memory starting at p[0].
** Return the number of bytes read, or 0 on error.
** The value is stored in *v.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3GetVarint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3Fts3GetVarintU</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_uint64</name><operator>*</operator><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Read a 64-bit variable-length integer from memory starting at p[0] and
** not extending past pEnd[-1].
** Return the number of bytes read, or 0 on error.
** The value is stored in *v.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3GetVarintBounded</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pEnd</name></decl></parameter>,
  <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>v</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>pBuf</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pStart</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pX</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>pEnd</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>b</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>shift</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>shift</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>shift</name><operator>&lt;=</operator><literal type="number">63</literal></expr>;</condition> <incr><expr><name>shift</name><operator>+=</operator><literal type="number">7</literal></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u64</name></type> <name>c</name> <init>= <expr><ternary><condition><expr><name>p</name><operator>&lt;</operator><name>pX</name></expr> ?</condition><then> <expr><operator>*</operator><name>p</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>+=</operator> <operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0x7F</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>pStart</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Similar to sqlite3Fts3GetVarint(), except that the output is truncated to 
** a non-negative 32-bit integer before it is returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3GetVarint32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pi</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>a</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>fts3GetVarint32</name></cpp:ifndef>
  <expr_stmt><expr><call><name>GETVARINT_INIT</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,  <argument><expr><literal type="number">0x00</literal></expr></argument>,     <argument><expr><literal type="number">0x80</literal></expr></argument>, <argument><expr><operator>*</operator><name>pi</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>ptr</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>a</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>GETVARINT_STEP</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>,  <argument><expr><literal type="number">0x7F</literal></expr></argument>,     <argument><expr><literal type="number">0x4000</literal></expr></argument>, <argument><expr><operator>*</operator><name>pi</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>GETVARINT_STEP</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>, <argument><expr><literal type="number">0x3FFF</literal></expr></argument>,   <argument><expr><literal type="number">0x200000</literal></expr></argument>, <argument><expr><operator>*</operator><name>pi</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>GETVARINT_STEP</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">21</literal></expr></argument>, <argument><expr><literal type="number">0x1FFFFF</literal></expr></argument>, <argument><expr><literal type="number">0x10000000</literal></expr></argument>, <argument><expr><operator>*</operator><name>pi</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>a</name> <operator>&amp;</operator> <literal type="number">0x0FFFFFFF</literal> <operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pi</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>a</name> <operator>|</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><operator>*</operator><name>ptr</name> <operator>&amp;</operator> <literal type="number">0x07</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">28</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name>a</name> <operator>&amp;</operator> <literal type="number">0x80000000</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pi</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">5</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of bytes required to encode v as a varint
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3VarintLen</name><parameter_list>(<parameter><decl><type><name>sqlite3_uint64</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert an SQL-style quoted string into a normal string by removing
** the quote characters.  The conversion is done in-place.  If the
** input does not begin with a quote character, then this routine
** is a no-op.
**
** Examples:
**
**     "abc"   becomes   abc
**     'xyz'   becomes   xyz
**     [pqr]   becomes   pqr
**     `mno`   becomes   mno
**
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Fts3Dequote</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>quote</name></decl>;</decl_stmt>                     <comment type="block">/* Quote character (if any ) */</comment>

  <expr_stmt><expr><name>quote</name> <operator>=</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>quote</name><operator>==</operator><literal type="char">'['</literal> <operator>||</operator> <name>quote</name><operator>==</operator><literal type="char">'\''</literal> <operator>||</operator> <name>quote</name><operator>==</operator><literal type="char">'"'</literal> <operator>||</operator> <name>quote</name><operator>==</operator><literal type="char">'`'</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iIn</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Index of next byte to read from input */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Index of next byte to write to output */</comment>

    <comment type="block">/* If the first byte was a '[', then the close-quote character is a ']' */</comment>
    <if_stmt><if>if<condition>( <expr><name>quote</name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>quote</name> <operator>=</operator> <literal type="char">']'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  

    <while>while<condition>( <expr><name><name>z</name><index>[<expr><name>iIn</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>==</operator><name>quote</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>iIn</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><name>quote</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>quote</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iIn</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>z</name><index>[<expr><name>iIn</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>z</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Read a single varint from the doclist at *pp and advance *pp to point
** to the first byte past the end of the varint.  Add the value of the varint
** to *pVal.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3GetDeltaVarint</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iVal</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarint</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pVal</name> <operator>+=</operator> <name>iVal</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** When this function is called, *pp points to the first byte following a
** varint that is part of a doclist (or position-list, or any other list
** of varints). This function moves *pp to point to the start of that varint,
** and sets *pVal by the varint value.
**
** Argument pStart points to the first byte of the doclist that the
** varint is part of.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3GetReverseVarint</name><parameter_list>(
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pStart</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

  <comment type="block">/* Pointer p now points at the first byte past the varint we are 
  ** interested in. So, unless the doclist is corrupt, the 0x80 bit is
  ** clear on character p[-1]. */</comment>
  <for>for<control>(<init><expr><name>p</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-</operator><literal type="number">2</literal></expr>;</init> <condition><expr><name>p</name><operator>&gt;=</operator><name>pStart</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name><operator>&amp;</operator><literal type="number">0x80</literal></expr>;</condition> <incr><expr><name>p</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3Fts3GetVarint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pVal</name> <operator>=</operator> <name>iVal</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The xDisconnect() virtual table method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3DisconnectMethod</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nPendingData</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSegments</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Free any prepared statements held */</comment>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSeekStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>SizeofArray</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aStmt</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aStmt</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSegmentsTbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zReadExprlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zWriteExprlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zContentTbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zLanguageid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Invoke the tokenizer destructor to free the tokenizer. */</comment>
  <expr_stmt><expr><call><name><name>p</name><operator>-&gt;</operator><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xDestroy</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write an error message into *pzErr
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Fts3ErrMsg</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>*</operator><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Construct one or more SQL statements from the format string given
** and then evaluate those statements. The success code is written
** into *pRc.
**
** If *pRc is initially non-zero then this routine is a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3DbExec</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>,              <comment type="block">/* Success code */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,           <comment type="block">/* Database in which to run SQL */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>,   <comment type="block">/* Format string for SQL */</comment>
  <parameter><decl><type><modifier>...</modifier></type></decl></parameter>                    <comment type="block">/* Arguments to the format string */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The xDestroy() virtual table method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3DestroyMethod</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>              <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Name of database (e.g. "main", "temp") */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Database handle */</comment>

  <comment type="block">/* Drop the shadow tables */</comment>
  <expr_stmt><expr><call><name>fts3DbExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, 
    <argument><expr><literal type="string">"DROP TABLE IF EXISTS %Q.'%q_segments';"</literal>
    <literal type="string">"DROP TABLE IF EXISTS %Q.'%q_segdir';"</literal>
    <literal type="string">"DROP TABLE IF EXISTS %Q.'%q_docsize';"</literal>
    <literal type="string">"DROP TABLE IF EXISTS %Q.'%q_stat';"</literal>
    <literal type="string">"%s DROP TABLE IF EXISTS %Q.'%q_content';"</literal></expr></argument>,
    <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
    <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
    <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
    <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
    <argument><expr><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>zContentTbl</name></name></expr> ?</condition><then> <expr><literal type="string">"--"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>zDb</name></expr></argument>,<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If everything has worked, invoke fts3DisconnectMethod() to free the
  ** memory associated with the Fts3Table structure and return SQLITE_OK.
  ** Otherwise, return an SQLite error code.
  */</comment>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> ?</condition><then> <expr><call><name>fts3DisconnectMethod</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>rc</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Invoke sqlite3_declare_vtab() to declare the schema for the FTS3 table
** passed as the first argument. This is done as part of the xConnect()
** and xCreate() methods.
**
** If *pRc is non-zero when this function is called, it is a no-op. 
** Otherwise, if an error occurs, an SQLite error code is stored in *pRc
** before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3DeclareVtab</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                        <comment type="block">/* Iterator variable */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                       <comment type="block">/* Return code */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>                   <comment type="block">/* SQL statement passed to declare_vtab() */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCols</name></decl>;</decl_stmt>                  <comment type="block">/* List of user defined columns */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLanguageid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>zLanguageid</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>zLanguageid</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>zLanguageid</name></name></expr> </then><else>: <expr><literal type="string">"__langid"</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_vtab_config</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_VTAB_CONSTRAINT_SUPPORT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create a list of user columns for the virtual table */</comment>
    <expr_stmt><expr><name>zCols</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%Q, "</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>azColumn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>zCols</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>zCols</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z%Q, "</literal></expr></argument>, <argument><expr><name>zCols</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>azColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Create the whole "CREATE TABLE" statement to pass to SQLite */</comment>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
        <argument><expr><literal type="string">"CREATE TABLE x(%s %Q HIDDEN, docid HIDDEN, %Q HIDDEN)"</literal></expr></argument>, 
        <argument><expr><name>zCols</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zLanguageid</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zCols</name> <operator>||</operator> <operator>!</operator><name>zSql</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Create the %_stat table if it does not already exist.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Fts3CreateStatTable</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>fts3DbExec</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, 
      <argument><expr><literal type="string">"CREATE TABLE IF NOT EXISTS %Q.'%q_stat'"</literal>
          <literal type="string">"(id INTEGER PRIMARY KEY, value BLOB);"</literal></expr></argument>,
      <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>pRc</name><operator>)</operator><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bHasStat</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Create the backing store tables (%_content, %_segments and %_segdir)
** required by the FTS3 table passed as the only argument. This is done
** as part of the vtab xCreate() method.
**
** If the p-&gt;bHasDocsize boolean is true (indicating that this is an
** FTS4 table, not an FTS3 table) then also create the %_docsize and
** %_stat tables required by FTS4.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3CreateTables</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Iterator variable */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>            <comment type="block">/* The database connection */</comment>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zContentTbl</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLanguageid</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>zLanguageid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zContentCols</name></decl>;</decl_stmt>           <comment type="block">/* Columns of %_content table */</comment>

    <comment type="block">/* Create a list of user columns for the content table */</comment>
    <expr_stmt><expr><name>zContentCols</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"docid INTEGER PRIMARY KEY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>zContentCols</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>azColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>zContentCols</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z, 'c%d%q'"</literal></expr></argument>, <argument><expr><name>zContentCols</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>zLanguageid</name> <operator>&amp;&amp;</operator> <name>zContentCols</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zContentCols</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z, langid"</literal></expr></argument>, <argument><expr><name>zContentCols</name></expr></argument>, <argument><expr><name>zLanguageid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>zContentCols</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  
    <comment type="block">/* Create the content table */</comment>
    <expr_stmt><expr><call><name>fts3DbExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, 
       <argument><expr><literal type="string">"CREATE TABLE %Q.'%q_content'(%s)"</literal></expr></argument>,
       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zContentCols</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zContentCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Create other tables */</comment>
  <expr_stmt><expr><call><name>fts3DbExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, 
      <argument><expr><literal type="string">"CREATE TABLE %Q.'%q_segments'(blockid INTEGER PRIMARY KEY, block BLOB);"</literal></expr></argument>,
      <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fts3DbExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, 
      <argument><expr><literal type="string">"CREATE TABLE %Q.'%q_segdir'("</literal>
        <literal type="string">"level INTEGER,"</literal>
        <literal type="string">"idx INTEGER,"</literal>
        <literal type="string">"start_block INTEGER,"</literal>
        <literal type="string">"leaves_end_block INTEGER,"</literal>
        <literal type="string">"end_block INTEGER,"</literal>
        <literal type="string">"root BLOB,"</literal>
        <literal type="string">"PRIMARY KEY(level, idx)"</literal>
      <literal type="string">");"</literal></expr></argument>,
      <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bHasDocsize</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fts3DbExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, 
        <argument><expr><literal type="string">"CREATE TABLE %Q.'%q_docsize'(docid INTEGER PRIMARY KEY, size BLOB);"</literal></expr></argument>,
        <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bHasStat</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>bFts4</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bHasStat</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Fts3CreateStatTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Store the current database page-size in bytes in p-&gt;nPgsz.
**
** If *pRc is non-zero when this function is called, it is a no-op. 
** Otherwise, if an error occurs, an SQLite error code is stored in *pRc
** before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3DatabasePageSize</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                       <comment type="block">/* Return code */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>                   <comment type="block">/* SQL text "PRAGMA %Q.page_size" */</comment>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>          <comment type="block">/* Compiled "PRAGMA %Q.page_size" statement */</comment>
  
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"PRAGMA %Q.page_size"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zSql</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nPgsz</name></name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_AUTH</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nPgsz</name></name> <operator>=</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nPgsz</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** "Special" FTS4 arguments are column specifications of the following form:
**
**   &lt;key&gt; = &lt;value&gt;
**
** There may not be whitespace surrounding the "=" character. The &lt;value&gt; 
** term may be quoted, but the &lt;key&gt; may not.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3IsSpecialColumn</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnKey</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzValue</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zValue</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCsr</name> <init>= <expr><name>z</name></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><operator>*</operator><name>zCsr</name><operator>!=</operator><literal type="char">'='</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>zCsr</name><operator>==</operator><literal type="char">'\0'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zCsr</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><operator>*</operator><name>pnKey</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zCsr</name><operator>-</operator><name>z</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>zValue</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zCsr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zValue</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Fts3Dequote</name><argument_list>(<argument><expr><name>zValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pzValue</name> <operator>=</operator> <name>zValue</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append the output of a printf() style formatting to an existing string.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3Appendf</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>,                       <comment type="block">/* IN/OUT: Error code */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pz</name></decl></parameter>,                      <comment type="block">/* IN/OUT: Pointer to string buffer */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>,            <comment type="block">/* Printf format string to append */</comment>
  <parameter><decl><type><modifier>...</modifier></type></decl></parameter>                             <comment type="block">/* Arguments for printf format string */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pz</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z2</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><operator>*</operator><name>pz</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <name>z2</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>*</operator><name>pz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pz</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return a copy of input string zInput enclosed in double-quotes (") and
** with all double quote characters escaped. For example:
**
**     fts3QuoteId("un \"zip\"")   -&gt;    "un \"\"zip\"\""
**
** The pointer returned points to memory obtained from sqlite3_malloc(). It
** is the callers responsibility to call sqlite3_free() to release this
** memory.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>fts3QuoteId</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zInput</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nRet</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>nRet</name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zInput</name></expr></argument>)</argument_list></call><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zRet</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name>zRet</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zInput</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>zInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>zInput</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a list of comma separated SQL expressions and a FROM clause that 
** could be used in a SELECT statement such as the following:
**
**     SELECT &lt;list of expressions&gt; FROM %_content AS x ...
**
** to return the docid, followed by each column of text data in order
** from left to write. If parameter zFunc is not NULL, then instead of
** being returned directly each column of text data is passed to an SQL
** function named zFunc first. For example, if zFunc is "unzip" and the
** table has the three user-defined columns "a", "b", and "c", the following
** string is returned:
**
**     "docid, unzip(x.'a'), unzip(x.'b'), unzip(x.'c') FROM %_content AS x"
**
** The pointer returned points to a buffer allocated by sqlite3_malloc(). It
** is the responsibility of the caller to eventually free it.
**
** If *pRc is not SQLITE_OK when this function is called, it is a no-op (and
** a NULL pointer is returned). Otherwise, if an OOM error is encountered
** by this function, NULL is returned and *pRc is set to SQLITE_NOMEM. If
** no error occurs, *pRc is left unmodified.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>fts3ReadExprList</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFunc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFunction</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zContentTbl</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zFunc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zFunction</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zFree</name> <operator>=</operator> <name>zFunction</name> <operator>=</operator> <call><name>fts3QuoteId</name><argument_list>(<argument><expr><name>zFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>fts3Appendf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zRet</name></expr></argument>, <argument><expr><literal type="string">"docid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>fts3Appendf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zRet</name></expr></argument>, <argument><expr><literal type="string">",%s(x.'c%d%q')"</literal></expr></argument>, <argument><expr><name>zFunction</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>azColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zLanguageid</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fts3Appendf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zRet</name></expr></argument>, <argument><expr><literal type="string">", x.%Q"</literal></expr></argument>, <argument><expr><literal type="string">"langid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>fts3Appendf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zRet</name></expr></argument>, <argument><expr><literal type="string">"rowid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>fts3Appendf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zRet</name></expr></argument>, <argument><expr><literal type="string">", x.'%q'"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>azColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zLanguageid</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fts3Appendf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zRet</name></expr></argument>, <argument><expr><literal type="string">", x.%Q"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zLanguageid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>fts3Appendf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zRet</name></expr></argument>, <argument><expr><literal type="string">" FROM '%q'.'%q%s' AS x"</literal></expr></argument>, 
      <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>,
      <argument><expr><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>zContentTbl</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>zContentTbl</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></else></ternary><operator>)</operator></expr></argument>,
      <argument><expr><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>zContentTbl</name></name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"_content"</literal></expr></else></ternary><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a list of N comma separated question marks, where N is the number
** of columns in the %_content table (one for the docid plus one for each
** user-defined text column).
**
** If argument zFunc is not NULL, then all but the first question mark
** is preceded by zFunc and an open bracket, and followed by a closed
** bracket. For example, if zFunc is "zip" and the FTS3 table has three 
** user-defined text columns, the following string is returned:
**
**     "?, zip(?), zip(?), zip(?)"
**
** The pointer returned points to a buffer allocated by sqlite3_malloc(). It
** is the responsibility of the caller to eventually free it.
**
** If *pRc is not SQLITE_OK when this function is called, it is a no-op (and
** a NULL pointer is returned). Otherwise, if an OOM error is encountered
** by this function, NULL is returned and *pRc is set to SQLITE_NOMEM. If
** no error occurs, *pRc is left unmodified.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>fts3WriteExprList</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFunc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFunction</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zFunc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zFunction</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zFree</name> <operator>=</operator> <name>zFunction</name> <operator>=</operator> <call><name>fts3QuoteId</name><argument_list>(<argument><expr><name>zFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>fts3Appendf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zRet</name></expr></argument>, <argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>fts3Appendf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zRet</name></expr></argument>, <argument><expr><literal type="string">",%s(?)"</literal></expr></argument>, <argument><expr><name>zFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zLanguageid</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fts3Appendf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zRet</name></expr></argument>, <argument><expr><literal type="string">", ?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Buffer z contains a positive integer value encoded as utf-8 text.
** Decode this value and store it in *pnOut, returning the number of bytes
** consumed. If an overflow error occurs return a negative value.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3ReadInt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u64</name></type> <name>iVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;=</operator><literal type="char">'9'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>iVal</name> <operator>=</operator> <name>iVal</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>&gt;</operator><literal type="number">0x7FFFFFFF</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>pnOut</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>iVal</name></expr>;</expr_stmt>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function interprets the string at (*pp) as a non-negative integer
** value. It reads the integer and sets *pnOut to the value read, then 
** sets *pp to point to the byte immediately following the last byte of
** the integer value.
**
** Only decimal digits ('0'..'9') may be part of an integer value. 
**
** If *pp does not being with a decimal digit SQLITE_ERROR is returned and
** the output value undefined. Otherwise SQLITE_OK is returned.
**
** This function is used when parsing the "prefix=" FTS4 parameter.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3GobbleInt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>MAX_NPREFIX</name> <init>= <expr><literal type="number">10000000</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nInt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Output value */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>sqlite3Fts3ReadInt</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nInt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nInt</name><operator>&gt;</operator><name>MAX_NPREFIX</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nInt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnOut</name> <operator>=</operator> <name>nInt</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called to allocate an array of Fts3Index structures
** representing the indexes maintained by the current FTS table. FTS tables
** always maintain the main "terms" index, but may also maintain one or
** more "prefix" indexes, depending on the value of the "prefix=" parameter
** (if any) specified as part of the CREATE VIRTUAL TABLE statement.
**
** Argument zParam is passed the value of the "prefix=" option if one was
** specified, or NULL otherwise.
**
** If no error occurs, SQLITE_OK is returned and *apIndex set to point to
** the allocated array. *pnIndex is set to the number of elements in the
** array. If an error does occur, an SQLite error code is returned.
**
** Regardless of whether or not an error is returned, it is the responsibility
** of the caller to call sqlite3_free() on the output array to free it.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3PrefixParameter</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zParam</name></decl></parameter>,             <comment type="block">/* ABC in prefix=ABC parameter to parse */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnIndex</name></decl></parameter>,                   <comment type="block">/* OUT: size of *apIndex[] array */</comment>
  <parameter><decl><type><name><name>struct</name> <name>Fts3Index</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>apIndex</name></decl></parameter>      <comment type="block">/* OUT: Array of indexes for this table */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>Fts3Index</name></name> <modifier>*</modifier></type><name>aIndex</name></decl>;</decl_stmt>       <comment type="block">/* Allocated array */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nIndex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Number of entries in array */</comment>

  <if_stmt><if>if<condition>( <expr><name>zParam</name> <operator>&amp;&amp;</operator> <name><name>zParam</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nIndex</name><operator>++</operator></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>zParam</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">','</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nIndex</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>aIndex</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>Fts3Index</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>apIndex</name> <operator>=</operator> <name>aIndex</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aIndex</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>Fts3Index</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zParam</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>zParam</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nIndex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nPrefix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>fts3GobbleInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPrefix</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nPrefix</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nPrefix</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nIndex</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>aIndex</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nPrefix</name> <operator>=</operator> <name>nPrefix</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pnIndex</name> <operator>=</operator> <name>nIndex</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called when initializing an FTS4 table that uses the
** content=xxx option. It determines the number of and names of the columns
** of the new FTS4 table.
**
** The third argument passed to this function is the value passed to the
** config=xxx option (i.e. "xxx"). This function queries the database for
** a table of that name. If found, the output variables are populated
** as follows:
**
**   *pnCol:   Set to the number of columns table xxx has,
**
**   *pnStr:   Set to the total amount of space required to store a copy
**             of each columns name, including the nul-terminator.
**
**   *pazCol:  Set to point to an array of *pnCol strings. Each string is
**             the name of the corresponding column in table xxx. The array
**             and its contents are allocated using a single allocation. It
**             is the responsibility of the caller to free this allocation
**             by eventually passing the *pazCol value to sqlite3_free().
**
** If the table cannot be found, an error code is returned and the output
** variables are undefined. Or, if an OOM is encountered, SQLITE_NOMEM is
** returned (and the output variables are undefined).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ContentColumns</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,                <comment type="block">/* Name of db (i.e. "main", "temp" etc.) */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTbl</name></decl></parameter>,               <comment type="block">/* Name of content table */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>pazCol</name></decl></parameter>,           <comment type="block">/* OUT: Malloc'd array of column names */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnCol</name></decl></parameter>,                     <comment type="block">/* OUT: Size of array *pazCol */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnStr</name></decl></parameter>,                     <comment type="block">/* OUT: Bytes of string content */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: error message */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>                     <comment type="block">/* "SELECT *" statement on zTbl */</comment>  
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Compiled version of zSql */</comment>

  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT * FROM %Q.%Q"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zSql</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3Fts3ErrMsg</name><argument_list>(<argument><expr><name>pzErr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name></decl>;</decl_stmt>           <comment type="block">/* Output array */</comment>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nStr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Size of all column names (incl. 0x00) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                     <comment type="block">/* Number of table columns */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                        <comment type="block">/* Used to iterate through columns */</comment>

    <comment type="block">/* Loop through the returned columns. Set nStr to the number of bytes of
    ** space required to store a copy of each column name, including the
    ** nul-terminator byte.  */</comment>
    <expr_stmt><expr><name>nCol</name> <operator>=</operator> <call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol</name> <init>= <expr><call><name>sqlite3_column_name</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>nStr</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zCol</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Allocate and populate the array to return. */</comment>
    <expr_stmt><expr><name>azCol</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nCol</name> <operator>+</operator> <name>nStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>azCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>azCol</name><index>[<expr><name>nCol</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol</name> <init>= <expr><call><name>sqlite3_column_name</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zCol</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set the output variables. */</comment>
    <expr_stmt><expr><operator>*</operator><name>pnCol</name> <operator>=</operator> <name>nCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnStr</name> <operator>=</operator> <name>nStr</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pazCol</name> <operator>=</operator> <name>azCol</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is the implementation of both the xConnect and xCreate
** methods of the FTS3 virtual table.
**
** The argv[] array contains the following:
**
**   argv[0]   -&gt; module name  ("fts3" or "fts4")
**   argv[1]   -&gt; database name
**   argv[2]   -&gt; table name
**   argv[...] -&gt; "column name" and other module argument fields.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3InitVtab</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>isCreate</name></decl></parameter>,                   <comment type="block">/* True for xCreate, false for xConnect */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* The SQLite database connection */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,                     <comment type="block">/* Hash table containing tokenizers */</comment>
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,                       <comment type="block">/* Number of elements in argv array */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>argv</name></decl></parameter>,       <comment type="block">/* xCreate/xConnect argument array */</comment>
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVTab</name></decl></parameter>,          <comment type="block">/* Write the resulting vtab structure here */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* Write any error message here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Hash</name> <modifier>*</modifier></type><name>pHash</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>Fts3HashWrapper</name><operator>*</operator><operator>)</operator><name>pAux</name><operator>)</operator><operator>-&gt;</operator><name>hash</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Pointer to allocated vtab */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Iterator variable */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl>;</decl_stmt>            <comment type="block">/* Size of allocation used for *p */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                       <comment type="block">/* Column index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nString</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Bytes required to hold all column names */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Number of columns in the FTS table */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCsr</name></decl>;</decl_stmt>                     <comment type="block">/* Space for holding column names */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nDb</name></decl>;</decl_stmt>                        <comment type="block">/* Bytes required to hold database name */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>                      <comment type="block">/* Bytes required to hold table name */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isFts4</name> <init>= <expr><operator>(</operator><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>==</operator><literal type="char">'4'</literal><operator>)</operator></expr></init></decl>;</decl_stmt> <comment type="block">/* True for FTS4, false for FTS3 */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>aCol</name></decl>;</decl_stmt>              <comment type="block">/* Array of column names */</comment>
  <decl_stmt><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Tokenizer for this table */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>nIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Size of aIndex[] array */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>Fts3Index</name></name> <modifier>*</modifier></type><name>aIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Array of indexes for this table */</comment>

  <comment type="block">/* The results of parsing supported FTS4 key=value options: */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bNoDocsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* True to omit %_docsize table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bDescIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* True to store descending indexes */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zPrefix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Prefix parameter value (or NULL) */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCompress</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* compress=? parameter (or NULL) */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zUncompress</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* uncompress=? parameter (or NULL) */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zContent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* content=? parameter (or NULL) */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zLanguageid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* languageid=? parameter (or NULL) */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azNotindexed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* The set of notindexed= columns */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nNotindexed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Size of azNotindexed[] array */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"fts4"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>isFts4</name><operator>)</operator>
       <operator>||</operator> <operator>(</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"fts3"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>isFts4</name><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>nDb</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nName</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>argc</name><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>aCol</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aCol</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>aCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>azNotindexed</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>azNotindexed</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>azNotindexed</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aCol</name> <operator>||</operator> <operator>!</operator><name>azNotindexed</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <goto>goto <name>fts3_init_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Loop through all of the arguments passed by the user to the FTS3/4
  ** module (i.e. all the column names and special arguments). This loop
  ** does the following:
  **
  **   + Figures out the number of columns the FTSX table will have, and
  **     the number of bytes of space that must be allocated to store copies
  **     of the column names.
  **
  **   + If there is a tokenizer specification included in the arguments,
  **     initializes the tokenizer pTokenizer.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">3</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zVal</name></decl>;</decl_stmt>

    <comment type="block">/* Check if this is a tokenizer specification */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTokenizer</name> 
     <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">8</literal>
     <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"tokenize"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> 
     <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3Fts3IsIdChar</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3InitTokenizer</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTokenizer</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>

    <comment type="block">/* Check if it is an FTS4 special argument. */</comment>
    <if type="elseif">else if<condition>( <expr><name>isFts4</name> <operator>&amp;&amp;</operator> <call><name>fts3IsSpecialColumn</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zVal</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <struct>struct <name>Fts4Option</name> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOpt</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nOpt</name></decl>;</decl_stmt>
      }</block> <decl><name><name>aFts4Opt</name><index>[]</index></name> <init>= <expr><block>{
        <expr><block>{ <expr><literal type="string">"matchinfo"</literal></expr>,   <expr><literal type="number">9</literal></expr> }</block></expr>,     <comment type="block">/* 0 -&gt; MATCHINFO */</comment>
        <expr><block>{ <expr><literal type="string">"prefix"</literal></expr>,      <expr><literal type="number">6</literal></expr> }</block></expr>,     <comment type="block">/* 1 -&gt; PREFIX */</comment>
        <expr><block>{ <expr><literal type="string">"compress"</literal></expr>,    <expr><literal type="number">8</literal></expr> }</block></expr>,     <comment type="block">/* 2 -&gt; COMPRESS */</comment>
        <expr><block>{ <expr><literal type="string">"uncompress"</literal></expr>, <expr><literal type="number">10</literal></expr> }</block></expr>,     <comment type="block">/* 3 -&gt; UNCOMPRESS */</comment>
        <expr><block>{ <expr><literal type="string">"order"</literal></expr>,       <expr><literal type="number">5</literal></expr> }</block></expr>,     <comment type="block">/* 4 -&gt; ORDER */</comment>
        <expr><block>{ <expr><literal type="string">"content"</literal></expr>,     <expr><literal type="number">7</literal></expr> }</block></expr>,     <comment type="block">/* 5 -&gt; CONTENT */</comment>
        <expr><block>{ <expr><literal type="string">"languageid"</literal></expr>, <expr><literal type="number">10</literal></expr> }</block></expr>,     <comment type="block">/* 6 -&gt; LANGUAGEID */</comment>
        <expr><block>{ <expr><literal type="string">"notindexed"</literal></expr>, <expr><literal type="number">10</literal></expr> }</block></expr>      <comment type="block">/* 7 -&gt; NOTINDEXED */</comment>
      }</block></expr></init></decl>;</struct>

      <decl_stmt><decl><type><name>int</name></type> <name>iOpt</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zVal</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <for>for<control>(<init><expr><name>iOpt</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iOpt</name><operator>&lt;</operator><call><name>SizeofArray</name><argument_list>(<argument><expr><name>aFts4Opt</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>iOpt</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name><name>struct</name> <name>Fts4Option</name></name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><operator>&amp;</operator><name><name>aFts4Opt</name><index>[<expr><name>iOpt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>nKey</name><operator>==</operator><name><name>pOp</name><operator>-&gt;</operator><name>nOpt</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>zOpt</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>nOpt</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <switch>switch<condition>( <expr><name>iOpt</name></expr> )</condition><block>{<block_content>
          <case>case <expr><literal type="number">0</literal></expr>:</case>               <comment type="block">/* MATCHINFO */</comment>
            <if_stmt><if>if<condition>( <expr><call><name>strlen</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">4</literal> <operator>||</operator> <call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>, <argument><expr><literal type="string">"fts3"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3Fts3ErrMsg</name><argument_list>(<argument><expr><name>pzErr</name></expr></argument>, <argument><expr><literal type="string">"unrecognized matchinfo: %s"</literal></expr></argument>, <argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>bNoDocsize</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break>

          <case>case <expr><literal type="number">1</literal></expr>:</case>               <comment type="block">/* PREFIX */</comment>
            <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>zPrefix</name> <operator>=</operator> <name>zVal</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>zVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>

          <case>case <expr><literal type="number">2</literal></expr>:</case>               <comment type="block">/* COMPRESS */</comment>
            <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCompress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>zCompress</name> <operator>=</operator> <name>zVal</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>zVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>

          <case>case <expr><literal type="number">3</literal></expr>:</case>               <comment type="block">/* UNCOMPRESS */</comment>
            <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zUncompress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>zUncompress</name> <operator>=</operator> <name>zVal</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>zVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>

          <case>case <expr><literal type="number">4</literal></expr>:</case>               <comment type="block">/* ORDER */</comment>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">3</literal> <operator>||</operator> <call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>, <argument><expr><literal type="string">"asc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator> 
             <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">4</literal> <operator>||</operator> <call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>, <argument><expr><literal type="string">"desc"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> 
            )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3Fts3ErrMsg</name><argument_list>(<argument><expr><name>pzErr</name></expr></argument>, <argument><expr><literal type="string">"unrecognized order: %s"</literal></expr></argument>, <argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>bDescIdx</name> <operator>=</operator> <operator>(</operator><name><name>zVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'d'</literal> <operator>||</operator> <name><name>zVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'D'</literal><operator>)</operator></expr>;</expr_stmt>
            <break>break;</break>

          <case>case <expr><literal type="number">5</literal></expr>:</case>              <comment type="block">/* CONTENT */</comment>
            <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>zContent</name> <operator>=</operator> <name>zVal</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>zVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>

          <case>case <expr><literal type="number">6</literal></expr>:</case>              <comment type="block">/* LANGUAGEID */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iOpt</name><operator>==</operator><literal type="number">6</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zLanguageid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>zLanguageid</name> <operator>=</operator> <name>zVal</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>zVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>

          <case>case <expr><literal type="number">7</literal></expr>:</case>              <comment type="block">/* NOTINDEXED */</comment>
            <expr_stmt><expr><name><name>azNotindexed</name><index>[<expr><name>nNotindexed</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>zVal</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>zVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>

          <default>default:</default>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iOpt</name><operator>==</operator><call><name>SizeofArray</name><argument_list>(<argument><expr><name>aFts4Opt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3Fts3ErrMsg</name><argument_list>(<argument><expr><name>pzErr</name></expr></argument>, <argument><expr><literal type="string">"unrecognized parameter: %s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></switch>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>

    <comment type="block">/* Otherwise, the argument is a column name. */</comment>
    <else>else <block>{<block_content>
      <expr_stmt><expr><name>nString</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aCol</name><index>[<expr><name>nCol</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* If a content=xxx option was specified, the following:
  **
  **   1. Ignore any compress= and uncompress= options.
  **
  **   2. If no column names were specified as part of the CREATE VIRTUAL
  **      TABLE statement, use all columns from the content table.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>zContent</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCompress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zUncompress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    <expr_stmt><expr><name>zCompress</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zUncompress</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>aCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <expr_stmt><expr><name>aCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ContentColumns</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>zContent</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>aCol</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nCol</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nString</name></expr></argument>,<argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If a languageid= option was specified, remove the language id
      ** column from the aCol[] array. */</comment> 
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>zLanguageid</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zLanguageid</name></expr></argument>, <argument><expr><name><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
            <for>for<control>(<init><expr><name>k</name><operator>=</operator><name>j</name></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aCol</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>aCol</name><index>[<expr><name>k</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><name>nCol</name><operator>--</operator></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>fts3_init_out</name>;</goto></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>nCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nString</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"content"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nString</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nCol</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pTokenizer</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3InitTokenizer</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><literal type="string">"simple"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTokenizer</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>fts3_init_out</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTokenizer</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3PrefixParameter</name><argument_list>(<argument><expr><name>zPrefix</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nIndex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ERROR</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zPrefix</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Fts3ErrMsg</name><argument_list>(<argument><expr><name>pzErr</name></expr></argument>, <argument><expr><literal type="string">"error parsing prefix parameter: %s"</literal></expr></argument>, <argument><expr><name>zPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>fts3_init_out</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Allocate and populate the Fts3Table structure. */</comment>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Fts3Table</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>                  <comment type="block">/* Fts3Table */</comment>
          <name>nCol</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>+</operator>              <comment type="block">/* azColumn */</comment>
          <name>nIndex</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>Fts3Index</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>  <comment type="block">/* aIndex */</comment>
          <name>nCol</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>u8</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>                  <comment type="block">/* abNotindexed */</comment>
          <name>nName</name> <operator>+</operator>                              <comment type="block">/* zName */</comment>
          <name>nDb</name> <operator>+</operator>                                <comment type="block">/* zDb */</comment>
          <name>nString</name></expr>;</expr_stmt>                             <comment type="block">/* Space for azColumn strings */</comment>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>Fts3Table</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <goto>goto <name>fts3_init_out</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>=</operator> <name>nCol</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nPendingData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>azColumn</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pTokenizer</name></name> <operator>=</operator> <name>pTokenizer</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nMaxPendingData</name></name> <operator>=</operator> <name>FTS3_MAX_PENDING_DATA</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bHasDocsize</name></name> <operator>=</operator> <operator>(</operator><name>isFts4</name> <operator>&amp;&amp;</operator> <name>bNoDocsize</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bHasStat</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>isFts4</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bFts4</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>isFts4</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bDescIdx</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>bDescIdx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAutoincrmerge</name></name> <operator>=</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>   <comment type="block">/* 0xff means setting unknown */</comment>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zContentTbl</name></name> <operator>=</operator> <name>zContent</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zLanguageid</name></name> <operator>=</operator> <name>zLanguageid</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zContent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>zLanguageid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TESTONLY</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>inTransaction</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TESTONLY</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>mxSavepoint</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aIndex</name></name> <operator>=</operator> <operator>(</operator>struct <name>Fts3Index</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>azColumn</name><index>[<expr><name>nCol</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aIndex</name></name></expr></argument>, <argument><expr><name>aIndex</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>Fts3Index</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name> <operator>=</operator> <name>nIndex</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nIndex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>fts3HashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aIndex</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hPending</name></expr></argument>, <argument><expr><name>FTS3_HASH_STRING</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>abNotindexed</name></name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aIndex</name><index>[<expr><name>nIndex</name></expr>]</index></name></expr>;</expr_stmt>

  <comment type="block">/* Fill in the zName and zDb fields of the vtab structure. */</comment>
  <expr_stmt><expr><name>zCsr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>abNotindexed</name><index>[<expr><name>nCol</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <name>zCsr</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zCsr</name> <operator>+=</operator> <name>nName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name> <operator>=</operator> <name>zCsr</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zCsr</name> <operator>+=</operator> <name>nDb</name></expr>;</expr_stmt>

  <comment type="block">/* Fill in the azColumn array */</comment>
  <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3Fts3NextToken</name><argument_list>(<argument><expr><name><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>zCsr</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Fts3Dequote</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>azColumn</name><index>[<expr><name>iCol</name></expr>]</index></name> <operator>=</operator> <name>zCsr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCsr</name> <operator>+=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zCsr</name> <operator>&lt;=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><index>[<expr><name>nByte</name></expr>]</index></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Fill in the abNotindexed array */</comment>
  <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>azColumn</name><index>[<expr><name>iCol</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nNotindexed</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNot</name> <init>= <expr><name><name>azNotindexed</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zNot</name> <operator>&amp;&amp;</operator> <name>n</name><operator>==</operator><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zNot</name></expr></argument>)</argument_list></call>
       <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>azColumn</name><index>[<expr><name>iCol</name></expr>]</index></name></expr></argument>, <argument><expr><name>zNot</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr> 
      )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>abNotindexed</name><index>[<expr><name>iCol</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zNot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>azNotindexed</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nNotindexed</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>azNotindexed</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3Fts3ErrMsg</name><argument_list>(<argument><expr><name>pzErr</name></expr></argument>, <argument><expr><literal type="string">"no such column: %s"</literal></expr></argument>, <argument><expr><name><name>azNotindexed</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>zCompress</name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>!=</operator><operator>(</operator><name>zUncompress</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zMiss</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>zCompress</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"compress"</literal></expr> </then><else>: <expr><literal type="string">"uncompress"</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Fts3ErrMsg</name><argument_list>(<argument><expr><name>pzErr</name></expr></argument>, <argument><expr><literal type="string">"missing %s parameter in fts4 constructor"</literal></expr></argument>, <argument><expr><name>zMiss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zReadExprlist</name></name> <operator>=</operator> <call><name>fts3ReadExprList</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zUncompress</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zWriteExprlist</name></name> <operator>=</operator> <call><name>fts3WriteExprList</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zCompress</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>fts3_init_out</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* If this is an xCreate call, create the underlying tables in the 
  ** database. TODO: For xConnect(), it could verify that said tables exist.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>isCreate</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3CreateTables</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check to see if a legacy fts3 table has been "upgraded" by the
  ** addition of a %_stat table so that it can use incremental merge.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isFts4</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isCreate</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bHasStat</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Figure out the page-size for the database. This is required in order to
  ** estimate the cost of loading large doclists from the database.  */</comment>
  <expr_stmt><expr><call><name>fts3DatabasePageSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nNodeSize</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nPgsz</name></name><operator>-</operator><literal type="number">35</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call><operator>||</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nMergeCount</name></name> <operator>=</operator> <name>FTS3_MERGE_COUNT</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Declare the table schema to SQLite. */</comment>
  <expr_stmt><expr><call><name>fts3DeclareVtab</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>fts3_init_out</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCompress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zUncompress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zLanguageid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nNotindexed</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>azNotindexed</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>aCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>azNotindexed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fts3DisconnectMethod</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_vtab</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pTokenizer</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xDestroy</name></name><argument_list>(<argument><expr><name>pTokenizer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSegments</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppVTab</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The xConnect() and xCreate() methods for the virtual table. All the
** work is done in function fts3InitVtab().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ConnectMethod</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database connection */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,                     <comment type="block">/* Pointer to tokenizer hash table */</comment>
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,                       <comment type="block">/* Number of elements in argv array */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>argv</name></decl></parameter>,       <comment type="block">/* xCreate/xConnect argument array */</comment>
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,          <comment type="block">/* OUT: New sqlite3_vtab object */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: sqlite3_malloc'd error message */</comment>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>fts3InitVtab</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ppVtab</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3CreateMethod</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database connection */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,                     <comment type="block">/* Pointer to tokenizer hash table */</comment>
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,                       <comment type="block">/* Number of elements in argv array */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>argv</name></decl></parameter>,       <comment type="block">/* xCreate/xConnect argument array */</comment>
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,          <comment type="block">/* OUT: New sqlite3_vtab object */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: sqlite3_malloc'd error message */</comment>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>fts3InitVtab</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ppVtab</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the pIdxInfo-&gt;estimatedRows variable to nRow. Unless this
** extension is currently being used by a version of SQLite too old to
** support estimatedRows. In that case this function is a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3SetEstimatedRows</name><parameter_list>(<parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nRow</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_VERSION_NUMBER</name><operator>&gt;=</operator><literal type="number">3008002</literal></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_libversion_number</name><argument_list>()</argument_list></call><operator>&gt;=</operator><literal type="number">3008002</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <name>nRow</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Set the SQLITE_INDEX_SCAN_UNIQUE flag in pIdxInfo-&gt;flags. Unless this
** extension is currently being used by a version of SQLite too old to
** support index-info flags. In that case this function is a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3SetUniqueFlag</name><parameter_list>(<parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_VERSION_NUMBER</name><operator>&gt;=</operator><literal type="number">3008012</literal></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_libversion_number</name><argument_list>()</argument_list></call><operator>&gt;=</operator><literal type="number">3008012</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxFlags</name></name> <operator>|=</operator> <name>SQLITE_INDEX_SCAN_UNIQUE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* 
** Implementation of the xBestIndex method for FTS3 tables. There
** are three possible strategies, in order of preference:
**
**   1. Direct lookup by rowid or docid. 
**   2. Full-text search using a MATCH operator on a non-docid column.
**   3. Linear scan of %_content table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3BestIndexMethod</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name>pVTab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Iterator variable */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCons</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Index of constraint to use */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>iLangidCons</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Index of langid=x constraint, if present */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDocidGe</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Index of docid&gt;=x constraint, if present */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDocidLe</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Index of docid&lt;=x constraint, if present */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iIdx</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bLock</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* By default use a full table scan. This is an expensive option,
  ** so search through the constraints to see if a more efficient 
  ** strategy is possible.
  */</comment>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>FTS3_FULLSCAN_SEARCH</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">5000000</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bDocid</name></decl>;</decl_stmt>                 <comment type="block">/* True if this constraint is on docid */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pCons</name> <init>= <expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCons</name><operator>-&gt;</operator><name>usable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCons</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_MATCH</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* There exists an unusable MATCH constraint. This means that if
        ** the planner does elect to use the results of this call as part
        ** of the overall query plan the user will see an "unable to use
        ** function MATCH in the requested context" error. To discourage
        ** this, return a very high cost here.  */</comment>
        <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>FTS3_FULLSCAN_SEARCH</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">1e50</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fts3SetEstimatedRows</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">50</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>bDocid</name> <operator>=</operator> <operator>(</operator><name><name>pCons</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCons</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* A direct lookup on the rowid or docid column. Assign a cost of 1.0. */</comment>
    <if_stmt><if>if<condition>( <expr><name>iCons</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCons</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name> <operator>&amp;&amp;</operator> <name>bDocid</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>FTS3_DOCID_SEARCH</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>iCons</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* A MATCH constraint. Use a full-text search.
    **
    ** If there is more than one MATCH constraint available, use the first
    ** one encountered. If there is both a MATCH constraint and a direct
    ** rowid/docid lookup, prefer the MATCH strategy. This is done even 
    ** though the rowid/docid lookup is faster than a MATCH query, selecting
    ** it would lead to an "unable to use function MATCH in the requested 
    ** context" error.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pCons</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_MATCH</name> 
     <operator>&amp;&amp;</operator> <name><name>pCons</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCons</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>FTS3_FULLTEXT_SEARCH</name> <operator>+</operator> <name><name>pCons</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>iCons</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Equality constraint on the langid column */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pCons</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name> 
     <operator>&amp;&amp;</operator> <name><name>pCons</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>+</operator> <literal type="number">2</literal></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iLangidCons</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>bDocid</name></expr> )</condition><block>{<block_content>
      <switch>switch<condition>( <expr><name><name>pCons</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
        <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_GE</name></expr>:</case>
        <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_GT</name></expr>:</case>
          <expr_stmt><expr><name>iDocidGe</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          <break>break;</break>

        <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_LE</name></expr>:</case>
        <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_LT</name></expr>:</case>
          <expr_stmt><expr><name>iDocidLe</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          <break>break;</break>
      </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* If using a docid=? or rowid=? strategy, set the UNIQUE flag. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pInfo</name><operator>-&gt;</operator><name>idxNum</name></name><operator>==</operator><name>FTS3_DOCID_SEARCH</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fts3SetUniqueFlag</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>iIdx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iCons</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iCons</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <name>iIdx</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iCons</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt> 
  <if_stmt><if>if<condition>( <expr><name>iLangidCons</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>|=</operator> <name>FTS3_HAVE_LANGID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iLangidCons</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <name>iIdx</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt> 
  <if_stmt><if>if<condition>( <expr><name>iDocidGe</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>|=</operator> <name>FTS3_HAVE_DOCID_GE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iDocidGe</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <name>iIdx</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt> 
  <if_stmt><if>if<condition>( <expr><name>iDocidLe</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>|=</operator> <name>FTS3_HAVE_DOCID_LE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iDocidLe</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <name>iIdx</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt> 

  <comment type="block">/* Regardless of the strategy selected, FTS can deliver rows in rowid (or
  ** docid) order. Both ascending and descending are possible. 
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pInfo</name><operator>-&gt;</operator><name>nOrderBy</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_orderby</name></name> <modifier>*</modifier></type><name>pOrder</name> <init>= <expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOrder</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOrder</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pOrder</name><operator>-&gt;</operator><name>desc</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>idxStr</name></name> <operator>=</operator> <literal type="string">"DESC"</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>idxStr</name></name> <operator>=</operator> <literal type="string">"ASC"</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>orderByConsumed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSegments</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of xOpen method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3OpenMethod</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>               <comment type="block">/* Allocated cursor */</comment>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pVTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate a buffer large enough for an Fts3Cursor structure. If the
  ** allocation succeeds, zero it and return SQLITE_OK. Otherwise, 
  ** if the allocation fails, return SQLITE_NOMEM.
  */</comment>
  <expr_stmt><expr><operator>*</operator><name>ppCsr</name> <operator>=</operator> <name>pCsr</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab_cursor</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3Cursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pCsr</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3Cursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Finalize the statement handle at pCsr-&gt;pStmt.
**
** Or, if that statement handle is one created by fts3CursorSeekStmt(),
** and the Fts3Table.pSeekStmt slot is currently NULL, save the statement
** pointer there instead of finalizing it.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3CursorFinalizeStmt</name><parameter_list>(<parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>bSeekStmt</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pSeekStmt</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pSeekStmt</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bSeekStmt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free all resources currently held by the cursor passed as the only
** argument.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3ClearCursor</name><parameter_list>(<parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>fts3CursorFinalizeStmt</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Fts3FreeDeferredTokens</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aDoclist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Fts3MIBufferFree</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pMIBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Fts3ExprFree</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3Cursor</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_vtab_cursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Close the cursor.  For additional information see the documentation
** on the xClose method of the virtual table interface.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3CloseMethod</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>Fts3Cursor</name> <operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name><operator>)</operator><operator>-&gt;</operator><name>pSegments</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fts3ClearCursor</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name><operator>)</operator><operator>-&gt;</operator><name>pSegments</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If pCsr-&gt;pStmt has not been prepared (i.e. if pCsr-&gt;pStmt==0), then
** compose and prepare an SQL statement of the form:
**
**    "SELECT &lt;columns&gt; FROM %_content WHERE rowid = ?"
**
** (or the equivalent for a content=xxx table) and set pCsr-&gt;pStmt to
** it. If an error occurs, return an SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3CursorSeekStmt</name><parameter_list>(<parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pSeekStmt</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSeekStmt</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pSeekStmt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT %s WHERE rowid = ?"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zReadExprlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zSql</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bLock</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v3</name><argument_list>(
          <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>SQLITE_PREPARE_PERSISTENT</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bLock</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bSeekStmt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Position the pCsr-&gt;pStmt statement so that it is on the row
** of the %_content table that contains the last match.  Return
** SQLITE_OK on success.  
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3CursorSeek</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>, <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>isRequireSeek</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3CursorSeekStmt</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Fts3Table</name><operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>bLock</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>isRequireSeek</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>bLock</name></name><operator>--</operator></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>bLock</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name><operator>)</operator><operator>-&gt;</operator><name>zContentTbl</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* If no row was found and no error has occurred, then the %_content
          ** table is missing a row that is present in the full-text index.
          ** The data structures are corrupt.  */</comment>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>FTS_CORRUPT_VTAB</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>isEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pContext</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is used to process a single interior node when searching
** a b-tree for a term or term prefix. The node data is passed to this 
** function via the zNode/nNode parameters. The term to search for is
** passed in zTerm/nTerm.
**
** If piFirst is not NULL, then this function sets *piFirst to the blockid
** of the child node that heads the sub-tree that may contain the term.
**
** If piLast is not NULL, then *piLast is set to the right-most child node
** that heads a sub-tree that may contain a term for which zTerm/nTerm is
** a prefix.
**
** If an OOM error occurs, SQLITE_NOMEM is returned. Otherwise, SQLITE_OK.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ScanInteriorNode</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>,              <comment type="block">/* Term to select leaves for */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,                      <comment type="block">/* Size of term zTerm in bytes */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNode</name></decl></parameter>,              <comment type="block">/* Buffer containing segment interior node */</comment>
  <parameter><decl><type><name>int</name></type> <name>nNode</name></decl></parameter>,                      <comment type="block">/* Size of buffer at zNode */</comment>
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piFirst</name></decl></parameter>,         <comment type="block">/* OUT: Selected child node */</comment>
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piLast</name></decl></parameter>           <comment type="block">/* OUT: Selected child node */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCsr</name> <init>= <expr><name>zNode</name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Cursor to iterate through node */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zCsr</name><index>[<expr><name>nNode</name></expr>]</index></name></expr></init></decl>;</decl_stmt><comment type="block">/* End of interior node buffer */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuffer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Buffer to load terms into */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nAlloc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Size of allocated buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isFirstTerm</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* True when processing first term on page */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>iChild</name></decl>;</decl_stmt>                     <comment type="block">/* Block id of child node to descend to */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuffer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Total term size */</comment>

  <comment type="block">/* Skip over the 'height' varint that occurs at the start of every 
  ** interior node. Then load the blockid of the left-child of the b-tree
  ** node into variable iChild.  
  **
  ** Even if the data structure on disk is corrupted, this (reading two
  ** varints from the buffer) does not risk an overread. If zNode is a
  ** root node, then the buffer comes from a SELECT statement. SQLite does
  ** not make this guarantee explicitly, but in practice there are always
  ** either more than 20 bytes of allocated space following the nNode bytes of
  ** contents, or two zero bytes. Or, if the node is read from the %_segments
  ** table, then there are always 20 bytes of zeroed padding following the
  ** nNode bytes of content (see sqlite3Fts3ReadBlock() for details).
  */</comment>
  <expr_stmt><expr><name>zCsr</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarintU</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zCsr</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarintU</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zCsr</name><operator>&gt;</operator><name>zEnd</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <while>while<condition>( <expr><name>zCsr</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>piFirst</name> <operator>||</operator> <name>piLast</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>                      <comment type="block">/* memcmp() result */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nSuffix</name></decl>;</decl_stmt>                  <comment type="block">/* Size of term suffix */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nPrefix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Size of term prefix */</comment>
  
    <comment type="block">/* Load the next term on the node into zBuffer. Use realloc() to expand
    ** the size of zBuffer if required.  */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isFirstTerm</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zCsr</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nPrefix</name><operator>&gt;</operator><name>nBuffer</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>FTS_CORRUPT_VTAB</name></expr>;</expr_stmt>
        <goto>goto <name>finish_scan</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>isFirstTerm</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCsr</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nPrefix</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nSuffix</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nPrefix</name><operator>&gt;</operator><name>zCsr</name><operator>-</operator><name>zNode</name> <operator>||</operator> <name>nSuffix</name><operator>&gt;</operator><name>zEnd</name><operator>-</operator><name>zCsr</name> <operator>||</operator> <name>nSuffix</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>FTS_CORRUPT_VTAB</name></expr>;</expr_stmt>
      <goto>goto <name>finish_scan</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>i64</name><operator>)</operator><name>nPrefix</name><operator>+</operator><name>nSuffix</name><operator>&gt;</operator><name>nAlloc</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name>nPrefix</name><operator>+</operator><name>nSuffix</name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>zNew</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name>zBuffer</name></expr></argument>, <argument><expr><name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zNew</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        <goto>goto <name>finish_scan</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>zBuffer</name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zBuffer</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBuffer</name><index>[<expr><name>nPrefix</name></expr>]</index></name></expr></argument>, <argument><expr><name>zCsr</name></expr></argument>, <argument><expr><name>nSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nBuffer</name> <operator>=</operator> <name>nPrefix</name> <operator>+</operator> <name>nSuffix</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCsr</name> <operator>+=</operator> <name>nSuffix</name></expr>;</expr_stmt>

    <comment type="block">/* Compare the term we are searching for with the term just loaded from
    ** the interior node. If the specified term is greater than or equal
    ** to the term from the interior node, then all terms on the sub-tree 
    ** headed by node iChild are smaller than zTerm. No need to search 
    ** iChild.
    **
    ** If the interior node term is larger than the specified term, then
    ** the tree headed by iChild may contain the specified term.
    */</comment>
    <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>zBuffer</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>nBuffer</name><operator>&gt;</operator><name>nTerm</name></expr> ?</condition><then> <expr><name>nTerm</name></expr> </then><else>: <expr><name>nBuffer</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>piFirst</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>cmp</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>cmp</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nBuffer</name><operator>&gt;</operator><name>nTerm</name><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>piFirst</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name>iChild</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>piFirst</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>piLast</name> <operator>&amp;&amp;</operator> <name>cmp</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>piLast</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name>iChild</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>piLast</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>iChild</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while><empty_stmt>;</empty_stmt>

  <if_stmt><if>if<condition>( <expr><name>piFirst</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>piFirst</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name>iChild</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>piLast</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>piLast</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name>iChild</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

 <label><name>finish_scan</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** The buffer pointed to by argument zNode (size nNode bytes) contains an
** interior node of a b-tree segment. The zTerm buffer (size nTerm bytes)
** contains a term. This function searches the sub-tree headed by the zNode
** node for the range of leaf nodes that may contain the specified term
** or terms for which the specified term is a prefix.
**
** If piLeaf is not NULL, then *piLeaf is set to the blockid of the 
** left-most leaf node in the tree that may contain the specified term.
** If piLeaf2 is not NULL, then *piLeaf2 is set to the blockid of the
** right-most leaf node that may contain a term for which the specified
** term is a prefix.
**
** It is possible that the range of returned leaf nodes does not contain 
** the specified term or any terms for which it is a prefix. However, if the 
** segment does contain any such terms, they are stored within the identified
** range. Because this function only inspects interior segment nodes (and
** never loads leaf nodes into memory), it is not possible to be sure.
**
** If an error occurs, an error code other than SQLITE_OK is returned.
*/</comment> 
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SelectLeaf</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>,              <comment type="block">/* Term to select leaves for */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,                      <comment type="block">/* Size of term zTerm in bytes */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNode</name></decl></parameter>,              <comment type="block">/* Buffer containing segment interior node */</comment>
  <parameter><decl><type><name>int</name></type> <name>nNode</name></decl></parameter>,                      <comment type="block">/* Size of buffer at zNode */</comment>
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piLeaf</name></decl></parameter>,          <comment type="block">/* Selected leaf node */</comment>
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piLeaf2</name></decl></parameter>          <comment type="block">/* Selected leaf node */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iHeight</name></decl>;</decl_stmt>                    <comment type="block">/* Height of this node in tree */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>piLeaf</name> <operator>||</operator> <name>piLeaf2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>zNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ScanInteriorNode</name><argument_list>(<argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>zNode</name></expr></argument>, <argument><expr><name>nNode</name></expr></argument>, <argument><expr><name>piLeaf</name></expr></argument>, <argument><expr><name>piLeaf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><operator>!</operator><name>piLeaf2</name> <operator>||</operator> <operator>!</operator><name>piLeaf</name> <operator>||</operator> <name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>(</operator><operator>*</operator><name>piLeaf</name><operator>&lt;=</operator><operator>*</operator><name>piLeaf2</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iHeight</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBlob</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Blob read from %_segments table */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Size of zBlob in bytes */</comment>

    <if_stmt><if>if<condition>( <expr><name>piLeaf</name> <operator>&amp;&amp;</operator> <name>piLeaf2</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>piLeaf</name><operator>!=</operator><operator>*</operator><name>piLeaf2</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3ReadBlock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>*</operator><name>piLeaf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zBlob</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nBlob</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SelectLeaf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>zBlob</name></expr></argument>, <argument><expr><name>nBlob</name></expr></argument>, <argument><expr><name>piLeaf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>piLeaf</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>zBlob</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3ReadBlock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><ternary><condition><expr><name>piLeaf</name></expr>?</condition><then><expr><operator>*</operator><name>piLeaf</name></expr></then><else>:<expr><operator>*</operator><name>piLeaf2</name></expr></else></ternary></expr></argument>, <argument><expr><operator>&amp;</operator><name>zBlob</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nBlob</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iNewHeight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>zBlob</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNewHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iNewHeight</name><operator>&gt;=</operator><name>iHeight</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>FTS_CORRUPT_VTAB</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SelectLeaf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>zBlob</name></expr></argument>, <argument><expr><name>nBlob</name></expr></argument>, <argument><expr><name>piLeaf</name></expr></argument>, <argument><expr><name>piLeaf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is used to create delta-encoded serialized lists of FTS3 
** varints. Each call to this function appends a single varint to a list.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3PutDeltaVarint</name><parameter_list>(
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,                      <comment type="block">/* IN/OUT: Output pointer */</comment>
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piPrev</name></decl></parameter>,          <comment type="block">/* IN/OUT: Previous value written to list */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iVal</name></decl></parameter>              <comment type="block">/* Write this value to the list */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><name>iVal</name><operator>-</operator><operator>*</operator><name>piPrev</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><operator>*</operator><name>piPrev</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iVal</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>, <argument><expr><name>iVal</name><operator>-</operator><operator>*</operator><name>piPrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>piPrev</name> <operator>=</operator> <name>iVal</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** When this function is called, *ppPoslist is assumed to point to the 
** start of a position-list. After it returns, *ppPoslist points to the
** first byte after the position-list.
**
** A position list is list of positions (delta encoded) and columns for 
** a single document record of a doclist.  So, in other words, this
** routine advances *ppPoslist so that it points to the next docid in
** the doclist, or to the first byte past the end of the doclist.
**
** If pp is not NULL, then the contents of the position list are copied
** to *pp. *pp is set to point to the first byte past the last byte copied
** before this function returns.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3PoslistCopy</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPoslist</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>*</operator><name>ppPoslist</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* The end of a position list is marked by a zero encoded as an FTS3 
  ** varint. A single POS_END (0) byte. Except, if the 0 byte is preceded by
  ** a byte with the 0x80 bit set, then it is not a varint 0, but the tail
  ** of some other, multi-byte, value.
  **
  ** The following while-loop moves pEnd to point to the first byte that is not 
  ** immediately preceded by a byte with the 0x80 bit set. Then increments
  ** pEnd once more so that it points to the byte immediately following the
  ** last byte in the position-list.
  */</comment>
  <while>while<condition>( <expr><operator>*</operator><name>pEnd</name> <operator>|</operator> <name>c</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>pEnd</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>c</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>pEnd</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>pEnd</name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* Advance past the POS_END terminator byte */</comment>

  <if_stmt><if>if<condition>( <expr><name>pp</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pEnd</name> <operator>-</operator> <operator>*</operator><name>ppPoslist</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>*</operator><name>ppPoslist</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppPoslist</name> <operator>=</operator> <name>pEnd</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** When this function is called, *ppPoslist is assumed to point to the 
** start of a column-list. After it returns, *ppPoslist points to the
** to the terminator (POS_COLUMN or POS_END) byte of the column-list.
**
** A column-list is list of delta-encoded positions for a single column
** within a single document within a doclist.
**
** The column-list is terminated either by a POS_COLUMN varint (1) or
** a POS_END varint (0).  This routine leaves *ppPoslist pointing to
** the POS_COLUMN or POS_END that terminates the column-list.
**
** If pp is not NULL, then the contents of the column-list are copied
** to *pp. *pp is set to point to the first byte past the last byte copied
** before this function returns.  The POS_COLUMN or POS_END terminator
** is not copied into *pp.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3ColumnlistCopy</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPoslist</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>*</operator><name>ppPoslist</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* A column-list is terminated by either a 0x01 or 0x00 byte that is
  ** not part of a multi-byte varint.
  */</comment>
  <while>while<condition>( <expr><literal type="number">0xFE</literal> <operator>&amp;</operator> <operator>(</operator><operator>*</operator><name>pEnd</name> <operator>|</operator> <name>c</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>pEnd</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>c</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>pEnd</name><operator>)</operator><operator>&amp;</operator><literal type="number">0xfe</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>pp</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pEnd</name> <operator>-</operator> <operator>*</operator><name>ppPoslist</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>*</operator><name>ppPoslist</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppPoslist</name> <operator>=</operator> <name>pEnd</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Value used to signify the end of an position-list. This must be
** as large or larger than any value that might appear on the
** position-list, even a position list that has been corrupted.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSITION_LIST_END</name></cpp:macro> <cpp:value>LARGEST_INT64</cpp:value></cpp:define>

<comment type="block">/*
** This function is used to help parse position-lists. When this function is
** called, *pp may point to the start of the next varint in the position-list
** being parsed, or it may point to 1 byte past the end of the position-list
** (in which case **pp will be a terminator bytes POS_END (0) or
** (1)).
**
** If *pp points past the end of the current position-list, set *pi to 
** POSITION_LIST_END and return. Otherwise, read the next varint from *pp,
** increment the current value of *pi by the value read, and set *pp to
** point to the next value before returning.
**
** Before calling this routine *pi must be initialized to the value of
** the previous position, or zero if we are reading the first position
** in the position-list.  Because positions are delta-encoded, the value
** of the previous position is needed in order to compute the value of
** the next position.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3ReadNextPos</name><parameter_list>(
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,                    <comment type="block">/* IN/OUT: Pointer into position-list buffer */</comment>
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pi</name></decl></parameter>             <comment type="block">/* IN/OUT: Value read from position-list */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>&amp;</operator><literal type="number">0xFE</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iVal</name></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pi</name> <operator>+=</operator> <name>iVal</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pi</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pi</name> <operator>=</operator> <name>POSITION_LIST_END</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If parameter iCol is not 0, write an POS_COLUMN (1) byte followed by
** the value of iCol encoded as a varint to *pp.   This will start a new
** column list.
**
** Set *pp to point to the byte just after the last byte written before 
** returning (do not modify it if iCol==0). Return the total number of bytes
** written (0 if iCol==0).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3PutColNumber</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                      <comment type="block">/* Number of bytes written */</comment>
  <if_stmt><if>if<condition>( <expr><name>iCol</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Output pointer */</comment>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compute the union of two position lists.  The output written
** into *pp contains all positions of both *pp1 and *pp2 in sorted
** order and with any duplicates removed.  All pointers are
** updated appropriately.   The caller is responsible for insuring
** that there is enough space in *pp to hold the complete output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3PoslistMerge</name><parameter_list>(
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,                      <comment type="block">/* Output buffer */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp1</name></decl></parameter>,                     <comment type="block">/* Left input list */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp2</name></decl></parameter>                      <comment type="block">/* Right input list */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><operator>*</operator><name>pp1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><operator>*</operator><name>pp2</name></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><operator>*</operator><name>p1</name> <operator>||</operator> <operator>*</operator><name>p2</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iCol1</name></decl>;</decl_stmt>         <comment type="block">/* The current column index in pp1 */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iCol2</name></decl>;</decl_stmt>         <comment type="block">/* The current column index in pp2 */</comment>

    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p1</name><operator>==</operator><name>POS_COLUMN</name></expr> )</condition><block>{<block_content> 
      <expr_stmt><expr><call><name>fts3GetVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCol1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCol1</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>( <expr><operator>*</operator><name>p1</name><operator>==</operator><name>POS_END</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iCol1</name> <operator>=</operator> <literal type="number">0x7fffffff</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>iCol1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p2</name><operator>==</operator><name>POS_COLUMN</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fts3GetVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCol2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCol2</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>( <expr><operator>*</operator><name>p2</name><operator>==</operator><name>POS_END</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iCol2</name> <operator>=</operator> <literal type="number">0x7fffffff</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>iCol2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iCol1</name><operator>==</operator><name>iCol2</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>i1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Last position from pp1 */</comment>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>i2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Last position from pp2 */</comment>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iPrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>fts3PutColNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>iCol1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>p1</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p2</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

      <comment type="block">/* At this point, both p1 and p2 point to the start of column-lists
      ** for the same column (the column with index iCol1 and iCol2).
      ** A column-list is a list of non-negative delta-encoded varints, each 
      ** incremented by 2 before being stored. Each list is terminated by a
      ** POS_END (0) or POS_COLUMN (1). The following block merges the two lists
      ** and writes the results to buffer p. p is left pointing to the byte
      ** after the list written. No terminator (POS_END or POS_COLUMN) is
      ** written to the output.
      */</comment>
      <expr_stmt><expr><call><name>fts3GetDeltaVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3GetDeltaVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>i1</name><operator>&lt;</operator><literal type="number">2</literal> <operator>||</operator> <name>i2</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <do>do <block>{<block_content>
        <expr_stmt><expr><call><name>fts3PutDeltaVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPrev</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>i1</name><operator>&lt;</operator><name>i2</name><operator>)</operator></expr> ?</condition><then> <expr><name>i1</name></expr> </then><else>: <expr><name>i2</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><name>iPrev</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>i1</name><operator>==</operator><name>i2</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fts3ReadNextPos</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>fts3ReadNextPos</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>i1</name><operator>&lt;</operator><name>i2</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fts3ReadNextPos</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>fts3ReadNextPos</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block>while<condition>( <expr><name>i1</name><operator>!=</operator><name>POSITION_LIST_END</name> <operator>||</operator> <name>i2</name><operator>!=</operator><name>POSITION_LIST_END</name></expr> )</condition>;</do>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iCol1</name><operator>&lt;</operator><name>iCol2</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>p1</name> <operator>+=</operator> <call><name>fts3PutColNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>iCol1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3ColumnlistCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>p2</name> <operator>+=</operator> <call><name>fts3PutColNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>iCol2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3ColumnlistCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>POS_END</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp1</name> <operator>=</operator> <name>p1</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp2</name> <operator>=</operator> <name>p2</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is used to merge two position lists into one. When it is
** called, *pp1 and *pp2 must both point to position lists. A position-list is
** the part of a doclist that follows each document id. For example, if a row
** contains:
**
**     'a b c'|'x y z'|'a b b a'
**
** Then the position list for this row for token 'b' would consist of:
**
**     0x02 0x01 0x02 0x03 0x03 0x00
**
** When this function returns, both *pp1 and *pp2 are left pointing to the
** byte following the 0x00 terminator of their respective position lists.
**
** If isSaveLeft is 0, an entry is added to the output position list for 
** each position in *pp2 for which there exists one or more positions in
** *pp1 so that (pos(*pp2)&gt;pos(*pp1) &amp;&amp; pos(*pp2)-pos(*pp1)&lt;=nToken). i.e.
** when the *pp1 token appears before the *pp2 token, but not more than nToken
** slots before it.
**
** e.g. nToken==1 searches for adjacent positions.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3PoslistPhraseMerge</name><parameter_list>(
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,                      <comment type="block">/* IN/OUT: Preallocated output buffer */</comment>
  <parameter><decl><type><name>int</name></type> <name>nToken</name></decl></parameter>,                     <comment type="block">/* Maximum difference in token positions */</comment>
  <parameter><decl><type><name>int</name></type> <name>isSaveLeft</name></decl></parameter>,                 <comment type="block">/* Save the left position */</comment>
  <parameter><decl><type><name>int</name></type> <name>isExact</name></decl></parameter>,                    <comment type="block">/* If *pp1 is exactly nTokens before *pp2 */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp1</name></decl></parameter>,                     <comment type="block">/* IN/OUT: Left input list */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp2</name></decl></parameter>                      <comment type="block">/* IN/OUT: Right input list */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><operator>*</operator><name>pp1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><operator>*</operator><name>pp2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Never set both isSaveLeft and isExact for the same invocation. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isSaveLeft</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isExact</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p1</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p2</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p1</name><operator>==</operator><name>POS_COLUMN</name></expr> )</condition><block>{<block_content> 
    <expr_stmt><expr><name>p1</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>p1</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCol1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p2</name><operator>==</operator><name>POS_COLUMN</name></expr> )</condition><block>{<block_content> 
    <expr_stmt><expr><name>p2</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>p2</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCol2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iCol1</name><operator>==</operator><name>iCol2</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pSave</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iPrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iPos1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iPos2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>iCol1</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>POS_COLUMN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iCol1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>fts3GetDeltaVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPos1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iPos1</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3GetDeltaVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPos2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iPos2</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iPos1</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>iPos2</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

      <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iPos2</name><operator>==</operator><name>iPos1</name><operator>+</operator><name>nToken</name> 
         <operator>||</operator> <operator>(</operator><name>isExact</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iPos2</name><operator>&gt;</operator><name>iPos1</name> <operator>&amp;&amp;</operator> <name>iPos2</name><operator>&lt;=</operator><name>iPos1</name><operator>+</operator><name>nToken</name><operator>)</operator></expr> 
        )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iSave</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>iSave</name> <operator>=</operator> <ternary><condition><expr><name>isSaveLeft</name></expr> ?</condition><then> <expr><name>iPos1</name></expr> </then><else>: <expr><name>iPos2</name></expr></else></ternary></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>fts3PutDeltaVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPrev</name></expr></argument>, <argument><expr><name>iSave</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iPrev</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>pSave</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>!</operator><name>isSaveLeft</name> <operator>&amp;&amp;</operator> <name>iPos2</name><operator>&lt;=</operator><operator>(</operator><name>iPos1</name><operator>+</operator><name>nToken</name><operator>)</operator><operator>)</operator> <operator>||</operator> <name>iPos2</name><operator>&lt;=</operator><name>iPos1</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>p2</name><operator>&amp;</operator><literal type="number">0xFE</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>fts3GetDeltaVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPos2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iPos2</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>p1</name><operator>&amp;</operator><literal type="number">0xFE</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>fts3GetDeltaVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPos1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iPos1</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></while>

      <if_stmt><if>if<condition>( <expr><name>pSave</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pp</name> <operator>&amp;&amp;</operator> <name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pSave</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>fts3ColumnlistCopy</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3ColumnlistCopy</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>*</operator><name>p1</name><operator>&amp;</operator><literal type="number">0xFE</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>p2</name><operator>&amp;</operator><literal type="number">0xFE</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>*</operator><name>p1</name> <operator>||</operator> <literal type="number">0</literal><operator>==</operator><operator>*</operator><name>p2</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>p1</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>p1</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCol1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p2</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>p2</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCol2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>

    <comment type="block">/* Advance pointer p1 or p2 (whichever corresponds to the smaller of
    ** iCol1 and iCol2) so that it points to either the 0x00 that marks the
    ** end of the position list, or the 0x01 that precedes the next 
    ** column-number in the position list. 
    */</comment>
    <if type="elseif">else if<condition>( <expr><name>iCol1</name><operator>&lt;</operator><name>iCol2</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fts3ColumnlistCopy</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>*</operator><name>p1</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>p1</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>p1</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCol1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>fts3ColumnlistCopy</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>*</operator><name>p2</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>p2</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>p2</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCol2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>fts3PoslistCopy</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fts3PoslistCopy</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp1</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp2</name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pp</name><operator>==</operator><name>p</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Merge two position-lists as required by the NEAR operator. The argument
** position lists correspond to the left and right phrases of an expression 
** like:
**
**     "phrase 1" NEAR "phrase number 2"
**
** Position list *pp1 corresponds to the left-hand side of the NEAR 
** expression and *pp2 to the right. As usual, the indexes in the position 
** lists are the offsets of the last token in each phrase (tokens "1" and "2" 
** in the example above).
**
** The output position list - written to *pp - is a copy of *pp2 with those
** entries that are not sufficiently NEAR entries in *pp1 removed.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3PoslistNearMerge</name><parameter_list>(
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,                      <comment type="block">/* Output buffer */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aTmp</name></decl></parameter>,                     <comment type="block">/* Temporary buffer space */</comment>
  <parameter><decl><type><name>int</name></type> <name>nRight</name></decl></parameter>,                     <comment type="block">/* Maximum difference in token positions */</comment>
  <parameter><decl><type><name>int</name></type> <name>nLeft</name></decl></parameter>,                      <comment type="block">/* Maximum difference in token positions */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp1</name></decl></parameter>,                     <comment type="block">/* IN/OUT: Left input list */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp2</name></decl></parameter>                      <comment type="block">/* IN/OUT: Right input list */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><operator>*</operator><name>pp1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><operator>*</operator><name>pp2</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pTmp1</name> <init>= <expr><name>aTmp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pTmp2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aTmp2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>fts3PoslistPhraseMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pTmp1</name></expr></argument>, <argument><expr><name>nRight</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pp1</name></expr></argument>, <argument><expr><name>pp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aTmp2</name> <operator>=</operator> <name>pTmp2</name> <operator>=</operator> <name>pTmp1</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp1</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp2</name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fts3PoslistPhraseMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pTmp2</name></expr></argument>, <argument><expr><name>nLeft</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pp2</name></expr></argument>, <argument><expr><name>pp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTmp1</name><operator>!=</operator><name>aTmp</name> <operator>&amp;&amp;</operator> <name>pTmp2</name><operator>!=</operator><name>aTmp2</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fts3PoslistMerge</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aTmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aTmp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pTmp1</name><operator>!=</operator><name>aTmp</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fts3PoslistCopy</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pTmp2</name><operator>!=</operator><name>aTmp2</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fts3PoslistCopy</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aTmp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** An instance of this function is used to merge together the (potentially
** large number of) doclists for each term that matches a prefix query.
** See function fts3TermSelectMerge() for details.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>TermSelect</name></name></type> <name>TermSelect</name>;</typedef>
<struct>struct <name>TermSelect</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>aaOutput</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>             <comment type="block">/* Malloc'd output buffers */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>anOutput</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>               <comment type="block">/* Size each output buffer in bytes */</comment>
}</block>;</struct>

<comment type="block">/*
** This function is used to read a single varint from a buffer. Parameter
** pEnd points 1 byte past the end of the buffer. When this function is
** called, if *pp points to pEnd or greater, then the end of the buffer
** has been reached. In this case *pp is set to 0 and the function returns.
**
** If *pp does not point to or past pEnd, then a single varint is read
** from *pp. *pp is then set to point 1 byte past the end of the read varint.
**
** If bDescIdx is false, the value read is added to *pVal before returning.
** If it is true, the value read is subtracted from *pVal before this 
** function returns.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3GetDeltaVarint3</name><parameter_list>(
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,                      <comment type="block">/* IN/OUT: Point to read varint from */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pEnd</name></decl></parameter>,                     <comment type="block">/* End of buffer */</comment>
  <parameter><decl><type><name>int</name></type> <name>bDescIdx</name></decl></parameter>,                   <comment type="block">/* True if docids are descending */</comment>
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>             <comment type="block">/* IN/OUT: Integer value */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pp</name><operator>&gt;=</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>u64</name></type> <name>iVal</name></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarintU</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bDescIdx</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pVal</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><operator>*</operator><name>pVal</name> <operator>-</operator> <name>iVal</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pVal</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><operator>*</operator><name>pVal</name> <operator>+</operator> <name>iVal</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is used to write a single varint to a buffer. The varint
** is written to *pp. Before returning, *pp is set to point 1 byte past the
** end of the value written.
**
** If *pbFirst is zero when this function is called, the value written to
** the buffer is that of parameter iVal. 
**
** If *pbFirst is non-zero when this function is called, then the value 
** written is either (iVal-*piPrev) (if bDescIdx is zero) or (*piPrev-iVal)
** (if bDescIdx is non-zero).
**
** Before returning, this function always sets *pbFirst to 1 and *piPrev
** to the value of parameter iVal.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3PutDeltaVarint3</name><parameter_list>(
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,                      <comment type="block">/* IN/OUT: Output pointer */</comment>
  <parameter><decl><type><name>int</name></type> <name>bDescIdx</name></decl></parameter>,                   <comment type="block">/* True for descending docids */</comment>
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piPrev</name></decl></parameter>,          <comment type="block">/* IN/OUT: Previous value written to list */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbFirst</name></decl></parameter>,                   <comment type="block">/* IN/OUT: True after first int written */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iVal</name></decl></parameter>              <comment type="block">/* Write this value to the list */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>iWrite</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>bDescIdx</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>pbFirst</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><operator>*</operator><name>pbFirst</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iVal</name><operator>&gt;=</operator><operator>*</operator><name>piPrev</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iWrite</name> <operator>=</operator> <operator>(</operator><name>u64</name><operator>)</operator><name>iVal</name> <operator>-</operator> <operator>(</operator><name>u64</name><operator>)</operator><operator>*</operator><name>piPrev</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><operator>*</operator><name>piPrev</name><operator>&gt;=</operator><name>iVal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iWrite</name> <operator>=</operator> <operator>(</operator><name>u64</name><operator>)</operator><operator>*</operator><name>piPrev</name> <operator>-</operator> <operator>(</operator><name>u64</name><operator>)</operator><name>iVal</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pbFirst</name> <operator>||</operator> <operator>*</operator><name>piPrev</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><operator>*</operator><name>pbFirst</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iWrite</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>, <argument><expr><name>iWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>piPrev</name> <operator>=</operator> <name>iVal</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pbFirst</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** This macro is used by various functions that merge doclists. The two
** arguments are 64-bit docid values. If the value of the stack variable
** bDescDoclist is 0 when this macro is invoked, then it returns (i1-i2). 
** Otherwise, (i2-i1).
**
** Using this makes it easier to write code that can merge doclists that are
** sorted in either ascending or descending order.
*/</comment>
<comment type="block">/* #define DOCID_CMP(i1, i2) ((bDescDoclist?-1:1) * (i64)((u64)i1-i2)) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOCID_CMP</name><parameter_list>(<parameter><type><name>i1</name></type></parameter>, <parameter><type><name>i2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((bDescDoclist?-1:1) * (i1&gt;i2?1:((i1==i2)?0:-1)))</cpp:value></cpp:define>

<comment type="block">/*
** This function does an "OR" merge of two doclists (output contains all
** positions contained in either argument doclist). If the docids in the 
** input doclists are sorted in ascending order, parameter bDescDoclist
** should be false. If they are sorted in ascending order, it should be
** passed a non-zero value.
**
** If no error occurs, *paOut is set to point at an sqlite3_malloc'd buffer
** containing the output doclist and SQLITE_OK is returned. In this case
** *pnOut is set to the number of bytes in the output doclist.
**
** If an error occurs, an SQLite error code is returned. The output values
** are undefined in this case.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3DoclistOrMerge</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>bDescDoclist</name></decl></parameter>,               <comment type="block">/* True if arguments are desc */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>a1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n1</name></decl></parameter>,               <comment type="block">/* First doclist */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>a2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n2</name></decl></parameter>,               <comment type="block">/* Second doclist */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>paOut</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>        <comment type="block">/* OUT: Malloc'd doclist */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>i1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>i2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iPrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pEnd1</name> <init>= <expr><operator>&amp;</operator><name><name>a1</name><index>[<expr><name>n1</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pEnd2</name> <init>= <expr><operator>&amp;</operator><name><name>a2</name><index>[<expr><name>n2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><name>a1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><name>a2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aOut</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bFirstOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>paOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Allocate space for the output. Both the input and output doclists
  ** are delta encoded. If they are in ascending order (bDescDoclist==0),
  ** then the first docid in each list is simply encoded as a varint. For
  ** each subsequent docid, the varint stored is the difference between the
  ** current and previous docid (a positive number - since the list is in
  ** ascending order).
  **
  ** The first docid written to the output is therefore encoded using the 
  ** same number of bytes as it is in whichever of the input lists it is
  ** read from. And each subsequent docid read from the same input list 
  ** consumes either the same or less bytes as it did in the input (since
  ** the difference between it and the previous value in the output must
  ** be a positive value less than or equal to the delta value read from 
  ** the input list). The same argument applies to all but the first docid
  ** read from the 'other' list. And to the contents of all position lists
  ** that will be copied and merged from the input to the output.
  **
  ** However, if the first docid copied to the output is a negative number,
  ** then the encoding of the first docid from the 'other' input list may
  ** be larger in the output than it was in the input (since the delta value
  ** may be a larger positive integer than the actual docid).
  **
  ** The space required to store the output is therefore the sum of the
  ** sizes of the two inputs, plus enough space for exactly one of the input
  ** docids to grow. 
  **
  ** A symetric argument may be made if the doclists are in descending 
  ** order.
  */</comment>
  <expr_stmt><expr><name>aOut</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><operator>(</operator><name>i64</name><operator>)</operator><name>n1</name><operator>+</operator><name>n2</name><operator>+</operator><name>FTS3_VARINT_MAX</name><operator>-</operator><literal type="number">1</literal><operator>+</operator><name>FTS3_BUFFER_PADDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aOut</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <name>aOut</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fts3GetDeltaVarint3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><name>pEnd1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fts3GetDeltaVarint3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>, <argument><expr><name>pEnd2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>p1</name> <operator>||</operator> <name>p2</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iDiff</name> <init>= <expr><call><name>DOCID_CMP</name><argument_list>(<argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>p2</name> <operator>&amp;&amp;</operator> <name>p1</name> <operator>&amp;&amp;</operator> <name>iDiff</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fts3PutDeltaVarint3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>bDescDoclist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPrev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bFirstOut</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3PoslistMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>fts3GetDeltaVarint3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><name>pEnd1</name></expr></argument>, <argument><expr><name>bDescDoclist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3GetDeltaVarint3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>, <argument><expr><name>pEnd2</name></expr></argument>, <argument><expr><name>bDescDoclist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><name>p2</name> <operator>||</operator> <operator>(</operator><name>p1</name> <operator>&amp;&amp;</operator> <name>iDiff</name><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fts3PutDeltaVarint3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>bDescDoclist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPrev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bFirstOut</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3PoslistCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3GetDeltaVarint3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><name>pEnd1</name></expr></argument>, <argument><expr><name>bDescDoclist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>fts3PutDeltaVarint3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>bDescDoclist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPrev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bFirstOut</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3PoslistCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3GetDeltaVarint3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>, <argument><expr><name>pEnd2</name></expr></argument>, <argument><expr><name>bDescDoclist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>p</name><operator>-</operator><name>aOut</name><operator>)</operator><operator>&lt;=</operator><operator>(</operator><operator>(</operator><ternary><condition><expr><name>p1</name></expr>?</condition><then><expr><operator>(</operator><name>p1</name><operator>-</operator><name>a1</name><operator>)</operator></expr></then><else>:<expr><name>n1</name></expr></else></ternary><operator>)</operator><operator>+</operator><operator>(</operator><ternary><condition><expr><name>p2</name></expr>?</condition><then><expr><operator>(</operator><name>p2</name><operator>-</operator><name>a2</name><operator>)</operator></expr></then><else>:<expr><name>n2</name></expr></else></ternary><operator>)</operator><operator>+</operator><name>FTS3_VARINT_MAX</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>aOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>p</name><operator>-</operator><name>aOut</name><operator>)</operator><operator>&lt;=</operator><name>n1</name><operator>+</operator><name>n2</name><operator>+</operator><name>FTS3_VARINT_MAX</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aOut</name><index>[<expr><operator>(</operator><name>p</name><operator>-</operator><name>aOut</name><operator>)</operator></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FTS3_BUFFER_PADDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>paOut</name> <operator>=</operator> <name>aOut</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnOut</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name><operator>-</operator><name>aOut</name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function does a "phrase" merge of two doclists. In a phrase merge,
** the output contains a copy of each position from the right-hand input
** doclist for which there is a position in the left-hand input doclist
** exactly nDist tokens before it.
**
** If the docids in the input doclists are sorted in ascending order,
** parameter bDescDoclist should be false. If they are sorted in ascending 
** order, it should be passed a non-zero value.
**
** The right-hand input doclist is overwritten by this function.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3DoclistPhraseMerge</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>bDescDoclist</name></decl></parameter>,               <comment type="block">/* True if arguments are desc */</comment>
  <parameter><decl><type><name>int</name></type> <name>nDist</name></decl></parameter>,                      <comment type="block">/* Distance from left to right (1=adjacent) */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aLeft</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLeft</name></decl></parameter>,         <comment type="block">/* Left doclist */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>paRight</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnRight</name></decl></parameter>    <comment type="block">/* IN/OUT: Right/output doclist */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>i1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>i2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iPrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aRight</name> <init>= <expr><operator>*</operator><name>paRight</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pEnd1</name> <init>= <expr><operator>&amp;</operator><name><name>aLeft</name><index>[<expr><name>nLeft</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pEnd2</name> <init>= <expr><operator>&amp;</operator><name><name>aRight</name><index>[<expr><operator>*</operator><name>pnRight</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><name>aLeft</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><name>aRight</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bFirstOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aOut</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nDist</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bDescDoclist</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>aOut</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><operator>*</operator><name>pnRight</name> <operator>+</operator> <name>FTS3_VARINT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>aOut</name> <operator>=</operator> <name>aRight</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <name>aOut</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>fts3GetDeltaVarint3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><name>pEnd1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fts3GetDeltaVarint3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>, <argument><expr><name>pEnd2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><name>p1</name> <operator>&amp;&amp;</operator> <name>p2</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iDiff</name> <init>= <expr><call><name>DOCID_CMP</name><argument_list>(<argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iDiff</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pSave</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iPrevSave</name> <init>= <expr><name>iPrev</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>bFirstOutSave</name> <init>= <expr><name>bFirstOut</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>fts3PutDeltaVarint3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>bDescDoclist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPrev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bFirstOut</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>fts3PoslistPhraseMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>nDist</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pSave</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iPrev</name> <operator>=</operator> <name>iPrevSave</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bFirstOut</name> <operator>=</operator> <name>bFirstOutSave</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>fts3GetDeltaVarint3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><name>pEnd1</name></expr></argument>, <argument><expr><name>bDescDoclist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3GetDeltaVarint3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>, <argument><expr><name>pEnd2</name></expr></argument>, <argument><expr><name>bDescDoclist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iDiff</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fts3PoslistCopy</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3GetDeltaVarint3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><name>pEnd1</name></expr></argument>, <argument><expr><name>bDescDoclist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>fts3PoslistCopy</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3GetDeltaVarint3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>, <argument><expr><name>pEnd2</name></expr></argument>, <argument><expr><name>bDescDoclist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><operator>*</operator><name>pnRight</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>aOut</name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bDescDoclist</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>paRight</name> <operator>=</operator> <name>aOut</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Argument pList points to a position list nList bytes in size. This
** function checks to see if the position list contains any entries for
** a token in position 0 (of any column). If so, it writes argument iDelta
** to the output buffer pOut, followed by a position list consisting only
** of the entries from pList at position 0, and terminated by an 0x00 byte.
** The value returned is the number of bytes written to pOut (if any).
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3FirstFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iDelta</name></decl></parameter>,           <comment type="block">/* Varint that may be written to pOut */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,                    <comment type="block">/* Position list (no 0x00 term) */</comment>
  <parameter><decl><type><name>int</name></type> <name>nList</name></decl></parameter>,                      <comment type="block">/* Size of pList in bytes */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>                      <comment type="block">/* Write output here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bWritten</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* True once iDelta has been written */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>pList</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>pList</name><index>[<expr><name>nList</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name><operator>!=</operator><literal type="number">0x01</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name><operator>==</operator><literal type="number">0x02</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nOut</name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOut</name><index>[<expr><name>nOut</name></expr>]</index></name></expr></argument>, <argument><expr><name>iDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOut</name><index>[<expr><name>nOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x02</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>bWritten</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fts3ColumnlistCopy</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <while>while<condition>( <expr><name>p</name><operator>&lt;</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iCol</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name><operator>==</operator><literal type="number">0x02</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>bWritten</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nOut</name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOut</name><index>[<expr><name>nOut</name></expr>]</index></name></expr></argument>, <argument><expr><name>iDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bWritten</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pOut</name><index>[<expr><name>nOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nOut</name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOut</name><index>[<expr><name>nOut</name></expr>]</index></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOut</name><index>[<expr><name>nOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x02</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fts3ColumnlistCopy</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>bWritten</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pOut</name><index>[<expr><name>nOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>nOut</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Merge all doclists in the TermSelect.aaOutput[] array into a single
** doclist stored in TermSelect.aaOutput[0]. If successful, delete all
** other doclists (except the aaOutput[0] one) and return SQLITE_OK.
**
** If an OOM error occurs, return SQLITE_NOMEM. In this case it is
** the responsibility of the caller to free any doclists left in the
** TermSelect.aaOutput[] array.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3TermSelectFinishMerge</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>TermSelect</name> <modifier>*</modifier></type><name>pTS</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Loop through the doclists in the aaOutput[] array. Merge them all
  ** into a single doclist.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>SizeofArray</name><argument_list>(<argument><expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aOut</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>aOut</name> <operator>=</operator> <name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nOut</name> <operator>=</operator> <name><name>pTS</name><operator>-&gt;</operator><name>anOutput</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nNew</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>fts3DoclistOrMerge</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>bDescIdx</name></name></expr></argument>, 
            <argument><expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pTS</name><operator>-&gt;</operator><name>anOutput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>aOut</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nNew</name></expr></argument>
        )</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>rc</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>aOut</name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nOut</name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>aOut</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTS</name><operator>-&gt;</operator><name>anOutput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>nOut</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Merge the doclist aDoclist/nDoclist into the TermSelect object passed
** as the first argument. The merge is an "OR" merge (see function
** fts3DoclistOrMerge() for details).
**
** This function is called with the doclist for each term that matches
** a queried prefix. It merges all these doclists into one, the doclist
** for the specified prefix. Since there can be a very large number of
** doclists to merge, the merging is done pair-wise using the TermSelect
** object.
**
** This function returns SQLITE_OK if the merge is successful, or an
** SQLite error code (SQLITE_NOMEM) if an error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3TermSelectMerge</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS table handle */</comment>
  <parameter><decl><type><name>TermSelect</name> <modifier>*</modifier></type><name>pTS</name></decl></parameter>,                <comment type="block">/* TermSelect object to merge into */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aDoclist</name></decl></parameter>,                 <comment type="block">/* Pointer to doclist */</comment>
  <parameter><decl><type><name>int</name></type> <name>nDoclist</name></decl></parameter>                    <comment type="block">/* Size of aDoclist in bytes */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* If this is the first term selected, copy the doclist to the output
    ** buffer using memcpy(). 
    **
    ** Add FTS3_VARINT_MAX bytes of unused space to the end of the 
    ** allocation. This is so as to ensure that the buffer is big enough
    ** to hold the current doclist AND'd with any other doclist. If the
    ** doclists are stored in order=ASC order, this padding would not be
    ** required (since the size of [doclistA AND doclistB] is always less
    ** than or equal to the size of [doclistA] in that case). But this is
    ** not true for order=DESC. For example, a doclist containing (1, -1) 
    ** may be smaller than (-1), as in the first example the -1 may be stored
    ** as a single-byte delta, whereas in the second it must be stored as a
    ** FTS3_VARINT_MAX byte varint.
    **
    ** Similar padding is added in the fts3DoclistOrMerge() function.
    */</comment>
    <expr_stmt><expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><operator>(</operator><name>i64</name><operator>)</operator><name>nDoclist</name> <operator>+</operator> <name>FTS3_VARINT_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTS</name><operator>-&gt;</operator><name>anOutput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>nDoclist</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>aDoclist</name></expr></argument>, <argument><expr><name>nDoclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>nDoclist</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FTS3_VARINT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aMerge</name> <init>= <expr><name>aDoclist</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nMerge</name> <init>= <expr><name>nDoclist</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iOut</name></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>iOut</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iOut</name><operator>&lt;</operator><call><name>SizeofArray</name><argument_list>(<argument><expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>iOut</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name><index>[<expr><name>iOut</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iOut</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <name>aMerge</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTS</name><operator>-&gt;</operator><name>anOutput</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <name>nMerge</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nNew</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>fts3DoclistOrMerge</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>bDescIdx</name></name></expr></argument>, <argument><expr><name>aMerge</name></expr></argument>, <argument><expr><name>nMerge</name></expr></argument>, 
            <argument><expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pTS</name><operator>-&gt;</operator><name>anOutput</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nNew</name></expr></argument>
        )</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>aMerge</name><operator>!=</operator><name>aDoclist</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aMerge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <return>return <expr><name>rc</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><name>aMerge</name><operator>!=</operator><name>aDoclist</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aMerge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  
        <expr_stmt><expr><name>aMerge</name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nMerge</name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iOut</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><call><name>SizeofArray</name><argument_list>(<argument><expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pTS</name><operator>-&gt;</operator><name>aaOutput</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <name>aMerge</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pTS</name><operator>-&gt;</operator><name>anOutput</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <name>nMerge</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append SegReader object pNew to the end of the pCsr-&gt;apSegment[] array.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegReaderCursorAppend</name><parameter_list>(
  <parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, 
  <parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pNew</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name><operator>%</operator><literal type="number">16</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3SegReader</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name> <init>= <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name> <operator>+</operator> <literal type="number">16</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3SegReader</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>apNew</name> <operator>=</operator> <operator>(</operator><name>Fts3SegReader</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>apNew</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3Fts3SegReaderFree</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add seg-reader objects to the Fts3MultiSegReader object passed as the
** 8th argument.
**
** This function returns SQLITE_OK if successful, or an SQLite error code
** otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegReaderCursor</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS3 table handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>,                    <comment type="block">/* Language id */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIndex</name></decl></parameter>,                     <comment type="block">/* Index to search (from 0 to p-&gt;nIndex-1) */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>,                     <comment type="block">/* Level of segments to scan */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>,              <comment type="block">/* Term to query for */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,                      <comment type="block">/* Size of zTerm in bytes */</comment>
  <parameter><decl><type><name>int</name></type> <name>isPrefix</name></decl></parameter>,                   <comment type="block">/* True for a prefix search */</comment>
  <parameter><decl><type><name>int</name></type> <name>isScan</name></decl></parameter>,                     <comment type="block">/* True to scan from zTerm to EOF */</comment>
  <parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>        <comment type="block">/* Cursor object to populate */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Error code */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Statement to iterate through segments */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>                        <comment type="block">/* Result of sqlite3_reset() */</comment>

  <comment type="block">/* If iLevel is less than 0 and this is not a scan, include a seg-reader 
  ** for the pending-terms. If this is a scan, then this call must be being
  ** made by an fts4aux module, not an FTS table. In this case calling
  ** Fts3SegReaderPending might segfault, as the data structures used by 
  ** fts4aux are not completely populated. So it's easiest to filter these
  ** calls out here.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>aIndex</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iPrevLangid</name></name><operator>==</operator><name>iLangid</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pSeg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SegReaderPending</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>isPrefix</name><operator>||</operator><name>isScan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pSeg</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegReaderCursorAppend</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>!=</operator><name>FTS3_SEGCURSOR_PENDING</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3AllSegdirs</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pSeg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Read the values returned by the SELECT into local variables. */</comment>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iStartBlock</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iLeavesEndBlock</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iEndBlock</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nRoot</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zRoot</name> <init>= <expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* If zTerm is not NULL, and this segment is not stored entirely on its
      ** root node, the range of leaves scanned can be reduced. Do this. */</comment>
      <if_stmt><if>if<condition>( <expr><name>iStartBlock</name> <operator>&amp;&amp;</operator> <name>zTerm</name> <operator>&amp;&amp;</operator> <name>zRoot</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pi</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>isPrefix</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>iLeavesEndBlock</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SelectLeaf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>zRoot</name></expr></argument>, <argument><expr><name>nRoot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iStartBlock</name></expr></argument>, <argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>finished</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>isPrefix</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>isScan</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iLeavesEndBlock</name> <operator>=</operator> <name>iStartBlock</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
 
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SegReaderNew</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, 
          <argument><expr><operator>(</operator><name>isPrefix</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>isScan</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument>,
          <argument><expr><name>iStartBlock</name></expr></argument>, <argument><expr><name>iLeavesEndBlock</name></expr></argument>, 
          <argument><expr><name>iEndBlock</name></expr></argument>, <argument><expr><name>zRoot</name></expr></argument>, <argument><expr><name>nRoot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSeg</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>finished</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegReaderCursorAppend</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

 <label><name>finished</name>:</label>
  <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set up a cursor object for iterating through a full-text index or a 
** single level therein.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3SegReaderCursor</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS3 table handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>,                    <comment type="block">/* Language-id to search */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIndex</name></decl></parameter>,                     <comment type="block">/* Index to search (from 0 to p-&gt;nIndex-1) */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>,                     <comment type="block">/* Level of segments to scan */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>,              <comment type="block">/* Term to query for */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,                      <comment type="block">/* Size of zTerm in bytes */</comment>
  <parameter><decl><type><name>int</name></type> <name>isPrefix</name></decl></parameter>,                   <comment type="block">/* True for a prefix search */</comment>
  <parameter><decl><type><name>int</name></type> <name>isScan</name></decl></parameter>,                     <comment type="block">/* True to scan from zTerm to EOF */</comment>
  <parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>       <comment type="block">/* Cursor object to populate */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iIndex</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iIndex</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLevel</name><operator>==</operator><name>FTS3_SEGCURSOR_ALL</name>
      <operator>||</operator>  <name>iLevel</name><operator>==</operator><name>FTS3_SEGCURSOR_PENDING</name> 
      <operator>||</operator>  <name>iLevel</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLevel</name><operator>&lt;</operator><name>FTS3_SEGDIR_MAXLEVEL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>FTS3_SEGCURSOR_ALL</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>FTS3_SEGCURSOR_PENDING</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isPrefix</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isScan</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3MultiSegReader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>fts3SegReaderCursor</name><argument_list>(
      <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>isPrefix</name></expr></argument>, <argument><expr><name>isScan</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>
  )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** In addition to its current configuration, have the Fts3MultiSegReader
** passed as the 4th argument also scan the doclist for term zTerm/nTerm.
**
** SQLITE_OK is returned if no error occurs, otherwise an SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegReaderCursorAddZero</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS virtual table handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>,              <comment type="block">/* Term to scan doclist of */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,                      <comment type="block">/* Number of bytes in zTerm */</comment>
  <parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>        <comment type="block">/* Fts3MultiSegReader to modify */</comment>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>fts3SegReaderCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, 
      <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FTS3_SEGCURSOR_ALL</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>pCsr</name></expr></argument>
  )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open an Fts3MultiSegReader to scan the doclist for term zTerm/nTerm. Or,
** if isPrefix is true, to scan the doclist for all terms for which 
** zTerm/nTerm is a prefix. If successful, return SQLITE_OK and write
** a pointer to the new Fts3MultiSegReader to *ppSegcsr. Otherwise, return
** an SQLite error code.
**
** It is the responsibility of the caller to free this object by eventually
** passing it to fts3SegReaderCursorFree() 
**
** SQLITE_OK is returned if no error occurs, otherwise an SQLite error code.
** Output parameter *ppSegcsr is set to 0 if an error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3TermSegReaderCursor</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* Virtual table cursor handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>,              <comment type="block">/* Term to query for */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,                      <comment type="block">/* Size of zTerm in bytes */</comment>
  <parameter><decl><type><name>int</name></type> <name>isPrefix</name></decl></parameter>,                   <comment type="block">/* True for a prefix search */</comment>
  <parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppSegcsr</name></decl></parameter>   <comment type="block">/* OUT: Allocated seg-reader cursor */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pSegcsr</name></decl>;</decl_stmt>    <comment type="block">/* Object to allocate and return */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_NOMEM</name></expr></init></decl>;</decl_stmt>          <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><name>pSegcsr</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3MultiSegReader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSegcsr</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bFound</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* True once an index has been found */</comment>
    <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>isPrefix</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>bFound</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aIndex</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nPrefix</name><operator>==</operator><name>nTerm</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bFound</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SegReaderCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iLangid</name></name></expr></argument>, 
              <argument><expr><name>i</name></expr></argument>, <argument><expr><name>FTS3_SEGCURSOR_ALL</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pSegcsr</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pSegcsr</name><operator>-&gt;</operator><name>bLookup</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>bFound</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aIndex</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nPrefix</name><operator>==</operator><name>nTerm</name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bFound</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SegReaderCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iLangid</name></name></expr></argument>, 
              <argument><expr><name>i</name></expr></argument>, <argument><expr><name>FTS3_SEGCURSOR_ALL</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pSegcsr</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegReaderCursorAddZero</name><argument_list>(
                <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iLangid</name></name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>pSegcsr</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>bFound</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SegReaderCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iLangid</name></name></expr></argument>, 
          <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FTS3_SEGCURSOR_ALL</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>isPrefix</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pSegcsr</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSegcsr</name><operator>-&gt;</operator><name>bLookup</name></name> <operator>=</operator> <operator>!</operator><name>isPrefix</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppSegcsr</name> <operator>=</operator> <name>pSegcsr</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free an Fts3MultiSegReader allocated by fts3TermSegReaderCursor().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3SegReaderCursorFree</name><parameter_list>(<parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pSegcsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3Fts3SegReaderFinish</name><argument_list>(<argument><expr><name>pSegcsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pSegcsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function retrieves the doclist for the specified term (or term
** prefix) from the database.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3TermSelect</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>Fts3PhraseToken</name> <modifier>*</modifier></type><name>pTok</name></decl></parameter>,          <comment type="block">/* Token to query for */</comment>
  <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>,                    <comment type="block">/* Column to query (or -ve for all columns) */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>,                     <comment type="block">/* OUT: Size of buffer at *ppOut */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>                    <comment type="block">/* OUT: Malloced result buffer */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pSegcsr</name></decl>;</decl_stmt>    <comment type="block">/* Seg-reader cursor for this term */</comment>
  <decl_stmt><decl><type><name>TermSelect</name></type> <name>tsc</name></decl>;</decl_stmt>                 <comment type="block">/* Object for pair-wise doclist merging */</comment>
  <decl_stmt><decl><type><name>Fts3SegFilter</name></type> <name>filter</name></decl>;</decl_stmt>           <comment type="block">/* Segment term filter configuration */</comment>

  <expr_stmt><expr><name>pSegcsr</name> <operator>=</operator> <name><name>pTok</name><operator>-&gt;</operator><name>pSegcsr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tsc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TermSelect</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>filter</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>FTS3_SEGMENT_IGNORE_EMPTY</name> <operator>|</operator> <name>FTS3_SEGMENT_REQUIRE_POS</name>
        <operator>|</operator> <operator>(</operator><ternary><condition><expr><name><name>pTok</name><operator>-&gt;</operator><name>isPrefix</name></name></expr> ?</condition><then> <expr><name>FTS3_SEGMENT_PREFIX</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
        <operator>|</operator> <operator>(</operator><ternary><condition><expr><name><name>pTok</name><operator>-&gt;</operator><name>bFirst</name></name></expr> ?</condition><then> <expr><name>FTS3_SEGMENT_FIRST</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
        <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>iColumn</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr> ?</condition><then> <expr><name>FTS3_SEGMENT_COLUMN_FILTER</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>filter</name><operator>.</operator><name>iCol</name></name> <operator>=</operator> <name>iColumn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>filter</name><operator>.</operator><name>zTerm</name></name> <operator>=</operator> <name><name>pTok</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>filter</name><operator>.</operator><name>nTerm</name></name> <operator>=</operator> <name><name>pTok</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SegReaderStart</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pSegcsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><name>rc</name>
      <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SegReaderStep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pSegcsr</name></expr></argument>)</argument_list></call><operator>)</operator></expr> 
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3TermSelectMerge</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tsc</name></expr></argument>, <argument><expr><name><name>pSegcsr</name><operator>-&gt;</operator><name>aDoclist</name></name></expr></argument>, <argument><expr><name><name>pSegcsr</name><operator>-&gt;</operator><name>nDoclist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3TermSelectFinishMerge</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name><name>tsc</name><operator>.</operator><name>aaOutput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnOut</name> <operator>=</operator> <name><name>tsc</name><operator>.</operator><name>anOutput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>SizeofArray</name><argument_list>(<argument><expr><name><name>tsc</name><operator>.</operator><name>aaOutput</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>tsc</name><operator>.</operator><name>aaOutput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>fts3SegReaderCursorFree</name><argument_list>(<argument><expr><name>pSegcsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTok</name><operator>-&gt;</operator><name>pSegcsr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function counts the total number of docids in the doclist stored
** in buffer aList[], size nList bytes.
**
** If the isPoslist argument is true, then it is assumed that the doclist
** contains a position-list following each docid. Otherwise, it is assumed
** that the doclist is simply a list of docids stored as delta encoded 
** varints.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3DoclistCountDocids</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aList</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nDoc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Return value */</comment>
  <if_stmt><if>if<condition>( <expr><name>aList</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aEnd</name> <init>= <expr><operator>&amp;</operator><name><name>aList</name><index>[<expr><name>nList</name></expr>]</index></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Pointer to one byte after EOF */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>aList</name></expr></init></decl>;</decl_stmt>              <comment type="block">/* Cursor */</comment>
    <while>while<condition>( <expr><name>p</name><operator>&lt;</operator><name>aEnd</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nDoc</name><operator>++</operator></expr>;</expr_stmt>
      <while>while<condition>( <expr><operator>(</operator><operator>*</operator><name>p</name><operator>++</operator><operator>)</operator><operator>&amp;</operator><literal type="number">0x80</literal></expr> )</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>     <comment type="block">/* Skip docid varint */</comment>
      <expr_stmt><expr><call><name>fts3PoslistCopy</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Skip over position list */</comment>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>nDoc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance the cursor to the next row in the %_content table that
** matches the search criteria.  For a MATCH search, this will be
** the next row that matches. For a full-table scan, this will be
** simply the next row in the %_content table.  For a docid lookup,
** this routine simply sets the EOF flag.
**
** Return SQLITE_OK if nothing goes wrong.  SQLITE_OK is returned
** even if we reach end-of-file.  The fts3EofMethod() will be called
** subsequently to determine whether or not an EOF was hit.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3NextMethod</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>Fts3Cursor</name> <operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>eSearch</name></name><operator>==</operator><name>FTS3_DOCID_SEARCH</name> <operator>||</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>eSearch</name></name><operator>==</operator><name>FTS3_FULLSCAN_SEARCH</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Fts3Table</name><operator>*</operator><operator>)</operator><name><name>pCursor</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>bLock</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>!=</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>isEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>bLock</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3EvalNext</name><argument_list>(<argument><expr><operator>(</operator><name>Fts3Cursor</name> <operator>*</operator><operator>)</operator><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name><operator>)</operator><operator>-&gt;</operator><name>pSegments</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the numeric type of argument pVal is "integer", then return it
** converted to a 64-bit signed integer. Otherwise, return a copy of
** the second parameter, iDefault.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_int64</name></type> <name>fts3DocidRange</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iDefault</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pVal</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><call><name>sqlite3_value_numeric_type</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name></expr> )</condition><block>{<block_content>
      <return>return <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>iDefault</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is the xFilter interface for the virtual table.  See
** the virtual table xFilter method documentation for additional
** information.
**
** If idxNum==FTS3_FULLSCAN_SEARCH then do a full table scan against
** the %_content table.
**
** If idxNum==FTS3_DOCID_SEARCH then do a docid lookup for a single entry
** in the %_content table.
**
** If idxNum&gt;=FTS3_FULLTEXT_SEARCH then use the full text index.  The
** column on the left-hand side of the MATCH operator is column
** number idxNum-FTS3_FULLTEXT_SEARCH, 0 indexed.  argv[0] is the right-hand
** side of the MATCH operator.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3FilterMethod</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,   <comment type="block">/* The cursor used for this query */</comment>
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>,                     <comment type="block">/* Strategy index */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,             <comment type="block">/* Unused */</comment>
  <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>,                       <comment type="block">/* Number of elements in apVal */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>           <comment type="block">/* Arguments for the indexing scheme */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>                     <comment type="block">/* SQL statement used to access %_content */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eSearch</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCursor</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>Fts3Cursor</name> <operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pCons</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* The MATCH or rowid constraint, if any */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pLangid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* The "langid = ?" constraint, if any */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pDocidGe</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* The "docid &gt;= ?" constraint, if any */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pDocidLe</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* The "docid &lt;= ?" constraint, if any */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iIdx</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>idxStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bLock</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>eSearch</name> <operator>=</operator> <operator>(</operator><name>idxNum</name> <operator>&amp;</operator> <literal type="number">0x0000FFFF</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eSearch</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>eSearch</name><operator>&lt;=</operator><operator>(</operator><name>FTS3_FULLTEXT_SEARCH</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSegments</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Collect arguments into local variables */</comment>
  <expr_stmt><expr><name>iIdx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eSearch</name><operator>!=</operator><name>FTS3_FULLSCAN_SEARCH</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pCons</name> <operator>=</operator> <name><name>apVal</name><index>[<expr><name>iIdx</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <name>FTS3_HAVE_LANGID</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pLangid</name> <operator>=</operator> <name><name>apVal</name><index>[<expr><name>iIdx</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <name>FTS3_HAVE_DOCID_GE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pDocidGe</name> <operator>=</operator> <name><name>apVal</name><index>[<expr><name>iIdx</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <name>FTS3_HAVE_DOCID_LE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pDocidLe</name> <operator>=</operator> <name><name>apVal</name><index>[<expr><name>iIdx</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iIdx</name><operator>==</operator><name>nVal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* In case the cursor has been used before, clear it now. */</comment>
  <expr_stmt><expr><call><name>fts3ClearCursor</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the lower and upper bounds on docids to return */</comment>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iMinDocid</name></name> <operator>=</operator> <call><name>fts3DocidRange</name><argument_list>(<argument><expr><name>pDocidGe</name></expr></argument>, <argument><expr><name>SMALLEST_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iMaxDocid</name></name> <operator>=</operator> <call><name>fts3DocidRange</name><argument_list>(<argument><expr><name>pDocidLe</name></expr></argument>, <argument><expr><name>LARGEST_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>idxStr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bDesc</name></name> <operator>=</operator> <operator>(</operator><name><name>idxStr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'D'</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bDesc</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>bDescIdx</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eSearch</name></name> <operator>=</operator> <operator>(</operator><name>i16</name><operator>)</operator><name>eSearch</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>eSearch</name><operator>!=</operator><name>FTS3_DOCID_SEARCH</name> <operator>&amp;&amp;</operator> <name>eSearch</name><operator>!=</operator><name>FTS3_FULLSCAN_SEARCH</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name>eSearch</name><operator>-</operator><name>FTS3_FULLTEXT_SEARCH</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zQuery</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pCons</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>zQuery</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pCons</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iLangid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pLangid</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iLangid</name></name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name>pLangid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3ExprParse</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iLangid</name></name></expr></argument>,
        <argument><expr><name><name>p</name><operator>-&gt;</operator><name>azColumn</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bFts4</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name>zQuery</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, 
        <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3EvalStart</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Fts3SegmentsClose</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pNextId</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aDoclist</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Compile a SELECT statement for this cursor. For a full-table-scan, the
  ** statement loops through all rows of the %_content table. For a
  ** full-text query or docid lookup, the statement retrieves a single
  ** row by docid.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eSearch</name><operator>==</operator><name>FTS3_FULLSCAN_SEARCH</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pDocidGe</name> <operator>||</operator> <name>pDocidLe</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"SELECT %s WHERE rowid BETWEEN %lld AND %lld ORDER BY rowid %s"</literal></expr></argument>,
          <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zReadExprlist</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iMinDocid</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iMaxDocid</name></name></expr></argument>,
          <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bDesc</name></name></expr> ?</condition><then> <expr><literal type="string">"DESC"</literal></expr> </then><else>: <expr><literal type="string">"ASC"</literal></expr></else></ternary><operator>)</operator></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT %s ORDER BY rowid %s"</literal></expr></argument>, 
          <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zReadExprlist</name></name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bDesc</name></name></expr> ?</condition><then> <expr><literal type="string">"DESC"</literal></expr> </then><else>: <expr><literal type="string">"ASC"</literal></expr></else></ternary><operator>)</operator></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>zSql</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bLock</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v3</name><argument_list>(
          <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>zSql</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>SQLITE_PREPARE_PERSISTENT</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bLock</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eSearch</name><operator>==</operator><name>FTS3_DOCID_SEARCH</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3CursorSeekStmt</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pCons</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>fts3NextMethod</name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** This is the xEof method of the virtual table. SQLite calls this 
** routine to find out if it has reached the end of a result set.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3EofMethod</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>Fts3Cursor</name><operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>isEof</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fts3ClearCursor</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>isEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>pCsr</name><operator>-&gt;</operator><name>isEof</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** This is the xRowid method. The SQLite core calls this routine to
** retrieve the rowid for the current row of the result set. fts3
** exposes %_content.docid as the rowid for the virtual table. The
** rowid should be written to *pRowid.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3RowidMethod</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>Fts3Cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** This is the xColumn method, called by SQLite to request a value from
** the row that the supplied cursor currently points to.
**
** If:
**
**   (iCol &lt;  p-&gt;nColumn)   -&gt; The value of the iCol'th user column.
**   (iCol == p-&gt;nColumn)   -&gt; Magic column with the same name as the table.
**   (iCol == p-&gt;nColumn+1) -&gt; Docid column
**   (iCol == p-&gt;nColumn+2) -&gt; Langid column
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ColumnMethod</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,   <comment type="block">/* Cursor to retrieve value from */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,          <comment type="block">/* Context for sqlite3_result_xxx() calls */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>                        <comment type="block">/* Index of column to read value from */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>Fts3Cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCursor</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* The column value supplied by SQLite must be in range. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <switch>switch<condition>( <expr><name>iCol</name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">0</literal></expr>:</case>
      <comment type="block">/* The special 'table-name' column */</comment>
      <expr_stmt><expr><call><name>sqlite3_result_pointer</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="string">"fts3cursor"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><literal type="number">1</literal></expr>:</case>
      <comment type="block">/* The docid column */</comment>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><literal type="number">2</literal></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pExpr</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iLangid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zLanguageid</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</expr_stmt>
        <comment type="block">/* no break */</comment> <expr_stmt><expr><name>deliberate_fall_through</name></expr></expr_stmt>
      </block_content>}</block></else></if_stmt>

    <default>default:</default>
      <comment type="block">/* A user column. Or, if this is a full-table scan, possibly the
      ** language-id column. Seek the cursor. */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3CursorSeek</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_data_count</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal><operator>&gt;</operator><name>iCol</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>iCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name><operator>)</operator><operator>-&gt;</operator><name>pSegments</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** This function is the implementation of the xUpdate callback used by 
** FTS3 virtual tables. It is invoked by SQLite each time a row is to be
** inserted, updated or deleted.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3UpdateMethod</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>,            <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,                       <comment type="block">/* Size of argument array */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>,          <comment type="block">/* Array of arguments */</comment>
  <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>            <comment type="block">/* OUT: The affected (or effected) rowid */</comment>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3Fts3UpdateMethod</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>apVal</name></expr></argument>, <argument><expr><name>pRowid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of xSync() method. Flush the contents of the pending-terms
** hash-table to the database.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SyncMethod</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>

  <comment type="block">/* Following an incremental-merge operation, assuming that the input
  ** segments are not completely consumed (the usual case), they are updated
  ** in place to remove the entries that have already been merged. This
  ** involves updating the leaf block that contains the smallest unmerged
  ** entry and each block (if any) between the leaf and the root node. So
  ** if the height of the input segment b-trees is N, and input segments
  ** are merged eight at a time, updating the input segments at the end
  ** of an incremental-merge requires writing (8*(1+N)) blocks. N is usually
  ** small - often between 0 and 2. So the overhead of the incremental
  ** merge is somewhere between 8 and 24 blocks. To avoid this overhead
  ** dwarfing the actual productive work accomplished, the incremental merge
  ** is only attempted if it will write at least 64 leaf blocks. Hence
  ** nMinMerge.
  **
  ** Of course, updating the input segments also involves deleting a bunch
  ** of blocks from the segments table. But this is not considered overhead
  ** as it would also be required by a crisis-merge that used the same input 
  ** segments.
  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u32</name></type> <name>nMinMerge</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Minimum amount of incr-merge work to do */</comment>

  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Fts3Table</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iLastRowid</name> <init>= <expr><call><name>sqlite3_last_insert_rowid</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3PendingTermsFlush</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> 
   <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nLeafAdd</name></name><operator>&gt;</operator><operator>(</operator><name>nMinMerge</name><operator>/</operator><literal type="number">16</literal><operator>)</operator> 
   <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nAutoincrmerge</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nAutoincrmerge</name></name><operator>!=</operator><literal type="number">0xff</literal></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>mxLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Maximum relative level value in db */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>A</name></decl>;</decl_stmt>                        <comment type="block">/* Incr-merge parameter A */</comment>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3MaxLevel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mxLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>mxLevel</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>A</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nLeafAdd</name></name> <operator>*</operator> <name>mxLevel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>A</name> <operator>+=</operator> <operator>(</operator><name>A</name><operator>/</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>A</name><operator>&gt;</operator><operator>(</operator><name>int</name><operator>)</operator><name>nMinMerge</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3Incrmerge</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nAutoincrmerge</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3Fts3SegmentsClose</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_set_last_insert_rowid</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>iLastRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If it is currently unknown whether or not the FTS table has an %_stat
** table (if p-&gt;bHasStat==2), attempt to determine this (set p-&gt;bHasStat
** to 0 or 1). Return SQLITE_OK if successful, or an SQLite error code
** if an error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SetHasStat</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bHasStat</name></name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTbl</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s_stat"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zTbl</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>sqlite3_table_column_metadata</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bHasStat</name></name> <operator>=</operator> <operator>(</operator><name>res</name><operator>==</operator><name>SQLITE_OK</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of xBegin() method. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3BeginMethod</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Fts3Table</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSegments</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nPendingData</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>!=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLeafAdd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SetHasStat</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>inTransaction</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mxSavepoint</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of xCommit() method. This is a no-op. The contents of
** the pending-terms hash-table have already been flushed into the database
** by fts3SyncMethod().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3CommitMethod</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>TESTONLY</name><argument_list>( <argument><expr><name>Fts3Table</name> <operator>*</operator><name>p</name> <operator>=</operator> <operator>(</operator><name>Fts3Table</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nPendingData</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSegments</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TESTONLY</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>inTransaction</name></name> <operator>=</operator> <literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>TESTONLY</name><argument_list>( <argument>p-&gt;mxSavepoint = -<literal type="number">1</literal>;</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of xRollback(). Discard the contents of the pending-terms
** hash-table. Any changes made to the database are reverted by SQLite.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3RollbackMethod</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Fts3Table</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3Fts3PendingTermsClear</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>inTransaction</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TESTONLY</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>inTransaction</name></name> <operator>=</operator> <literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>TESTONLY</name><argument_list>( <argument>p-&gt;mxSavepoint = -<literal type="number">1</literal>;</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** When called, *ppPoslist must point to the byte immediately following the
** end of a position-list. i.e. ( (*ppPoslist)[-1]==POS_END ). This function
** moves *ppPoslist so that it instead points to the first byte of the
** same position list.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3ReversePoslist</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pStart</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPoslist</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>ppPoslist</name><operator>)</operator><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Skip backwards passed any trailing 0x00 bytes added by NearTrim() */</comment>
  <while>while<condition>( <expr><name>p</name><operator>&gt;</operator><name>pStart</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name><operator>=</operator><operator>*</operator><name>p</name><operator>--</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>

  <comment type="block">/* Search backwards for a varint with value zero (the end of the previous 
  ** poslist). This is an 0x00 byte preceded by some byte that does not
  ** have the 0x80 bit set.  */</comment>
  <while>while<condition>( <expr><name>p</name><operator>&gt;</operator><name>pStart</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>|</operator> <name>c</name></expr> )</condition><block>{<block_content> 
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>--</operator></expr>;</expr_stmt> 
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>==</operator><name>pStart</name> <operator>||</operator> <name>c</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* At this point p points to that preceding byte without the 0x80 bit
  ** set. So to find the start of the poslist, skip forward 2 bytes then
  ** over a varint. 
  **
  ** Normally. The other case is that p==pStart and the poslist to return
  ** is the first in the doclist. In this case do not skip forward 2 bytes.
  ** The second part of the if condition (c==0 &amp;&amp; *ppPoslist&gt;&amp;p[2])
  ** is required for cases where the first byte of a doclist and the
  ** doclist is empty. For example, if the first docid is 10, a doclist
  ** that begins with:
  **
  **   0x0A 0x00 &lt;next docid delta varint&gt;
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>&gt;</operator><name>pStart</name> <operator>||</operator> <operator>(</operator><name>c</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ppPoslist</name><operator>&gt;</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  <while>while<condition>( <expr><operator>*</operator><name>p</name><operator>++</operator><operator>&amp;</operator><literal type="number">0x80</literal></expr> )</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
  <expr_stmt><expr><operator>*</operator><name>ppPoslist</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Helper function used by the implementation of the overloaded snippet(),
** offsets() and optimize() SQL functions.
**
** If the value passed as the third argument is a blob of size
** sizeof(Fts3Cursor*), then the blob contents are copied to the 
** output variable *ppCsr and SQLITE_OK is returned. Otherwise, an error
** message is written to context pContext and SQLITE_ERROR returned. The
** string passed via zFunc is used as part of the error message.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3FunctionArg</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>,      <comment type="block">/* SQL function call context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFunc</name></decl></parameter>,              <comment type="block">/* Function name */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>,            <comment type="block">/* argv[0] passed to function */</comment>
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCsr</name></decl></parameter>              <comment type="block">/* OUT: Store cursor handle here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCsr</name> <operator>=</operator> <operator>(</operator><name>Fts3Cursor</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_pointer</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><literal type="string">"fts3cursor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>ppCsr</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"illegal first argument to %s"</literal></expr></argument>, <argument><expr><name>zFunc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the snippet() function for FTS3
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3SnippetFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>,      <comment type="block">/* SQLite function call context */</comment>
  <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>,                       <comment type="block">/* Size of apVal[] array */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>           <comment type="block">/* Array of arguments */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>               <comment type="block">/* Cursor handle passed through apVal[0] */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStart</name> <init>= <expr><literal type="string">"&lt;b&gt;"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><literal type="string">"&lt;/b&gt;"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEllipsis</name> <init>= <expr><literal type="string">"&lt;b&gt;...&lt;/b&gt;"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nToken</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Default number of tokens in snippet */</comment>

  <comment type="block">/* There must be at least one argument passed to this function (otherwise
  ** the non-overloaded version would have been called instead of this one).
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nVal</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>&gt;</operator><literal type="number">6</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, 
        <argument><expr><literal type="string">"wrong number of arguments to function snippet()"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>fts3FunctionArg</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"snippet"</literal></expr></argument>, <argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCsr</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <switch>switch<condition>( <expr><name>nVal</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">6</literal></expr>:</case> <expr_stmt><expr><name>nToken</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* no break */</comment> <macro><name>deliberate_fall_through</name></macro>
    <case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><name>iCol</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* no break */</comment> <macro><name>deliberate_fall_through</name></macro>
    <case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name>zEllipsis</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* no break */</comment> <macro><name>deliberate_fall_through</name></macro>
    <case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* no break */</comment> <macro><name>deliberate_fall_through</name></macro>
    <case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>zStart</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></switch>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zEllipsis</name> <operator>||</operator> <operator>!</operator><name>zEnd</name> <operator>||</operator> <operator>!</operator><name>zStart</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nToken</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><call><name>fts3CursorSeek</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Fts3Snippet</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>zStart</name></expr></argument>, <argument><expr><name>zEnd</name></expr></argument>, <argument><expr><name>zEllipsis</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the offsets() function for FTS3
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3OffsetsFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>,      <comment type="block">/* SQLite function call context */</comment>
  <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>,                       <comment type="block">/* Size of argument array */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>           <comment type="block">/* Array of arguments */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>               <comment type="block">/* Cursor handle passed through apVal[0] */</comment>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nVal</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>fts3FunctionArg</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"offsets"</literal></expr></argument>, <argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCsr</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCsr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><call><name>fts3CursorSeek</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Fts3Offsets</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* 
** Implementation of the special optimize() function for FTS3. This 
** function merges all segments in the database to a single segment.
** Example usage is:
**
**   SELECT optimize(t) FROM t LIMIT 1;
**
** where 't' is the name of an FTS3 table.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3OptimizeFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>,      <comment type="block">/* SQLite function call context */</comment>
  <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>,                       <comment type="block">/* Size of argument array */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>           <comment type="block">/* Array of arguments */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                   <comment type="block">/* Virtual table handle */</comment>
  <decl_stmt><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl>;</decl_stmt>            <comment type="block">/* Cursor handle passed through apVal[0] */</comment>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nVal</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>fts3FunctionArg</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"optimize"</literal></expr></argument>, <argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCursor</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCursor</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3Optimize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_OK</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"Index optimized"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>SQLITE_DONE</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"Index already optimal"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the matchinfo() function for FTS3
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3MatchinfoFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>,      <comment type="block">/* SQLite function call context */</comment>
  <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>,                       <comment type="block">/* Size of argument array */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>           <comment type="block">/* Array of arguments */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>               <comment type="block">/* Cursor handle passed through apVal[0] */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nVal</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>nVal</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><call><name>fts3FunctionArg</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"matchinfo"</literal></expr></argument>, <argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCsr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zArg</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3Fts3Matchinfo</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine implements the xFindFunction method for the FTS3
** virtual table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3FindFunctionMethod</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>,            <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,                       <comment type="block">/* Number of SQL function arguments */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,              <comment type="block">/* Name of SQL function */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><modifier>*</modifier><name>pxFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <comment type="block">/* OUT: Result */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppArg</name></decl></parameter>                    <comment type="block">/* Unused */</comment>
)</parameter_list><block>{<block_content>
  <struct>struct <name>Overloaded</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
    <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  }</block> <decl><name><name>aOverload</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"snippet"</literal></expr>, <expr><name>fts3SnippetFunc</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"offsets"</literal></expr>, <expr><name>fts3OffsetsFunc</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"optimize"</literal></expr>, <expr><name>fts3OptimizeFunc</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"matchinfo"</literal></expr>, <expr><name>fts3MatchinfoFunc</name></expr> }</block></expr>,
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Iterator variable */</comment>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>ppArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>SizeofArray</name><argument_list>(<argument><expr><name>aOverload</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>aOverload</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pxFunc</name> <operator>=</operator> <name><name>aOverload</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xFunc</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* No function of the specified name was found. Return 0. */</comment>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of FTS3 xRename method. Rename an fts3 table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3RenameMethod</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>,            <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>               <comment type="block">/* New name of table */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>            <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return Code */</comment>

  <comment type="block">/* At this point it must be known if the %_stat table exists or not.
  ** So bHasStat may not be 2.  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SetHasStat</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* As it happens, the pending terms table is always empty here. This is
  ** because an "ALTER TABLE RENAME TABLE" statement inside a transaction 
  ** always opens a savepoint transaction. And the xSavepoint() method 
  ** flushes the pending terms table. But leave the (no-op) call to
  ** PendingTermsFlush() in in case that changes.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nPendingData</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3PendingTermsFlush</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zContentTbl</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fts3DbExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>,
      <argument><expr><literal type="string">"ALTER TABLE %Q.'%q_content'  RENAME TO '%q_content';"</literal></expr></argument>,
      <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bHasDocsize</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fts3DbExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>,
      <argument><expr><literal type="string">"ALTER TABLE %Q.'%q_docsize'  RENAME TO '%q_docsize';"</literal></expr></argument>,
      <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bHasStat</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fts3DbExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>,
      <argument><expr><literal type="string">"ALTER TABLE %Q.'%q_stat'  RENAME TO '%q_stat';"</literal></expr></argument>,
      <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fts3DbExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>,
    <argument><expr><literal type="string">"ALTER TABLE %Q.'%q_segments' RENAME TO '%q_segments';"</literal></expr></argument>,
    <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fts3DbExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>,
    <argument><expr><literal type="string">"ALTER TABLE %Q.'%q_segdir'   RENAME TO '%q_segdir';"</literal></expr></argument>,
    <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The xSavepoint() method.
**
** Flush the contents of the pending-terms table to disk.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SavepointMethod</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iSavepoint</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name>pVtab</name><operator>)</operator><operator>-&gt;</operator><name>inTransaction</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name>pVtab</name><operator>)</operator><operator>-&gt;</operator><name>mxSavepoint</name> <operator>&lt;=</operator> <name>iSavepoint</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TESTONLY</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name>pVtab</name><operator>)</operator><operator>-&gt;</operator><name>mxSavepoint</name> <operator>=</operator> <name>iSavepoint</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name>pVtab</name><operator>)</operator><operator>-&gt;</operator><name>bIgnoreSavepoint</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SyncMethod</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The xRelease() method.
**
** This is a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ReleaseMethod</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iSavepoint</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>TESTONLY</name><argument_list>( <argument><expr><name>Fts3Table</name> <operator>*</operator><name>p</name> <operator>=</operator> <operator>(</operator><name>Fts3Table</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>inTransaction</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>mxSavepoint</name></name> <operator>&gt;=</operator> <name>iSavepoint</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TESTONLY</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>mxSavepoint</name></name> <operator>=</operator> <name>iSavepoint</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The xRollbackTo() method.
**
** Discard the contents of the pending terms table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3RollbackToMethod</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iSavepoint</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Fts3Table</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>inTransaction</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TESTONLY</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>mxSavepoint</name></name> <operator>=</operator> <name>iSavepoint</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Fts3PendingTermsClear</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if zName is the extension on one of the shadow tables used
** by this module.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ShadowName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azName</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="string">"content"</literal></expr>, <expr><literal type="string">"docsize"</literal></expr>, <expr><literal type="string">"segdir"</literal></expr>, <expr><literal type="string">"segments"</literal></expr>, <expr><literal type="string">"stat"</literal></expr>, 
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>azName</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>azName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>azName</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_module</name></type> <name>fts3Module</name> <init>= <expr><block>{
  <comment type="block">/* iVersion      */</comment> <expr><literal type="number">3</literal></expr>,
  <comment type="block">/* xCreate       */</comment> <expr><name>fts3CreateMethod</name></expr>,
  <comment type="block">/* xConnect      */</comment> <expr><name>fts3ConnectMethod</name></expr>,
  <comment type="block">/* xBestIndex    */</comment> <expr><name>fts3BestIndexMethod</name></expr>,
  <comment type="block">/* xDisconnect   */</comment> <expr><name>fts3DisconnectMethod</name></expr>,
  <comment type="block">/* xDestroy      */</comment> <expr><name>fts3DestroyMethod</name></expr>,
  <comment type="block">/* xOpen         */</comment> <expr><name>fts3OpenMethod</name></expr>,
  <comment type="block">/* xClose        */</comment> <expr><name>fts3CloseMethod</name></expr>,
  <comment type="block">/* xFilter       */</comment> <expr><name>fts3FilterMethod</name></expr>,
  <comment type="block">/* xNext         */</comment> <expr><name>fts3NextMethod</name></expr>,
  <comment type="block">/* xEof          */</comment> <expr><name>fts3EofMethod</name></expr>,
  <comment type="block">/* xColumn       */</comment> <expr><name>fts3ColumnMethod</name></expr>,
  <comment type="block">/* xRowid        */</comment> <expr><name>fts3RowidMethod</name></expr>,
  <comment type="block">/* xUpdate       */</comment> <expr><name>fts3UpdateMethod</name></expr>,
  <comment type="block">/* xBegin        */</comment> <expr><name>fts3BeginMethod</name></expr>,
  <comment type="block">/* xSync         */</comment> <expr><name>fts3SyncMethod</name></expr>,
  <comment type="block">/* xCommit       */</comment> <expr><name>fts3CommitMethod</name></expr>,
  <comment type="block">/* xRollback     */</comment> <expr><name>fts3RollbackMethod</name></expr>,
  <comment type="block">/* xFindFunction */</comment> <expr><name>fts3FindFunctionMethod</name></expr>,
  <comment type="block">/* xRename */</comment>       <expr><name>fts3RenameMethod</name></expr>,
  <comment type="block">/* xSavepoint    */</comment> <expr><name>fts3SavepointMethod</name></expr>,
  <comment type="block">/* xRelease      */</comment> <expr><name>fts3ReleaseMethod</name></expr>,
  <comment type="block">/* xRollbackTo   */</comment> <expr><name>fts3RollbackToMethod</name></expr>,
  <comment type="block">/* xShadowName   */</comment> <expr><name>fts3ShadowName</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** This function is registered as the module destructor (called when an
** FTS3 enabled database connection is closed). It frees the memory
** allocated for the tokenizer hash table.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>hashDestroy</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3HashWrapper</name> <modifier>*</modifier></type><name>pHash</name> <init>= <expr><operator>(</operator><name>Fts3HashWrapper</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>nRef</name></name><operator>--</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pHash</name><operator>-&gt;</operator><name>nRef</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Fts3HashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHash</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The fts3 built-in tokenizers - "simple", "porter" and "icu"- are 
** implemented in files fts3_tokenizer1.c, fts3_porter.c and fts3_icu.c
** respectively. The following three forward declarations are for functions
** declared in these files used to retrieve the respective implementations.
**
** Calling sqlite3Fts3SimpleTokenizerModule() sets the value pointed
** to by the argument to point to the "simple" tokenizer implementation.
** And so on.
*/</comment>
<function_decl><type><name>void</name></type> <name>sqlite3Fts3SimpleTokenizerModule</name><parameter_list>(<parameter><decl><type><name>sqlite3_tokenizer_module</name> <specifier>const</specifier><modifier>*</modifier><modifier>*</modifier></type><name>ppModule</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3Fts3PorterTokenizerModule</name><parameter_list>(<parameter><decl><type><name>sqlite3_tokenizer_module</name> <specifier>const</specifier><modifier>*</modifier><modifier>*</modifier></type><name>ppModule</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DISABLE_FTS3_UNICODE</name></cpp:ifndef>
<function_decl><type><name>void</name></type> <name>sqlite3Fts3UnicodeTokenizer</name><parameter_list>(<parameter><decl><type><name>sqlite3_tokenizer_module</name> <specifier>const</specifier><modifier>*</modifier><modifier>*</modifier></type><name>ppModule</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ICU</name></cpp:ifdef>
<function_decl><type><name>void</name></type> <name>sqlite3Fts3IcuTokenizerModule</name><parameter_list>(<parameter><decl><type><name>sqlite3_tokenizer_module</name> <specifier>const</specifier><modifier>*</modifier><modifier>*</modifier></type><name>ppModule</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Initialize the fts3 extension. If this extension is built as part
** of the sqlite library, then this function is called directly by
** SQLite. If fts3 is built as a dynamically loadable extension, this
** function is called by the sqlite3_extension_init() entry point.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3Init</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3HashWrapper</name> <modifier>*</modifier></type><name>pHash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>pSimple</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>pPorter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DISABLE_FTS3_UNICODE</name></cpp:ifndef>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>pUnicode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ICU</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>pIcu</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3Fts3IcuTokenizerModule</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pIcu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DISABLE_FTS3_UNICODE</name></cpp:ifndef>
  <expr_stmt><expr><call><name>sqlite3Fts3UnicodeTokenizer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pUnicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3InitTerm</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3InitAux</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3Fts3SimpleTokenizerModule</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pSimple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Fts3PorterTokenizerModule</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pPorter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate and initialize the hash-table used to store tokenizers. */</comment>
  <expr_stmt><expr><name>pHash</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3HashWrapper</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pHash</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Fts3HashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHash</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><name>FTS3_HASH_STRING</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>nRef</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Load the built-in tokenizers into the hash table */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3Fts3HashInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHash</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><literal type="string">"simple"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pSimple</name></expr></argument>)</argument_list></call>
     <operator>||</operator> <call><name>sqlite3Fts3HashInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHash</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><literal type="string">"porter"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pPorter</name></expr></argument>)</argument_list></call> 

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DISABLE_FTS3_UNICODE</name></cpp:ifndef>
     <operator>||</operator> <call><name>sqlite3Fts3HashInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHash</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><literal type="string">"unicode61"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pUnicode</name></expr></argument>)</argument_list></call> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ICU</name></cpp:ifdef>
     <operator>||</operator> <operator>(</operator><name>pIcu</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Fts3HashInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHash</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><literal type="string">"icu"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pIcu</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3ExprInitTestInterface</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pHash</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Create the virtual table wrapper around the hash-table and overload 
  ** the four scalar functions. If this is successful, register the
  ** module with sqlite.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><name>rc</name> 
   <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name><operator>=</operator><call><name>sqlite3Fts3InitHashTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pHash</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>,<argument><expr><literal type="string">"fts3_tokenizer"</literal></expr></argument>)</argument_list></call><operator>)</operator>
   <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_overload_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"snippet"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator>
   <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_overload_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"offsets"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator>
   <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_overload_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"matchinfo"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator>
   <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_overload_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"matchinfo"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator>
   <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_overload_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"optimize"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module_v2</name><argument_list>(
        <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"fts3"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fts3Module</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pHash</name></expr></argument>, <argument><expr><name>hashDestroy</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module_v2</name><argument_list>(
          <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"fts4"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fts3Module</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pHash</name></expr></argument>, <argument><expr><name>hashDestroy</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3InitTok</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pHash</name></expr></argument>, <argument><expr><name>hashDestroy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>


  <comment type="block">/* An error has occurred. Delete the hash table and return the error code. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pHash</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Fts3HashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHash</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate an Fts3MultiSegReader for each token in the expression headed
** by pExpr. 
**
** An Fts3SegReader object is a cursor that can seek or scan a range of
** entries within a single segment b-tree. An Fts3MultiSegReader uses multiple
** Fts3SegReader objects internally to provide an interface to seek or scan
** within the union of all segments of a b-tree. Hence the name.
**
** If the allocated Fts3MultiSegReader just seeks to a single entry in a
** segment b-tree (if the term is not a prefix or it is a prefix for which
** there exists prefix b-tree of the right length) then it may be traversed
** and merged incrementally. Otherwise, it has to be merged into an in-memory 
** doclist and then traversed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3EvalAllocateReaders</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* FTS cursor handle */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,                <comment type="block">/* Allocate readers for this expression */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnToken</name></decl></parameter>,                   <comment type="block">/* OUT: Total number of tokens in phrase. */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOr</name></decl></parameter>,                      <comment type="block">/* OUT: Total number of OR nodes in expr. */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name> <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><operator>*</operator><name>pRc</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_PHRASE</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nToken</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><name>pnToken</name> <operator>+=</operator> <name>nToken</name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nToken</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>Fts3PhraseToken</name> <modifier>*</modifier></type><name>pToken</name> <init>= <expr><operator>&amp;</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>fts3TermSegReaderCursor</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, 
            <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>isPrefix</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pToken</name><operator>-&gt;</operator><name>pSegcsr</name></name></expr></argument>
        )</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
          <return>return;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>iDoclistToken</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>iDoclistToken</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pnOr</name> <operator>+=</operator> <operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_OR</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3EvalAllocateReaders</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>pnToken</name></expr></argument>, <argument><expr><name>pnOr</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3EvalAllocateReaders</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>pnToken</name></expr></argument>, <argument><expr><name>pnOr</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Arguments pList/nList contain the doclist for token iToken of phrase p.
** It is merged into the main doclist stored in p-&gt;doclist.aAll/nAll.
**
** This function assumes that pList points to a buffer allocated using
** sqlite3_malloc(). This function takes responsibility for eventually
** freeing the buffer.
**
** SQLITE_OK is returned if successful, or SQLITE_NOMEM if an error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3EvalPhraseMergeToken</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                <comment type="block">/* FTS Table pointer */</comment>
  <parameter><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                  <comment type="block">/* Phrase to merge pList/nList into */</comment>
  <parameter><decl><type><name>int</name></type> <name>iToken</name></decl></parameter>,                     <comment type="block">/* Token pList/nList corresponds to */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,                    <comment type="block">/* Pointer to doclist */</comment>
  <parameter><decl><type><name>int</name></type> <name>nList</name></decl></parameter>                       <comment type="block">/* Number of bytes in pList */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iToken</name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>iDoclistToken</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>aAll</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>aAll</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nAll</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if>

  <if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iDoclistToken</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>aAll</name></name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nAll</name></name> <operator>=</operator> <name>nList</name></expr>;</expr_stmt>
  </block_content>}</block></if>

  <if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>aAll</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>

  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pLeft</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pRight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nLeft</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nRight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nDiff</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iDoclistToken</name></name><operator>&lt;</operator><name>iToken</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>aAll</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nLeft</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nAll</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pRight</name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRight</name> <operator>=</operator> <name>nList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nDiff</name> <operator>=</operator> <name>iToken</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>iDoclistToken</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pRight</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>aAll</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRight</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nAll</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nLeft</name> <operator>=</operator> <name>nList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nDiff</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iDoclistToken</name></name> <operator>-</operator> <name>iToken</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3DoclistPhraseMerge</name><argument_list>(
        <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>bDescIdx</name></name></expr></argument>, <argument><expr><name>nDiff</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>nLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nRight</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>aAll</name></name> <operator>=</operator> <name>pRight</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nAll</name></name> <operator>=</operator> <name>nRight</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>iToken</name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>iDoclistToken</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iDoclistToken</name></name> <operator>=</operator> <name>iToken</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Load the doclist for phrase p into p-&gt;doclist.aAll/nAll. The loaded doclist
** does not take deferred tokens into account.
**
** SQLITE_OK is returned if no error occurs, otherwise an SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3EvalPhraseLoad</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* FTS Cursor handle */</comment>
  <parameter><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>p</name></decl></parameter>                   <comment type="block">/* Phrase object */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iToken</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>iToken</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iToken</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</condition> <incr><expr><name>iToken</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3PhraseToken</name> <modifier>*</modifier></type><name>pToken</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>iToken</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>pDeferred</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pToken</name><operator>-&gt;</operator><name>pSegcsr</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pToken</name><operator>-&gt;</operator><name>pSegcsr</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nThis</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pThis</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3TermSelect</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nThis</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pThis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3EvalPhraseMergeToken</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iToken</name></expr></argument>, <argument><expr><name>pThis</name></expr></argument>, <argument><expr><name>nThis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>pSegcsr</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DISABLE_FTS4_DEFERRED</name></cpp:ifndef>
<comment type="block">/*
** This function is called on each phrase after the position lists for
** any deferred tokens have been loaded into memory. It updates the phrases
** current position list to include only those positions that are really
** instances of the phrase (after considering deferred tokens). If this
** means that the phrase does not appear in the current row, doclist.pList
** and doclist.nList are both zeroed.
**
** SQLITE_OK is returned if no error occurs, otherwise an SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3EvalDeferredPhrase</name><parameter_list>(<parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>pPhrase</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iToken</name></decl>;</decl_stmt>                     <comment type="block">/* Used to iterate through phrase tokens */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aPoslist</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Position list for deferred tokens */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPoslist</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Number of bytes in aPoslist */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPrev</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Token number of previous deferred token */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aFree</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>bFreeList</name></name></expr> ?</condition><then> <expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>iToken</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iToken</name><operator>&lt;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</condition> <incr><expr><name>iToken</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3PhraseToken</name> <modifier>*</modifier></type><name>pToken</name> <init>= <expr><operator>&amp;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>iToken</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Fts3DeferredToken</name> <modifier>*</modifier></type><name>pDeferred</name> <init>= <expr><name><name>pToken</name><operator>-&gt;</operator><name>pDeferred</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>pDeferred</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nList</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3Fts3DeferredTokenList</name><argument_list>(<argument><expr><name>pDeferred</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aPoslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>

      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>aPoslist</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>aPoslist</name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nPoslist</name> <operator>=</operator> <name>nList</name></expr>;</expr_stmt>

      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aOut</name> <init>= <expr><name>pList</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><name>aPoslist</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><name>aOut</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iPrev</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fts3PoslistPhraseMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aOut</name></expr></argument>, <argument><expr><name>iToken</name><operator>-</operator><name>iPrev</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aPoslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>aPoslist</name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nPoslist</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>aOut</name> <operator>-</operator> <name>aPoslist</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nPoslist</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aPoslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_OK</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>iPrev</name> <operator>=</operator> <name>iToken</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>iPrev</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nMaxUndeferred</name> <init>= <expr><name><name>pPhrase</name><operator>-&gt;</operator><name>iDoclistToken</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>nMaxUndeferred</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <name>aPoslist</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nList</name></name> <operator>=</operator> <name>nPoslist</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>iDocid</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>bFreeList</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nDistance</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aOut</name></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>nMaxUndeferred</name><operator>&gt;</operator><name>iPrev</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>p1</name> <operator>=</operator> <name>aPoslist</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p2</name> <operator>=</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nDistance</name> <operator>=</operator> <name>nMaxUndeferred</name> <operator>-</operator> <name>iPrev</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>p1</name> <operator>=</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p2</name> <operator>=</operator> <name>aPoslist</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nDistance</name> <operator>=</operator> <name>iPrev</name> <operator>-</operator> <name>nMaxUndeferred</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><name>aOut</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3Fts3MallocZero</name><argument_list>(<argument><expr><name>nPoslist</name><operator>+</operator><name>FTS3_BUFFER_PADDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aOut</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aPoslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      
      <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <name>aOut</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name> <operator>&amp;&amp;</operator> <name>p2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>fts3PoslistPhraseMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aOut</name></expr></argument>, <argument><expr><name>nDistance</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>bFreeList</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nList</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>aOut</name> <operator>-</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aPoslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name><operator>!=</operator><name>aFree</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DISABLE_FTS4_DEFERRED */</comment>

<comment type="block">/*
** Maximum number of tokens a phrase may have to be considered for the
** incremental doclists strategy.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_INCR_PHRASE_TOKENS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<comment type="block">/*
** This function is called for each Fts3Phrase in a full-text query 
** expression to initialize the mechanism for returning rows. Once this
** function has been called successfully on an Fts3Phrase, it may be
** used with fts3EvalPhraseNext() to iterate through the matching docids.
**
** If parameter bOptOk is true, then the phrase may (or may not) use the
** incremental loading strategy. Otherwise, the entire doclist is loaded into
** memory within this call.
**
** SQLITE_OK is returned if no error occurs, otherwise an SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3EvalPhraseStart</name><parameter_list>(<parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bOptOk</name></decl></parameter>, <parameter><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Error code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Determine if doclists may be loaded from disk incrementally. This is
  ** possible if the bOptOk argument is true, the FTS doclists will be
  ** scanned in forward order, and the phrase consists of 
  ** MAX_INCR_PHRASE_TOKENS or fewer tokens, none of which are are "^first"
  ** tokens or prefix tokens that cannot use a prefix-index.  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bHaveIncr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bIncrOk</name> <init>= <expr><operator>(</operator><name>bOptOk</name> 
   <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>bDesc</name></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>bDescIdx</name></name> 
   <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nToken</name></name><operator>&lt;=</operator><name>MAX_INCR_PHRASE_TOKENS</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nToken</name></name><operator>&gt;</operator><literal type="number">0</literal>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
   <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>bNoIncrDoclist</name></name><operator>==</operator><literal type="number">0</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <operator>)</operator></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>bIncrOk</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3PhraseToken</name> <modifier>*</modifier></type><name>pToken</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pToken</name><operator>-&gt;</operator><name>bFirst</name></name> <operator>||</operator> <operator>(</operator><name><name>pToken</name><operator>-&gt;</operator><name>pSegcsr</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pToken</name><operator>-&gt;</operator><name>pSegcsr</name><operator>-&gt;</operator><name>bLookup</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>bIncrOk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pToken</name><operator>-&gt;</operator><name>pSegcsr</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bHaveIncr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>bIncrOk</name> <operator>&amp;&amp;</operator> <name>bHaveIncr</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Use the incremental approach. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>&gt;=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nColumn</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Fts3PhraseToken</name> <modifier>*</modifier></type><name>pToken</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pSegcsr</name> <init>= <expr><name><name>pToken</name><operator>-&gt;</operator><name>pSegcsr</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pSegcsr</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3MsrIncrStart</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pSegcsr</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bIncr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Load the full doclist for the phrase into memory. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3EvalPhraseLoad</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bIncr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>nToken</name></name><operator>&lt;</operator><literal type="number">1</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSegcsr</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>bIncr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is used to iterate backwards (from the end to start) 
** through doclists. It is used by this module to iterate through phrase
** doclists in reverse and by the fts3_write.c module to iterate through
** pending-terms lists when writing to databases with "order=desc".
**
** The doclist may be sorted in ascending (parameter bDescIdx==0) or 
** descending (parameter bDescIdx==1) order of docid. Regardless, this
** function iterates from the end of the doclist to the beginning.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Fts3DoclistPrev</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>bDescIdx</name></decl></parameter>,                   <comment type="block">/* True if the doclist is desc */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aDoclist</name></decl></parameter>,                 <comment type="block">/* Pointer to entire doclist */</comment>
  <parameter><decl><type><name>int</name></type> <name>nDoclist</name></decl></parameter>,                   <comment type="block">/* Length of aDoclist in bytes */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppIter</name></decl></parameter>,                  <comment type="block">/* IN/OUT: Iterator pointer */</comment>
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piDocid</name></decl></parameter>,         <comment type="block">/* IN/OUT: Docid pointer */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnList</name></decl></parameter>,                    <comment type="block">/* OUT: List length pointer */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pbEof</name></decl></parameter>                       <comment type="block">/* OUT: End-of-file flag */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>ppIter</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nDoclist</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pbEof</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><name>p</name> <operator>||</operator> <operator>*</operator><name>piDocid</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>p</name> <operator>||</operator> <operator>(</operator><name>p</name><operator>&gt;</operator><name>aDoclist</name> <operator>&amp;&amp;</operator> <name>p</name><operator>&lt;</operator><operator>&amp;</operator><name><name>aDoclist</name><index>[<expr><name>nDoclist</name></expr>]</index></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iDocid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pDocid</name> <init>= <expr><name>aDoclist</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>aDoclist</name><index>[<expr><name>nDoclist</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iMul</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <while>while<condition>( <expr><name>pDocid</name><operator>&lt;</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iDelta</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pDocid</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarint</name><argument_list>(<argument><expr><name>pDocid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iDocid</name> <operator>+=</operator> <operator>(</operator><name>iMul</name> <operator>*</operator> <name>iDelta</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name>pDocid</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3PoslistCopy</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>pDocid</name><operator>&lt;</operator><name>pEnd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pDocid</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pDocid</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
      <expr_stmt><expr><name>iMul</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>bDescIdx</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><operator>*</operator><name>pnList</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pEnd</name> <operator>-</operator> <name>pNext</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppIter</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>piDocid</name> <operator>=</operator> <name>iDocid</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iMul</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>bDescIdx</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iDelta</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fts3GetReverseVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>aDoclist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>piDocid</name> <operator>-=</operator> <operator>(</operator><name>iMul</name> <operator>*</operator> <name>iDelta</name><operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><name>aDoclist</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pbEof</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pSave</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fts3ReversePoslist</name><argument_list>(<argument><expr><name>aDoclist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pnList</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pSave</name> <operator>-</operator> <name>p</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppIter</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Iterate forwards through a doclist.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Fts3DoclistNext</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>bDescIdx</name></decl></parameter>,                   <comment type="block">/* True if the doclist is desc */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aDoclist</name></decl></parameter>,                 <comment type="block">/* Pointer to entire doclist */</comment>
  <parameter><decl><type><name>int</name></type> <name>nDoclist</name></decl></parameter>,                   <comment type="block">/* Length of aDoclist in bytes */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppIter</name></decl></parameter>,                  <comment type="block">/* IN/OUT: Iterator pointer */</comment>
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piDocid</name></decl></parameter>,         <comment type="block">/* IN/OUT: Docid pointer */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pbEof</name></decl></parameter>                       <comment type="block">/* OUT: End-of-file flag */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>ppIter</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nDoclist</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pbEof</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><name>p</name> <operator>||</operator> <operator>*</operator><name>piDocid</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>p</name> <operator>||</operator> <operator>(</operator><name>p</name><operator>&gt;=</operator><name>aDoclist</name> <operator>&amp;&amp;</operator> <name>p</name><operator>&lt;=</operator><operator>&amp;</operator><name><name>aDoclist</name><index>[<expr><name>nDoclist</name></expr>]</index></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>aDoclist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>piDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>fts3PoslistCopy</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>p</name><operator>&lt;</operator><operator>&amp;</operator><name><name>aDoclist</name><index>[<expr><name>nDoclist</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while> 
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>&gt;=</operator><operator>&amp;</operator><name><name>aDoclist</name><index>[<expr><name>nDoclist</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pbEof</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iVar</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>piDocid</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><ternary><condition><expr><name>bDescIdx</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator> <operator>*</operator> <name>iVar</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppIter</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Advance the iterator pDL to the next entry in pDL-&gt;aAll/nAll. Set *pbEof
** to true if EOF is reached.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3EvalDlPhraseNext</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,
  <parameter><decl><type><name>Fts3Doclist</name> <modifier>*</modifier></type><name>pDL</name></decl></parameter>,
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pbEof</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>                            <comment type="block">/* Used to iterate through aAll */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pEnd</name></decl>;</decl_stmt>                             <comment type="block">/* 1 byte past end of aAll */</comment>
 
  <if_stmt><if>if<condition>( <expr><name><name>pDL</name><operator>-&gt;</operator><name>pNextDocid</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pIter</name> <operator>=</operator> <name><name>pDL</name><operator>-&gt;</operator><name>pNextDocid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDL</name><operator>-&gt;</operator><name>aAll</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>pIter</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pIter</name> <operator>=</operator> <name><name>pDL</name><operator>-&gt;</operator><name>aAll</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pIter</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pIter</name><operator>&gt;=</operator><operator>(</operator><name>pEnd</name> <operator>=</operator> <name><name>pDL</name><operator>-&gt;</operator><name>aAll</name></name> <operator>+</operator> <name><name>pDL</name><operator>-&gt;</operator><name>nAll</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
    <comment type="block">/* We have already reached the end of this doclist. EOF. */</comment>
    <expr_stmt><expr><operator>*</operator><name>pbEof</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iDelta</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pIter</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarint</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>bDescIdx</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pDL</name><operator>-&gt;</operator><name>pNextDocid</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pDL</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>+=</operator> <name>iDelta</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pDL</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>-=</operator> <name>iDelta</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pDL</name><operator>-&gt;</operator><name>pList</name></name> <operator>=</operator> <name>pIter</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fts3PoslistCopy</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDL</name><operator>-&gt;</operator><name>nList</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pIter</name> <operator>-</operator> <name><name>pDL</name><operator>-&gt;</operator><name>pList</name></name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* pIter now points just past the 0x00 that terminates the position-
    ** list for document pDL-&gt;iDocid. However, if this position-list was
    ** edited in place by fts3EvalNearTrim(), then pIter may not actually
    ** point to the start of the next docid value. The following line deals
    ** with this case by advancing pIter past the zero-padding added by
    ** fts3EvalNearTrim().  */</comment>
    <while>while<condition>( <expr><name>pIter</name><operator>&lt;</operator><name>pEnd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pIter</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pIter</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

    <expr_stmt><expr><name><name>pDL</name><operator>-&gt;</operator><name>pNextDocid</name></name> <operator>=</operator> <name>pIter</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIter</name><operator>&gt;=</operator><operator>&amp;</operator><name><name>pDL</name><operator>-&gt;</operator><name>aAll</name><index>[<expr><name><name>pDL</name><operator>-&gt;</operator><name>nAll</name></name></expr>]</index></name> <operator>||</operator> <operator>*</operator><name>pIter</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pbEof</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Helper type used by fts3EvalIncrPhraseNext() and incrPhraseTokenNext().
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>TokenDoclist</name></name></type> <name>TokenDoclist</name>;</typedef>
<struct>struct <name>TokenDoclist</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>bIgnore</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iDocid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nList</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** Token pToken is an incrementally loaded token that is part of a 
** multi-token phrase. Advance it to the next matching document in the
** database and populate output variable *p with the details of the new
** entry. Or, if the iterator has reached EOF, set *pbEof to true.
**
** If an error occurs, return an SQLite error code. Otherwise, return 
** SQLITE_OK.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>incrPhraseTokenNext</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>pPhrase</name></decl></parameter>,            <comment type="block">/* Phrase to advance token of */</comment>
  <parameter><decl><type><name>int</name></type> <name>iToken</name></decl></parameter>,                     <comment type="block">/* Specific token to advance */</comment>
  <parameter><decl><type><name>TokenDoclist</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                <comment type="block">/* OUT: Docid and doclist for new entry */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pbEof</name></decl></parameter>                       <comment type="block">/* OUT: True if iterator is at EOF */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pPhrase</name><operator>-&gt;</operator><name>iDoclistToken</name></name><operator>==</operator><name>iToken</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIgnore</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>iToken</name></expr>]</index></name><operator>.</operator><name>pSegcsr</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fts3EvalDlPhraseNext</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name></name></expr></argument>, <argument><expr><name>pbEof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pList</name></name> <operator>=</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nList</name></name> <operator>=</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>=</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>iDocid</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>Fts3PhraseToken</name> <modifier>*</modifier></type><name>pToken</name> <init>= <expr><operator>&amp;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>iToken</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>pDeferred</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>pSegcsr</name></name> <operator>||</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>iDoclistToken</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pToken</name><operator>-&gt;</operator><name>pSegcsr</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIgnore</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3MsrIncrNext</name><argument_list>(
          <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>pSegcsr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>iDocid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>nList</name></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pList</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pbEof</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bIgnore</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** The phrase iterator passed as the second argument:
**
**   * features at least one token that uses an incremental doclist, and 
**
**   * does not contain any deferred tokens.
**
** Advance it to the next matching documnent in the database and populate
** the Fts3Doclist.pList and nList fields. 
**
** If there is no "next" entry and no error occurs, then *pbEof is set to
** 1 before returning. Otherwise, if no error occurs and the iterator is
** successfully advanced, *pbEof is set to 0.
**
** If an error occurs, return an SQLite error code. Otherwise, return 
** SQLITE_OK.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3EvalIncrPhraseNext</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* FTS Cursor handle */</comment>
  <parameter><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                  <comment type="block">/* Phrase object to advance to next docid */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pbEof</name></decl></parameter>                       <comment type="block">/* OUT: Set to 1 if EOF */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Doclist</name> <modifier>*</modifier></type><name>pDL</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>doclist</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>bEof</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* This is only called if it is guaranteed that the phrase has at least
  ** one incremental token. In which case the bIncr flag is set. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIncr</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nToken</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3MsrIncrNext</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSegcsr</name></expr></argument>, 
        <argument><expr><operator>&amp;</operator><name><name>pDL</name><operator>-&gt;</operator><name>iDocid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDL</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDL</name><operator>-&gt;</operator><name>nList</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pDL</name><operator>-&gt;</operator><name>pList</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bEof</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bDescDoclist</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>bDesc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>TokenDoclist</name></name></type> <name><name>a</name><index>[<expr><name>MAX_INCR_PHRASE_TOKENS</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nToken</name></name><operator>&lt;=</operator><name>MAX_INCR_PHRASE_TOKENS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iDoclistToken</name></name><operator>&lt;</operator><name>MAX_INCR_PHRASE_TOKENS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <while>while<condition>( <expr><name>bEof</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>bMaxSet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iMax</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Largest docid for all iterators */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                      <comment type="block">/* Used to iterate through tokens */</comment>

      <comment type="block">/* Advance the iterator for each token in the phrase once. */</comment>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nToken</name></name> <operator>&amp;&amp;</operator> <name>bEof</name><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>incrPhraseTokenNext</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bEof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bIgnore</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>bMaxSet</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>DOCID_CMP</name><argument_list>(<argument><expr><name>iMax</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iDocid</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iMax</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iDocid</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>bMaxSet</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nToken</name></name><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nToken</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>bIgnore</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name>bMaxSet</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Keep advancing iterators until they all point to the same document */</comment>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bEof</name><operator>==</operator><literal type="number">0</literal> 
            <operator>&amp;&amp;</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bIgnore</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>DOCID_CMP</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iDocid</name></expr></argument>, <argument><expr><name>iMax</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr> 
        )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>incrPhraseTokenNext</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bEof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>DOCID_CMP</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iDocid</name></expr></argument>, <argument><expr><name>iMax</name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>iMax</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iDocid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
      </block_content>}</block></for>

      <comment type="block">/* Check if the current entries really are a phrase match */</comment>
      <if_stmt><if>if<condition>( <expr><name>bEof</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><name><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nToken</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nList</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aDoclist</name> <init>= <expr><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><operator>(</operator><name>i64</name><operator>)</operator><name>nByte</name><operator>+</operator><name>FTS3_BUFFER_PADDING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aDoclist</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aDoclist</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nToken</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pList</name></expr></argument>, <argument><expr><name>nByte</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aDoclist</name><index>[<expr><name>nByte</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FTS3_BUFFER_PADDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nToken</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bIgnore</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pL</name> <init>= <expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pList</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pR</name> <init>= <expr><name>aDoclist</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><name>aDoclist</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nDist</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nToken</name></name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>i</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>fts3PoslistPhraseMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pOut</name></expr></argument>, <argument><expr><name>nDist</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>nList</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOut</name> <operator>-</operator> <name>aDoclist</name><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nToken</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pDL</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>=</operator> <name>iMax</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pDL</name><operator>-&gt;</operator><name>pList</name></name> <operator>=</operator> <name>aDoclist</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pDL</name><operator>-&gt;</operator><name>nList</name></name> <operator>=</operator> <name>nList</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pDL</name><operator>-&gt;</operator><name>bFreeList</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aDoclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pbEof</name> <operator>=</operator> <name>bEof</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to move the phrase iterator to point to the next matching docid. 
** If an error occurs, return an SQLite error code. Otherwise, return 
** SQLITE_OK.
**
** If there is no "next" entry and no error occurs, then *pbEof is set to
** 1 before returning. Otherwise, if no error occurs and the iterator is
** successfully advanced, *pbEof is set to 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3EvalPhraseNext</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* FTS Cursor handle */</comment>
  <parameter><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                  <comment type="block">/* Phrase object to advance to next docid */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pbEof</name></decl></parameter>                       <comment type="block">/* OUT: Set to 1 if EOF */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Doclist</name> <modifier>*</modifier></type><name>pDL</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>doclist</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bIncr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3EvalIncrPhraseNext</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbEof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>bDesc</name></name><operator>!=</operator><name><name>pTab</name><operator>-&gt;</operator><name>bDescIdx</name></name> <operator>&amp;&amp;</operator> <name><name>pDL</name><operator>-&gt;</operator><name>nAll</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Fts3DoclistPrev</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>bDescIdx</name></name></expr></argument>, <argument><expr><name><name>pDL</name><operator>-&gt;</operator><name>aAll</name></name></expr></argument>, <argument><expr><name><name>pDL</name><operator>-&gt;</operator><name>nAll</name></name></expr></argument>, 
        <argument><expr><operator>&amp;</operator><name><name>pDL</name><operator>-&gt;</operator><name>pNextDocid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDL</name><operator>-&gt;</operator><name>iDocid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDL</name><operator>-&gt;</operator><name>nList</name></name></expr></argument>, <argument><expr><name>pbEof</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDL</name><operator>-&gt;</operator><name>pList</name></name> <operator>=</operator> <name><name>pDL</name><operator>-&gt;</operator><name>pNextDocid</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>fts3EvalDlPhraseNext</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pDL</name></expr></argument>, <argument><expr><name>pbEof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
**
** If *pRc is not SQLITE_OK when this function is called, it is a no-op.
** Otherwise, fts3EvalPhraseStart() is called on all phrases within the
** expression. Also the Fts3Expr.bDeferred variable is set to true for any
** expressions for which all descendent tokens are deferred.
**
** If parameter bOptOk is zero, then it is guaranteed that the
** Fts3Phrase.doclist.aAll/nAll variables contain the entire doclist for
** each phrase in the expression (subject to deferred token processing).
** Or, if bOptOk is non-zero, then one or more tokens within the expression
** may be loaded incrementally, meaning doclist.aAll/nAll is not available.
**
** If an error occurs within this function, *pRc is set to an SQLite error
** code before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3EvalStartReaders</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* FTS Cursor handle */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,                <comment type="block">/* Expression to initialize phrases in */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name> <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><operator>*</operator><name>pRc</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_PHRASE</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nToken</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nToken</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nToken</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pDeferred</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>bDeferred</name></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>==</operator><name>nToken</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>fts3EvalPhraseStart</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>fts3EvalStartReaders</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3EvalStartReaders</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>bDeferred</name></name> <operator>=</operator> <operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>bDeferred</name></name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>bDeferred</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** An array of the following structures is assembled as part of the process
** of selecting tokens to defer before the query starts executing (as part
** of the xFilter() method). There is one element in the array for each
** token in the FTS expression.
**
** Tokens are divided into AND/NEAR clusters. All tokens in a cluster belong
** to phrases that are connected only by AND and NEAR operators (not OR or
** NOT). When determining tokens to defer, each AND/NEAR cluster is considered
** separately. The root of a tokens AND/NEAR cluster is stored in 
** Fts3TokenAndCost.pRoot.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>Fts3TokenAndCost</name></name></type> <name>Fts3TokenAndCost</name>;</typedef>
<struct>struct <name>Fts3TokenAndCost</name> <block>{
  <decl_stmt><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>pPhrase</name></decl>;</decl_stmt>            <comment type="block">/* The phrase the token belongs to */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iToken</name></decl>;</decl_stmt>                     <comment type="block">/* Position of token in phrase */</comment>
  <decl_stmt><decl><type><name>Fts3PhraseToken</name> <modifier>*</modifier></type><name>pToken</name></decl>;</decl_stmt>        <comment type="block">/* The token itself */</comment>
  <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pRoot</name></decl>;</decl_stmt>                <comment type="block">/* Root of NEAR/AND cluster */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOvfl</name></decl>;</decl_stmt>                      <comment type="block">/* Number of overflow pages to load doclist */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                       <comment type="block">/* The column the token must match */</comment>
}</block>;</struct>

<comment type="block">/*
** This function is used to populate an allocated Fts3TokenAndCost array.
**
** If *pRc is not SQLITE_OK when this function is called, it is a no-op.
** Otherwise, if an error occurs during execution, *pRc is set to an
** SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3EvalTokenCosts</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* FTS Cursor handle */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pRoot</name></decl></parameter>,                <comment type="block">/* Root of current AND/NEAR cluster */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,                <comment type="block">/* Expression to consider */</comment>
  <parameter><decl><type><name>Fts3TokenAndCost</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppTC</name></decl></parameter>,        <comment type="block">/* Write new entries to *(*ppTC)++ */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>ppOr</name></decl></parameter>,               <comment type="block">/* Write new OR root to *(*ppOr)++ */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_PHRASE</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>pPhrase</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>Fts3TokenAndCost</name> <modifier>*</modifier></type><name>pTC</name> <init>= <expr><operator>(</operator><operator>*</operator><name>ppTC</name><operator>)</operator><operator>++</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pTC</name><operator>-&gt;</operator><name>pPhrase</name></name> <operator>=</operator> <name>pPhrase</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTC</name><operator>-&gt;</operator><name>iToken</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTC</name><operator>-&gt;</operator><name>pRoot</name></name> <operator>=</operator> <name>pRoot</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTC</name><operator>-&gt;</operator><name>pToken</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTC</name><operator>-&gt;</operator><name>iCol</name></name> <operator>=</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>sqlite3Fts3MsrOvfl</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pTC</name><operator>-&gt;</operator><name>pToken</name><operator>-&gt;</operator><name>pSegcsr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTC</name><operator>-&gt;</operator><name>nOvfl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>eType</name></name><operator>!=</operator><name>FTSQUERY_NOT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_OR</name>
           <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_AND</name>
           <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_NEAR</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_OR</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>*</operator><name>ppOr</name> <operator>=</operator> <name>pRoot</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>ppOr</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>fts3EvalTokenCosts</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>ppTC</name></expr></argument>, <argument><expr><name>ppOr</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_OR</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>*</operator><name>ppOr</name> <operator>=</operator> <name>pRoot</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>ppOr</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>fts3EvalTokenCosts</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>ppTC</name></expr></argument>, <argument><expr><name>ppOr</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Determine the average document (row) size in pages. If successful,
** write this value to *pnPage and return SQLITE_OK. Otherwise, return
** an SQLite error code.
**
** The average document size in pages is calculated by first calculating 
** determining the average size in bytes, B. If B is less than the amount
** of data that will fit on a single leaf page of an intkey table in
** this database, then the average docsize is 1. Otherwise, it is 1 plus
** the number of overflow pages consumed by a record B bytes in size.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3EvalAverageDocsize</name><parameter_list>(<parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>nRowAvg</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* The average document size, which is required to calculate the cost
    ** of each doclist, has not yet been determined. Read the required 
    ** data from the %_stat table to calculate it.
    **
    ** Entry 0 of the %_stat table is a blob containing (nCol+1) FTS3 
    ** varints, where nCol is the number of columns in the FTS3 table.
    ** The first varint is the number of documents currently stored in
    ** the table. The following nCol varints contain the total amount of
    ** data stored in all rows of each column of the table, from left
    ** to right.
    */</comment>
    <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Fts3Table</name><operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nDoc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pEnd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SelectDoctotal</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>a</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* If %_stat.value set to X'' */</comment>
    <if_stmt><if>if<condition>( <expr><name>a</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>a</name><index>[<expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>a</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarintBounded</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>pEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nDoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>a</name><operator>&lt;</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>a</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarintBounded</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>pEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nDoc</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nByte</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nDoc</name></name> <operator>=</operator> <name>nDoc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nRowAvg</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>nByte</name> <operator>/</operator> <name>nDoc</name><operator>)</operator> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>nPgsz</name></name><operator>)</operator> <operator>/</operator> <name><name>p</name><operator>-&gt;</operator><name>nPgsz</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nRowAvg</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pnPage</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>nRowAvg</name></name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called to select the tokens (if any) that will be 
** deferred. The array aTC[] has already been populated when this is
** called.
**
** This function is called once for each AND/NEAR cluster in the 
** expression. Each invocation determines which tokens to defer within
** the cluster with root node pRoot. See comments above the definition
** of struct Fts3TokenAndCost for more details.
**
** If no error occurs, SQLITE_OK is returned and sqlite3Fts3DeferToken()
** called on each token to defer. Otherwise, an SQLite error code is
** returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3EvalSelectDeferred</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* FTS Cursor handle */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pRoot</name></decl></parameter>,                <comment type="block">/* Consider tokens with this root node */</comment>
  <parameter><decl><type><name>Fts3TokenAndCost</name> <modifier>*</modifier></type><name>aTC</name></decl></parameter>,          <comment type="block">/* Array of expression tokens and costs */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTC</name></decl></parameter>                         <comment type="block">/* Number of entries in aTC[] */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDocSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Number of pages per doc loaded */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>                         <comment type="block">/* Iterator variable for various purposes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOvfl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Total overflow pages used by doclists */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nToken</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Total number of tokens in cluster */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>nMinEst</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* The minimum count for any phrase so far. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nLoad4</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* (Phrases that will be loaded)^4. */</comment>

  <comment type="block">/* Tokens are never deferred for FTS tables created using the content=xxx
  ** option. The reason being that it is not guaranteed that the content
  ** table actually contains the same data as the index. To prevent this from
  ** causing any problems, the deferred token optimization is completely
  ** disabled for content=xxx tables. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>zContentTbl</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Count the tokens in this AND/NEAR cluster. If none of the doclists
  ** associated with the tokens spill onto overflow pages, or if there is
  ** only 1 token, exit early. No tokens to defer in this case. */</comment>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nTC</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aTC</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pRoot</name><operator>==</operator><name>pRoot</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nOvfl</name> <operator>+=</operator> <name><name>aTC</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>nOvfl</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nToken</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>nOvfl</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nToken</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Obtain the average docsize (in pages). */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3EvalAverageDocsize</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nDocSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name>nDocSize</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/* Iterate through all tokens in this AND/NEAR cluster, in ascending order 
  ** of the number of overflow pages that will be loaded by the pager layer 
  ** to retrieve the entire doclist for the token from the full-text index.
  ** Load the doclists for tokens that are either:
  **
  **   a. The cheapest token in the entire query (i.e. the one visited by the
  **      first iteration of this loop), or
  **
  **   b. Part of a multi-token phrase.
  **
  ** After each token doclist is loaded, merge it with the others from the
  ** same phrase and count the number of documents that the merged doclist
  ** contains. Set variable "nMinEst" to the smallest number of documents in 
  ** any phrase doclist for which 1 or more token doclists have been loaded.
  ** Let nOther be the number of other phrases for which it is certain that
  ** one or more tokens will not be deferred.
  **
  ** Then, for each token, defer it if loading the doclist would result in
  ** loading N or more overflow pages into memory, where N is computed as:
  **
  **    (nMinEst + 4^nOther - 1) / (4^nOther)
  */</comment>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nToken</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iTC</name></decl>;</decl_stmt>                      <comment type="block">/* Used to iterate through aTC[] array. */</comment>
    <decl_stmt><decl><type><name>Fts3TokenAndCost</name> <modifier>*</modifier></type><name>pTC</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Set to cheapest remaining token. */</comment>

    <comment type="block">/* Set pTC to point to the cheapest remaining token. */</comment>
    <for>for<control>(<init><expr><name>iTC</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iTC</name><operator>&lt;</operator><name>nTC</name></expr>;</condition> <incr><expr><name>iTC</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aTC</name><index>[<expr><name>iTC</name></expr>]</index></name><operator>.</operator><name>pToken</name> <operator>&amp;&amp;</operator> <name><name>aTC</name><index>[<expr><name>iTC</name></expr>]</index></name><operator>.</operator><name>pRoot</name><operator>==</operator><name>pRoot</name> 
       <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>pTC</name> <operator>||</operator> <name><name>aTC</name><index>[<expr><name>iTC</name></expr>]</index></name><operator>.</operator><name>nOvfl</name><operator>&lt;</operator><name><name>pTC</name><operator>-&gt;</operator><name>nOvfl</name></name><operator>)</operator></expr> 
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>pTC</name> <operator>=</operator> <operator>&amp;</operator><name><name>aTC</name><index>[<expr><name>iTC</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>ii</name> <operator>&amp;&amp;</operator> <name><name>pTC</name><operator>-&gt;</operator><name>nOvfl</name></name><operator>&gt;=</operator><operator>(</operator><operator>(</operator><name>nMinEst</name><operator>+</operator><operator>(</operator><name>nLoad4</name><operator>/</operator><literal type="number">4</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><operator>(</operator><name>nLoad4</name><operator>/</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator><operator>*</operator><name>nDocSize</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* The number of overflow pages to load for this (and therefore all
      ** subsequent) tokens is greater than the estimated number of pages 
      ** that will be loaded if all subsequent tokens are deferred.
      */</comment>
      <decl_stmt><decl><type><name>Fts3PhraseToken</name> <modifier>*</modifier></type><name>pToken</name> <init>= <expr><name><name>pTC</name><operator>-&gt;</operator><name>pToken</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3DeferToken</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>, <argument><expr><name><name>pTC</name><operator>-&gt;</operator><name>iCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3SegReaderCursorFree</name><argument_list>(<argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>pSegcsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>pSegcsr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Set nLoad4 to the value of (4^nOther) for the next iteration of the
      ** for-loop. Except, limit the value to 2^24 to prevent it from 
      ** overflowing the 32-bit integer it is stored in. */</comment>
      <if_stmt><if>if<condition>( <expr><name>ii</name><operator>&lt;</operator><literal type="number">12</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nLoad4</name> <operator>=</operator> <name>nLoad4</name><operator>*</operator><literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>ii</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pTC</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>ii</name><operator>!=</operator><name>nToken</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <comment type="block">/* Either this is the cheapest token in the entire query, or it is
        ** part of a multi-token phrase. Either way, the entire doclist will
        ** (eventually) be loaded into memory. It may as well be now. */</comment>
        <decl_stmt><decl><type><name>Fts3PhraseToken</name> <modifier>*</modifier></type><name>pToken</name> <init>= <expr><name><name>pTC</name><operator>-&gt;</operator><name>pToken</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3TermSelect</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>, <argument><expr><name><name>pTC</name><operator>-&gt;</operator><name>iCol</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>pList</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3EvalPhraseMergeToken</name><argument_list>(
              <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>pTC</name><operator>-&gt;</operator><name>pPhrase</name></name></expr></argument>, <argument><expr><name><name>pTC</name><operator>-&gt;</operator><name>iToken</name></name></expr></argument>,<argument><expr><name>pList</name></expr></argument>,<argument><expr><name>nList</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>nCount</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>nCount</name> <operator>=</operator> <call><name>fts3DoclistCountDocids</name><argument_list>(
              <argument><expr><name><name>pTC</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>aAll</name></name></expr></argument>, <argument><expr><name><name>pTC</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nAll</name></name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>ii</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nCount</name><operator>&lt;</operator><name>nMinEst</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nMinEst</name> <operator>=</operator> <name>nCount</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pTC</name><operator>-&gt;</operator><name>pToken</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called from within the xFilter method. It initializes
** the full-text query currently stored in pCsr-&gt;pExpr. To iterate through
** the results of a query, the caller does:
**
**    fts3EvalStart(pCsr);
**    while( 1 ){
**      fts3EvalNext(pCsr);
**      if( pCsr-&gt;bEof ) break;
**      ... return row pCsr-&gt;iPrevId to the caller ...
**    }
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3EvalStart</name><parameter_list>(<parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nToken</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Allocate a MultiSegReader for each token in the expression. */</comment>
  <expr_stmt><expr><call><name>fts3EvalAllocateReaders</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Determine which, if any, tokens in the expression should be deferred. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DISABLE_FTS4_DEFERRED</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>nToken</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>bFts4</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3TokenAndCost</name> <modifier>*</modifier></type><name>aTC</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>aTC</name> <operator>=</operator> <operator>(</operator><name>Fts3TokenAndCost</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(
        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3TokenAndCost</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nToken</name>
      <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Fts3Expr</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nOr</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aTC</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>apOr</name> <init>= <expr><operator>(</operator><name>Fts3Expr</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aTC</name><index>[<expr><name>nToken</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Fts3TokenAndCost</name> <modifier>*</modifier></type><name>pTC</name> <init>= <expr><name>aTC</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOr</name> <init>= <expr><name>apOr</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>fts3EvalTokenCosts</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ppOr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nToken</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pTC</name><operator>-</operator><name>aTC</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>nOr</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ppOr</name><operator>-</operator><name>apOr</name><operator>)</operator></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3EvalSelectDeferred</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>aTC</name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>ii</name><operator>&lt;</operator><name>nOr</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3EvalSelectDeferred</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>apOr</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, <argument><expr><name>aTC</name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aTC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>fts3EvalStartReaders</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Invalidate the current position list for phrase pPhrase.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3EvalInvalidatePoslist</name><parameter_list>(<parameter><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>pPhrase</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>bFreeList</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>bFreeList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called to edit the position list associated with
** the phrase object passed as the fifth argument according to a NEAR
** condition. For example:
**
**     abc NEAR/5 "def ghi"
**
** Parameter nNear is passed the NEAR distance of the expression (5 in
** the example above). When this function is called, *paPoslist points to
** the position list, and *pnToken is the number of phrase tokens in the
** phrase on the other side of the NEAR operator to pPhrase. For example,
** if pPhrase refers to the "def ghi" phrase, then *paPoslist points to
** the position list associated with phrase "abc".
**
** All positions in the pPhrase position list that are not sufficiently
** close to a position in the *paPoslist position list are removed. If this
** leaves 0 positions, zero is returned. Otherwise, non-zero.
**
** Before returning, *paPoslist is set to point to the position lsit 
** associated with pPhrase. And *pnToken is set to the number of tokens in
** pPhrase.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3EvalNearTrim</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nNear</name></decl></parameter>,                      <comment type="block">/* NEAR distance. As in "NEAR/nNear". */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aTmp</name></decl></parameter>,                     <comment type="block">/* Temporary space to use */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>paPoslist</name></decl></parameter>,               <comment type="block">/* IN/OUT: Position list */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnToken</name></decl></parameter>,                   <comment type="block">/* IN/OUT: Tokens in phrase of *paPoslist */</comment>
  <parameter><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>pPhrase</name></decl></parameter>             <comment type="block">/* The phrase object to trim the doclist of */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nParam1</name> <init>= <expr><name>nNear</name> <operator>+</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nParam2</name> <init>= <expr><name>nNear</name> <operator>+</operator> <operator>*</operator><name>pnToken</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pOut</name></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>p2</name> <operator>=</operator> <name>pOut</name> <operator>=</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>fts3PoslistNearMerge</name><argument_list>(
    <argument><expr><operator>&amp;</operator><name>pOut</name></expr></argument>, <argument><expr><name>aTmp</name></expr></argument>, <argument><expr><name>nParam1</name></expr></argument>, <argument><expr><name>nParam2</name></expr></argument>, <argument><expr><name>paPoslist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nNew</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOut</name> <operator>-</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><name>nNew</name><operator>&lt;=</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nList</name></name> <operator>&amp;&amp;</operator> <name>nNew</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nNew</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nNew</name><operator>&lt;=</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nList</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name><index>[<expr><name>nNew</name></expr>]</index></name><operator>==</operator><literal type="char">'\0'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name><index>[<expr><name>nNew</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nList</name></name> <operator>-</operator> <name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nList</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>paPoslist</name> <operator>=</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnToken</name> <operator>=</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if *pRc is other than SQLITE_OK when it is called.
** Otherwise, it advances the expression passed as the second argument to
** point to the next matching row in the database. Expressions iterate through
** matching rows in docid order. Ascending order if Fts3Cursor.bDesc is zero,
** or descending if it is non-zero.
**
** If an error occurs, *pRc is set to an SQLite error code. Otherwise, if
** successful, the following variables in pExpr are set:
**
**   Fts3Expr.bEof                (non-zero if EOF - there is no next row)
**   Fts3Expr.iDocid              (valid if bEof==0. The docid of the next row)
**
** If the expression is of type FTSQUERY_PHRASE, and the expression is not
** at EOF, then the following variables are populated with the position list
** for the phrase for the visited row:
**
**   FTs3Expr.pPhrase-&gt;doclist.nList        (length of pList in bytes)
**   FTs3Expr.pPhrase-&gt;doclist.pList        (pointer to position list)
**
** It says above that this function advances the expression to the next
** matching row. This is usually true, but there are the following exceptions:
**
**   1. Deferred tokens are not taken into account. If a phrase consists
**      entirely of deferred tokens, it is assumed to match every row in
**      the db. In this case the position-list is not populated at all. 
**
**      Or, if a phrase contains one or more deferred tokens and one or
**      more non-deferred tokens, then the expression is advanced to the 
**      next possible match, considering only non-deferred tokens. In other
**      words, if the phrase is "A B C", and "B" is deferred, the expression
**      is advanced to the next row that contains an instance of "A * C", 
**      where "*" may match any single token. The position list in this case
**      is populated as for "A * C" before returning.
**
**   2. NEAR is treated as AND. If the expression is "x NEAR y", it is 
**      advanced to point to the next row that matches "x AND y".
** 
** See sqlite3Fts3EvalTestDeferred() for details on testing if a row is
** really a match, taking into account deferred tokens and NEAR operators.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3EvalNextRow</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* FTS Cursor handle */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,                <comment type="block">/* Expr. to advance to next matching row */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bDescDoclist</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>bDesc</name></name></expr></init></decl>;</decl_stmt>         <comment type="block">/* Used by DOCID_CMP() macro */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>bEof</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>bStart</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <switch>switch<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>eType</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>FTSQUERY_NEAR</name></expr>:</case>
      <case>case <expr><name>FTSQUERY_AND</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pLeft</name><operator>-&gt;</operator><name>bDeferred</name></name> <operator>||</operator> <operator>!</operator><name><name>pRight</name><operator>-&gt;</operator><name>bDeferred</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><name><name>pLeft</name><operator>-&gt;</operator><name>bDeferred</name></name></expr> )</condition><block>{<block_content>
          <comment type="block">/* LHS is entirely deferred. So we assume it matches every row.
          ** Advance the RHS iterator to find the next row visited. */</comment>
          <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>iDocid</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>bEof</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pRight</name><operator>-&gt;</operator><name>bDeferred</name></name></expr> )</condition><block>{<block_content>
          <comment type="block">/* RHS is entirely deferred. So we assume it matches every row.
          ** Advance the LHS iterator to find the next row visited. */</comment>
          <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>iDocid</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>bEof</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* Neither the RHS or LHS are deferred. */</comment>
          <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <while>while<condition>( <expr><operator>!</operator><name><name>pLeft</name><operator>-&gt;</operator><name>bEof</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pRight</name><operator>-&gt;</operator><name>bEof</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iDiff</name> <init>= <expr><call><name>DOCID_CMP</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>iDocid</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>iDocid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><name>iDiff</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name>iDiff</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></while>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>iDocid</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <operator>(</operator><name><name>pLeft</name><operator>-&gt;</operator><name>bEof</name></name> <operator>||</operator> <name><name>pRight</name><operator>-&gt;</operator><name>bEof</name></name><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_NEAR</name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>bEof</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_PHRASE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pRight</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>aAll</name></name></expr> )</condition><block>{<block_content>
              <decl_stmt><decl><type><name>Fts3Doclist</name> <modifier>*</modifier></type><name>pDl</name> <init>= <expr><operator>&amp;</operator><name><name>pRight</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name></name></expr></init></decl>;</decl_stmt>
              <while>while<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>bEof</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pDl</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pDl</name><operator>-&gt;</operator><name>nList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></while>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pLeft</name><operator>-&gt;</operator><name>pPhrase</name></name> <operator>&amp;&amp;</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>aAll</name></name></expr> )</condition><block>{<block_content>
              <decl_stmt><decl><type><name>Fts3Doclist</name> <modifier>*</modifier></type><name>pDl</name> <init>= <expr><operator>&amp;</operator><name><name>pLeft</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name></name></expr></init></decl>;</decl_stmt>
              <while>while<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>bEof</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pDl</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pDl</name><operator>-&gt;</operator><name>nList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></while>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>pRight</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
  
      <case>case <expr><name>FTSQUERY_OR</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iCmp</name> <init>= <expr><call><name>DOCID_CMP</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>iDocid</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>iDocid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>bStart</name></name> <operator>||</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>iDocid</name></name><operator>==</operator><name><name>pRight</name><operator>-&gt;</operator><name>iDocid</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>bStart</name></name> <operator>||</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>iDocid</name></name><operator>==</operator><name><name>pRight</name><operator>-&gt;</operator><name>iDocid</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><name><name>pRight</name><operator>-&gt;</operator><name>bEof</name></name> <operator>||</operator> <operator>(</operator><name><name>pLeft</name><operator>-&gt;</operator><name>bEof</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCmp</name><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pLeft</name><operator>-&gt;</operator><name>bEof</name></name> <operator>||</operator> <name>iCmp</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <operator>(</operator><name><name>pLeft</name><operator>-&gt;</operator><name>bEof</name></name> <operator>&amp;&amp;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>bEof</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>iCmp</name> <operator>=</operator> <call><name>DOCID_CMP</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>iDocid</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>iDocid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pRight</name><operator>-&gt;</operator><name>bEof</name></name> <operator>||</operator> <operator>(</operator><name><name>pLeft</name><operator>-&gt;</operator><name>bEof</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator>  <name>iCmp</name><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>iDocid</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>iDocid</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <break>break;</break>
      </block_content>}</block>

      <case>case <expr><name>FTSQUERY_NOT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if<condition>( <expr><name><name>pRight</name><operator>-&gt;</operator><name>bStart</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pRc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>pRight</name><operator>-&gt;</operator><name>bStart</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pLeft</name><operator>-&gt;</operator><name>bEof</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <while>while<condition>( <expr><operator>!</operator><operator>*</operator><name>pRc</name> 
              <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pRight</name><operator>-&gt;</operator><name>bEof</name></name> 
              <operator>&amp;&amp;</operator> <call><name>DOCID_CMP</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>iDocid</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>iDocid</name></name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr> 
          )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>iDocid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>bEof</name></name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>

      <default>default:</default> <block>{<block_content>
        <decl_stmt><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>pPhrase</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>fts3EvalInvalidatePoslist</name><argument_list>(<argument><expr><name>pPhrase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>fts3EvalPhraseNext</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPhrase</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pExpr</name><operator>-&gt;</operator><name>bEof</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>=</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>iDocid</name></name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If *pRc is not SQLITE_OK, or if pExpr is not the root node of a NEAR
** cluster, then this function returns 1 immediately.
**
** Otherwise, it checks if the current row really does match the NEAR 
** expression, using the data currently stored in the position lists 
** (Fts3Expr-&gt;pPhrase.doclist.pList/nList) for each phrase in the expression. 
**
** If the current row is a match, the position list associated with each
** phrase in the NEAR expression is edited in place to contain only those
** phrase instances sufficiently close to their peers to satisfy all NEAR
** constraints. In this case it returns 1. If the NEAR expression does not 
** match the current row, 0 is returned. The position lists may or may not
** be edited if 0 is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3EvalNearTest</name><parameter_list>(<parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* The following block runs if pExpr is the root of a NEAR query.
  ** For example, the query:
  **
  **         "w" NEAR "x" NEAR "y" NEAR "z"
  **
  ** which is represented in tree form as:
  **
  **                               |
  **                          +--NEAR--+      &lt;-- root of NEAR query
  **                          |        |
  **                     +--NEAR--+   "z"
  **                     |        |
  **                +--NEAR--+   "y"
  **                |        |
  **               "w"      "x"
  **
  ** The right-hand child of a NEAR node is always a phrase. The 
  ** left-hand child may be either a phrase or a NEAR node. There are
  ** no exceptions to this - it's the way the parser in fts3_expr.c works.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name> 
   <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_NEAR</name> 
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pParent</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>eType</name></name><operator>!=</operator><name>FTSQUERY_NEAR</name><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nTmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Bytes of temp space */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aTmp</name></decl>;</decl_stmt>                   <comment type="block">/* Temp space for PoslistNearMerge() */</comment>

    <comment type="block">/* Allocate temporary working space. */</comment>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pExpr</name></expr>;</init> <condition><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nList</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nTmp</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nList</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>nTmp</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aTmp</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nTmp</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aTmp</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aPoslist</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nToken</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name></expr></init></decl>;</decl_stmt>

      <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</init><condition><expr><name>res</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_NEAR</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pParent</name></name></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>pPhrase</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>pPhrase</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nNear</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nNear</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>fts3EvalNearTrim</name><argument_list>(<argument><expr><name>nNear</name></expr></argument>, <argument><expr><name>aTmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aPoslist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nToken</name></expr></argument>, <argument><expr><name>pPhrase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>

      <expr_stmt><expr><name>aPoslist</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nToken</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</init> <condition><expr><name>p</name> <operator>&amp;&amp;</operator> <name>res</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nNear</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>pPhrase</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pParent</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pLeft</name></name><operator>==</operator><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nNear</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>nNear</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pPhrase</name> <operator>=</operator> <operator>(</operator>
            <ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_NEAR</name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>pPhrase</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>pPhrase</name></name></expr></else></ternary>
        <operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>fts3EvalNearTrim</name><argument_list>(<argument><expr><name>nNear</name></expr></argument>, <argument><expr><name>aTmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aPoslist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nToken</name></expr></argument>, <argument><expr><name>pPhrase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a helper function for sqlite3Fts3EvalTestDeferred().
** Assuming no error occurs or has occurred, It returns non-zero if the
** expression passed as the second argument matches the row that pCsr 
** currently points to, or zero if it does not.
**
** If *pRc is not SQLITE_OK when this function is called, it is a no-op.
** If an error occurs during execution of this function, *pRc is set to 
** the appropriate SQLite error code. In this case the returned value is 
** undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3EvalTestExpr</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* FTS cursor handle */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,                <comment type="block">/* Expr to test. May or may not be root. */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>bHit</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Return value */</comment>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <switch>switch<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>eType</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>FTSQUERY_NEAR</name></expr>:</case>
      <case>case <expr><name>FTSQUERY_AND</name></expr>:</case>
        <expr_stmt><expr><name>bHit</name> <operator>=</operator> <operator>(</operator>
            <call><name>fts3EvalTestExpr</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call>
         <operator>&amp;&amp;</operator> <call><name>fts3EvalTestExpr</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call>
         <operator>&amp;&amp;</operator> <call><name>fts3EvalNearTest</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call>
        <operator>)</operator></expr>;</expr_stmt>

        <comment type="block">/* If the NEAR expression does not match any rows, zero the doclist for 
        ** all phrases involved in the NEAR. This is because the snippet(),
        ** offsets() and matchinfo() functions are not supposed to recognize 
        ** any instances of phrases that are part of unmatched NEAR queries. 
        ** For example if this expression:
        **
        **    ... MATCH 'a OR (b NEAR c)'
        **
        ** is matched against a row containing:
        **
        **        'a b d e'
        **
        ** then any snippet() should ony highlight the "a" term, not the "b"
        ** (as "b" is part of a non-matching NEAR clause).
        */</comment>
        <if_stmt><if>if<condition>( <expr><name>bHit</name><operator>==</operator><literal type="number">0</literal> 
         <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_NEAR</name> 
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pParent</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>eType</name></name><operator>!=</operator><name>FTSQUERY_NEAR</name><operator>)</operator></expr>
        )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pExpr</name></expr>;</init> <condition><expr><name><name>p</name><operator>-&gt;</operator><name>pPhrase</name></name><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>iDocid</name></name><operator>==</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>fts3EvalInvalidatePoslist</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>pPhrase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iDocid</name></name><operator>==</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>fts3EvalInvalidatePoslist</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPhrase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <break>break;</break>

      <case>case <expr><name>FTSQUERY_OR</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>bHit1</name> <init>= <expr><call><name>fts3EvalTestExpr</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bHit2</name> <init>= <expr><call><name>fts3EvalTestExpr</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>bHit</name> <operator>=</operator> <name>bHit1</name> <operator>||</operator> <name>bHit2</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>

      <case>case <expr><name>FTSQUERY_NOT</name></expr>:</case>
        <expr_stmt><expr><name>bHit</name> <operator>=</operator> <operator>(</operator>
            <call><name>fts3EvalTestExpr</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call>
         <operator>&amp;&amp;</operator> <operator>!</operator><call><name>fts3EvalTestExpr</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call>
        <operator>)</operator></expr>;</expr_stmt>
        <break>break;</break>

      <default>default:</default> <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DISABLE_FTS4_DEFERRED</name></cpp:ifndef>
        <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDeferred</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>bDeferred</name></name> <operator>||</operator> <operator>(</operator>
            <name><name>pExpr</name><operator>-&gt;</operator><name>iDocid</name></name><operator>==</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name>
        <operator>)</operator><operator>)</operator></expr>)</condition><block>{<block_content>
          <decl_stmt><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>pPhrase</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name></name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>bDeferred</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>fts3EvalInvalidatePoslist</name><argument_list>(<argument><expr><name>pPhrase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>fts3EvalDeferredPhrase</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pPhrase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>bHit</name> <operator>=</operator> <operator>(</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
          <expr_stmt><expr><name>bHit</name> <operator>=</operator> <operator>(</operator> 
              <name><name>pExpr</name><operator>-&gt;</operator><name>bEof</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iDocid</name></name><operator>==</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name>
           <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nList</name></name><operator>&gt;</operator><literal type="number">0</literal>
          <operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>bHit</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called as the second part of each xNext operation when
** iterating through the results of a full-text query. At this point the
** cursor points to a row that matches the query expression, with the
** following caveats:
**
**   * Up until this point, "NEAR" operators in the expression have been
**     treated as "AND".
**
**   * Deferred tokens have not yet been considered.
**
** If *pRc is not SQLITE_OK when this function is called, it immediately
** returns 0. Otherwise, it tests whether or not after considering NEAR
** operators and deferred tokens the current row is still a match for the
** expression. It returns 1 if both of the following are true:
**
**   1. *pRc is SQLITE_OK when this function returns, and
**
**   2. After scanning the current FTS table row for the deferred tokens,
**      it is determined that the row does *not* match the query.
**
** Or, if no error occurs and it seems the current row does match the FTS
** query, return 0.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3EvalTestDeferred</name><parameter_list>(<parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><operator>*</operator><name>pRc</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bMiss</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>

    <comment type="block">/* If there are one or more deferred tokens, load the current row into
    ** memory and scan it to determine the position list for each deferred
    ** token. Then, see if this row is really a match, considering deferred
    ** tokens and NEAR operators (neither of which were taken into account
    ** earlier, by fts3EvalNextRow()). 
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDeferred</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3CursorSeek</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3CacheDeferredDoclists</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>bMiss</name> <operator>=</operator> <operator>(</operator><literal type="number">0</literal><operator>==</operator><call><name>fts3EvalTestExpr</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Free the position-lists accumulated for each deferred token above. */</comment>
    <expr_stmt><expr><call><name>sqlite3Fts3FreeDeferredDoclists</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bMiss</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance to the next document that matches the FTS expression in
** Fts3Cursor.pExpr.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3EvalNext</name><parameter_list>(<parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>isEof</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>isEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <do>do <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>isRequireSeek</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_data_count</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>isEof</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>bEof</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>isRequireSeek</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>isMatchinfoNeeded</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iDocid</name></name></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>isEof</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3Fts3EvalTestDeferred</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition>;</do>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Check if the cursor is past the end of the docid range specified
  ** by Fts3Cursor.iMinDocid/iMaxDocid. If so, set the EOF flag.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator>
        <operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>bDesc</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name><operator>&gt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iMaxDocid</name></name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>bDesc</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iMinDocid</name></name><operator>)</operator>
  <operator>)</operator></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>isEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Restart interation for expression pExpr so that the next call to
** fts3EvalNext() visits the first row. Do not allow incremental 
** loading or merging of phrase doclists for this iteration.
**
** If *pRc is other than SQLITE_OK when this function is called, it is
** a no-op. If an error occurs within this function, *pRc is set to an
** SQLite error code before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3EvalRestart</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>pPhrase</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>pPhrase</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fts3EvalInvalidatePoslist</name><argument_list>(<argument><expr><name>pPhrase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pPhrase</name><operator>-&gt;</operator><name>bIncr</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>Fts3PhraseToken</name> <modifier>*</modifier></type><name>pToken</name> <init>= <expr><operator>&amp;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>pDeferred</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pToken</name><operator>-&gt;</operator><name>pSegcsr</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3Fts3MsrIncrRestart</name><argument_list>(<argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>pSegcsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>fts3EvalPhraseStart</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pPhrase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pNextDocid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>iDocid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>pOrPoslist</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>bStart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fts3EvalRestart</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fts3EvalRestart</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** After allocating the Fts3Expr.aMI[] array for each phrase in the 
** expression rooted at pExpr, the cursor iterates through all rows matched
** by pExpr, calling this function for each row. This function increments
** the values in Fts3Expr.aMI[] according to the position-list currently
** found in Fts3Expr.pPhrase-&gt;doclist.pList for each of the phrase 
** expression nodes.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3EvalUpdateCounts</name><parameter_list>(<parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>pPhrase</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pPhrase</name> <operator>&amp;&amp;</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name></expr></init></decl>;</decl_stmt>

      <do>do<block>{<block_content>
        <decl_stmt><decl><type><name>u8</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iCnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <while>while<condition>( <expr><literal type="number">0xFE</literal> <operator>&amp;</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>|</operator> <name>c</name><operator>)</operator></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iCnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/* aMI[iCol*3 + 1] = Number of occurrences
        ** aMI[iCol*3 + 2] = Number of rows containing at least one instance
        */</comment>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>aMI</name><index>[<expr><name>iCol</name><operator>*</operator><literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>iCnt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>aMI</name><index>[<expr><name>iCol</name><operator>*</operator><literal type="number">3</literal> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <operator>(</operator><name>iCnt</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name><operator>==</operator><literal type="number">0x00</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>while<condition>( <expr><name>iCol</name><operator>&lt;</operator><name>nCol</name></expr> )</condition>;</do>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>fts3EvalUpdateCounts</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fts3EvalUpdateCounts</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Expression pExpr must be of type FTSQUERY_PHRASE.
**
** If it is not already allocated and populated, this function allocates and
** populates the Fts3Expr.aMI[] array for expression pExpr. If pExpr is part
** of a NEAR expression, then it also allocates and populates the same array
** for all other phrases that are part of the NEAR expression.
**
** SQLITE_OK is returned if the aMI[] array is successfully allocated and
** populated. Otherwise, if an error occurs, an SQLite error code is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3EvalGatherStats</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* Cursor object */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>                 <comment type="block">/* FTSQUERY_PHRASE expression */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_PHRASE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>aMI</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pRoot</name></decl>;</decl_stmt>                <comment type="block">/* Root of NEAR expression */</comment>
    <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                    <comment type="block">/* Iterator used for several purposes */</comment>

    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iPrevId</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iDocid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>bEof</name></decl>;</decl_stmt>

    <comment type="block">/* Find the root of the NEAR expression */</comment>
    <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>pRoot</name><operator>-&gt;</operator><name>pParent</name></name> <operator>&amp;&amp;</operator> <name><name>pRoot</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_NEAR</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <name><name>pRoot</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>iDocid</name> <operator>=</operator> <name><name>pRoot</name><operator>-&gt;</operator><name>iDocid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bEof</name> <operator>=</operator> <name><name>pRoot</name><operator>-&gt;</operator><name>bEof</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>bStart</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Allocate space for the aMSI[] array of each FTSQUERY_PHRASE node */</comment>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pRoot</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pE</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_PHRASE</name></expr>?</condition><then><expr><name>p</name></expr></then><else>:<expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pE</name><operator>-&gt;</operator><name>aMI</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pE</name><operator>-&gt;</operator><name>aMI</name></name> <operator>=</operator> <operator>(</operator><name>u32</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>*</operator> <literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pE</name><operator>-&gt;</operator><name>aMI</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pE</name><operator>-&gt;</operator><name>aMI</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>*</operator> <literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>fts3EvalRestart</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>isEof</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>

      <do>do <block>{<block_content>
        <comment type="block">/* Ensure the %_content statement is reset. */</comment>
        <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>isRequireSeek</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_data_count</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Advance to the next document */</comment>
        <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>isEof</name></name> <operator>=</operator> <name><name>pRoot</name><operator>-&gt;</operator><name>bEof</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>isRequireSeek</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>isMatchinfoNeeded</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name> <operator>=</operator> <name><name>pRoot</name><operator>-&gt;</operator><name>iDocid</name></name></expr>;</expr_stmt>
      </block_content>}</block>while<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>isEof</name></name><operator>==</operator><literal type="number">0</literal> 
           <operator>&amp;&amp;</operator> <name><name>pRoot</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_NEAR</name> 
           <operator>&amp;&amp;</operator> <call><name>sqlite3Fts3EvalTestDeferred</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr> 
      )</condition>;</do>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>isEof</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fts3EvalUpdateCounts</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>isEof</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name> <operator>=</operator> <name>iPrevId</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>bEof</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <name>bEof</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Caution: pRoot may iterate through docids in ascending or descending
      ** order. For this reason, even though it seems more defensive, the 
      ** do loop can not be written:
      **
      **   do {...} while( pRoot-&gt;iDocid&lt;iDocid &amp;&amp; rc==SQLITE_OK );
      */</comment>
      <expr_stmt><expr><call><name>fts3EvalRestart</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <do>do <block>{<block_content>
        <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>bEof</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pRoot</name><operator>-&gt;</operator><name>bEof</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>FTS_CORRUPT_VTAB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block>while<condition>( <expr><name><name>pRoot</name><operator>-&gt;</operator><name>iDocid</name></name><operator>!=</operator><name>iDocid</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition>;</do>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is used by the matchinfo() module to query a phrase 
** expression node for the following information:
**
**   1. The total number of occurrences of the phrase in each column of 
**      the FTS table (considering all rows), and
**
**   2. For each column, the number of rows in the table for which the
**      column contains at least one instance of the phrase.
**
** If no error occurs, SQLITE_OK is returned and the values for each column
** written into the array aiOut as follows:
**
**   aiOut[iCol*3 + 1] = Number of occurrences
**   aiOut[iCol*3 + 2] = Number of rows containing at least one instance
**
** Caveats:
**
**   * If a phrase consists entirely of deferred tokens, then all output 
**     values are set to the number of documents in the table. In other
**     words we assume that very common tokens occur exactly once in each 
**     column of each row of the table.
**
**   * If a phrase contains some deferred tokens (and some non-deferred 
**     tokens), count the potential occurrence identified by considering
**     the non-deferred tokens instead of actual phrase occurrences.
**
**   * If the phrase is part of a NEAR expression, then only phrase instances
**     that meet the NEAR constraint are included in the counts.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3EvalPhraseStats</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* FTS cursor handle */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,                <comment type="block">/* Phrase expression */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>aiOut</name></decl></parameter>                      <comment type="block">/* Array to write results into (see above) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>bDeferred</name></name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>eType</name></name><operator>!=</operator><name>FTSQUERY_NEAR</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nDoc</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>aiOut</name><index>[<expr><name>iCol</name><operator>*</operator><literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nDoc</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aiOut</name><index>[<expr><name>iCol</name><operator>*</operator><literal type="number">3</literal> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nDoc</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3EvalGatherStats</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>aMI</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>aiOut</name><index>[<expr><name>iCol</name><operator>*</operator><literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>aMI</name><index>[<expr><name>iCol</name><operator>*</operator><literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aiOut</name><index>[<expr><name>iCol</name><operator>*</operator><literal type="number">3</literal> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>aMI</name><index>[<expr><name>iCol</name><operator>*</operator><literal type="number">3</literal> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The expression pExpr passed as the second argument to this function
** must be of type FTSQUERY_PHRASE. 
**
** The returned value is either NULL or a pointer to a buffer containing
** a position-list indicating the occurrences of the phrase in column iCol
** of the current row. 
**
** More specifically, the returned buffer contains 1 varint for each 
** occurrence of the phrase in the column, stored using the normal (delta+2) 
** compression and is terminated by either an 0x01 or 0x00 byte. For example,
** if the requested column contains "a b X c d X X" and the position-list
** for 'X' is requested, the buffer returned may contain:
**
**     0x04 0x05 0x03 0x01   or   0x04 0x05 0x03 0x00
**
** This function works regardless of whether or not the phrase is deferred,
** incremental, or neither.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3EvalPhrasePoslist</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* FTS3 cursor object */</comment>
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,                <comment type="block">/* Phrase to return doclist for */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>,                       <comment type="block">/* Column to return position list for */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>                    <comment type="block">/* OUT: Pointer to position list */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>pPhrase</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iThis</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iDocid</name></decl>;</decl_stmt>

  <comment type="block">/* If this phrase is applies specifically to some column other than 
  ** column iCol, return a NULL pointer.  */</comment>
  <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>&amp;&amp;</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>iColumn</name></name><operator>!=</operator><name>iCol</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>iDocid</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iDocid</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIter</name> <operator>=</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iDocid</name><operator>!=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>bEof</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bDescDoclist</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>bDescIdx</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* For DOCID_CMP macro */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bOr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>bTreeEof</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                  <comment type="block">/* Used to iterate from pExpr to root */</comment>
    <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pNear</name></decl>;</decl_stmt>              <comment type="block">/* Most senior NEAR ancestor (or pExpr) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bMatch</name></decl>;</decl_stmt>

    <comment type="block">/* Check if this phrase descends from an OR expression node. If not, 
    ** return NULL. Otherwise, the entry that corresponds to docid 
    ** pCsr-&gt;iPrevId may lie earlier in the doclist buffer. Or, if the
    ** tree that the node is part of has been marked as EOF, but the node
    ** itself is not EOF, then it may point to an earlier entry. */</comment>
    <expr_stmt><expr><name>pNear</name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pParent</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_OR</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bOr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_NEAR</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pNear</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bEof</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bTreeEof</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>bOr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* This is the descendent of an OR node. In this case we cannot use
    ** an incremental phrase. Load the entire doclist for the phrase
    ** into memory in this case.  */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pPhrase</name><operator>-&gt;</operator><name>bIncr</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>bEofSave</name> <init>= <expr><name><name>pNear</name><operator>-&gt;</operator><name>bEof</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fts3EvalRestart</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pNear</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pNear</name><operator>-&gt;</operator><name>bEof</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pNear</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bEofSave</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pNear</name><operator>-&gt;</operator><name>iDocid</name></name><operator>==</operator><name>iDocid</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>bIncr</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pNear</name><operator>-&gt;</operator><name>bEof</name></name><operator>!=</operator><name>bEofSave</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>FTS_CORRUPT_VTAB</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>bTreeEof</name></expr> )</condition><block>{<block_content>
      <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pNear</name><operator>-&gt;</operator><name>bEof</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fts3EvalNextRow</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pNear</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>bMatch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pNear</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name></type> <name>bEof</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pTest</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>pPh</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTest</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_NEAR</name> <operator>||</operator> <name><name>pTest</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_PHRASE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTest</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_NEAR</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pTest</name> <operator>=</operator> <name><name>pTest</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTest</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>FTSQUERY_PHRASE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPh</name> <operator>=</operator> <name><name>pTest</name><operator>-&gt;</operator><name>pPhrase</name></name></expr>;</expr_stmt>

      <expr_stmt><expr><name>pIter</name> <operator>=</operator> <name><name>pPh</name><operator>-&gt;</operator><name>pOrPoslist</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iDocid</name> <operator>=</operator> <name><name>pPh</name><operator>-&gt;</operator><name>iOrDocid</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>bDesc</name></name><operator>==</operator><name>bDescDoclist</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bEof</name> <operator>=</operator> <operator>!</operator><name><name>pPh</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nAll</name></name> <operator>||</operator>
          <operator>(</operator><name>pIter</name> <operator>&gt;=</operator> <operator>(</operator><name><name>pPh</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>aAll</name></name> <operator>+</operator> <name><name>pPh</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nAll</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
        <while>while<condition>( <expr><operator>(</operator><name>pIter</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>DOCID_CMP</name><argument_list>(<argument><expr><name>iDocid</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal> <operator>)</operator> <operator>&amp;&amp;</operator> <name>bEof</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3Fts3DoclistNext</name><argument_list>(
              <argument><expr><name>bDescDoclist</name></expr></argument>, <argument><expr><name><name>pPh</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>aAll</name></name></expr></argument>, <argument><expr><name><name>pPh</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nAll</name></name></expr></argument>, 
              <argument><expr><operator>&amp;</operator><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDocid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bEof</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>bEof</name> <operator>=</operator> <operator>!</operator><name><name>pPh</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nAll</name></name> <operator>||</operator> <operator>(</operator><name>pIter</name> <operator>&amp;&amp;</operator> <name>pIter</name><operator>&lt;=</operator><name><name>pPh</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>aAll</name></name><operator>)</operator></expr>;</expr_stmt>
        <while>while<condition>( <expr><operator>(</operator><name>pIter</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>DOCID_CMP</name><argument_list>(<argument><expr><name>iDocid</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal> <operator>)</operator> <operator>&amp;&amp;</operator> <name>bEof</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>dummy</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3Fts3DoclistPrev</name><argument_list>(
              <argument><expr><name>bDescDoclist</name></expr></argument>, <argument><expr><name><name>pPh</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>aAll</name></name></expr></argument>, <argument><expr><name><name>pPh</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>nAll</name></name></expr></argument>, 
              <argument><expr><operator>&amp;</operator><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDocid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bEof</name></expr></argument>
              )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>pPh</name><operator>-&gt;</operator><name>pOrPoslist</name></name> <operator>=</operator> <name>pIter</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPh</name><operator>-&gt;</operator><name>iOrDocid</name></name> <operator>=</operator> <name>iDocid</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>bEof</name> <operator>||</operator> <name>iDocid</name><operator>!=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>bMatch</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pIter</name> <operator>=</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>pOrPoslist</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pIter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pIter</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pIter</name><operator>==</operator><literal type="number">0x01</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pIter</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIter</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iThis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iThis</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <while>while<condition>( <expr><name>iThis</name><operator>&lt;</operator><name>iCol</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fts3ColumnlistCopy</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pIter</name><operator>==</operator><literal type="number">0x00</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pIter</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIter</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iThis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pIter</name><operator>==</operator><literal type="number">0x00</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pIter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>iCol</name><operator>==</operator><name>iThis</name><operator>)</operator></expr>?</condition><then><expr><name>pIter</name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free all components of the Fts3Phrase structure that were allocated by
** the eval module. Specifically, this means to free:
**
**   * the contents of pPhrase-&gt;doclist, and
**   * any Fts3MultiSegReader objects held by phrase tokens.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Fts3EvalPhraseCleanup</name><parameter_list>(<parameter><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>pPhrase</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pPhrase</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>aAll</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fts3EvalInvalidatePoslist</name><argument_list>(<argument><expr><name>pPhrase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3Doclist</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>fts3SegReaderCursorFree</name><argument_list>(<argument><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSegcsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>aToken</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSegcsr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Return SQLITE_CORRUPT_VTAB.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<function><type><name>int</name></type> <name>sqlite3Fts3Corrupt</name><parameter_list>()</parameter_list><block>{<block_content>
  <return>return <expr><name>SQLITE_CORRUPT_VTAB</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_CORE</name></expr></cpp:if>
<comment type="block">/*
** Initialize API pointer table, if required.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_fts3_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <macro><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument>pApi</argument>)</argument_list></macro>
  <return>return <expr><call><name>sqlite3Fts3Init</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
